(function(app) {
 SUGAR.jssource = {"fields": {
"base": {
"dataprivacyerase": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DataPrivacyEraseField
 * @alias SUGAR.App.view.fields.BaseDataPrivacyEraseField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Dataprivacyerase Field (base) 

    extendsFrom: 'RowactionField',

    events: {
        'click [name="dataprivacy-erase"]': 'showMarkForErasePanel'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * Check if the given module has any PII fields
     * @private
     */
    _hasPIIFields: function(baseModule) {
        return _.some(app.metadata.getModule(baseModule, 'fields'), function(field) {
            return field.pii;
        });
    },

    /**
     * @inheritdoc
     * Add ability to hide/show the erase action based on conditions
     */
    _render: function() {
        // only show erase link if all these donditions are met
        if (this.context.parent.get('module') == 'DataPrivacy' &&
            this.context.parent.get('model').get('status') == 'Open' &&
            this.context.parent.get('model').get('type') == 'Request to Erase Information' &&
            this._hasPIIFields(this.module) &&
            app.acl.hasAccess('admin', 'DataPrivacy') &&
            app.acl.hasAccess('admin', this.module)) {
            this._super('_render');
        } else {
            this.hide();
        }
    },

    bindDataChange: function() {
        this._super('bindDataChange', arguments);
        //When the parent record resaves, check if we need to show/hide
        this.listenTo(this.context.parent.get('model'), 'sync', this.render);
    },

    /**
     * Trigger event to open the Mark for Erasure drawer.
     */
    showMarkForErasePanel: function() {
        this.context.parent.trigger('mark-erasure:click', this.model);
    }
}) },
"button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ButtonField
 * @alias SUGAR.App.view.fields.BaseButtonField
 * @extends View.Fields.Base.BaseField
 */
({
	// Button Field (base) 

    tagName: "span",
    fieldTag: "a",

    plugins: ['MetadataEventDriven'],

    initialize: function(options) {
        var self = this;
        this.tabIndex = options.def.tabindex || 0;

        this.events = _.extend({}, {
            'click *' : 'preventClick'
        }, this.events, options.def.events);

        this._super('initialize', [options]);

        // take advantage of this hook to do the acl check
        // we use this wrapper because our spec
        // requires us to set the button.isHidden = true
        // if we don't render it.
        this.before("render", function() {
            if (self.hasAccess()) {
                this._show();
                return true;
            }
            else {
                this.hide();
                return false;
            }
        });
    },
    _render:function() {
        this.fullRoute = _.isString(this.def.route) ? this.def.route : null;
        this.ariaLabel = null;
        if (!this.label || this.label.trim() === '') {
            if (this.def.tooltip) {
                this.ariaLabel = app.lang.get(this.def.tooltip, this.module);
            } else {
                this.ariaLabel = _.isString(this.def.icon) ? this.def.icon.replace(/^fa-(.*)/, '$1').replace(/-o(-)|-o$/, ' outline$1').replace('-', ' ') : null;
            }
        }

        app.view.Field.prototype._render.call(this);
    },
    getFieldElement: function() {
        return this.$(this.fieldTag);
    },
    setDisabled: function(disable) {
        disable = _.isUndefined(disable) ? true : disable;
        this.def.css_class = this.def.css_class || '';
        var css_class = this.def.css_class.split(' ');
        if (disable) {
            css_class.push('disabled');
        } else {
            css_class = _.without(css_class, 'disabled');
        }
        this.tabIndex = disable ? -1 : 0;
        this.def.css_class = _.unique(_.compact(css_class)).join(' ');
        app.view.Field.prototype.setDisabled.call(this, disable);
    },

    /**
     * Prevents the `click` event from propagating further if the button is
     * in a disabled state.
     *
     * @param {Event} evt The `click` event.
     * @return {boolean} Returns `false` if the button is disabled.
     */
    preventClick: function(evt) {
        // FIXME: isDisabled should not check against `this.action`, and should
        // should eliminate the need here to check for the `disabled` class.
        // Should be fixed with SC-3418.
        if (this.isDisabled() || (!this.disposed && this.$(this.fieldTag).hasClass('disabled'))) {
            evt.preventDefault();
            evt.stopImmediatePropagation();
            return false;
        }
    },

    /**
     * Handles the jquery showing and event throwing
     * of the button. does no access checks.
     * @protected
     */
    _show: function() {
        if (this.isHidden !== false) {
            if (!this.triggerBefore("show")) {
                return false;
            }

            this.getFieldElement().removeClass("hide").show();
            this.isHidden = false;
            this.trigger('show');
        }
    },
    show: function() {
        if(this.hasAccess()) {
            this._show();
        } else {
            this.isHidden = true;
        }
    },
    hide: function() {
        if (this.isHidden !== true) {
            if (!this.triggerBefore("hide")) {
                return false;
            }

            this.getFieldElement().addClass("hide").hide();
            this.isHidden = true;
            this.trigger('hide');
        }
    },
    /**
     * Track using the flag that is set on the hide and show from above.
     *
     * It should check the visivility by isHidden instead of DOM visibility testing
     * since actiondropdown renders its dropdown lazy
     *
     * @return {boolean}
     */
    isVisible: function() {
        return !this.isHidden;
    },
    /**
     * @inheritdoc
     *
     * No data changes to bind.
     */
    bindDomChange: function () {
    },
    /**
     * @inheritdoc
     *
     * No need to bind DOM changes to a model.
     */
    bindDataChange: function () {
    },
    /**
     * Determine if ACLs or other properties (for example, "allow_bwc") allow for the button to show
     * @return {Boolean} true if allow access, false otherwise
     */
    hasAccess: function() {
        // buttons use the acl_action and acl_module properties in metadata to denote their action for acls
        var acl_module = this.def.acl_module,
            acl_action = this.def.acl_action;

        // Need to test BWC status
        if (_.isBoolean(this.def.allow_bwc) && !this.def.allow_bwc) {
            app.logger.warn('The "allow_bwc" property has been deprecated since 7.9, and will be removed in 7.10.');

            var isBwc = app.metadata.getModule(acl_module || this.module).isBwcEnabled;
            if (isBwc) {
                // Action not allowed for BWC module
                return false;
            }
        }

        // Finally check ACLs
        if (!acl_module) {
            return app.acl.hasAccessToModel(acl_action, this.model, this);
        } else {
            return app.acl.hasAccess(acl_action, acl_module);
        }
    }
}) },
"unlink-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Unlink row action used in subpanels and dashlets.
 *
 * @class View.Fields.Base.UnlinkActionField
 * @alias SUGAR.App.view.fields.BaseUnlinkActionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Unlink-action Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     *
     * By default `list:unlinkrow:fire` event is triggered if none supplied
     * through metadata.
     */
    initialize: function(options) {
        options.def.event = options.def.event || 'list:unlinkrow:fire';
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * @inheritdoc
     *
     * If parent module matches `Homepage` then `false` is returned.
     *
     * Plus, we cannot unlink one-to-many relationships when the relationship
     * is a required field - if that's the case `false` is returned as well.
     *
     * @return {Boolean} `true` if access is allowed, `false` otherwise.
     */
    hasAccess: function() {
        var parentModule = this.context.get('parentModule');
        if (parentModule === 'Home') {
            return false;
        }

        var link = this.context.get('link');
        if (link && app.utils.isRequiredLink(parentModule, link)) {
            return false;
        }

        return this._super('hasAccess');
    }
}) },
"commentlog": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CommentLogField
 * @alias SUGAR.App.view.fields.BaseCommentLogField
 * @extends View.Fields.Base.BaseField
 */
({
	// Commentlog Field (base) 

    fieldTag: 'textarea',

    /**
     * @inheritdoc
     */
    events: {
        'click [data-action=toggle]': 'toggleCollapsedEntry'
    },

    /**
     * Object to keep track of what comment entries are collapsed
     */
    collapsedEntries: undefined,

    /**
     * Defaults
     */
    _defaultSettings: {
        max_display_chars: 500,
    },

    /**
     * Called when initializing the field
     * @param options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.collapsedEntries = {};
        this._initSettings();
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Fields.BaseCommentlogField} Instance of this field.
     * @protected
     */
    _initSettings: function() {
        var configSettings = {
            max_display_chars: app.config.commentlog.maxchars,
        };
        this._settings = _.extend({}, this._defaultSettings, configSettings);
        return this;
    },

    /**
     * Called when rendering the field
     * @private
     */
    _render: function() {
        this.showCommentLog();
        this._super('_render'); // everything showing in the UI should be done before this line.
    },

    /**
     * Called when formatting the value for display
     * @param value
     */
    format: function(value) {
        return value;
    },

    /**
     * Builds model for handlebar to show pass commentlog messages in record view.
     * This should only be called when there is need to render past messages, only
     * when this.getFormattedValue() returns the data format for message.
     */
    showCommentLog: function() {
        var collection = this.model.get('commentlog');

        if (!collection) {
            return;
        }
        var comments = collection.models;

        if (comments) {
            this.msgs = [];
            // add readable time and user link to users
            _.each(comments, function(commentModel) {
                var id = commentModel.get('id');
                if (_.isUndefined(this.collapsedEntries[id])) {
                    this.collapsedEntries[id] = true;
                }

                var msg = {
                    id: commentModel.get('id'),
                    entry: commentModel.get('entry'),
                    entryShort: this._getShortComment(commentModel.get('entry')),
                    created_by_name: commentModel.get('created_by_name'),
                    collapsed: this.collapsedEntries[id],
                };

                msg.showShort = msg.entry !== msg.entryShort;

                // to date display format
                var enteredDate = app.date(commentModel.get('date_entered'));
                if (enteredDate.isValid()) {
                    msg.entered_date = enteredDate.formatUser();
                }

                var link = commentModel.get('created_by_link');
                if (link && link.id) {
                    if (app.acl.hasAccess('view', 'Employees', {acls: link._acl})) {
                        msg.href = '#' + app.router.buildRoute('Employees', link.id, 'detail');
                    }
                } else if (commentModel.has('created_by')) {
                    msg.href = '#' + app.router.buildRoute('Employees', commentModel.get('created_by'), 'detail');
                }

                if (commentModel === this._newEntryModel) {
                    msg.isNew = true;
                }
                this.msgs.push(msg);
            }, this);
        }

        this.newValue = this._newEntryModel ? this._newEntryModel.get('entry') : '';
    },

    /**
     * Truncate the comment log entry so it is shorter than the max_display_chars
     * Only truncate on full words to prevent ellipsis in the middle of words
     * @param {string} comment The comment log entry to truncate
     * @return {string} the shortened version of an entry if it was originally longer than max_display_chars
     * @private
     */
    _getShortComment: function(comment) {
        if (comment.length > this._settings.max_display_chars) {

            var cut = comment.substring(0, this._settings.max_display_chars);
            // let's cut at a full word by checking we are at a whitespace char
            while (!(/\s/.test(cut[cut.length - 1])) && cut.length > 0) {
                cut = cut.substring(0, cut.length - 1);
            }
            comment = cut;
        }

        return comment;
    },

    /**
     * Save the id in this.collapsedEntries to keep track of what entries are shortened on view or not
     * @param event
     */
    toggleCollapsedEntry: function(event) {
        var id = $(event.currentTarget).data('commentId');
        this.collapsedEntries[id] = !this.collapsedEntries[id];
        this.render();
    },

    /**
     * Called when unformatting the value for storage
     * @param value
     */
    unformat: function(value) {
        return value;
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
        if (!(this.model instanceof Backbone.Model)) {
            return;
        }

        var el = this.$el.find(this.fieldTag);

        var self = this;

        el.on('change', function() {
            var value = self.unformat(el.val());

            if (!self._newEntryModel) {
                var collectionField = self.model.get('commentlog');

                if (!collectionField) {
                    self.model.set(self.name, []);
                    collectionField = self.model.get('commentlog');
                }

                self._newEntryModel = app.data.createRelatedBean(self.model, null, 'commentlog_link', {
                    entry: value,
                    _link: 'commentlog_link',
                });

                collectionField.add(self._newEntryModel);
            }

            self._newEntryModel.set('entry', value);
        });
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.model) {
            var collectionField = this.model.get(this.name);
            if (collectionField) {
                this.listenTo(collectionField, 'reset', function() {
                    this.newValue = this._newEntryModel = null;
                });
            }
            this.model.on('change:' + this.name, function(model, value) {
                if (this.action !== 'edit') {
                    this.newValue = this._newEntryModel = null;
                }
                this.render();
            }, this);
        }
    },
}) },
"duration": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * DurationFieldView is a fieldset for Meetings/Calls for managing duration of an event
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.DurationField
 * @alias SUGAR.App.view.fields.BaseDurationField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Duration Field (base) 

    extendsFrom: 'FieldsetField',

    detailViewNames: ['record', 'create', 'create-nodupecheck', 'preview', 'pmse-case'],

    /**
     * Set default start date time if date_start has not been set. Add custom validation
     * to make sure that the date range is valid before saving.
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        if (this.model.isNew() && (!this.model.get('date_start'))) {
            this.setDefaultStartDateTime();
            this.modifyEndDateToRetainDuration();
            this.updateDurationHoursAndMinutes();

            // Values for date_start, date_end, duration_hours, and duration_minutes
            // should be set as the default on the model.
            this.model.setDefault({
                'date_start': this.model.get('date_start'),
                'date_end': this.model.get('date_end'),
                'duration_hours': this.model.get('duration_hours'),
                'duration_minutes': this.model.get('duration_minutes')
            });
        }

        // Date range should be valid before saving the record.
        this.model.addValidationTask('duration_date_range_' + this.cid, _.bind(function(fields, errors, callback) {
            _.extend(errors, this.validate());
            callback(null, fields, errors);
        }, this));
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        // Change the end date when start date changes.
        this.model.on('change:date_start', this.modifyEndDateToRetainDuration, this);

        // Check for valid date range on edit. If not valid, show a validation error.
        // In detail mode, re-render the field if either start or end date changes.
        this.model.on('change:date_start change:date_end', function(model) {
            var dateStartField;
            var dateEndField;
            var errors;

            this.updateDurationHoursAndMinutes();

            if (this.action === 'edit') {
                dateStartField = this.view.getField('date_start');
                dateEndField = this.view.getField('date_end');

                if (dateStartField && !dateStartField.disposed && dateEndField && !dateEndField.disposed) {
                    dateStartField.clearErrorDecoration();
                    dateEndField.clearErrorDecoration();
                    errors = this.validate();

                    if (errors) {
                        dateStartField.decorateError(errors.date_start);
                        dateEndField.decorateError(errors.date_end);
                    }
                }
            } else {
                this.render();
            }
        }, this);

        this._super('bindDataChange');
    },

    /**
     * Check to see if there are any errors on the field. Returns undefined if it is valid.
     * @return {Object} Errors
     */
    validate: function() {
        var errors,
            dateStartField = this.view.getField('date_start'),
            dateEndField = this.view.getField('date_end');

        if (!this.isDateRangeValid()) {
            errors = {};
            errors.date_start = {
                isBefore: dateEndField.label
            };
            errors.date_end = {
                isAfter: dateStartField.label
            };
        }

        return errors;
    },

    /**
     * @override
     *
     * Return the display string for the start and date, along with the duration.
     *
     * @param {Array/Object/string/number/boolean} value The value to format.
     * @return {string} The duration string
     */
    format: function(value) {
        var displayString = '',
            startDateString = this.model.get('date_start'),
            endDateString = this.model.get('date_end'),
            startDate,
            endDate,
            duration,
            durationString;

        if (startDateString && endDateString) {
            startDate = app.date(startDateString);
            endDate = app.date(endDateString);
            duration = app.date.duration(endDate - startDate);
            durationString = duration.format() || ('0 ' + app.lang.get('LBL_DURATION_MINUTES'));

            if ((startDate.date() === endDate.date()) &&
                (startDate.month() === endDate.month()) &&
                (startDate.year() === endDate.year())
            ) {
                // Should not display the date twice when the start and the end dates are the same.
                displayString = app.lang.get('LBL_START_AND_END_DATE_SAME_DAY', this.module, {
                    date: startDate.formatUser(true),
                    start: startDate.format(app.date.getUserTimeFormat()),
                    end: endDate.format(app.date.getUserTimeFormat()),
                    duration: durationString
                });
            } else {
                displayString = app.lang.get('LBL_START_AND_END_DATE', this.module, {
                    start: startDate.formatUser(false),
                    end: endDate.formatUser(false),
                    duration: durationString
                });
            }
        }

        return displayString;
    },

    /**
     * Set the default start date time to the upcoming hour or half hour,
     * whichever is closest.
     * @param {Utils.Date} currentDateTime (optional) - current date time
     */
    setDefaultStartDateTime: function(currentDateTime) {
        var defaultDateTime = currentDateTime || app.date().seconds(0);

        if (defaultDateTime.minutes() > 30) {
            defaultDateTime
                .add(1, 'h')
                .minutes(0);
        } else if (defaultDateTime.minutes() > 0) {
            defaultDateTime.minutes(30);
        }

        this.model.set('date_start', defaultDateTime.formatServer());
    },

    /**
     * Set duration_hours and duration_minutes based upon date_start and date_end.
     */
    updateDurationHoursAndMinutes: function() {
        var diff = app.date(this.model.get('date_end')).diff(this.model.get('date_start'));
        this.model.set('duration_hours', Math.floor(app.date.duration(diff).asHours()));
        this.model.set('duration_minutes', app.date.duration(diff).minutes());
    },

    /**
     * If the start and end date has been set and the start date changes,
     * automatically change the end date to maintain duration.
     */
    modifyEndDateToRetainDuration: function() {
        var startDateString = this.model.get('date_start'),
            originalStartDateString = this.model.previous('date_start'),
            originalStartDate,
            endDateString = this.model.get('date_end'),
            endDate,
            duration,
            changedAttributes = this.model.changedAttributes();

        // Do not change the end date if the start date has not been set or if the start date
        // and the end date have been changed at the same time.
        if (!startDateString ||
            (changedAttributes.date_start && changedAttributes.date_end) ||
            !app.acl.hasAccessToModel('edit', this.model, 'date_end')
        ) {
            return;
        }

        if (endDateString && originalStartDateString) {
            // If end date has been set, maintain duration when the start
            // date changes.
            originalStartDate = app.date(originalStartDateString);
            duration = app.date(endDateString).diff(originalStartDate);

            // Only set the end date if start date is before the end date.
            if (duration >= 0) {
                endDate = app.date(startDateString).add(duration).formatServer();
                this.model.set('date_end', endDate);
            }
        } else {
            // Set the end date to be an hour from the start date if the end
            // date has not been set yet.
            endDate = app.date(startDateString).add(30, 'm').formatServer();
            this.model.set('date_end', endDate);
        }
    },

    /**
     * Is this date range valid?
     * @return {boolean} `true` when start date is before end date, `false` otherwise
     */
    isDateRangeValid: function() {
        var start = this.model.get('date_start'),
            end = this.model.get('date_end'),
            isValid = false;

        if (start && end) {
            if (app.date.compare(start, end) < 1) {
                isValid = true;
            }
        }

        return isValid;
    },

    /**
     * Inherit fieldset templates for edit.
     * FIXME: Will be refactored by SC-3471.
     * @inheritdoc
     * @private
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');
        // FIXME: SC-3836 will replace special-casing view names/actions via
        // action based templates.
        // Use detail view if the view.name is in list of views defined in detailViewNames
        if ((_.indexOf(this.detailViewNames, this.view.name) > -1) && (this.action === 'edit')) {
            this.template = app.template.getField('fieldset', 'record-detail', this.model.module);
        }
    },

    /**
     * Remove validation on the model.
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('duration_date_range_' + this.cid);
        this._super('_dispose');
    },

    /**
     * Forces the date and time pickers to close in the event that they remain
     * opened when the field is re-rendered.
     *
     * @inheritdoc
     */
    _render: function() {
        var start = this.view.getField('date_start');
        var end = this.view.getField('date_end');

        if (start) {
            start.$(start.fieldTag).datepicker('hide');
            start.$(start.secondaryFieldTag).timepicker('hide');
        }

        if (end) {
            end.$(end.fieldTag).datepicker('hide');
            end.$(end.secondaryFieldTag).timepicker('hide');
        }

        return this._super('_render');
    },

    /**
     * Special case for duration fields on preview view
     *
     * @inheritdoc
     */
    setMode: function(name) {
        //on preview view, we use the preview action instead of detail
        if (this.view.name === 'preview' && name === 'detail') {
            name = 'preview';
        }

        this._super('setMode', [name]);
    }
}) },
"mass-email-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This field uses the `EmailClientLaunch` plugin to launch the appropriate
 * email client.
 *
 * Recipients to pre-populate are pulled from the mass_collection.
 * For external email client: Changes to the mass_collection will rebuild the mailto: link
 * For internal email client: Recipients are gathered from the mass_collection on click.
 * In order for the recipients to be prepopulated, this field requires the models in the
 * mass_collection contain the email field - if not, recipients will simply be blank (no error).
 *
 * @class View.Fields.Base.MassEmailButtonField
 * @alias SUGAR.App.view.fields.BaseMassEmailButtonField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Mass-email-button Field (base) 

    extendsFrom: 'ButtonField',

    /**
     * @inheritdoc
     *
     * Add the `EmailClientLaunch` plugin and force use of `ButtonField`
     * templates.
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['EmailClientLaunch']);
        this._super('initialize', [options]);
    },

    /**
     * Set up `add`, `remove` and `reset` listeners on the `mass_collection` so
     * we can render this button appropriately whenever the mass collection changes.
     */
    bindDataChange: function() {
        var massCollection = this.context.get('mass_collection');
        massCollection.on('add remove reset', this.render, this);
        this._super('bindDataChange');
    },

    /**
     * Clean up listener on mass_collection updates
     */
    unbindData: function() {
        var massCollection = this.context.get('mass_collection');
        if (massCollection) {
            massCollection.off(null, null, this);
        }
        this._super('unbindData');
    },

    /**
     * Map mass collection models to the appropriate format
     * required to prepopulate the to on email compose
     *
     * @return {Object} options to prepopulate on the email compose
     * @private
     */
    _retrieveEmailOptionsFromLink: function() {
        var massCollection = this.context.get('mass_collection'),
            to = _.map(massCollection.models, function(model) {
                return {bean: model};
            }, this);
        return {
            to: to
        };
    }
}) },
"bool": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.BoolField
 * @alias SUGAR.App.view.fields.BaseBoolField
 * @extends View.Fields.Base.BaseField
 */
({
	// Bool Field (base) 

    /**
     * HTML tag of the select2 field.
     *
     * @property {String}
     */
    select2fieldTag: 'select',

    /**
     * @inheritdoc
     *
     * Renders both checkbox and dropdown
     */
    _render: function() {
        this._super('_render');
        this.$(this.select2fieldTag).select2({'minimumResultsForSearch': -1});
    },

    /**
     * @inheritdoc
     */
    _getFallbackTemplate: function(viewName) {
        if (viewName === 'massupdate') {
            return 'dropdown';
        }
        return this._super('_getFallbackTemplate', [viewName]);
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
        var $el = this.$(this.select2fieldTag);
        if (!$el.length) {
            $el = this.$(this.fieldTag);
        }
        $el.on('change', _.bind(function() {
            var value = $el.is(this.select2fieldTag) ? $el.val() : $el.prop('checked');
            this.model.set(this.name, this.unformat(value));
        }, this));
    },

    /**
     * @inheritdoc
     *
     * Bypass `render` when action is `massupdate` or `edit`.
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        this.model.on('change:' + this.name, function(model, value) {
            if (this.action === 'massupdate') {
                this.$(this.select2fieldTag).val(this.format(value) ? '1' : '0');
            } else if (this.action === 'edit') {
                this.$(this.fieldTag).prop('checked', this.format(value));
            } else {
                this.render();
            }
        }, this);
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$(this.select2fieldTag).off();
        this._super('unbindDom');
    },

    /**
     * @inheritdoc
     *
     * @param {String/Boolean} value The value to unformat.
     * @return {Boolean} Unformatted value.
     */
    unformat: function(value) {
        if (_.isString(value)) {
            value = value == '1';
        }
        return value;
    },

    /**
     * @inheritdoc
     *
     * @param {String/Boolean} value The value to format.
     * @return {Boolean} formatted value.
     */
    format: function(value) {
        if (_.isString(value)) {
            value = value == '1';
        }
        return value;
    }
}) },
"htmleditable_tinymce": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Htmleditable_tinymceField
 * @alias SUGAR.App.view.fields.BaseHtmleditable_tinymceField
 * @extends View.Fields.Base.BaseField
 */
({
	// Htmleditable_tinymce Field (base) 

    plugins: ['Tinymce'],

    fieldSelector: '.htmleditable', //iframe or textarea selector
    _htmleditor: null, // TinyMCE html editor
    _isDirty: false,
    // When the model already has the value being set, there is no need to trigger the "SetContent" event, which calls
    // our callback to save the content to the model. But we don't want to short-circuit events in TinyMCE's workflow,
    // so the following flag can be toggled to false to indicate that we don't need to save the content to the model
    // inside of the callback.
    _saveOnSetContent: true,

    /**
     * Render an editor for edit view or an iframe for others
     *
     * @private
     */
    _render: function() {

        this.destroyTinyMCEEditor();

        this._super('_render');

        this._getHtmlEditableField().attr('name', this.name);
        if (this._isEditView()) {
            this._renderEdit(this.def.tinyConfig || null);
        } else {
            this._renderView();
        }
    },

    /**
     * Populate the editor or textarea with the value from the model
     */
    bindDataChange: function() {
        this.model.on('change:' + this.name, function(model, value) {
            if (this._isEditView()) {
                this._saveOnSetContent = false; // the model already has the value being set, so don't set it again
                this.setEditorContent(value);
            } else {
                this.setViewContent(value);
            }
        }, this);
    },

    /**
     * Determines if the iframe is loaded and has a body element
     *
     * @param {Object} editable A reference to a field jQuery object
     * @protected
     */
    _iframeHasBody: function(editable) {
        return editable.contents().length > 0 && editable.contents().find('body').length > 0;
    },

    /**
     * Sets the content displayed in the non-editor view
     *
     * @param {String} value Sanitized HTML to be placed in view
     */
    setViewContent: function(value){
        var editable = this._getHtmlEditableField();
        var styleExists = false;
        var styleSrc = 'styleguide/assets/css/iframe-sugar.css';

        if (!editable) {
            return;
        }

        if (this._iframeHasBody(editable)) {
            // Only add the stylesheet that is sugar-specific while making sure not to add any duplicates
            editable.contents().find('link[rel="stylesheet"]').each(function() {
                if ($(this).attr('href') === styleSrc) {
                    styleExists = true;
                }
            });

            if (!styleExists) {
                // Add the tinyMCE specific stylesheet to the iframe
                editable.contents().find('head').append($('<link/>', {
                    rel: 'stylesheet',
                    href: styleSrc,
                    type: 'text/css'
                }));
            }

            editable.contents().find('body').html(value);
        } else {
            editable.html(value);
        }
    },

    /**
     * Render editor for edit view
     *
     * @param {Array} value TinyMCE config settings
     * @private
     */
    _renderEdit: function(options) {
        var self = this;
        this.initTinyMCEEditor(options);
        this._getHtmlEditableField().on('change', function(){
            self.model.set(self.name, self._getHtmlEditableField().val());
        });
    },

    /**
     * Render read-only view for other views
     *
     * @private
     */
    _renderView: function() {
        this.setViewContent(this.value);
    },

    /**
     * Is this an edit view?  If the field contains a textarea, it will assume that it's in an edit view.
     *
     * @return {Boolean}
     * @private
     */
    _isEditView: function() {
        return this.action === 'edit';
    },

    /**
     * Returns a default TinyMCE init configuration for the htmleditable widget.
     * This function can be overridden to provide a custom TinyMCE configuration.
     *
     * See [TinyMCE Configuration Documentation](http://www.tinymce.com/wiki.php/Configuration)for details.
     *
     * @return {Object} TinyMCE configuration to use with this widget
     */
    getTinyMCEConfig: function(){
        return {
            // Location of TinyMCE script
            script_url: 'include/javascript/tinymce4/tinymce.min.js',

            // General options
            theme: 'modern',
            skin: 'sugar',
            plugins: 'code,textcolor',
            browser_spellcheck: true,

            // User Interface options
            width: '100%',
            height: '100%',
            menubar: false,
            statusbar: false,
            resize: false,
            toolbar: 'code | bold italic underline strikethrough | bullist numlist | alignleft aligncenter ' +
                'alignright alignjustify | forecolor backcolor | fontsizeselect | formatselect | fontselect',

            // Sets the text of the Target element of the link plugin. To disable
            // this completely, set target_list: false
            target_list: [
                {
                    text: app.lang.getAppString('LBL_TINYMCE_TARGET_SAME'),
                    value: ''
                },
                {
                    text: app.lang.getAppString('LBL_TINYMCE_TARGET_NEW'),
                    value: '_blank'
                }
            ],

            // Output options
            entity_encoding: 'raw',

            // URL options
            relative_urls: false,
            convert_urls: false
        };
    },

    /**
     * Initializes the TinyMCE editor.
     *
     * @param {Object} optConfig Optional TinyMCE config to use when initializing editor.  If none provided, will load config provided from {@link getTinyMCEConfig}.
     */
    initTinyMCEEditor: function(optConfig) {
        var self = this;
        if(_.isEmpty(this._htmleditor)){
            var config = _.extend({}, this.getTinyMCEConfig(), optConfig || {});
            var __superSetup__ = config.setup;
            // Preserve custom setup if it exists, add setup function needed for widget to work properly
            config.setup = function(editor){
                if(_.isFunction(__superSetup__)){
                    __superSetup__.call(this, editor);
                }
                self._htmleditor = editor;
                self._htmleditor.on('init', function(event) {
                    self.setEditorContent(self.getFormattedValue());
                    $(event.target.getWin()).blur(function(e){ // Editor window lost focus, update model immediately
                        self._saveEditor(true);
                    });
                });
                self._htmleditor.on('deactivate', function(ed){
                    self._saveEditor();
                });
                self._htmleditor.on('change', function(ed, l) {
                    // Changes have been made, mark widget as dirty so we don't lose them
                    self._isDirty = true;
                });
                self._htmleditor.on('paste', function() {
                    // Some content has been pasted, mark widget as dirty so we don't lose pasted content.
                    self._isDirty = true;
                });
                self.addCustomButtons(editor);
            };
            config.oninit = function(inst) {
                self.context.trigger('tinymce:oninit', inst);
            };

            this._getHtmlEditableField().tinymce(config);
        }
    },

    /**
     * Add custom buttons.
     * @param {Object} editor TinyMCE editor
     */
    addCustomButtons: function(editor) {},

    /**
     * Destroy TinyMCE Editor instance
     */
    destroyTinyMCEEditor: function() {
        // Clean up existing TinyMCE editor
        if(!_.isNull(this._htmleditor)){
            try {
                // A known issue with Firefox and TinyMCE produces a NS_ERROR_UNEXPECTED Exception
                this._saveEditor(true);
                this._htmleditor.remove();
                this._htmleditor.destroy();
            } catch (e) {
            }
            this._htmleditor = null;
        }
    },

    /**
     * Save the TinyMCE editor's contents to the model
     * @private
     */
    _saveEditor: function(force){
        var save = force | this._isDirty;
        if(save){
            this.model.set(this.name, this.getEditorContent(), {silent: true});
            this._isDirty = false;
        }
    },

    /**
     * Finds textarea or iframe element in the field template
     *
     * @return {HTMLElement} element from field template
     * @private
     */
    _getHtmlEditableField: function() {
        return this.$el.find(this.fieldSelector);
    },

    /**
     * Sets TinyMCE editor content
     *
     * @param {String} value HTML content to place into HTML editor body
     */
    setEditorContent: function(value) {
        if(_.isEmpty(value)){
            value = "";
        }
        if (this._isEditView() && this._htmleditor && this._htmleditor.dom) {
            this._htmleditor.setContent(value);
        }
    },

    /**
     * Retrieves the  TinyMCE editor content
     *
     * @return {String} content from the editor
     */
    getEditorContent: function() {
        return this._htmleditor.getContent({format: 'raw'});
    },

    /**
     * Destroy TinyMCE Editor on dispose
     *
     * @private
     */
    _dispose: function() {
        this.destroyTinyMCEEditor();
        app.view.Field.prototype._dispose.call(this);
    }

}) },
"badge-select": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.BadgeSelectField
 * @alias SUGAR.App.view.fields.BaseBadgeSelectField
 * @extends View.Fields.Base.EnumField
 */
({
	// Badge-select Field (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        if (this.view && this.view.layout) {
            this.view.layout.on('headerpane:adjust_fields', this.repositionDropdown, this);
        }
        /**
         * An object where its keys map to specific status and color to matching
         * CSS classes.
         */
        this.statusClasses = {
            'important': 'label-important',
            'warning': 'label-warning',
            'pending': 'label-pending',
            'success': 'label-success',
            'info': 'label-info',
            'inverse': 'label-inverse',
            'unknown': 'label-unknown',
            'log': 'label-log'
        };
    },

    /**
     * Resets position of status dropdown if Select2 is active and open
     * and the position of the Select2 container is shifted, which happens
     * when other fields in the headerpane are hidden on status edit
     */
    repositionDropdown: function() {
        var $el = this.$(this.fieldTag).select2('container');

        if ($el.hasClass('select2-dropdown-open')) {
            this.$(this.fieldTag).data('select2').dropdown.css({'left': $el.offset().left});
        }
    },

    /**
     * @inheritdoc
     *
     * This field renders as a badge when not in edit mode and as an enum when
     * in edit mode.
     *
     * @private
     */
    _loadTemplate: function() {
        if (this.action === 'edit') {
            this.type = 'enum';
        }

        this._super('_loadTemplate');
        this.type = 'badge-select';
    },

    /**
     * @inheritdoc
     *
     * Convert model value to dropdown value based on key.
     *
     * @param {Array/Object/string/number/boolean} value The value to format.
     * @return {string} the formatted value based on view name.
     */
    format: function(value) {
        this.statusClass = this.styleLabel(value);

        return value;
    },

    /**
     * Returns the appropriate CSS class on the label based on the value of the
     * status.
     *
     * It is a noop when the field is in edit mode.
     *
     * @param {string} status
     */
    styleLabel: function(status) {
        if (this.action === 'edit') {
            return;
        }
        if (this.action === 'disabled') {
            return 'label-disabled';
        }
        return this.statusClasses[status];
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.view && this.view.layout) {
            this.view.layout.off(null, null, this);
        }

        this._super('_dispose');
    }
}) },
"repeat-until": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Repeat Until is a custom field for Meetings/Calls modules used to add
 * validation that ensures the date is after the end date, but only if this
 * field is editable.
 *
 * FIXME: This component will be moved out of clients/base folder as part of
 * MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatUntilField
 * @alias SUGAR.App.view.fields.BaseRepeatUntilField
 * @extends View.Fields.Base.DateField
 */
({
	// Repeat-until Field (base) 

    extendsFrom: 'DateField',

    /**
     * @inheritdoc
     *
     * Add validation that ensures the date is after the end date, but only if
     * this field is editable.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'date';

        this.model.addValidationTask(
            'repeat_until_validator_' + this.cid,
            _.bind(this._doValidateRepeatUntil, this)
        );
    },

    /**
     * Custom validator for the `repeat_until` field.
     *
     * This validates `repeat_until` to ensure the date is on or after the start date,
     * but only if this field is editable.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatUntil: function(fields, errors, callback) {
        var isOnOrAfterStartDate,
            startDate = this.model.get('date_start'),
            repeatUntil = this.model.get(this.name),
            startDateField = this.view.getField('date_start');

        if (!_.isEmpty(repeatUntil) && (this.action === 'edit') && startDateField) {
            startDate = app.date(startDate).minutes(0).hours(0);
            isOnOrAfterStartDate = !app.date(repeatUntil).isBefore(startDate);
            if (!isOnOrAfterStartDate || !startDate.isValid()) {
                errors[this.name] = {'isAfter': startDateField.label};
            }
        }

        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_until_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"tag": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TagField
 * @alias SUGAR.App.view.fields.BaseTagField
 * @extends View.Fields.Base.BaseField
 */
({
	// Tag Field (base) 

    /**
     * HTML tag of the append tag checkbox.
     *
     * @property {String}
     */
    appendTagInput: 'input[name=append_tag]',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // init bean collection used for type aheads
        this.filterResults = app.data.createBeanCollection('Tags');

        // initialize value to empty array
        if (!this.model.has(this.name)) {
            this.model.setDefault(this.name, []);
        }

        // Set append as default when mass updating tags
        this.appendTagValue = true;
        this.model.setDefault('tag_type', this.appendTagValue ? '1' : '0');
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.setTagList();

        this._super('_render');

        this.initializeSelect2();
        this.$select2.on('change', _.bind(this.storeValues, this));
        this.$select2.on('select2-selecting', this.handleNewSelection);
    },

    /**
     * Set up tagList variable for use in the list view
     */
    setTagList: function() {
        var self = this;
        this.value = this.getFormattedValue();
        this.tagList = [];
        if (this.value) {
            _.each(this.value, function(tag){
                if (_.isString(tag)) {
                    self.tagList.push(tag);
                } else {
                    self.tagList.push(tag.name);
                }
            })
            this.tagList = this.tagList.join(', ');
        }
    },

    /**
     * @inheritdoc
     */
    format: function(value) {
        return _.map(value, function(tag){
            return _.extend(tag, {encodedValue: encodeURIComponent(tag.name)});
        });
    },

    /**
     * Overrides select2 function. For more details, check out select2's documentation
     *
     * @param term
     * @param results
     * @return {Mixed}
     * @private
     */
    _createSearchChoice: function(term, results) {
        // If tag is for filter, don't allow new choices to be selected
        if (this.view.action === 'filter-rows') {
            return false;
        }

        // Trim up the term for sanity sake
        term = $.trim(term);

        // Check previously found results to see tag exists with different casing
        if (results && results.length) {
            if (_.find(results, function(tag) {
                return tag.text.toLowerCase() === term.toLowerCase();
            })) {
                return false;
            }
        }
        
        // Check if input is empty after trim
        if (term === '') {
            return false;
        }

        // Check for existence amongst tags that exist but haven't been saved yet
        if (this.checkExistingTags(term)) {
            return false;
        }

        return {
            id: term,
            text: term + ' ' + app.lang.get('LBL_TAG_NEW_TAG'),
            locked: false,
            newTag: true
        };
    },

    /**
     * Check tag select2's currently selected tags for term to see if it already exists (case insensitive)
     * @param term term to be checked
     * @return {boolean} `true` if tag exists already, `false` otherwise
     */
    checkExistingTags: function(term) {
        if (this.$select2 && _.isFunction(this.$select2.val)) {
            var currentSelections = this.$select2.val().split(',');
        }
        if (currentSelections && currentSelections.length) {
            if (_.find(currentSelections, function(tag) {
                return tag.toLowerCase() === term.toLowerCase();
            })) {
                return true;
            }
        }

        return false;
    },

    /**
     * Overrides select2 function. For more details, check out select2's documentation
     * @param query
     * @private
     */
    _query: function(query) {
        var self = this,
            shortlist = {results: []};

        // Trim the query term right up front since it needs to be clean
        query.term = $.trim(query.term);

        this.filterResults.filterDef = {
            'filter': [{
                'name_lower': { '$starts': query.term.toLowerCase() }
            }]
        };

        // Tags should always be available because it's public
        this.filterResults.module = 'Tags';
        this.filterResults.fetch({
            success: function(data) {
                shortlist.results = self.parseRecords(data.models);

                //Format results so that already existing records don't show up
                shortlist.results = _.reject(shortlist.results, function(result) {
                    return self.checkExistingTags(result.text)
                });

                query.callback(shortlist);
            },
            error: function() {
                app.alert.show('collections_error', {
                    level: 'error',
                    messages: 'LBL_TAG_FETCH_ERROR'
                });
            }
        });
    },

    /**
     * Upon selection of a tag, if it's a new tag, get rid of the text indicating new tag
     * @param {event} e
     */
    handleNewSelection: function(e) {
        // For new tags, look for New Tag indicator and remove it if it's there
        if (e.object.newTag) {
            var newTagIdx = e.object.text.lastIndexOf(' ' + app.lang.get('LBL_TAG_NEW_TAG'));
            e.object.text = e.object.text.substr(0, newTagIdx);
        }
    },

    /**
     * Initialize select2 jquery widget
     */
    initializeSelect2: function() {
        var self = this,
            escapeChars = '!\"#$%&\'()*+,./:;<=>?@[\\]^`{|}~';

        this.$select2 = this.$('.select2field').select2({
            placeholder: '',
            minimumResultsForSearch: 5,
            minimumInputLength: 1,
            tags: true,
            multiple: true,
            closeOnSelect: true,
            width: '100%',
            containerCssClass: 'select2-choices-pills-close',
            tokenSeparators: [','],

            initSelection: function(element, callback) {
                var data = self.parseRecords(self.value);
                callback(data);
            },

            createSearchChoice: _.bind(this._createSearchChoice, this),
            query: _.debounce(_.bind(this._query, this), 300),

            sortResults: function(results, container, query) {
                results = _.sortBy(results, 'text');
                return results;
            }
        });

        this.setSelect2Records();

        // Workaround to make select2 treat enter the same as it would a comma (INT-668)
        this.$('.select2-search-field > input.select2-input').on('keyup', function(e) {
            if (e.keyCode === 13) {
                var val = self.$('input.select2-input').val();

                // Trim the tag
                val = $.trim(val);

                // Prevent blank tags
                if (val === '') {
                    return;
                }

                // Sanitize input
                if (escapeChars.indexOf(val.charAt(0)) >= 0) {
                    val = '\\\\' + val;
                }

                var tags = self.$select2.select2('data');

                // If the current input already exists as a tag (case insensitive), just exit
                var exists = _.find(tags, function(tag) {
                    return tag.id.toLowerCase() === val.toLowerCase();
                });
                if (exists) {
                    // Close the search box and return
                    self.$select2.select2('close');
                    // Re-opens the search box with the default message
                    // (this is to maintain consistency with select2's OOB tokenizer)
                    self.$select2.select2('open');
                    return;
                }

                // Otherwise, create a tag out of current input
                tags.push({id: val, text: val, locked: false});
                self.$select2.select2('data', tags, true);
                e.preventDefault();

                // Close the search box
                self.$select2.select2('close');
            }
        });
    },

    /**
     * Format related records in select2 format
     * @param {array} list of objects/beans
     */
    parseRecords: function(list) {
        var results = [];

        _.each(list, function(item) {
            var record = item;

            // we may have a bean from a collection
            if (_.isFunction(record.toJSON)) {
                record = record.toJSON();
            }
            if (_.isString(record)) {
                results.push({id: record, text: record});
            } else {
                results.push({id: record.name, text: record.name});
            }
        });

        return results;
    },

    /**
     * Store selected/removed values on our field which is put to the server
     * @param {event} e - event data
     */
    storeValues: function(e) {
        this.value = app.utils.deepCopy(this.value) || [];
        if (e.added) {
            app.analytics.trackEvent('click', 'tag_pill_added');
            // Check if added is an array or a single object
            if (_.isArray(e.added)) {
                // Even if it is an array, only one object gets added at a time,
                // so we just need it to be the first element
                e.added = e.added[0];
            }

            // Check to see if the tag we're adding has already been added.
            var valFound = _.find(this.value, function(vals) {
                return vals.name === e.added.text;
            });

            if (!valFound) {
                this.value.push(e.added.text);
            }
        } else if (e.removed) {
            app.analytics.trackEvent('click', 'tag_pill_removed');
            // Remove the tag
            this.value = _.reject(this.value, function(record) {
                if (_.isString(record)) {
                    return record === e.removed.text;
                } else {
                    return record.name === e.removed.text;
                }
            });
        }
        this.model.set('tag', this.value);
    },

    /**
     * Sanitize the tags and set the select2
     */
    setSelect2Records: function() {
        var escapeChars = '!\"#$%&\'()*+,./:;<=>?@[\\]^`{|}~';
        var records = _.map(this.value, function(record) {
            if (_.isString(record)) {
                // If a special character is the first character of a tag, it breaks select2 and jquery and everything
                // So escape that character if it's the first char
                if (escapeChars.indexOf(record.charAt(0)) >= 0) {
                    return '\\\\' + record;
                }
                return record;
            }
            if (escapeChars.indexOf(record.name.charAt(0)) >= 0) {
                return '\\\\' + record.name;
            }
            return record.name;
        });

        this.$select2.select2('val', records);

    },

    /**
     * Avoid rendering process on Select2 change in order to keep focus
     * @override
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function() {
                if (!_.isEmpty(this.$select2.data('select2'))) {
                    this.setTagList();
                    this.setSelect2Records();
                } else {
                    this.render();
                }
            }, this);
        }
    },

    /**
     * Override to remove default DOM change listener, we use Select2 events instead
     * @override
     */
    bindDomChange: function() {
        // Borrowed from team set
        var $el = this.$(this.appendTagInput);
        if ($el.length) {
            $el.on('change', _.bind(function() {
                this.appendTagValue = $el.prop('checked');
                this.model.set('tag_type', this.appendTagValue ? '1' : '0');
            }, this));
        }
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        // This line is likewise borrowed from team set
        this.$(this.appendTagInput).off();
        this.$('.select2field').select2('destroy');
        this._super('unbindDom');
    }

}) },
"follow": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FollowField
 * @alias SUGAR.App.view.fields.BaseFollowField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Follow Field (base) 

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    events: {
        'click [data-event="list:follow:fire"]': 'toggleFollowing'
    },

    extendsFrom: 'RowactionField',

    initialize: function(options) {
        this._super("initialize", [options]);
        this.format();
    },
    bindDataChange: function() {
        if (this.model) {
            this.model.on("change:following", this.resetLabel, this);
        }

        // when the record is marked as favorite, it is subsequently followed by the current user (on server-side)
        // need to sync the client-side model, so an event is fired on the context from the favorite field upon success
        // set following on the model so we don't have to make a server request to get the latest value
        this.model.on("favorite:active", function() {
            this.model.set("following", true);
        }, this);
    },
    /**
     * Set current label and value since the follow button relates to the following
     *
     * @param value
     */
    format: function(value) {
        value = this.model.get("following");

        //For record view, the label should be diffent from other views
        //It also needs to have mouseover handlers for updating text
        if(this.tplName === "detail") {
            var label = value ? "LBL_FOLLOWING" : "LBL_FOLLOW";
            this.label = app.lang.get(label, this.module);
        } else {
            var label = value ? "LBL_UNFOLLOW" : "LBL_FOLLOW";
            this.label = app.lang.get(label, this.module);
        }
        return value;
    },
    /**
     * Reset label and triggers "show" handler to update parent controller dom
     */
    resetLabel: function() {
        this.render();
        //It should trigger the handler "show" to update parent controller
        //i.e. actiondropdown
        this.trigger("show");
    },
    unbindDom: function() {
        this.$("[data-hover=true]").off();
        this._super("unbindDom");
    },
    _render: function () {
        var module, mouseoverText, mouseoverClass, self = this;

        module = app.metadata.getModule(this.model.module);
        if (!module.activityStreamEnabled) {
            this.hide();
        } else {
            this._super("_render");

            if (this.tplName !== "detail") {
                return;
            }

            if (this.model.get("following")) {
                mouseoverText = app.lang.get("LBL_UNFOLLOW");
                mouseoverClass = "label-important";
            } else {
                mouseoverText = app.lang.get("LBL_FOLLOW");
                mouseoverClass = "label-success";
            }

            this.$("[data-hover=true]").on("mouseover",function () {
                $(this).text(mouseoverText).attr("class", "label").addClass(mouseoverClass);
            }).on("mouseout", function () {
                    var kls = self.model.get("following") ? "label-success" : "";
                    $(this).text(self.label).attr("class", "label").addClass(kls);
                });
        }
    },
    /**
     * Call REST API for subscribe and unsubscribe
     *
     * @param {Event} event The `click` event.
     */
    toggleFollowing: function(event) {
        var isFollowing = this.model.get("following");

        if(!_.isUndefined(isFollowing)) {
            var options = {
                alerts: false
            };
            if (this.model.follow(!isFollowing, options) === false) {
                app.logger.error('Unable to follow "' + this.model.module + '" record "' + this.model.id);
                return;
            }
        }
    }
}) },
"emailaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EmailactionField is a button that when selected will launch the appropriate
 * email client.
 *
 * @class View.Fields.Base.EmailactionField
 * @alias SUGAR.App.view.fields.BaseEmailactionField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Emailaction Field (base) 

    extendsFrom: 'ButtonField',

    /**
     * @inheritdoc
     *
     * Adds the EmailClientLaunch plugin to enable the field to be used for
     * sending email.
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['EmailClientLaunch']);
        this._super('initialize', [options]);
    },

    /**
     * Set up email options, listening for parent model changes to update the
     * email options on change.
     *
     * @private
     * @deprecated The EmailClientLaunch plugin handles email options.
     */
    _initEmailOptions: function() {
        app.logger.warn('View.Fields.Base.EmailactionField#_initEmailOptions is deprecated. ' +
            'The EmailClientLaunch plugin handles email options.');
    },

    /**
     * Update email options based on field def settings
     *
     * @param {Object} parentModel
     * @private
     * @deprecated The EmailClientLaunch plugin handles email options.
     */
    _updateEmailOptions: function(parentModel) {
        app.logger.warn('View.Fields.Base.EmailactionField#_updateEmailOptions is deprecated. ' +
            'The EmailClientLaunch plugin handles email options.');
    }
}) },
"manage-subscription": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ManageSubscriptionField
 * @alias SUGAR.App.view.fields.BaseManageSubscriptionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Manage-subscription Field (base) 

    extendsFrom: 'RowactionField',

    initialize: function (options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    /**
     * Event to navigate to the BWC Manage Subscriptions
     */
    rowActionSelect: function() {

        var route = app.bwc.buildRoute('Campaigns', this.model.id, 'Subscriptions', {
            return_module: this.module,
            return_id: this.model.id
        });
        app.router.navigate(route, {trigger: true});
    },

    /**
     * @inheritdoc
     * Check access for Campaigns Module.
     */
    hasAccess: function() {
        var access = app.acl.hasAccess('view', 'Campaigns');
        return access && this._super('hasAccess');
    }
}) },
"invitation-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.InvitationActionsField
 * @alias SUGAR.App.view.fields.BaseInvitationActionsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Invitation-actions Field (base) 

    events: {
        'click [data-action]': 'toggleStatus'
    },

    /**
     * Toggle invitation acceptance status.
     *
     * This will fire the save automatically to the server since it is a toggle
     * button and won't make sense to do save from the view (same as favorite).
     *
     * @param {Event} evt The click event that triggered the change.
     */
    toggleStatus: function(evt) {
        var attr = {};

        attr[this.name] = $(evt.currentTarget).data('action');

        this.model.save(attr, {relate: true});
    }
}) },
"password": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PasswordField
 * @alias SUGAR.App.view.fields.BasePasswordField
 * @extends View.Fields.Base.BaseField
 */
({
	// Password Field (base) 

    direction: 'ltr'
}) },
"datetimecombo-colorcoded": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * DatetimecomboColorcodedField is a field for Meetings/Calls/Tasks that sets a background color for the field based on the value of the status field
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.DatetimecomboColorcodedField
 * @alias SUGAR.App.view.fields.BaseDatetimecomboColorcodedField
 * @extends View.Fields.Base.DatetimecomboField
 */
({
	// Datetimecombo-colorcoded Field (base) 

    extendsFrom: 'DatetimecomboField',

    colorCodeClasses: {
        overdue: 'label label-important',
        upcoming: 'label label-info'
    },

    /**
     * @inheritdoc
     *
     * Checks color code conditions to determine if field should have
     * color applied to it.
     */
    _render: function() {
        this.type = 'datetimecombo'; //use datetimecombo templates
        this._super('_render');
        this.setColorCoding();
    },

    /**
    * @inheritdoc
    *
    * Listen for status change - set color coding appropriately
    */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.model.on('change:status', this.setColorCoding, this);
    },

    /**
    * Set color coding based on completion status and date compared to today
    * This is only applied when the action is list (not inline edit on list view)
    */
    setColorCoding: function() {
        var colorCodeClass;

        this._clearColorCode();

        if (!this.model || this.action !== 'list') {
            return;
        }
        colorCodeClass = this._isCompletedStatus() ? null : this._getColorCodeClass();
        this._setColorCodeClass(colorCodeClass);
    },

    /**
    * Check if status is completed based on status value defined in the view def
    *
    * @return {Boolean}
    * @private
    */
    _isCompletedStatus: function() {
        if (_.isUndefined(this.def.completed_status_value)) {
            return false;
        }
        return (this.model.get('status') === this.def.completed_status_value);
    },

    /**
    * Get color code class based on the date compared to today
    * If event is today - use 'today' color code
    * If event is yesterday or earlier - use 'overdue' color code
    *
    * @return {String|null} One of the color codes or null if no color code
    * @private
    */
    _getColorCodeClass: function() {
        var eventDate,
            today,
            nextDay;

        if (_.isEmpty(this.model.get(this.name))) {
            return null;
        }

        eventDate = app.date(this.model.get(this.name));
        today = app.date();
        nextDay = app.date().add(1, 'days');

        if (eventDate.isBefore(today)) {
            return this.colorCodeClasses.overdue;
        } else if (eventDate.isBefore(nextDay)) {
            return this.colorCodeClasses.upcoming;
        } else {
            return null;
        }
    },

    /**
    * Set the color code class to the field tag or clear out if no
    * color code should be applied (colorCodeClass is null)
    *
    * @param {String|null} colorCodeClass
    * @private
    */
    _setColorCodeClass: function(colorCodeClass) {
        if (!_.isNull(colorCodeClass)) {
            this.$el.addClass(colorCodeClass);
        }
    },

    /**
     * Clear color coding classes
     *
     * @private
     */
    _clearColorCode: function() {
        _.each(this.colorCodeClasses, function(colorCodeClass) {
            this.$el.removeClass(colorCodeClass);
        }, this);
    }
}) },
"avatar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.AvatarField
 * @alias SUGAR.App.view.fields.BaseAvatarField
 * @extends View.Fields.Base.ImageField
 */
({
	// Avatar Field (base) 

    extendsFrom: 'ImageField',

    plugins: ['File', 'FieldDuplicate'],

    MAPSIZECLASS: {
        'large': 'label-module-lg',
        'medium': 'label-module-md',
        'button': 'label-module-btn',
        'default': '',  //This field does not fallback to this size
        'small': 'label-module-sm',
        'mini': 'label-module-mini'
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        var template,
            className;
        this._super("_render");
        if (this.action !== 'edit' || this.view.name === 'merge-duplicates') {
            if (_.isEmpty(this.value)) {
                className = _.isUndefined(this.MAPSIZECLASS[this.def.size]) ? this.MAPSIZECLASS['large'] : this.MAPSIZECLASS[this.def.size];
                // replace the image field with the module icon when there is no avatar to display
                // load the module icon template
                template = app.template.getField(this.type, 'module-icon', this.module);
                if (template) {
                    this.$('.image_field').replaceWith(template({
                        module: this.module,
                        labelSizeClass: className,
                        tooltipPlacement: app.lang.direction === 'ltr' ? 'right' : 'left'
                    }));
                }
            } else {
                // add the image_rounded class to the image_field div when there is an avatar to display
                this.$('.image_field').addClass('image_rounded');
            }
        }
        return this;
    },

    /**
     * To inherit templates from the image field, we want to tell sidecar to load the templates from the image field's
     * directory. To do this, we must change this.type to "image" temporarily. We want to restore this.type before
     * exiting, however, so that we don't really change the field's attributes.
     *
     * Beware that this causes sidecar to never automatically load any templates found in the avatar field's directory.
     * Sidecar will always look for templates in the image field's directory, by default.
     *
     * @override
     * @private
     */
    _loadTemplate: function() {
        this.type = 'image';
        this._super("_loadTemplate");
        this.type = this.def.type;
    }
}) },
"actiondropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Create a dropdown button that contains multiple
 * {@link View.Fields.Base.RowactionField} fields.
 *
 * Supported Properties:
 *
 * - {Boolean} primary True if the entire dropdown group shows as primary.
 * - {String} icon Css icon that places on dropdown caret.
 * - {Boolean} switch_on_click True if the selected action needs to switch
 *   against the default action.
 * - {Boolean} no_default_action True if the default action should be empty and
 *   all buttons place under the dropdown action.
 * - {Array} buttons List of actions.
 *   First action goes to the default action (unless no_default_action set as `true`)
 *
 * Example usage:
 *
 *      array(
 *          'type' => 'actiondropdown',
 *          'primary' => true,
 *          'switch_on_click' => true,
 *          'no_default_action' => false,
 *          'icon' => 'fa-cog',
 *          'buttons' => array(
 *              ...
 *          )
 *      )
 *
 * @class View.Fields.Base.ActiondropdownField
 * @alias SUGAR.App.view.fields.BaseActiondropdownField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Actiondropdown Field (base) 

    extendsFrom: 'FieldsetField',

    events: {
        'click [data-toggle=dropdown]' : 'renderDropdown',
        'shown.bs.dropdown': '_toggleAria',
        'hidden.bs.dropdown': '_toggleAria'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        /**
         * A subset of {@link #fields}.
         * Contains ACL accessible fields that are part of the dropdown.
         *
         * @property {Array}
         */
        this.dropdownFields = [];

        /**
         * Dom element selector for dropdown action.
         *
         * @property {string}
         */
        this.actionDropDownTag = '[data-toggle=dropdown]';

        /**
         * Dom element selector for mobile dropdown selector.
         *
         * @property {string}
         */
        this.selectDropdownTag = '[data-toggle=dropdownmenu]';

        /**
         * The dropdown tag to append the dropdown list to.
         *
         * @property {string}
         */
        this.dropdownTag = '[data-menu=dropdown]';

        /**
         * The default action button. An item in {@link #fields}.
         * This is a readonly property. Use {@link #_setDefaultBtn} to modify.
         *
         * @property {Object}
         */
        this.defaultActionBtn = {};

        /**
         * @inheritdoc
         *
         * This field doesn't support `showNoData`.
         */
        this.showNoData = false;

        /**
         * @inheritdoc
         *
         * This field's user action is enabled.
         */
        this.tabIndex = 0;

        this._super('initialize', [options]);

        /**
         * The caret icon class.
         *
         * @property {string}
         */
        this.caretIcon = this.def.icon || 'fa-caret-down';

        this.def.css_class = this.def.css_class ?
            this.def.css_class + ' actions' : 'actions';

        if (this.def.no_default_action) {
            this.def.switch_on_click = false;
        }

        //shortcut keys
        app.shortcuts.register({
            id: 'Dropdown:More',
            keys: 'm',
            component: this,
            description: 'LBL_SHORTCUT_OPEN_MORE_ACTION',
            handler: function() {
                var $primaryDropdown = this.$('.btn-primary[data-toggle=dropdown]');
                if ($primaryDropdown.is(':visible') && !$primaryDropdown.hasClass('disabled')) {
                    $primaryDropdown.click();
                }
            }
        });
        this.model.on('acl:change', function() {
            if (this.disposed) {
                return;
            }
            this._orderButtons();
            this.render();
        }, this);
    },

    /**
     * @inheritdoc
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.buttons);
    },

    /**
     * @inheritdoc
     *
     * Calls {@link #_reorganizeButtons} if creating fields for the first time.
     * @return {Array} Array of accessible fields, a subset of {@link #fields}.
     */
    _getChildFields: function() {
        if (_.isEmpty(this.fields)) {
            var fields = this._super('_getChildFields');
            this._orderButtons(fields);
        }
        return !_.isEmpty(this.defaultActionBtn) ?
            [this.defaultActionBtn].concat(this.dropdownFields) :
            this.dropdownFields;
    },

    /**
     * Orders the fields according to order given and places the ACL accessible
     * fields in {@link #defaultActionBtn} and {@link #dropdownFields}.
     *
     * @param {Array} [fields=this.fields] Buttons in a specific order.
     * @private
     */
    _orderButtons: function(fields) {
        //Set to `true` to avoid starting the list with a divider.
        var prevIsDivider = true,
            orderedFields = fields || this.fields;
        this.dropdownFields = _.filter(orderedFields, function(field) {
            var actionHidden = (_.isFunction(field.hasAccess) && !field.hasAccess()) ||
                (_.isFunction(field.isVisible) && !field.isVisible());

            if (actionHidden || (field.type === 'divider' && prevIsDivider)) {
                return false;
            }
            prevIsDivider = field.type === 'divider';
            return true;
        });

        if (!this.def.no_default_action && !_.isEmpty(this.dropdownFields)) {
            this._setDefaultBtn(_.first(this.dropdownFields));
            this.dropdownFields = _.rest(this.dropdownFields);
        }
    },

    /**
     * Gets the dropdown template and caches it to `this.dropdownTpl`.
     *
     * @return {Function} The handlebars dropdown template.
     * @protected
     */
    _getDropdownTpl: function() {
        this.dropdownTpl = this.dropdownTpl ||
            app.template.getField('actiondropdown', 'dropdown', this.module);
        return this.dropdownTpl;
    },

    /**
     * Appends the dropdown from `dropdown.hbs` and binds the
     * {@link #switchButton} method to the dropdown buttons if necessary.
     *
     * @param {Event} evt The `click` event.
     */
    renderDropdown: function(evt) {
        var $dropdown = this.$(this.dropdownTag);

        if (_.isEmpty(this.dropdownFields) || this.isDisabled() || !$dropdown.is(':empty')) {
            return;
        }
        var dropdownTpl = this._getDropdownTpl();

        $dropdown.append(dropdownTpl(this));

        _.each(this.dropdownFields, function(field) {
            field.setElement(this.$('span[sfuuid="' + field.sfId + '"]'));
            if (this.def['switch_on_click'] && !this.def['no_default_action']) {
                field.$el.on('click.' + this.cid, _.bind(this.switchButton, this));
            }
            field.render();
        }, this);
    },

    /**
     * Sets a button accessibility class 'aria-expanded' to true or false
     * depending on if the dropdown menu is open or closed.
     *
     * @private
     */
    _toggleAria: function() {
        var $button = this.$(this.actionDropDownTag);
        $button.attr('aria-expanded', this.$el.hasClass('open'));
    },

    /**
     * Sets a button to {@link #defaultActionBtn} and to have default-button
     * properties. Unsets the previous {@link #defaultActionBtn}.
     *
     * @param {Object} button The button of interest.
     * @private
     */
    _setDefaultBtn: function(button) {
        if (!button || button.disposed) {
            return;
        }
        if (!_.isEmpty(this.defaultActionBtn)) {
            this.defaultActionBtn.def.primary = this.defaultActionBtn.def.button = false;
        }
        this.defaultActionBtn = button;
        this.defaultActionBtn.def.primary = this.def.primary;
        this.defaultActionBtn.def.button = true;
    },

    /**
     * Switch the default button against one that is clicked.
     *
     * @param {Event} evt The `click` event
     */
    switchButton: function(evt) {
        var sfId = parseInt(this.$(evt.currentTarget).attr('sfuuid'), 10),
            index = -1;

        if (sfId === this.defaultActionBtn.sfId) {
            return;
        }
        var selectedField = _.find(this.dropdownFields, function(field, idx) {
            if (field.sfId === sfId) {
                index = idx;
                return true;
            }
            return false;
        });

        if (!selectedField) {
            return;
        }

        //rebuild `dropdownFields` with the new ordering
        this.dropdownFields.splice(index, 1, this.defaultActionBtn);
        this._setDefaultBtn(selectedField);
        this.render();
    },

    /**
     * @inheritdoc
     *
     * Rendering an `ActiondropdownField` will always force the dropdown to be
     * re-rendered.
     */
    _render: function() {
        this.$(this.dropdownTag).empty();

        this._super('_render');
        this._updateCaret();
        this._renderDefaultActionBtn();
        this.$el.toggleClass('btn-group', !_.isEmpty(this.dropdownFields));

        return this;
    },

    /**
     * Renders the default action button only.
     * The fields in the dropdown will be rendered on click on the dropdown
     * button with {@link #renderDropdown}.
     *
     * @override
     * @protected
     */
    _renderFields: function() {
        if (!_.isEmpty(this.defaultActionBtn)) {
            this.defaultActionBtn.setElement(this.$('span[sfuuid="' + this.defaultActionBtn.sfId + '"]'));
            this.defaultActionBtn.render();
        }
    },

    /**
     * Formats the default action button if it exists.
     * Sets the mode of the button to `small` if it is in a subpanel.
     *
     * A button is in `small` mode when it contains only the icon, with the label
     * shown as a tooltip.
     *
     * @protected
     */
    _renderDefaultActionBtn: function() {
        if (_.isEmpty(this.defaultActionBtn)) {
            return;
        }
        //FIXME: SC-3366 Should not explicitly look for `closestComponent`
        if (this.defaultActionBtn.def.icon &&
            this.defaultActionBtn.closestComponent('subpanel')) {
            this.defaultActionBtn.setMode('small');
        }

        if (!this.def['switch_on_click'] || this.def['no_default_action']) {
            return;
        }

        this.defaultActionBtn.$el.on('click.' + this.cid, _.bind(this.switchButton, this));
        app.accessibility.run(this.defaultActionBtn.$el, 'click');
    },

    /**
     * Enable or disable caret depending on if there are any enabled actions in the dropdown list
     * @private
     */
    _updateCaret: function() {
        if (_.isEmpty(this.dropdownFields)) {
            return;
        }
        //FIXME: SC-3365 Should not need to check for 'disabled' in css_class
        var caretEnabled = _.some(this.dropdownFields, function(field) {
            if (_.isFunction(field.hasAccess) && field.hasAccess()) {
                if (field.def.css_class && field.def.css_class.indexOf('disabled') > -1) {
                    //If action disabled in metadata
                    return false;
                } else if (field.isDisabled()) { //Or disabled via field controller
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        });
        this.$('.' + this.caretIcon)
            .closest('a')
                .toggleClass('disabled', !caretEnabled)
                .attr('aria-haspopup', caretEnabled)
                .attr('tabindex', caretEnabled ? 0 : -1);
    },

    /**
     * @inheritdoc
     */
    setDisabled: function(disable) {
        this._super('setDisabled', [disable]);
        disable = _.isUndefined(disable) ? true : disable;
        this.tabIndex = disable ? -1 : 0;
        this.$(this.actionDropDownTag)
            .toggleClass('disabled', disable)
            .attr('aria-haspopup', !disable)
            .attr('tabindex', this.tabIndex);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        _.each(this.fields, function(field) {
            if (!field.disposed) {
                field.$el.off('click.' + this.cid);
            }
        }, this);
        this.defaultActionBtn = null;
        this.dropdownFields = null;
        this._super('_dispose');
    }
}) },
"shareaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Share row action.
 *
 * This allows an user to share a record that is currently mapped with this
 * field context.
 *
 * @class View.Fields.Base.ShareactionField
 * @alias SUGAR.App.view.fields.BaseShareactionField
 * @extends View.Fields.Base.EmailactionField
 */
({
	// Shareaction Field (base) 

    extendsFrom: 'EmailactionField',

    /**
     * Share template for subject.
     *
     * See {@link #_initShareTemplates}.
     */
    shareTplSubject: null,

    /**
     * Share template for body.
     *
     * See {@link #_initShareTemplates}.
     */
    shareTplBody: null,

    /**
     * Share template for body in HTML format.
     *
     * See {@link #_initShareTemplates}.
     */
    shareTplBodyHtml: null,

    /**
     * @inheritdoc
     *
     * Adds the share options for use when launching the email client.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'emailaction';
        this._initShareTemplates();

        // If there is a default signature in email compose, it should be
        // placed below the share content in the email body.
        this.addEmailOptions({signature_location: 'below'});
    },

    /**
     * Initializes the sharing feature templates.
     *
     * This will get the templates from either the current module (since we
     * might want to customize it per module) or from core templates.
     *
     * Please define your templates on:
     *
     * - `custom/clients/{platform}/view/share/subject.hbs`
     * - `custom/clients/{platform}/view/share/body.hbs`
     * - `custom/clients/{platform}/view/share/body-html.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/share/subject.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/share/body.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/share/body-html.hbs`
     *
     * @template
     * @protected
     */
    _initShareTemplates: function() {
        this.shareTplSubject = app.template.getView('share.subject', this.module) ||
            app.template.getView('share.subject');
        this.shareTplBody = app.template.getView('share.body', this.module) ||
            app.template.getView('share.body');
        this.shareTplBodyHtml = app.template.getView('share.body-html', this.module) ||
            app.template.getView('share.body-html');
    },

    /**
     * Returns the subject to use in the email.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when constructing the subject.
     * @return {undefined|string}
     */
    emailOptionSubject: function(model) {
        var shareParams = this._getShareParams(model);
        var subject = this.shareTplSubject(shareParams);

        return subject;
    },

    /**
     * Returns the plain-text body to use in the email.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when constructing the body.
     * @return {undefined|string}
     */
    emailOptionDescription: function(model) {
        var shareParams = this._getShareParams(model);
        var description = this.shareTplBody(shareParams);

        return description;
    },

    /**
     * Returns the HTML body to use in the email.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when constructing the body.
     * @return {undefined|string}
     */
    emailOptionDescriptionHtml: function(model) {
        var shareParams = this._getShareParams(model);
        var description = this.shareTplBody(shareParams);
        var descriptionHtml = this.shareTplBodyHtml(shareParams);

        return descriptionHtml || description;
    },

    /**
     * Set subject and body settings for the EmailClientLaunch plugin to use
     *
     * @protected
     * @deprecated Use
     * View.Fields.Base.ShareactionField#emailOptionSubject,
     * View.Fields.Base.ShareactionField#emailOptionDescription, and
     * View.Fields.Base.ShareactionField#emailOptionDescriptionHtml
     * instead.
     */
    _setShareOptions: function() {
        app.logger.warn('View.Fields.Base.ShareactionField#_setShareOptions is deprecated. Use ' +
            'View.Fields.Base.ShareactionField#emailOptionSubject, ' +
            'View.Fields.Base.ShareactionField#emailOptionDescription, and ' +
            'View.Fields.Base.ShareactionField#emailOptionDescriptionHtml instead.');
    },

    /**
     * Get the params required by the templates defined on
     * {@link #_initShareTemplates}.
     *
     * Override this if your templates need more information to be sent on the
     * share email.
     *
     * @template
     * @protected
     * @param {Data.Bean} model The params come from this model's attributes.
     * EmailClientLaunch plugin should dictate the model based on the context.
     */
    _getShareParams: function(model) {
        // Falls back to the `this.model` for backward compatibility.
        model = model || this.model;

        return _.extend({}, model.attributes, {
            module: app.lang.getModuleName(model.module),
            appId: app.config.appId,
            url: window.location.href,
            name: new Handlebars.SafeString(app.utils.getRecordName(model))
        });
    },

    /**
     * Explicit share action to launch the sugar email client with share info
     * (used by bwc)
     */
    shareWithSugarEmailClient: function() {
        this.launchSugarEmailClient(this.emailOptions);
    },

    /**
     * If there is a default signature in email compose, it should be placed
     * below the share content in the email body.
     *
     * @return {Object}
     * @protected
     * @deprecated The signature location option is set during initialization.
     */
    _retrieveEmailOptionsFromLink: function() {
        app.logger.warn('View.Fields.Base.ShareactionField#_retrieveEmailOptionsFromLink is deprecated. ' +
            'The signature location option is set during initialization.');
        return {};
    },

    /**
     * Retrieve a mailto URL to launch an external mail client with share info
     * (used by bwc)
     */
    getShareMailtoUrl: function() {
        return this._buildMailToURL(this.emailOptions);
    }
}) },
"dashletaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DashletactionField
 * @alias SUGAR.App.view.fields.BaseDashletactionField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Dashletaction Field (base) 

    events: {
        'click [data-dashletaction]': 'actionClicked'
    },
    extendsFrom: 'ButtonField',
    /**
     * Trigger the function which is in the dashlet view.
     *
     * @param {Event} evt Mouse event.
     */
    actionClicked: function(evt) {
        if (this.preventClick(evt) === false) {
            return;
        }
        var action = $(evt.currentTarget).data('dashletaction');
        this._runAction(evt, action);
    },

    /**
     * Handles rowaction's event trigger and propagate the event to the main dashlet.
     *
     * @param {Event} evt Mouse event.
     * @param {String} action Name of executing parent action.
     * @protected
     */
    _runAction: function(evt, action) {
        if (!action) {
            return;
        }
        var dashlet = this.view.layout ? _.first(this.view.layout._components) : null;
        if (dashlet && _.isFunction(dashlet[action])) {
            dashlet[action](evt, this.def.params);
        } else if (_.isFunction(this.view[action])) {
            this.view[action](evt, this.def.params);
        }
    }
}) },
"email": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EmailField
 * @alias SUGAR.App.view.fields.BaseEmailField
 * @extends View.Fields.Base.BaseField
 */
({
	// Email Field (base) 

    events: {
        'change .existingAddress': 'updateExistingAddress',
        'click  .btn-edit':        'toggleExistingAddressProperty',
        'click  .removeEmail':     'removeExistingAddress',
        'click  .addEmail':        'addNewAddress',
        'change .newEmail': 'addNewAddress',
        'click [data-action=audit-email-address]': 'auditEmailAddress',
    },

    _flag2Deco: {
        primary_address: {lbl: "LBL_EMAIL_PRIMARY", cl: "primary"},
        opt_out: {lbl: "LBL_EMAIL_OPT_OUT", cl: "opted-out"},
        invalid_email: {lbl: "LBL_EMAIL_INVALID", cl: "invalid"}
    },

    plugins: ['ListEditable', 'EmailClientLaunch'],

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     * @param options
     */
    initialize: function(options) {
        options     = options || {};
        options.def = options.def || {};

        // By default, compose email link should be allowed
        if (_.isUndefined(options.def.emailLink)) {
            options.def.emailLink = true;
        }

        // Check if the email1 field was made required, if-so copy that property to the dynamic field.
        if (options.model &&
            options.model.fields &&
            options.model.fields.email1 &&
            options.model.fields.email1.required) {
            options.def.required = options.model.fields.email1.required;
        }

        if (options.view.action === 'filter-rows') {
            options.viewName = 'filter-rows-edit';
        }

        this._super('initialize', [options]);

        //set model as the related record when composing an email (copy is made by plugin)
        this.addEmailOptions({related: this.model});
    },

    /**
     * When data changes, re-render the field only if it is not on edit (see MAR-1617).
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:' + this.name, function() {
            if (this.action !== 'edit') {
                this.render();
            }
        }, this);
    },

    /**
     * In edit mode, render email input fields using the edit-email-field template.
     * @inheritdoc
     * @private
     */
    _render: function() {
        var emailsHtml = '';

        this._super("_render");

        if (this.tplName === 'edit') {
            // Add email input fields for edit
            _.each(this.value, function(email) {
                emailsHtml += this._buildEmailFieldHtml(email);
            }, this);
            this.$el.prepend(emailsHtml);
        }
    },

    /**
     * Get HTML for email input field.
     * @param {Object} email
     * @return {Object}
     * @private
     */
    _buildEmailFieldHtml: function(email) {
        var editEmailFieldTemplate = app.template.getField('email', 'edit-email-field'),
            emails = this.model.get(this.name),
            index = _.indexOf(emails, email);

        return editEmailFieldTemplate({
            max_length: this.def.len,
            index: index === -1 ? emails.length-1 : index,
            email_address: email.email_address,
            primary_address: email.primary_address,
            opt_out: email.opt_out,
            invalid_email: email.invalid_email
        });
    },

    /**
     * Event handler to add a new address field.
     * @param {Event} evt
     */
    addNewAddress: function(evt){
        if (!evt) return;

        var email = this.$(evt.currentTarget).val() || this.$('.newEmail').val(),
            currentValue,
            emailFieldHtml,
            $newEmailField;

        email = $.trim(email);

        if ((email !== '') && (this._addNewAddressToModel(email))) {
            // build the new email field
            currentValue = this.model.get(this.name);
            emailFieldHtml = this._buildEmailFieldHtml({
                email_address: email,
                primary_address: currentValue && (currentValue.length === 1),
                opt_out: app.config.newEmailAddressesOptedOut || false,
                invalid_email: false
            });

            // append the new field before the new email input
            $newEmailField = this._getNewEmailField()
                .closest('.email')
                .before(emailFieldHtml);

            if (this.def.required && this._shouldRenderRequiredPlaceholder()) {
                // we need to remove the required place holder now
                var label = app.lang.get('LBL_REQUIRED_FIELD', this.module),
                    el = this.$(this.fieldTag).last(),
                    placeholder = el.prop('placeholder').replace('(' + label + ') ', '');

                el.prop('placeholder', placeholder.trim()).removeClass('required');
            }
        }

        this._clearNewAddressField();
    },

    /**
     * Event handler to update an email address.
     * @param {Event} evt
     */
    updateExistingAddress: function(evt) {
        if (!evt) return;
        var $inputs = this.$('.existingAddress'),
            $input = this.$(evt.currentTarget),
            index = $inputs.index($input),
            newEmail = $input.val(),
            emails = this.model.get(this.name) || [],
            primaryRemoved;

        newEmail = $.trim(newEmail);

        if (newEmail === '') {
            // remove email if email is empty
            primaryRemoved = this._removeExistingAddressInModel(index);

            $input
                .closest('.email')
                .remove();

            if (primaryRemoved) {
                // on list views we need to set the current value on the input
                if (this.view && this.view.action === 'list') {
                    var primaryAddress = _.filter(emails, function(address) {
                        if (address.primary_address) {
                            return true;
                        }
                    });
                    if(primaryAddress[0] && primaryAddress[0].email_address) {
                        app.alert.show('list_delete_email_info', {
                            level: 'info',
                            autoClose: true,
                            messages: app.lang.get('LBL_LIST_REMOVE_EMAIL_INFO')
                        });
                        $input.val(primaryAddress[0].email_address);
                    }
                }
                this.$('[data-emailproperty=primary_address]')
                    .first()
                    .addClass('active');
            }
            return;
        }
        if (this.tplName === 'list-edit') {
            // In list-edit mode the index is not always at the index of the current target.
            _.find(emails, function(email, i) {
                if (email.primary_address) {
                    index = i;
                    return true;
                }
            });
        }
        this._updateExistingAddressInModel(index, newEmail);
    },

    /**
     * Event handler to remove an email address.
     * @param {Event} evt
     */
    removeExistingAddress: function(evt) {
        if (!evt) return;

        var $deleteButtons = this.$('.removeEmail'),
            $deleteButton = this.$(evt.currentTarget),
            index = $deleteButtons.index($deleteButton),
            primaryRemoved,
            $removeThisField;

        primaryRemoved = this._removeExistingAddressInModel(index);

        $removeThisField = $deleteButton.closest('.email');
        $removeThisField.remove();

        if (primaryRemoved) {
            // If primary has been removed, the first email address is the primary address.
            this.$('[data-emailproperty=primary_address]')
                .first()
                .addClass('active');
        }

        // if this field is required, and there is nothing in the model, then we should decorate it as required
        if (this.def.required && _.isEmpty(this.model.get(this.name))) {
            this.decorateRequired();
        }
    },

    /**
     * Event handler to toggle email address properties.
     * @param {Event} evt
     */
    toggleExistingAddressProperty: function(evt) {
        if (!evt) return;

        var $property = this.$(evt.currentTarget),
            property = $property.data('emailproperty'),
            $properties = this.$('[data-emailproperty='+property+']'),
            index = $properties.index($property);

        if (property === 'primary_address') {
            $properties.removeClass('active').attr('aria-pressed', false);
        }
        $property.attr('aria-pressed', !$property.hasClass('active'));

        this._toggleExistingAddressPropertyInModel(index, property);
    },

    /**
     * Add the new email address to the model.
     * @param {String} email
     * @return {boolean} Returns true when a new email is added.  Returns false if duplicate is found,
     *          and was not added to the model.
     * @private
     */
    _addNewAddressToModel: function(email) {
        var existingAddresses = this.model.get(this.name) ? app.utils.deepCopy(this.model.get(this.name)) : [],
            dupeAddress = _.find(existingAddresses, function(address){
                return (address.email_address === email);
            }),
            success = false;

        if (_.isUndefined(dupeAddress)) {
            existingAddresses.push({
                email_address: email,
                primary_address: (existingAddresses.length === 0),
                opt_out: app.config.newEmailAddressesOptedOut || false
            });
            this.model.set(this.name, existingAddresses);
            success = true;
        }

        return success;
    },

    /**
     * Update email address in the model.
     * @param {Number} index
     * @param {String} newEmail
     * @private
     */
    _updateExistingAddressInModel: function(index, newEmail) {
        var existingAddresses = app.utils.deepCopy(this.model.get(this.name));
        //Simply update the email address
        existingAddresses[index].email_address = newEmail;
        if (this.tplName === 'edit') {
            this.model.set(this.name + (index + 1), newEmail);
        }
        this.model.set(this.name, existingAddresses);
    },

    /**
     * Toggle email address properties: primary, opt-out, and invalid.
     * @param {Number} index
     * @param {String} property
     * @private
     */
    _toggleExistingAddressPropertyInModel: function(index, property) {
        var existingAddresses = app.utils.deepCopy(this.model.get(this.name));

        //If property is primary_address, we want to make sure one and only one primary email is set
        //As a consequence we reset all the primary_address properties to 0 then we toggle property for this index.
        if (property === 'primary_address') {
            existingAddresses[index][property] = false;
            _.each(existingAddresses, function(email, i) {
                if (email[property]) {
                    existingAddresses[i][property] = false;
                }
            });
        }

        // Toggle property for this email
        if (existingAddresses[index][property]) {
            existingAddresses[index][property] = false;
        } else {
            existingAddresses[index][property] = true;
        }

        this.model.set(this.name, existingAddresses);
    },

    /**
     * Remove email address from the model.
     * @param {Number} index
     * @return {boolean} Returns true if the removed address was the primary address.
     * @private
     */
    _removeExistingAddressInModel: function(index) {
        var existingAddresses = app.utils.deepCopy(this.model.get(this.name)),
            primaryAddressRemoved = !!existingAddresses[index]['primary_address'];

        //Reject this index from existing addresses
        existingAddresses = _.reject(existingAddresses, function (emailInfo, i) { return i == index; });

        // If a removed address was the primary email, we still need at least one address to be set as the primary email
        if (primaryAddressRemoved) {
            //Let's pick the first one
            var address = _.first(existingAddresses);
            if (address) {
                address.primary_address = true;
            }
        }

        this.model.set(this.name, existingAddresses);
        return primaryAddressRemoved;
    },

    /**
     * Clear out the new email address field.
     * @private
     */
    _clearNewAddressField: function() {
        this._getNewEmailField()
            .val('');
    },

    /**
     * Get the new email address input field.
     * @return {jQuery}
     * @private
     */
    _getNewEmailField: function() {
        return this.$('.newEmail');
    },

    /**
     * Need to call `decorateError` after all email fields are rendered.
     * @inheritdoc
     *
     * FIXME This is a temporary fix due to time constraints, a proper solution will be implemented in SC-4358
     */
    handleValidationError: function(errors) {
        this._super('handleValidationError', [errors]);
        _.defer(function (field) {
            field.decorateError(errors);
        }, this);
    },

    /**
     * Custom error styling for the e-mail field
     * @param {Object} errors
     * @override BaseField
     */
    decorateError: function(errors){
        var emails;

        this.$el.closest('.record-cell').addClass("error");

        //Select all existing emails
        emails = this.$('input:not(.newEmail)');

        _.each(errors, function(errorContext, errorName) {
            //For `email` validator the error is specific to an email
            if (errorName === 'email' || errorName === 'duplicateEmail') {

                // For each of our `sub-email` fields
                _.each(emails, function(e) {
                    var $email = this.$(e),
                        email = $email.val();

                    var isError = _.find(errorContext, function(emailError) { return emailError === email; });
                    // if we're on an email sub field where error occurred, add error styling
                    if(!_.isUndefined(isError)) {
                        this._addErrorDecoration($email, errorName, [isError]);
                    }
                }, this);
            //For required or primaryEmail we want to decorate only the first email
            } else {
                var $email = this.$('input:first');
                this._addErrorDecoration($email, errorName, errorContext);
            }
        }, this);
    },

    _addErrorDecoration: function($input, errorName, errorContext) {
        var isWrapped = $input.parent().hasClass('input-append');
        if (!isWrapped)
            $input.wrap('<div class="input-append error '+this.fieldTag+'">');
        $input.next('.error-tooltip').remove();
        $input.after(this.exclamationMarkTemplate([app.error.getErrorString(errorName, errorContext)]));
    },

    /**
     * {@inheritdoc}
     *
     * Updates the email address' `confirmation_requested_on` datetime to "now"
     * when the user copies an opted out email address' confirmation URL to the
     * clipboard.
     */
    bindDomChange: function() {
        if(this.tplName === 'list-edit') {
            this._super("bindDomChange");
        }

        this.$('[data-clipboard=enabled]').on('clipboard.success', function() {
            var id = $(this).data('email-address-id');
            var bean;

            if (!id) {
                return;
            }

            bean = app.data.createBean('EmailAddresses', {id: id});
            bean.set('confirmation_requested_on', app.date().format());
            bean.save();
        });
    },

    /**
     * {@inheritdoc}
     *
     * Removes the listeners for clipboard-enabled elements.
     */
    unbindDom: function() {
        this.$('[data-clipboard=enabled]').off('clipboard');
        this._super('unbindDom');
    },

    /**
     * To display representation
     * @param {string|Array|Object} value single email address or set of email addresses.
     */
    format: function(value) {
        /**
         * Get the confirmation URL for an email address.
         *
         * @param {string} id
         * @return {string}
         */
        function getConfirmationUrl(id) {
            return app.utils.getSiteUrl() + '?entryPoint=ConfirmEmailAddress&email_address_id=' + id;
        }

        value = app.utils.deepCopy(value);
        if (_.isArray(value) && value.length > 0) {
            // got an array of email addresses
            _.each(value, function(email) {
                // On render, determine which e-mail addresses need anchor tag included
                // Needed for handlebars template, can't accomplish this boolean expression with handlebars
                email.hasAnchor = this.def.emailLink && !email.invalid_email;
                email.confirmation_url = getConfirmationUrl(email.email_address_id);
            }, this);
        } else if (_.isObject(value) && !_.isEmpty(value)) {
            // Expecting an object containing attributes for an email address
            value = [{
                email_address: value.email_address,
                email_address_id: value.id,
                primary_address: value.primary_address,
                confirmation_url: getConfirmationUrl(value.id)
            }];
        } else if ((_.isString(value) && value !== "") || this.view.action === 'list') {
            // expected an array with a single address but got a string or an empty array
            value = [{
                email_address: value,
                primary_address: true,
                hasAnchor: true,
                confirmation_url: ''
            }];
        }

        if (value && value.length === 1) {
            value[0].soleEmail = true;
        }

        value = this.addFlagLabels(value);
        return value;
    },

    /**
     * Build label that gets displayed in tooltips.
     * @param {Object} value
     * @return {Object}
     */
    addFlagLabels: function(value) {
        var flagStr = "", flagArray;
        _.each(value, function(emailObj) {
            flagStr = "";
            flagArray = _.map(emailObj, function (flagValue, key) {
                if (!_.isUndefined(this._flag2Deco[key]) && this._flag2Deco[key].lbl && flagValue) {
                    return app.lang.get(this._flag2Deco[key].lbl);
                }
            }, this);
            flagArray = _.without(flagArray, undefined);
            if (flagArray.length > 0) {
                flagStr = flagArray.join(", ");
            }
            emailObj.flagLabel = flagStr;
        }, this);
        return value;
    },

    /**
     * To API representation
     * @param {String|Array} value single email address or set of email addresses
     */
    unformat: function(value) {
        if (this.view.action === 'list') {
            var emails = app.utils.deepCopy(this.model.get(this.name));

            if (!_.isArray(emails)) { // emails is empty, initialize array
                emails = [];
            }

            emails = _.map(emails, function(email) {
                if (email.primary_address && email.email_address !== value) {
                    email.email_address = value;
                }
                return email;
            }, this);

            // Adding a new email
            if (emails.length == 0) {
                emails.push({
                    email_address: value,
                    primary_address: true
                });
            }

            return emails;
        }

        if (this.view.action === 'filter-rows') {
            return value;
        }
    },

    /**
     * Opens a drawer to audit the email address.
     */
    auditEmailAddress: function() {
        var email = _.first(this.value);
        var emailModel = app.data.createBean('EmailAddresses', {
            name: email.email_address,
            id: email.email_address_id
        });

        var parentContext = this.context.getChildContext({
            forceNew: true,
            model: emailModel,
            module: 'EmailAddresses',
            modelId: email.email_address_id
        });

        app.drawer.open({
            layout: 'audit',
            context: {
                module: 'Audit',
                model: emailModel,
                parent: parentContext,
            }
        });
    },

    /**
     * Apply focus on the new email input field.
     */
    focus: function () {
        if(this.action !== 'disabled') {
            this._getNewEmailField().focus();
        }
    },

    /**
     * Retrieve link specific email options for launching the email client
     * Builds upon emailOptions on this
     *
     * @param {jQuery} $link
     * @private
     */
    _retrieveEmailOptionsFromLink: function($link) {
        return {
            to: [
                {
                    email: app.data.createBean('EmailAddresses', {
                        id: $link.data('email-address-id'),
                        email_address: $link.data('email-to'),
                        opt_out: $link.data('email-opt-out')
                    }),
                    bean: this.model
                }
            ]
        };
    },

    /**
     * @override
     *
     * Check if the value is a string representing the UUID.
     */
    _isErasedField: function() {
        if (!this.model) {
            return false;
        }

        var value = this.model.get(this.name);
        var erasedFields = this.model.get('_erased_fields');
        return _.isString(value) && _.contains(erasedFields, this.name);
    }
}) },
"attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.AttachmentsField
 * @alias SUGAR.App.view.fields.BaseAttachmentsField
 * @extends View.Fields.Base.BaseField
 * @deprecated Use {@link View.Fields.Base.EmailAttachmentsField} instead.
 */
({
	// Attachments Field (base) 

    fieldSelector: '.attachments',
    fileInputSelector: '.fileinput',
    $node: null,
    fileCounter: 0,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Fields.Base.AttachmentsField is deprecated. Use ' +
            'View.Fields.Base.EmailAttachmentsField instead.');

        this.events = _.extend({}, this.events, options.def.events, {
            'change .fileinput': 'uploadFile'
        });
        app.view.Field.prototype.initialize.call(this, options);

        this.context.on('attachment:add', this.addAttachment, this);
        this.context.on('attachment:filepicker:launch', this.launchFilePicker, this);
        this.context.on('attachment:upload:remove', this.removeUploadedAttachment, this);
        this.context.on('attachments:remove-by-tag', this.removeAttachmentsByTag, this);
        this.context.on('attachments:remove-by-id', this.removeAttachmentsById, this);

        // Put id on the context so <label>s can be created elsewhere to trigger this file input
        // This is required to work around an IE issue (only files picked directly or
        // from click on label can be uploaded - not programatically)
        this.fileInputName = 'email_attachment';
        this.context.set('attachment_field_' + this.fileInputName, this.cid);

        this.clearUserAttachmentCache();

        // keep track of active file upload requests so that they can be
        // aborted when the user cancels an in-progress upload
        this.requests = {};
    },

    /**
     * Allow Backspace and Delete Keys for attachments (Select2) and disable all other keys
     * @param e
     * @return {Boolean}
     * @private
     */
    _keyHandler: function(e) {
        // if key is backspace or delete ...
        if ((event.keyCode == 8 || event.keyCode == 46)) {
            return true; // Allow
        }
        return false; // Ignore Any other Keyboard Input
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var result = app.view.Field.prototype._render.call(this);

        this.$node = this.$(this.fieldSelector);

        this.$node.select2({
            allowClear:          true,
            multiple:            true,
            containerCssClass:   'select2-choices-pills-close',
            containerCss:        {'width':'100%'},
            tags: [],
            formatSelection: this.formatSelection,
            width: 'off',
            escapeMarkup: function(m) { return m; }
        });

        var inp = this.$el.find('.attachments.select2-container .select2-choices .select2-search-field .select2-input');
        if (inp && inp[0]) {
            $(inp[0]).keypress(this._keyHandler);
            $(inp[0]).keyup(this._keyHandler);
            $(inp[0]).keydown(this._keyHandler);
        }

        //handle case where attachments are pre-populated on the model
        this.refreshFromModel();

        return result;
    },

    /**
     * Launch the file input picker.
     */
    launchFilePicker: function() {
        var $fileInput = this.$(this.fileInputSelector);
        $fileInput.click();
    },

    /**
     * Add attachment to the select2 field and update the model explicitly (because select2 does not fire change on add)
     *
     * @param attachment object containing at least guid and nameForDisplay attributes
     */
    addAttachment: function(attachment) {
        this.addAttachmentToContainer(attachment);
        this.updateModel();
    },

    /**
     * Just add the attachment to the container - useful for upload progress items
     * @param attachment
     */
    addAttachmentToContainer: function(attachment) {
        var attachments = this.getDisplayedAttachments();

        if (attachment.replaceId) {
            attachments = _.map(attachments, function(existing) {
                return (existing.id == attachment.replaceId) ? attachment : existing;
            });
            delete attachment.replaceId;
        } else {
            attachments.push(attachment);
        }

        this.setDisplayedAttachments(attachments);
    },

    /**
     * @inheritdoc
     * Update model if attachments are removed (select2-removing event fires when attachment removed)
     * Prevent dropdown from opening on this field (its a container only)
     */
    bindDomChange: function() {
        this.$node = this.$(this.fieldSelector);
        this.$node.on("select2-removing", _.bind(this.handleChange, this));
        this.$node.on("select2-opening", function(event) {
            event.preventDefault();
        });
    },

    /**
     * Before handling any attachment uploads, need to clear the user's attachment cache.
     */
    clearUserAttachmentCache: function() {
        var clearCacheUrl = app.api.buildURL('Mail/attachment', "cache");
        app.api.call('delete', clearCacheUrl);
    },

    /**
     * Format how the attachment should be displayed in the pill
     *
     * @param attachment
     * @return {String}
     */
    formatSelection: function(attachment) {
        var item = '<span data-id="'+attachment.id+'">'+attachment.nameForDisplay+'</span>';
        if (attachment.showProgress) {
            item += ' <i class="fa fa-refresh fa-spin"></i>';
        }
        return item;
    },

    /**
     * Get the attachments displayed in select2
     *
     * @return {array} of attachments
     */
    getDisplayedAttachments: function() {
        return this.$node.select2('data');
    },

    /**
     * Handle change event fired by select2 - this is really just remove attachment events
     * @param event
     */
    handleChange: function(event) {
        if (event && event.choice && event.choice.id) {
            this.removeAttachmentsById(event.choice.id);
        }

        this.updateModel();
        this.notifyAttachmentsChanged();
    },

    /**
     * Fire event when attachment is removed
     * (useful for attachment types that require cleanup)
     *
     * Aborts the associated request if it is still active.
     *
     * @param attachment
     */
    notifyAttachmentRemoved: function(attachment) {
        if (this.requests[attachment.id]) {
            app.api.abortRequest(this.requests[attachment.id]);
        }

        this.context.trigger('attachment:' + attachment.type + ':remove', attachment);
    },

    /**
     * Fire event when attachments displayed has changed
     *
     * @param attachments
     */
    notifyAttachmentsChanged: function(attachments) {
        attachments = attachments || this.getDisplayedAttachments();
        this.context.trigger('attachments:updated', attachments);
    },

    /**
     * Refresh select2 from model
     */
    refreshFromModel: function() {
        var attachments = [];
        if (this.model.has(this.name)) {
            attachments = this.model.get(this.name);
        }
        this.setDisplayedAttachments(attachments);
    },

    /**
     * Remove attachments in list based on a given truth test iterator
     * Removes from select2 and then updates the model
     *
     * @param iterator
     */
    removeAttachmentsByIterator: function(iterator) {
        var attachments = this.getDisplayedAttachments();
        attachments = _.reject(attachments, iterator);
        this.setDisplayedAttachments(attachments);
        this.updateModel();
    },

    /**
     * Remove attachments in list based on a given guid
     *
     * @param id
     */
    removeAttachmentsById: function(id) {
        this.removeAttachmentsByIterator(_.bind(function(attachment) {
            if (attachment.id && attachment.id === id) {
                this.notifyAttachmentRemoved(attachment);
                return true;
            }
        }, this));
    },

    /**
     * Remove attachments in list based on a given tag
     *
     * @param tag
     */
    removeAttachmentsByTag: function(tag) {
        this.removeAttachmentsByIterator(_.bind(function(attachment) {
            if (attachment.tag && attachment.tag === tag) {
                this.notifyAttachmentRemoved(attachment);
                return true;
            }
        }, this));
    },

    /**
     * Remove the given attachment from the server, if there is a problem doing this, no big deal (hence no error alert)
     * @param attachment
     */
    removeUploadedAttachment: function(attachment) {
        var deleteUrl = app.api.buildURL('Mail/attachment', "delete", {id:attachment.id});
        app.api.call('delete', deleteUrl);
    },

    /**
     * Sets the attachments on select2
     */
    setDisplayedAttachments: function(attachments) {
        this.$node.select2('data', attachments);
        this.notifyAttachmentsChanged(attachments);
    },

    /**
     * Update the model from the data stored in select2
     */
    updateModel: function() {
        this.model.set(this.name, this.getDisplayedAttachments());
    },

    /**
     * Returns a File object from the HTML element passed in.
     *
     * @private
     * @param {HTMLElement} el The <input> element containing the file.
     * @return {File} The File object, containing file information.
     */
    _getFileFromInput: function(el) {
        return el.files[0];
    },

    /**
     * Upload the file and define callbacks for success & failure
     */
    uploadFile: function() {
        var $fileInput = this.$(this.fileInputSelector),
            ajaxParams = {
                files: $fileInput,
                iframe: true
            },
            fileId,
            myURL,
            options;

        //don't do anything if user cancels out of picking a file
        if (_.isEmpty(this.getFileInputVal())) {
            return;
        }

        var inputEl = $fileInput.get(0);
        var file = this._getFileFromInput(inputEl);

        if (file.size > app.config.uploadMaxsize) {
            app.alert.show('large_attachment_error', {
                level: 'error',
                messages: app.lang.get('ERROR_MAX_FILESIZE_EXCEEDED')
            });
            return;
        }

        //Notify user of progress uploading by adding a placeholder pill
        this.fileCounter++;
        fileId = 'upload'+this.fileCounter;
        this.addAttachmentToContainer({
            id: fileId,
            nameForDisplay: this.getFileInputVal().split('\\').pop(),
            showProgress: true
        });

        options = {
            format: 'sugar-html-json',
        };
        myURL = app.api.buildURL('Mail/attachment', null, null, options);
        var request = app.api.call('create', myURL, null, {
                success: _.bind(function (result) {
                    if (this.disposed === true) return; //if field is already disposed, bail out
                    if (!result.guid) {
                        this.handleUploadError(fileId, result);
                        app.logger.error('Attachment Upload Failed - no guid returned from API');
                        return;
                    }

                    //add attachment to container, replacing placeholder pill from above
                    result.id = result.guid;
                    delete result.guid;
                    result.type = 'upload';
                    result.replaceId = fileId;
                    this.context.trigger('attachment:add', result);
                }, this),

                error: _.bind(function(e) {
                    //if field is already disposed, bail out
                    if (this.disposed === true) {
                        return;
                    }

                    // When a user cancels a file upload, the associated request
                    // is aborted. The error handler is called when a request is
                    // aborted. No error message needs to be shown in this case.
                    if (e && e.errorThrown === 'abort') {
                        return;
                    }

                    this.handleUploadError(fileId, e);
                    app.logger.error('Attachment Upload Failed: ' + e);
                }, this),

                complete: _.bind(function() {
                    // the request is done so there is nothing to cancel
                    // no need to keep track of finished requests
                    delete this.requests[fileId];

                    //clear out the file input so we can detect the next change, even if it is the same file
                    this.clearFileInputVal($fileInput);
                }, this)
            },
            ajaxParams
        );

        // keep track of the request so that it can be aborted when the user cancels the file upload
        if (request) {
            this.requests[fileId] = request.uid;
        }
    },

    /**
     * Retrieve the val from the file input element (return null if not there)
     */
    getFileInputVal: function($fileInput) {
        $fileInput = $fileInput || this.$(this.fileInputSelector);
        if (_.isUndefined($fileInput)) {
            return null;
        }
        return $fileInput.val();
    },

    /**
     * Clear the value of the file input element
     * This is a bit of a hack, but is required for cross-browser (read IE isn't playing nice)
     * FIXME: When we drop IE10 support, change to: $fileInput.val(null);
     *
     * @param $fileInput
     */
    clearFileInputVal: function($fileInput) {
        $fileInput = $fileInput || this.$(this.fileInputSelector);
        if (!_.isUndefined($fileInput)) {
            $fileInput.wrap('<form>').closest('form').get(0).reset();
            $fileInput.unwrap();
        }
    },

    /**
     * When upload fails, display an error alert and remove the placeholder pill
     * @param fileId
     * @param {Object} [error] The error object containing the message to display.
     * @param {string} [error.error_message] The error message to display.
     */
    handleUploadError: function(fileId, error) {
        var message = (error && error.error_message) ? error.error_message : 'LBL_EMAIL_ATTACHMENT_UPLOAD_FAILED';

        this.context.trigger('attachments:remove-by-id', fileId);
        app.alert.show('upload_error', {
            level: 'error',
            messages: message
        });
    },

    /**
     * Turn off re-rendering of field when model changes - let select2 handle how the field looks
     */
    bindDataChange:$.noop,

    _dispose: function() {
        this.$node.select2('destroy');
        app.view.Field.prototype._dispose.call(this);
    }
}) },
"save-and-send-invites-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * SaveAndSendInvitesButtonField field is a field for Meetings/Calls that handles setting the flag for sending emails to guests
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.SaveAndSendInvitesButtonField
 * @alias SUGAR.App.view.fields.BaseSaveAndSendInvitesButtonField
 * @extends View.Fields.Base.RowactionField
 *
 */
({
	// Save-and-send-invites-button Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     *
     * Sets the type to "rowaction" so that the templates are loaded from
     * super.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * Setting model event to allow unsetting of send_invites after validation error or data sync completed.
     * @inheritdoc
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        this.model.on('error:validation data:sync:complete', function() {
            this.model.unset('send_invites');
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Silently sets `send_invites` to true on the model before saving.
     */
    rowActionSelect: function(event) {
        this.model.set('send_invites', true, {silent: true});
        this._super('rowActionSelect', [event]);
    }
}) },
"currency": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CurrencyField
 * @alias SUGAR.App.view.fields.BaseCurrencyField
 * @extends View.Fields.Base.BaseField
 */
({
	// Currency Field (base) 

    /**
     * list of events to listen for
     * @type {Object}
     */
    'events': {
        'click': 'updateCss'
    },
    /**
     * @type {String}
     * field value non-formatted or converted
     */
    transactionValue: '',
    /**
     * @type {Object}
     * reference to the currency dropdown field object
     */
    _currencyField: null,
    /**
     * @type {Boolean}
     * whether or not the currency dropdown is hidden from view
     */
    hideCurrencyDropdown: false,
    /**
     * @type {String}
     * last known record currency id
     */
    _lastCurrencyId: null,

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * Do we have edit access to this field?
     */
    hasEditAccess: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var currencyField = this.def.currency_field || 'currency_id',
            currencyFieldValue, baseRateField, baseRateFieldValue;

        // should we ignore the user preference currency
        // currently this is only used in quotes
        var ignoreUserPrefCurrency = this.model.ignoreUserPrefCurrency || false;

        if (this.model.isNew() && (!this.model.isCopy()) && (!ignoreUserPrefCurrency)) {
            // new records are set the user's preferred currency
            currencyFieldValue = app.user.getPreference('currency_id');
            this.model.set(currencyField, currencyFieldValue);

            // set the base rate for the user's preferred currency
            baseRateField = this.def.base_rate_field || 'base_rate';
            baseRateFieldValue = app.metadata.getCurrency(currencyFieldValue).conversion_rate;
            this.model.set(baseRateField, baseRateFieldValue);

            // Modules such as `Forecasts` uses models that aren't `Data.Bean`
            if (_.isFunction(this.model.setDefault)) {
                var defaults = {};
                defaults[currencyField] = currencyFieldValue;
                defaults[baseRateField] = baseRateFieldValue;
                this.model.setDefault(defaults);
            }
        }
        this.hasEditAccess = app.acl.hasAccess('edit', this.model.module, undefined, this.name);
        // hide currency dropdown on list views
        this.hideCurrencyDropdown = this.view.action === 'list';
        // track the last currency id to convert the value on change
        this._lastCurrencyId = this.model.get(currencyField);
    },

    /**
     * @inheritdoc
     *
     * Setup transactional amount if flag is present and transaction currency
     * is not base.
     * On edit view render the currency enum field associated with this field on
     * the correct placeholder
     *
     * @return {Object} this
     * @private
     */
    _render: function() {
        if (this._currencyField) {
            this._currencyField.dispose();
            this._currencyField = null;
        }
        this._super('_render');
        if (this.hideCurrencyDropdown === false && this.tplName === 'edit') {
            this.getCurrencyField().setElement(this.$('span[sfuuid="' + this.currencySfId + '"]'));
            this.$el.find('div.select2-container').css('min-width', '8px');
            this.getCurrencyField().render();
        }
        return this;
    },

    handleValidationError: function(errors) {
        this._super('handleValidationError', [errors]);
        _.defer(function (field) {
            field.clearErrorDecoration();
            field.decorateError(errors);

        }, this);
    },

    clearErrorDecoration: function () {
        var self = this,
            ftag = this.fieldTag || '',
            $ftag = this.$(ftag);
        // Remove previous exclamation then add back.
        this.$('.add-on').remove();

        //Not all inputs are necessarily wrapped so check each individually
        $ftag.each(function(index, el) {
            var isWrapped = self.$(el).parent().hasClass('input-append');
            if (isWrapped) {
                self.$(el).unwrap();
            }
        });
        this.$el.removeClass(ftag);
        this.$el.removeClass("error");
        this.$el.closest('.record-cell').removeClass("error");
    },

    /**
     * @override
     *
     * If the incoming value is the same as the value on the model
     * then just set the currency value so it's formatted correctly
     * otherwise, set the new value on the model
     */
    bindDomChange: function() {
        if (!(this.model instanceof Backbone.Model)) {
            return;
        }

        var self = this;
        var el = this.$el.find(this.fieldTag);
        el.on('change', function() {
            // trimming the value to remove space if any
            var trimVal = el.val() ? el.val().trim() : el.val();
            var val = self.unformat(trimVal);
            if (_.isEqual(val, self.model.get(self.name))) {
                self.setCurrencyValue(val);
            } else {
                self.model.set(self.name, val);
            }
        });
    },

    /**
     * When currency changes, we need to make appropriate silent changes to the base rate.
     */
    bindDataChange: function() {
        // we do not call the parent which re-renders,
        // but instead update the value on the field directly
        this.model.on('change:' + this.name, this._valueChangeHandler, this);

        if (this.def.is_base_currency) {
            // do not add change handler to _usdollar fields
            return;
        }

        var currencyField = this.def.currency_field || 'currency_id';
        var baseRateField = this.def.base_rate_field || 'base_rate';
        // if the current_user doesn't have edit access to the field
        // don't add these listeners
        if (this.hasEditAccess && !this.hideCurrencyDropdown) {
            this.model.on('change:' + baseRateField, this.handleBaseRateFieldChange, this);
            this.model.on('change:' + currencyField, this.handleCurrencyFieldChange, this);
        }
    },

    /**
     * Listens to currency field changes. Calls the update model value method if required and saves the latest
     * currencyId
     * @protected
     */
    handleCurrencyFieldChange: function(model, currencyId, options) {
        var baseRateField = this.def.base_rate_field || 'base_rate';
        //When model is reset, it should not be called
        if (!currencyId || !this._lastCurrencyId || options.revert === true) {
            this._lastCurrencyId = currencyId;
            return;
        }

        if (_.has(model.changed, this.name)) {
            // if this field is on the view more than once, this will trigger x number of times. so if the
            // currency_id has changed and this field has already changed on the model, we should ignore it.
            return;
        }

        // update the base rate in the model, set it silently since we are already going to do a re-render
        this.model.set(baseRateField, app.metadata.getCurrency(currencyId).conversion_rate, {silent: true});

        if (!_.isUndefined(this.view.getField('base_rate'))) {
            this.view.getField('base_rate').render();
        }

        // convert the value to new currency on the model
        if (model.has(this.name)) {
            var val = model.get(this.name);
            this.updateModelWithValue(model, currencyId, val);
        }
        this._lastCurrencyId = currencyId;
    },

    /**
     * Updates the currency field value when the currency field changes.  Defers model changes and re-renders the field
     * so that the currency value changes when a 0 amount is switched between currencies.
     * @protected
     */
    updateModelWithValue: function(model, currencyId, val) {
        if (val) {
            this.model.set(
                this.name,
                app.currency.convertAmount(
                    val,
                    this._lastCurrencyId,
                    currencyId
                ),
                // we don't want to affect other bindings like sugar logic
                // when updating a value upon a currency_id change,
                // so set the model silently, then update the field value
                // directly (see next func call)
                {silent: true}
            );
        }
        // now defer changes to the end of the thread to avoid conflicts
        // with other events (from SugarLogic, etc.)
        this._deferModelChange();
    },

    /**
     * handles when the base rate changes.  Defers model changes and re-renders the field
     * so that the currency symbol changes when a 0 amount is switched between currencies.
     * @private
     */
    handleBaseRateFieldChange: function(model, currencyId, options) {
        var baseRateField = this.def.base_rate_field || 'base_rate';
        var prevBaseRate = model.previous(baseRateField);
        var baseRate = model.get(baseRateField);
        var precision;
        var newValue;
        var previousValue;

        if (!_.isUndefined(prevBaseRate)) { // it is undefined, of course, at first load
            precision = this.def && this.def.precision || 6;
            // lets actually make sure this really changed before triggering the deferModelChange method.
            // that way if base_rate is a integer we can actually make sure it didn't change
            // eg: 1 to "1.000000"
            newValue = app.math.round(baseRate, precision, true);
            previousValue = app.math.round(prevBaseRate, precision, true);
            if (!_.isEqual(newValue, previousValue)) {
                if (options && _.isUndefined(options.revert)) {
                    this._deferModelChange();
                }
            }
        }
        //rerender the currency field. This is needed if a currency field is 0, but changes currencies.  Since
        //$0 and 0 EUR are the same, it doesn't detect the switch and 0 fields can show the wrong currency symbol.
        this._render();
    },

    /**
     * Trigger the model change, but only if the current user has edit access to it.
     *
     * @private
     */
    _deferModelChange: function() {
        if (this.hasEditAccess) {
            _.defer(_.bind(function() {
                if (!this.disposed) {
                    this.model.trigger('change:' + this.name, this.model, this.model.get(this.name));
                }
            }, this));
        }
    },

    /**
     * Handler for when the value changes on the model.
     *
     * If action does not match edit, field is re-rendered, otherwise the field
     * value is updated, plus, if the currency of the given model is different
     * from the one we have, the supplied amount is also converted to the new
     * currency.
     *
     * @param {Data.Bean} model Model.
     * @param {String} value Amount.
     * @private
     */
    _valueChangeHandler: function(model, value) {
        if (this.action != 'edit') {
            this.render();
            return;
        }

        if (model.get('currency_id') !== this.model.get('currency_id')) {
            value = app.currency.convertAmount(
                value,
                model.get('currency_id'),
                this.model.get('currency_id')
            );
        }

        this.setCurrencyValue(value);
    },

    /**
     * set the currency value on the field directly
     *
     * @param {String} value
     */
    setCurrencyValue: function(value) {
        this.$('[name=' + this.name + ']').val(app.utils.formatNumberLocale(value));
    },

    /**
     * @inheritdoc
     *
     * Convert to base currency if flag is present.
     *
     * @param {Array/Object/String/Number/Boolean} value The value to format.
     * @return {String} the formatted value based on view name.
     */
    format: function(value) {
        if (_.isNull(value) || _.isUndefined(value) || _.isNaN(value)) {
            value = '';
        }

        if (this.tplName === 'edit') {
            this.currencySfId = this.getCurrencyField().sfId;
            return app.utils.formatNumberLocale(value);
        }

        var baseRate = this.model.get(this.def.base_rate_field || 'base_rate');
        var transactionalCurrencyId = this.model.get(this.def.currency_field || 'currency_id'),
            convertedCurrencyId = transactionalCurrencyId,
            origTransactionValue = value;

        // TODO review this forecasts requirement and make it work with css defined on metadata
        // force this to recalculate the transaction value if needed
        // and more importantly, clear out previous transaction value
        this.transactionValue = '';
        if (value === '') {
            return value;
        }
        if (this.def.is_base_currency) {
            // usdollar field, treat the field as base currency
            transactionalCurrencyId = convertedCurrencyId = app.currency.getBaseCurrencyId();
        } else {
            if (this.def.convertToBase && transactionalCurrencyId !== app.currency.getBaseCurrencyId()) {
                if (this.def.showTransactionalAmount) {
                    this.transactionValue = app.currency.formatAmountLocale(
                        this.model.get(this.name) || 0,
                        transactionalCurrencyId
                    );
                }
                value = app.currency.convertWithRate(value, baseRate) || 0;
                convertedCurrencyId = app.currency.getBaseCurrencyId();
            }
        }
        // convert value to user preferred currency
        if ((this.def.is_base_currency || this.def.convertToBase) &&
            !this.def.skip_preferred_conversion &&
            app.user.get('preferences').currency_show_preferred) {
                var userPreferredCurrencyId = app.user.getPreference('currency_id');
                if (userPreferredCurrencyId !== transactionalCurrencyId) {
                    convertedCurrencyId = userPreferredCurrencyId;

                    // when we are displaying in the user preferred currency, the transactional
                    // amount should equal the row amount
                    this.transactionValue = app.currency.formatAmountLocale(
                        this.model.get(this.name) || 0,
                        transactionalCurrencyId
                    );
                    value = app.currency.convertWithRate(
                        value,
                        '1.0',
                        app.metadata.getCurrency(userPreferredCurrencyId).conversion_rate
                    );
                } else {
                    // user preferred same as transactional, no conversion required
                    this.transactionValue = '';
                    convertedCurrencyId = transactionalCurrencyId;
                    value = origTransactionValue;
                }
        }
        return app.currency.formatAmountLocale(value, convertedCurrencyId);
    },

    /**
     * @inheritdoc
     *
     * @param {String} value The value to unformat.
     * @return {Number} Unformatted value.
     */
    unformat: function(value) {
        var unformattedValue;
        if (this.tplName === 'edit') {
            unformattedValue = app.utils.unformatNumberStringLocale(value);
        } else {
            unformattedValue = app.currency.unformatAmountLocale(value);
        }

        // if we got a number back and we have a precision we should round to that precision as that is what will
        // be stored in the db, this is needed just in case SugarLogic is used on this field's value
        if (_.isFinite(unformattedValue)) {
            // if no precision is defined, default to 6 which is the system default
            var precision = this.def && this.def.precision || 6;
            return app.math.round(unformattedValue, precision, true);
        }

        return value;
    },

    /**
     * update dropdown css to active state
     */
    updateCss: function() {
        $('div.select2-drop.select2-drop-active').width('auto');
    },

    /**
     * Get the currency field related to this currency amount.
     *
     * @return {View.Field} the currency field associated.
     */
    getCurrencyField: function() {

        if (!_.isNull(this._currencyField)) {
            return this._currencyField;
        }

        var currencyDef = this.model.fields[this.def.currency_field || 'currency_id'];
        currencyDef.type = 'enum';
        currencyDef.options = app.currency.getCurrenciesSelector(Handlebars.compile('{{symbol}} ({{iso4217}})'));
        currencyDef.enum_width = '100%';
        currencyDef.searchBarThreshold = this.def.searchBarThreshold || 7;

        this._currencyField = app.view.createField({
            def: currencyDef,
            view: this.view,
            viewName: this.tplName,
            model: this.model
        });
        this._currencyField.defaultOnUndefined = false;

        return this._currencyField;
    },

    /**
     * set the mode of the dropdown field
     * @param {String} the mode name.
     */
    setMode: function(name) {
        this._super('setMode', [name]);
        if (this.action === 'edit') {
            this.getCurrencyField().setMode(name);
        }
    },

    /**
     * @inheritdoc
     */
    dispose: function() {
        if (this._currencyField) {
            this._currencyField.dispose();
            this._currencyField = null;
        }
        this._super('dispose');
    }
}) },
"closebutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * ClosebuttonField is a field for Meetings/Calls/Tasks that handles setting a value on a field in the model based on meta data with
 * an option to create a new record
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.ClosebuttonField
 * @alias SUGAR.App.view.fields.BaseClosebuttonField
 * @extends View.Fields.Base.RowactionField
 */


({
	// Closebutton Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * Setup click event handlers.
     * @inheritdoc
     *
     * @param {Object} options
     */
    initialize: function(options) {
        this.events = _.extend({}, this.events, options.def.events, {
            'click [name="record-close"]': 'closeClicked',
            'click [name="record-close-new"]': 'closeNewClicked'
        });

        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * Handle record close event.
     *
     * @param {Event} event The click event for the close button
     */
    closeClicked: function(event) {
        this._close(false);
    },

    /**
     * Handle record close and create new event.
     *
     * @param {Event} event The click event for the close and create new button
     */
    closeNewClicked: function(event) {
        this._close(true);
    },

    /**
     * @inheritdoc
     *
     * Button should be hidden if record displayed is already closed
     */
    _render: function() {
        if (this.model.get(this.getStatusFieldName()) === this.getClosedStatus()) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Retrieve the closed status value from the fields meta definition
     *
     * @return {string}
     */
    getClosedStatus: function() {
        return ((this.def && this.def.closed_status) ?
            this.def.closed_status :
            'Completed');
    },

    /**
     * Retrieve the status field name from the field meta definition.
     * Defaults to 'status'
     *
     * @return {string}
     */
    getStatusFieldName: function() {
        return ((this.def && this.def.status_field_name) ?
            this.def.status_field_name :
            'status');
    },

    /**
     * Close the record by setting the appropriate status on the record.
     *
     * @param {boolean} createNew Flag for whether to open a new drawer to create a
     *   record after close.
     * @private
     */
    _close: function(createNew) {
        var self = this;

        this.model.set(this.getStatusFieldName(), this.getClosedStatus());
        this.model.save({}, {
            success: function() {
                self.showSuccessMessage();
                if (createNew) {
                    self.openDrawerToCreateNewRecord();
                }
            },
            error: function(model, error) {
                self.showErrorMessage();
                app.logger.error('Record failed to close. ' + error);

                // we didn't save, revert!
                self.model.revertAttributes();
            }
        });
    },

    /**
     * Open a drawer to create a new record.
     */
    openDrawerToCreateNewRecord: function() {
        var self = this,
            statusField = this.getStatusFieldName(),
            module = app.metadata.getModule(this.model.module),
            prefill = app.data.createBean(this.model.module);

        prefill.copy(this.model);

        if (module.fields[statusField] && module.fields[statusField]['default']) {
            prefill.set(statusField, module.fields[statusField]['default']);
        } else {
            prefill.unset(statusField);
        }

        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                model: prefill
            }
        }, function() {
            if (self.parent) {
                self.parent.render();
            } else {
                self.render();
            }
        });
    },

    /**
     * Display a success message.
     *
     * This message includes the value the status field was set to - so we need
     * to retrieve the translated string (if there is one).
     */
    showSuccessMessage: function() {
        var statusField = this.getStatusFieldName(),
            statusFieldMetadata = app.metadata.getModule(this.module).fields[statusField],
            optionStrings,
            statusValue;

        // if this is an enum field, retrieve translated value
        if (statusFieldMetadata && statusFieldMetadata.options) {
            optionStrings = app.lang.getAppListStrings(statusFieldMetadata.options);
            statusValue = optionStrings[this.getClosedStatus()].toLocaleLowerCase();
        } else {
            // not an enum field - just display lowercase version of the value
            statusValue = this.getClosedStatus().toLocaleLowerCase();
        }

        app.alert.show('status_change_success', {
            level: 'success',
            autoClose: true,
            messages: app.lang.get('TPL_STATUS_CHANGE_SUCCESS',
                this.module,
                {
                    moduleSingular: app.lang.getModuleName(this.module),
                    status: statusValue
                }
            )
        });
    },

    /**
     * Display an error message.
     */
    showErrorMessage: function() {
        app.alert.show('close_record_error', {
            level: 'error',
            title: app.lang.get('ERR_AJAX_LOAD')
        });
    },

    /**
     * Re-render the field when the status on the record changes.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:status', this.render, this);
        }
    }
}) },
"piiname": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PiinameField
 * @alias SUGAR.App.view.fields.BasePiinameField
 * @extends View.Fields.Base.BaseField
 */
({
	// Piiname Field (base) 

    /**
     * @inheritdoc
     *
     * Convert the raw field type name into the label of the field
     * of the Pii module or Pii parent module; if not available,
     * use raw value.
     */
    format: function(value) {
        var module;
        var field;

        if (!this.context) {
            return value;
        }

        if (this.context.has('piiModule')) {
            module = this.context.get('piiModule');
            field = app.metadata.getField({module: module, name: value});
        } else if (this.context.parent) {
            var model = this.context.parent.get('model');
            module = model.module;
            field = model.fields[value];
        }

        if (field) {
            value = app.lang.get(field.label || field.vname, module);
        }

        return value;
    }
}) },
"image": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ImageField
 * @alias SUGAR.App.view.fields.BaseImageField
 * @extends View.Fields.Base.BaseField
 */
({
	// Image Field (base) 

    fieldTag: 'input[type=file]',

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    events: {
        "click .delete": "delete",
        "change input[type=file]": "selectImage"
    },

    plugins: ['File', 'FieldDuplicate'],

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @override
     *
     * FIXME: The {@link #model} used by this view should be a {@link Data.Bean}
     * and not a simple {@link Backbone.Model}. This should be removed when
     * {@link View.Views.Base.HistorySummaryView} view is refactored to use a
     * true {@link Data.MixedBeanCollection}.
     */
    initialize: function(options) {
        app.view.Field.prototype.initialize.call(this, options);

        // FIXME: This needs an API instead. SC-3369 should address this.
        // Also, this field should extend the file field to inherit these
        // error properties.
        app.error.errorName2Keys['tooBig'] = 'ERROR_MAX_FILESIZE_EXCEEDED';
        app.error.errorName2Keys['uploadFailed'] = 'ERROR_UPLOAD_FAILED';

        // FIXME: we should have a {@link Da
        if (_.isFunction(this.model.addValidationTask)) {
            this.model.hasImageRequiredValidator = true;
            this.model.addValidationTask('image_required_' + this.cid, _.bind(this._doValidateImageField, this));
        }
    },

    /**
     * @override
     * @private
     */
    _dispose: function() {
        //Remove specific validation task from the model
        this.model.hasImageRequiredValidator = false;
        if (this.model.removeValidationTask) {
            this.model.removeValidationTask('image_required_' + this.cid);
        }
        app.view.Field.prototype._dispose.call(this);
    },

    /**
     * Handler to refresh field state.
     *
     * Called from {@link app.plugins._onFieldDuplicate}
     */
    onFieldDuplicate: function() {
        if (this.disposed || this.view.name !== 'merge-duplicates') {
            return;
        }
        this.render();
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this.model.fileField = this.name;
        app.view.Field.prototype._render.call(this);

        //Define default sizes
        if (this.view && this.view.meta && this.view.meta.type === 'list') {
            this.width = this.height = this.$el.parent().height() || 42;
            this.def.width = this.def.height = undefined;
        } else {
            this.width = parseInt(this.def.width || this.def.height, 10) || 42;
            this.height = parseInt(this.def.height, 10) || this.width;
        }

        //Resize widget before the image is loaded
        this.resizeWidth(this.width);
        this.resizeHeight(this.height);
        this.$('.image_field').removeClass('hide');
        //Resize widget once the image is loaded
        this.$('img').addClass('hide').on('load', $.proxy(this.resizeWidget, this));
        return this;
    },

    /**
     * @override
     * @param value
     * @return value
     */
    format: function(value) {
        if (value) {
            value = this.buildUrl() + "&_hash=" + value;
        }
        return value;
    },

    /**
     * @override
     */
    bindDataChange: function() {
        //Keep empty for edit because you cannot set a value of an input type `file`
        var viewType = this.view.name || this.options.viewName;
        var ignoreViewType = ["edit", "create"];
        if ((_.indexOf(ignoreViewType, viewType) < 0)
            && (this.view.action !== "edit")
            && (this.view.name !== 'merge-duplicates')) {
            app.view.Field.prototype.bindDataChange.call(this);
        }
    },

    /**
     * @override
     */
    bindDomChange: function() {
        //Override default behavior
        this.$(this.fieldTag).on('focus', _.bind(this.handleFocus, this));
    },

    /**
     * This is the custom implementation of bindDomChange. Here we upload the image to give a preview to the user.
     * @param e
     */
    selectImage: function(e) {
        var self = this,
            $input = self.$('input[type=file]');

        //Set flag to indicate we are previewing an image
        self.preview = true;

        //Remove error message
        self.clearErrorDecoration();

        // Upload a temporary file for preview
        self.model.uploadFile(
            self.name,
            $input,
            {
                field: self.name,
                //Callbacks
                success: function(rsp) {
                    //read the guid
                    var fileId = (rsp[self.name]) ? rsp[self.name]['guid'] : null;
                    var url = app.api.buildFileURL({
                        module: self.module,
                        id: 'temp',
                        field: self.name,
                        fileId: fileId
                    }, {keep: true});
                    // show image
                    var image = $('<img>').addClass('hide').attr('src', url).on('load', $.proxy(self.resizeWidget, self));
                    self.$('.image_preview').html(image);

                    // Add the guid to the list of fields to set on the model.
                    if (fileId) {
                        if (!self.model.fields[self.name + '_guid']) {
                            self.model.fields[self.name + '_guid'] = {
                                type: 'file_temp',
                                group: self.name
                            };
                        }
                        self.model.unset(self.name);
                        self.model.set(self.name + '_guid', fileId);
                    }
                },
                error: function(resp) {
                    var errors = errors || {},
                        fieldName = self.name;
                    errors[fieldName] = {};

                    switch (resp.error) {
                        case 'request_too_large':
                           errors[fieldName].tooBig = true;
                           break;
                        default:
                            errors[fieldName].uploadFailed = true;
                    }
                    self.model.unset(fieldName + '_guid');
                    self.model.trigger('error:validation:' + this.field, errors[fieldName]);
                    self.model.trigger('error:validation', errors);
                }
            },
            { temp: true }); //for File API to understand we upload a temporary file
    },

    /**
     * Calls when deleting the image or canceling the preview
     * @param e
     */
    'delete': function(e) {
        var self = this;
        //If we are previewing a file and want to cancel
        if (this.preview === true) {
            self.preview = false;
            self.clearErrorDecoration();
            self.render();
            return;
        }

        // If it's a duplicate, don't delete the file
        if (this._duplicateBeanId) {
            self.model.unset(self.name);
            self.model.set(self.name, null);
            self.render();
            return;
        }

        var confirmMessage = app.lang.get('LBL_IMAGE_DELETE_CONFIRM', self.module);
        if (confirm(confirmMessage)) {
            //Otherwise delete the image
            app.api.call('delete', self.buildUrl({htmlJsonFormat: false}), {}, {
                    success: function(response) {
                        //Need to fire the change event twice so model.previous(self.name) is also changed.
                        self.model.unset(self.name);
                        self.model.set(self.name, null);
                        if (response.record && response.record.date_modified) {
                            self.model.set('date_modified', response.record.date_modified);
                        }
                        if (!self.disposed) {
                            self.render();
                        }
                    },
                    error: function(data) {
                        // refresh token if it has expired
                        app.error.handleHttpError(data, {});
                    }}
            );
        }
    },

    /**
     * Build URI for File API
     * @param options
     */
    buildUrl: function(options) {
        return app.api.buildFileURL({
            module: this._duplicateBeanModule ? this._duplicateBeanModule : this.module,
            id: this._duplicateBeanId ? this._duplicateBeanId : this.model.id,
            field: this.name
        }, options);
    },

    /**
     * Resize widget based on field defs and image size
     */
    resizeWidget: function() {
        var image = this.$('.image_preview img, .image_detail img');

        if (!image[0]) return;

        var isDefHeight = !_.isUndefined(this.def.height) && this.def.height > 0,
            isDefWidth = !_.isUndefined(this.def.width) && this.def.width > 0;

        //set width/height defined in field defs
        if (isDefWidth) {
            image.css('width', this.width);
        }
        if (isDefHeight) {
            image.css('height', this.height);
        }

        if (!isDefHeight && !isDefWidth)
            image.css({
                'height': this.height,
                'width': this.width
            });

        //now resize widget
        //we resize the widget based on current image height
        this.resizeHeight(image.height());
        //if height was defined but not width, we want to resize image width to keep
        //proportionality: this.height/naturalHeight = newWidth/naturalWidth
        if (isDefHeight && !isDefWidth) {
            var newWidth = Math.floor((this.height / image[0].naturalHeight) * image[0].naturalWidth);
            image.css('width', newWidth);
            this.resizeWidth(newWidth);
        }

        image.removeClass('hide');
        this.$('.delete').remove();
        var icon = this.preview === true ? 'times' : 'trash-o';
        image.closest('label, a').after('<span class="image_btn delete fa fa-' + icon + ' " />');
    },

    /**
     * Utility function to append px to an integer
     *
     * @param size
     * @return {string}
     */
    formatPX: function(size) {
        size = parseInt(size, 10);
        return size + 'px';
    },

    /**
     * Resize the elements carefully to render a pretty input[type=file]
     * @param height (in pixels)
     */
    resizeHeight: function(height) {
        var $image_field = this.$('.image_field'),
            isEditAndIcon = this.$('.fa-plus').length > 0;

        if (isEditAndIcon) {
            var $image_btn = $image_field.find('.image_btn');
            var edit_btn_height = parseInt($image_btn.css('height'), 10);

            var previewHeight = parseInt(height, 10);
            //Remove the edit button height in edit view so that the icon is centered.
            previewHeight -= edit_btn_height ? edit_btn_height : 0;
            previewHeight = this.formatPX(previewHeight);

            $image_field.find('.fa-plus').css({lineHeight: previewHeight});
        }


        var totalHeight = this.formatPX(height);
        $image_field.css({'height': totalHeight, minHeight: totalHeight, lineHeight: totalHeight});
        $image_field.find('label').css({lineHeight: totalHeight});
    },

    /**
     * Resize the elements carefully to render a pretty input[type=file]
     * @param width (in pixels)
     */
    resizeWidth: function(width) {
        var $image_field = this.$('.image_field'),
            width = this.formatPX(width),
            isInHeaderpane = $(this.el).closest('.headerpane').length > 0,
            isInRowFluid = $(this.el).closest('.row-fluid').closest('.record').length > 0;

        if (isInHeaderpane || !isInRowFluid) {
            //Need to fix width
            $image_field.css({'width': width});
        } else {
            //Width will be the biggest possible
            $image_field.css({'maxWidth': width});
        }
    },

    /**
     * Custom requiredValidator for image field because we need to check if the
     * input inside the view is empty or not.
     *
     * @param {Object} fields Hash of field definitions to validate.
     * @param {Object} errors Error validation errors.
     * @param {Function} callback Async.js waterfall callback.
     */
    _doValidateImageField: function(fields, errors, callback) {
        if (this.def.required && !this.model.get(this.name + '_guid') && !this.model.get(this.name)) {
            errors[this.name] = errors[this.name] || {};
            errors[this.name].required = true;
        }

        callback(null, fields, errors);
    },

    /**
     * Handles errors message
     *
     * @override
     * @param errors
     */
    handleValidationError: function(errors) {
        var errorMessages = [];

        if (this.action === 'detail') {
            this.setMode('edit');
        }

        //Change the preview of the image widget
        this.$('.image_preview').html('<i class="fa fa-times"></i>');
        //Put the cancel icon
        this.$('label').after('<span class="image_btn delete fa fa-times" />');

        this.$el.closest('.record-cell').addClass("error");
        this.$el.addClass('input-append error');

        _.each(errors, function(errorContext, errorName) {
            errorMessages.push(app.error.getErrorString(errorName, errorContext));
        });
        this.$('.image_field').append(this.exclamationMarkTemplate(errorMessages));
    },

    /**
     * @override
     */
    clearErrorDecoration: function() {
        //Remove the current icon
        this.$('.delete').remove();
        //Remove error message
        this.$('.error-tooltip').remove();
        this.$el.closest('.record-cell').removeClass('error');
        this.$el.removeClass('input-append error');
    }
}) },
"deleterecurrencesbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * DeleterecurrencesbuttonField is a field for Meetings/Calls for the ability to delete all recurring events for a parent record
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.DeleterecurrencesbuttonField
 * @alias SUGAR.App.view.fields.BaseDeleterecurrencesbuttonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Deleterecurrencesbutton Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * @inheritdoc
     *
     *  The field is hidden if event is not a recurring calendar event
     */
    _render: function() {
        if (_.isEmpty(this.model.get('repeat_type'))) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Renders the field when the status on the record changes.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:repeat_type', this.render, this);
        }
    },

    /**
     * Event handler for deleting all recurring calendar events of a series
     * @inheritdoc
     */
    rowActionSelect: function() {
        app.alert.show('delete_recurrence_confirmation', {
            title: app.lang.get('LBL_REMOVE_ALL_RECURRENCES', this.module),
            level: 'confirmation',
            messages: this.getDeleteMessages().confirmation,
            onConfirm: _.bind(this.deleteRecurrences, this)
        });
    },

    /**
     * Calls destroy on the model and makes api call to delete all recurring calendar events in a series.
     * Navigates to the list view on success.
     */
    deleteRecurrences: function() {
        this.model.destroy({
            params: {'all_recurrences': true},
            showAlerts: {
                'process': true,
                'success': {
                    messages: this.getDeleteMessages().success
                }
            },
            success: _.bind(function() {
                var route = '#' + this.module,
                    currentRoute = '#' + Backbone.history.getFragment();
                (currentRoute === route) ? app.router.refresh() : app.router.navigate(route, {trigger: true});
            }, this)
        });
    },

    /**
     * Formats the messages to display in the alerts when deleting recurrences.
     *
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getDeleteMessages: function() {
        var messages = {};
        var model = this.model;
        var name = app.utils.getRecordName(model);
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name.trim();

        messages.confirmation = app.lang.get('LBL_CONFIRM_REMOVE_ALL_RECURRENCES', this.module);
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    }
}) },
"username": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.UsernameField
 * @alias SUGAR.App.view.fields.BaseUsernameField
 * @extends View.Fields.Base.BaseField
 */
({
	// Username Field (base) 

    //FIXME: SC-3447 this field should have bidirectional input
    direction: 'ltr'
}) },
"name": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.NameField
 * @alias SUGAR.App.view.fields.BaseNameField
 * @extends View.Fields.Base.BaseField
 */
({
	// Name Field (base) 

    plugins: ['MetadataEventDriven'],

    _render: function() {
        // FIXME: This will be cleaned up by SC-3478.
        if (this.view.name === 'audit') {
            this.def.link = false;
        } else if (this.view.name === 'preview') {
            this.def.link = _.isUndefined(this.def.link) ? true : this.def.link;
            this.def.events = false;
        }
        this._super('_render');
    }
}) },
"rowactions-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RowactionsCreateField
 * @alias SUGAR.App.view.fields.BaseRowactionsCreateField
 * @extends View.Fields.Base.RowactionsField
 */
({
	// Rowactions-create Field (base) 

    extendsFrom: 'FieldsetField',

    /**
     * @inheritdoc
     *
     * Overriding FieldsetField's method to use def.buttons not def.fields
     *
     * @override
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.buttons);
    }
}) },
"related-contact": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * RelatedContactField is needed because BaseField specifically gets values from specific keys
 * on the model, and for the HistorySummaryView list, we need to set values on the model
 * that are different from what BaseField uses so it doesn't conflict with the other values
 * on BaseField's model
 *
 * @class View.Fields.Base.RelatedContactField
 * @alias SUGAR.App.view.fields.BaseRelatedContactField
 * @extends View.Fields.Base.BaseField
 */
({
	// Related-contact Field (base) 

    events: {
        'click a': 'onLinkClicked'
    },

    /**
     * Holds the href for the field link
     */
    linkRoute: '',

    /**
     * @inheritdoc
     * @override
     *
     * Overriding since the parent buildHref would use 'id' not 'contact_id'
     * to create the href link
     */
    buildHref: function() {
        var defRoute = this.def.route ? this.def.route : {},
            module = this.model.module || this.context.get('module'),
            id = this.model.get('contact_id');
        this.linkRoute = '#' + app.router.buildRoute(module, id, defRoute.action);
        return this.linkRoute;
    },

    /**
     * Intercepts the clicked link, if the user clicked on the Contact
     * that the user was already viewing, refresh the page, because otherwise
     * the url will not change
     *
     * @param {jQuery.Event} evt The click event from the link
     */
    onLinkClicked: function(evt) {
        var currentRoute = '#' + Backbone.history.getFragment();
        if (currentRoute === this.linkRoute) {
            app.router.refresh();
        }
    }
}) },
"base": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This is the base field and all of other fields extend from it.
 *
 * @class View.Fields.Base.BaseField
 * @alias SUGAR.App.view.fields.BaseBaseField
 * @extends View.Field
 */
({
	// Base Field (base) 

    plugins: ['MetadataEventDriven'],

    /**
     * @inheritdoc
     *
     * Some plugins use events which prevents {@link View.Field#delegateEvents}
     * to fallback to metadata defined events.
     * This will make sure we merge metadata events with the ones provided by
     * the plugins.
     *
     * The Base Field will always clear any tooltips after `render`.
     */
    initialize: function(options) {

        this.events = _.extend({}, this.events, options.def.events);

        this._super('initialize', arguments);

        /**
         * Property to add or not the `ellipsis_inline` class when rendering the
         * field in the `list` template. `true` to add the class, `false`
         * otherwise.
         *
         * Defaults to `true`.
         *
         * @property {boolean}
         */
        this.ellipsis = _.isUndefined(this.def.ellipsis) || this.def.ellipsis;

        if (app.tooltip) {
            this.on('render', app.tooltip.clear);
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var action = 'view';
        if (this.def.link && this.def.route) {
            action = this.def.route.action;
        }
        if (this.def.link && app.acl.hasAccessToModel(action, this.model)) {
            this.href = this.buildHref();
        }
        app.view.Field.prototype._render.call(this);
    },

    /**
     * Takes care of building href for when there's a def.link and also if is
     * bwc enabled.
     *
     * Deprecated functionality:
     * If `this.def.bwcLink` is set to `true` on metadata, we force the href
     * to be in BWC.
     *
     * TODO remove this from the base field
     */
    buildHref: function() {
        var defRoute = this.def.route ? this.def.route : {},
            module = this.model.module || this.context.get('module');
        // FIXME remove this.def.bwcLink functionality (not yet removed due to Portal need for Documents)
        return '#' + app.router.buildRoute(module, this.model.get('id'), defRoute.action, this.def.bwcLink);
    },

    /**
     * @inheritdoc
     *
     * Trim whitespace from value if it is a String.
     */
    unformat: function(value) {
        return _.isString(value) ? value.trim() : value;
    }
}) },
"datetimecombo": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DatetimecomboField
 * @alias SUGAR.App.view.fields.BaseDatetimecomboField
 * @extends View.Fields.Base.DateField
 */
({
	// Datetimecombo Field (base) 

    extendsFrom: 'DateField',

    /**
     * HTML tag of the secondary field.
     *
     * @property {String}
     */
    secondaryFieldTag: 'input[data-type=time]',

    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * If a time picker has been initialized on the field or not.
         *
         * @type {boolean}
         * @private
         */
        this._hasTimePicker = false;
    },

    /**
     * @inheritdoc
     *
     * Add `show-timepicker` on click listener.
     */
    _initEvents: function() {
        this._super('_initEvents');

        _.extend(this.events, {
            'click [data-action="show-timepicker"]': 'showTimePicker'
        });

        return this;
    },

    /**
     * @override
     */
    _initDefaultValue: function() {
        if (!this.model.isNew() || this.model.get(this.name) || !this.def.display_default) {
            return this;
        }

        var value = app.date.parseDisplayDefault(this.def.display_default);
        if (!value) {
            return this;
        }

        value = this.unformat(
            app.date(value).format(
                app.date.convertFormat(this.getUserDateTimeFormat())
            )
        );

        this.model.setDefault(this.name, value);

        return this;
    },

    /**
     * @inheritdoc
     */
    _initPlaceholderAttribute: function() {
        this._super('_initPlaceholderAttribute');

        var placeholder = this.getTimePlaceHolder(this.getUserTimeFormat());

        this.secondaryFieldPlaceholder = this.def.placeholder && app.lang.get(
            this.def.placeholder,
            this.module,
            {format: placeholder}
        ) || placeholder;

        return this;
    },

    /**
     * Handler to show time picker on icon click.
     *
     * We trigger the focus on element instead of the jqueryfied element, to
     * trigger the focus on the input and avoid the `preventDefault()` imposed
     * in the library.
     */
    showTimePicker: function() {
        this.$(this.secondaryFieldTag)[0].focus();
    },

    /**
     * Return user time format.
     *
     * @return {string} User time format.
     */
    getUserTimeFormat: function() {
        return app.user.getPreference('timepref');
    },

    /**
     * Return user datetime format.
     *
     * @return {string} User datetime format.
     */
    getUserDateTimeFormat: function() {
        return this.getUserDateFormat() + ' ' + this.getUserTimeFormat();
    },

    /**
     * Return time place holder based on supplied format.
     *
     * @param {String} format Format.
     * @return {String} Time place holder.
     */
    getTimePlaceHolder: function(format) {
        var map = {
            'H': 'hh',
            'h': 'hh',
            'i': 'mm',
            'a': '',
            'A': ''
        };

        return format.replace(/[HhiaA]/g, function(s) {
            return map[s];
        });
    },

    /**
     * Set up the time picker.
     *
     * @protected
     */
    _setupTimePicker: function() {
        var options;
        var localeData = app.date.localeData();
        var lang = {
            am: localeData.meridiem(1, 00, true),
            pm: localeData.meridiem(13, 00, true),
            AM: localeData.meridiem(1, 00, false),
            PM: localeData.meridiem(13, 00, false)
        };

        this.def.time || (this.def.time = {});

        options = {
            timeFormat: this.getUserTimeFormat(),
            scrollDefaultNow: _.isUndefined(this.def.time.scroll_default_now) ?
                true :
                !!this.def.time.scroll_default_now,
            step: this.def.time.step || 15,
            disableTextInput: _.isUndefined(this.def.time.disable_text_input) ?
                false :
                !!this.def.time.disable_text_input,
            className: this.def.time.css_class || 'prevent-mousedown',
            appendTo: this.$el,
            lang: lang
        };

        this._enableDuration(options);

        this.$(this.secondaryFieldTag).timepicker(options);
        this._hasTimePicker = true;
    },

    /**
     * Show duration on the timepicker dropdown if enabled in view definition.
     * @param {Object} options The timepicker options (see
     *   https://github.com/jonthornton/jquery-timepicker#options).
     * @private
     */
    _enableDuration: function(options) {
        var self = this;

        if (this.def.time.duration) {
            options.maxTime = 85500; //23.75 hours, which is 11:45pm

            options.durationTime = function() {
                var dateStartString = self.model.get(self.def.time.duration.relative_to),
                    dateEndString = self.model.get(self.name),
                    startDate,
                    endDate;

                this.minTime = null;
                this.showDuration = false;

                if (!dateStartString || !dateEndString) {
                    return;
                }

                startDate = app.date(dateStartString);
                endDate = app.date(dateEndString);

                if ((startDate.year() === endDate.year()) &&
                    (startDate.month() === endDate.month()) &&
                    (startDate.day() === endDate.day())
                ) {
                    this.minTime = app.date.duration({
                        hours: startDate.hours(),
                        minutes: startDate.minutes()
                    }).asSeconds();
                    this.showDuration = true;
                }

                return this.minTime;
            };
        }
    },

    /**
     * Handle date and time picker changes.
     *
     * If model value is defined and supplied date or time is empty, an empty
     * string is returned, otherwise, empty values will fallback to current
     * date/time.
     *
     * All parameters and returned value are formatted according to user
     * preferences.
     *
     * @param {String} d Date value.
     * @param {String} t Time value.
     * @return {String} Datetime value.
     */
    handleDateTimeChanges: function(d, t) {
        if (this.model.get(this.name) && (!d || !t)) {
            return '';
        }

        var now = app.date();

        d = d || (t && now.format(app.date.convertFormat(this.getUserDateFormat())));
        t = t || (d && now.format(app.date.convertFormat(this.getUserTimeFormat())));

        return (d + ' ' + t).trim();
    },

    /**
     * Date picker doesn't trigger a `change` event whenever the date value
     * changes we need to override this method and listen to the `hide` event.
     *
     * Handles `hide` date picker event expecting to set the default time if
     * not filled yet, see {@link #handleDateTimeChanges}.
     *
     * All invalid values are cleared from fields without triggering an event
     * because `this.model.set()` could have been already empty thus not
     * triggering a new event and not calling the default code of
     * `bindDomChange()`.
     *
     * Undefined model values will not be replaced with empty string to prevent
     * unnecessary unsaved changes warnings.
     *
     * @override
     */
    handleHideDatePicker: function() {
        var $dateField = this.$(this.fieldTag),
            $timeField = this.$(this.secondaryFieldTag),
            d = $dateField.val(),
            t = $timeField.val(),
            datetime = this.unformat(this.handleDateTimeChanges(d, t));

        if (!datetime) {
            $dateField.val('');
            $timeField.val('');
        }

        if (_.isEmptyValue(datetime) && _.isUndefined(this.model.get(this.name))) {
            return;
        }

        this.model.set(this.name, datetime);
    },

    /**
     * @inheritdoc
     *
     * Bind time picker `changeTime` event expecting to set the default date if
     * not filled yet, see {@link #handleDateTimeChanges}.
     */
    bindDomChange: function() {
        this._super('bindDomChange');

        if (this._inDetailMode()) {
            return;
        }

        var $dateField = this.$(this.fieldTag),
            $timeField = this.$(this.secondaryFieldTag),
            selfView = this.view;

        $timeField.timepicker().on({
            showTimepicker: function() {
                selfView.trigger('list:scrollLock', true);
            },
            hideTimepicker: function() {
                selfView.trigger('list:scrollLock', false);
            },
            change: _.bind(function() {
                var t = $timeField.val().trim(),
                    datetime = '';

                if (t) {
                    var d = $dateField.val();
                    datetime = this.unformat(this.handleDateTimeChanges(d, t));
                    if (!datetime) {
                        $dateField.val('');
                        $timeField.val('');
                    }
                }
                this.model.set(this.name, datetime);
            }, this),
            focus: _.bind(function() {
                this.handleFocus();
            }, this)
        });
    },

    /**
     * @inheritdoc
     *
     * Add extra logic to unbind secondary field tag.
     */
    unbindDom: function() {
        this._super('unbindDom');

        if (this._inDetailMode()) {
            return;
        }

        this.$(this.secondaryFieldTag).off();
    },

    /**
     * Binds model changes on this field, taking into account both field tags.
     *
     * @override
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }

        this.model.on('change:' + this.name, function(model, value) {
            if (this.disposed) {
                return;
            }

            if (this._inDetailMode()) {
                this.render();
                return;
            }

            value = this.format(value) || {'date': '', 'time': ''};

            this.$(this.fieldTag).val(value['date']);
            if (value['date']) {
                this.$(this.fieldTag).data('datepicker').setValue(value['date']);
            }
            this.$(this.secondaryFieldTag).val(value['time']);
        }, this);
    },

    /**
     * Formats date value according to user preferences.
     *
     * @param {String} value Datetime value to format.
     * @return {Object/String/undefined} On edit mode the returned value is an
     *   object with two keys, `date` and `time`. On detail mode the returned
     *   value is a date, formatted according to user preferences if supplied
     *   value is a valid date, otherwise returned value is `undefined`.
     *
     * @override
     */
    format: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value);

        if (!value.isValid()) {
            return;
        }

        if (this.action === 'edit' || this.action === 'massupdate') {
            value = {
                'date': value.format(app.date.convertFormat(this.getUserDateFormat())),
                'time': value.format(app.date.convertFormat(this.getUserTimeFormat()))
            };

        } else {
            value = value.formatUser(false);
        }

        return value;
    },

    /**
     * Unformats datetime value for storing in model.
     *
     * @return {String} Unformatted value or `undefined` if value is
     *   an invalid date.
     *
     * @override
     */
    unformat: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value, app.date.convertFormat(this.getUserDateTimeFormat()), true);

        if (!value.isValid()) {
            return;
        }

        return value.formatServer();
    },

    /**
     * Override decorateError to take into account the two fields.
     *
     * @override
     */
    decorateError: function(errors) {
        var ftag = this.fieldTag || '',
            $ftag = this.$(ftag),
            errorMessages = [],
            $tooltip;

        // Add error styling
        this.$el.closest('.record-cell').addClass('error');
        this.$el.addClass('error');

        if (_.isString(errors)) {
            // A custom validation error was triggered for this field
            errorMessages.push(errors);
        } else {
            // For each error add to error help block
            _.each(errors, function(errorContext, errorName) {
                errorMessages.push(app.error.getErrorString(errorName, errorContext));
            });
        }

        $ftag.parent().addClass('error');

        $tooltip = [$(this.exclamationMarkTemplate(errorMessages)), $(this.exclamationMarkTemplate(errorMessages))];

        var self = this;

        $ftag.parent().children('input').each(function(index) {
            $(this).after($tooltip[index]);
        });
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (this._hasTimePicker) {
            this.$(this.secondaryFieldTag).timepicker('hide');
        }

        this._super('_render');

        if (this._inDetailMode()) {
            return;
        }

        this._setupTimePicker();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this._hasTimePicker) {
            this.$(this.secondaryFieldTag).timepicker('remove');
        }

        this._super('_dispose');
    }
}) },
"timeperiod": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.SelectionField
 * @alias SUGAR.App.view.fields.BaseTimeperiodField
 * @extends View.Fields.Base.EnumField
 */
({
	// Timeperiod Field (base) 

    /**
     * Who we should extend
     */
    extendsFrom: 'EnumField',

    /**
     * The template for the tooltip
     */
    tooltipTemplate: '',

    /**
     * Mapping of ID's with the start ane end dates formatted for use when the tooltip is displayed
     */
    tpTooltipMap: {},

    /**
     * The selector we use to find the dropdown since it's appended to the body and not the current element
     */
    cssClassSelector: '',

    /**
     * Flag to use if Select2 tries to format the tooltips before timeperiod data returns from the server
     */
    updateDefaultTooltip: false,

    /**
     * Tooltip placement direction for the template
     */
    tooltipDir: 'right',

    /**
     * Tooltip key for determining which language string to use
     */
    tooltipKey: 'LBL_DROPDOWN_TOOLTIP',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var tooltipCssClasses = '',
            ttTemplate;

        if (app.lang.direction === 'rtl') {
            this.tooltipDir = 'left';
            tooltipCssClasses = 'force-ltr';
            this.tooltipKey += '_RTL';
        }

        ttTemplate = app.template.getField('timeperiod', 'tooltip-default');
        Handlebars.registerPartial('tooltipHtmlTemplate', ttTemplate({
            cssClasses: tooltipCssClasses
        }));

        var collectionParams = {
            limit: 100,
            params: {}
        };

        this._super('initialize', [options]);

        if (this.def.use_generic_timeperiods) {
            collectionParams.params.use_generic_timeperiods = true;
        }

        /**
         * Collection for fetching all the Timeperiods.
         *
         * @property {Data.BeanCollection}
         */
        this.tpCollection = app.data.createBeanCollection('TimePeriods');
        this.tpCollection.once('reset', this.formatTooltips, this);
        this.tpCollection.on('sync', this.render, this);
        this.tpCollection.fetch(collectionParams);

        // load the tooltip template
        this.tooltipTemplate = app.template.getField('timeperiod', 'tooltip', this.module);

        // if forecast is not setup, then we need to use the generic options
        var config = app.metadata.getModule('Forecasts', 'config');
        if (!config || config.is_setup === 0) {
            this.def.options = 'generic_timeperiod_options';
        }
    },

    /**
     * Utility method to take the TimePeriod collection and parse our the start and end dates to be in the user
     * date preference and store them for when the enum is actually opened
     * @param {Backbone.Collection} data
     */
    formatTooltips: function(data) {
        var usersDatePrefs = app.user.getPreference('datepref');
        data.each(function(model) {
          this.tpTooltipMap[model.id] = {
              start: app.date.format(app.date.parse(model.get('start_date')), usersDatePrefs),
              end: app.date.format(app.date.parse(model.get('end_date')), usersDatePrefs)
          };
        }, this);
        // since we don't need it any more, destroy it
        this._destroyTpCollection();

        if (this.updateDefaultTooltip) {
            this.updateDefaultTooltip = false;
            // manually update the default selected item's tooltip
            var tooltipText = app.lang.get('LBL_DROPDOWN_TOOLTIP', 'TimePeriods', this.tpTooltipMap[this.value[0]]);
            this.$('[rel="tooltip"]').attr('data-original-title', tooltipText);
        }
    },

    /**
     * Since this is specific to fetching the timeperiods and it's a dynamic endpoint
     * override the module for when it has to load the enum options
     *
     * @override
     * @return {string}
     */
    getLoadEnumOptionsModule: function() {
        return 'Forecasts';
    },

    /**
     * @inheritdoc
     */
    getSelect2Options: function(optionsKeys) {
        var options = this._super('getSelect2Options', [optionsKeys]);

        // this is to format the results
        options.formatResult = _.bind(this.formatOption, this);

        // this is to format the currently selected option
        options.formatSelection = _.bind(this.formatOption, this);

        if (_.isEmpty(options.dropdownCssClass)) {
            options.dropdownCssClass = 'select2-timeperiod-dropdown-' + this.cid;
        }

        this.cssClassSelector = options.dropdownCssClass;

        return options;
    },

    /**
     * Format Option for the results and the selected option to bind the tool tip data into the html
     * that gets output
     *
     * @param {Object} object
     * @return {string}
     */
    formatOption: function(object) {
        // check once if the tpTooltipMap has been built yet
        this.updateDefaultTooltip = _.isUndefined(this.tpTooltipMap[object.id]);
        return this.tooltipTemplate({
            tooltip: this.tpTooltipMap[object.id],
            value: object.text,
            tooltipDir: this.tooltipDir,
            tooltipKey: this.tooltipKey
        });
    },

    /**
     * Disposes the {@link #tpCollection} properly.
     *
     * @private
     */
    _destroyTpCollection: function() {
        if (this.tpCollection) {
            this.tpCollection.off(null, null, this);
            this.tpCollection = null;
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._destroyTpCollection();
        this._super('_dispose');
    }
}) },
"label": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.LabelField
 * @alias SUGAR.App.view.fields.BaseLabelField
 * @extends View.Fields.Base.BaseField
 */
({
	// Label Field (base) 

    /**
     * @override
     *
     * No-op function because this field is static.
     */
    bindDataChange: $.noop,

    /**
     * @override
     *
     * No-op function because this field is static.
     */
    bindDomChange: $.noop,

    /**
     * @override
     *
     * No-op function because this field is static.
     */
    unbindDom: $.noop,

    /**
     * @inheritdoc
     */
    format: function(value) {
        if (this.def.formatted_value) {
            value = this.def.formatted_value;
        } else {
            value = app.lang.get(this.def.default_value, this.module);
        }
        return value;
    },

    /**
     * @inheritdoc
     */
    _isErasedField: function() {
        //Labels cannot be erased, they contain no data.
        return false;
    }
}) },
"recurrence": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Recurrence is a field for Meetings/Calls module used to set attributes
 * about a recurring record.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RecurrenceField
 * @alias SUGAR.App.view.fields.BaseRecurrenceField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Recurrence Field (base) 

    extendsFrom: 'FieldsetField',

    /**
     * @property {boolean} showNoData
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    /**
     * @property {int} repeatCountMin
     *
     * The minimum number of occurrences that is allowed when the repeat_count
     * field is used.
     */
    repeatCountMin: 1,

    /**
     * @property {Object} repeatEndLastValues
     *
     * Place to save off the last values of the repeat end fields so we can put
     * the values back if the user toggles back.
     */
    repeatEndLastValues: {},

    repeatTypeSpecificFields: {
        repeat_dow: ['Weekly'],
        repeat_selector: ['Monthly', 'Yearly']
    },

    /**
     * @inheritdoc
     *
     * Default the `repeat_end_type` to "Until" and update the visibility of the
     * `repeat_count` and `repeat_until` fields.
     *
     * Add validator to ensure that `repeat_count` or `repeat_until`
     * have appropriate values based on `repeat_end_type`
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.model.addValidationTask(
            'repeat_count_or_until_required_validator_' + this.cid,
            _.bind(this._doValidateRepeatCountOrUntilRequired, this)
        );
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.model.on('sync', this.setEndTypeFromEndFieldValues, this);
        this.model.on('change:repeat_type', this.repeatTypeChanged, this);
        this.model.on('change:repeat_selector', this.updateRepeatSelectorDependentFieldVisibility, this);
        this.model.on('change:repeat_end_type', this.updateRepeatEndFieldVisibility, this);
    },

    /**
     * Inherit fieldset templates
     * FIXME: Will be refactored by SC-3471.
     * @inheritdoc
     * @private
     */
    _loadTemplate: function() {
        var originalType = this.type;
        this.type = 'fieldset';
        this._super('_loadTemplate');
        this.type = originalType;
    },

    /**
     * @inheritdoc
     *
     * Prepare the recurrence fields based on the value of `repeat_type`
     */
    _render: function() {
        var repeatType = this.model.get('repeat_type');

        this._super('_render');

        switch (repeatType) {
            case 'Daily':
            case 'Weekly':
            case 'Monthly':
            case 'Yearly':
                this.show();
                break;
            default:
                this.hide();
                break;
        }

        this.prepareView();
    },

    /**
     * Set up the recurrence fields based on `repeat_type` and the action
     *
     * * `repeat_dow` - show when repeat_type is weekly, hide otherwise
     * * `repeat_end_type` - hide on detail view
     */
    prepareView: function() {
        if (this.action === 'detail') {
            this._hideField('repeat_end_type');
        }

        // If copying or view/edit - we are defaulting from end field values
        if (!this.model.isNew() || this.model.isCopy()) {
            this.setEndTypeFromEndFieldValues();
        }

        this.updateRepeatTypeDependentFieldVisibility();
        this.updateRepeatEndFieldVisibility();
        this.updateRepeatSelectorDependentFieldVisibility();
    },

    /**
     * Set field defaults when `repeat_type` changes & then re-render so the
     * hide/show logic is applied.
     *
     * When `repeat_type` is cleared (set to None), force fields to their
     * default values. Exclude repeat_end_type from defaulting since its value
     * is based on the values of repeat_count and repeat_until.
     */
    repeatTypeChanged: function() {
        var isRecurring = this._isPopulated(this.model.get('repeat_type'));
        _.each(this.fields, function(field) {
            var fieldValue = this.model.get(field.name),
                isEmpty = !this._isPopulated(fieldValue) || (fieldValue === 0);
            if ((!isRecurring || isEmpty) && field.name !== 'repeat_end_type') {
                this.model.set(field.name, field.def['default']);
            }
        }, this);

        this.render();
    },

    /**
     * Update the visibility of fields dependent on the `repeat_type` field
     */
    updateRepeatTypeDependentFieldVisibility: function() {
        var repeatType = this.model.get('repeat_type');
        _.each(this.repeatTypeSpecificFields, function(showValues, fieldName) {
            if (_.contains(showValues, repeatType)) {
                this._showField(fieldName);
            } else {
                this._hideField(fieldName);
            }
        }, this);
    },

    /**
     * Update the visibility of fields dependent on the `repeat_selector` field
     */
    updateRepeatSelectorDependentFieldVisibility: function() {
        var repeatSelector = this.model.get('repeat_selector'),
            repeatSelectorVisible = this._isFieldVisible('repeat_selector');

        if (repeatSelectorVisible && repeatSelector === 'Each') {
            this._showField('repeat_days');
        } else {
            this._hideField('repeat_days');
        }

        if (repeatSelectorVisible && repeatSelector === 'On') {
            this._showField('repeat_ordinal');
            this._showField('repeat_unit');
        } else {
            this._hideField('repeat_ordinal');
            this._hideField('repeat_unit');
        }
    },

    /**
     * Set the value of repeat_end_type based on whether values are set for
     * repeat_count and repeat_until.
     */
    setEndTypeFromEndFieldValues: function() {
        var repeatUntil = this.model.get('repeat_until') || '',
            repeatCount = this.model.get('repeat_count') || '',
            repeatEndType;

        if (this._isPopulated(repeatUntil)) {
            repeatEndType = 'Until';
        } else if (this._isPopulated(repeatCount)) {
            repeatEndType = 'Occurrences';
        }

        if (repeatEndType) {
            this.model.set('repeat_end_type', repeatEndType);
        }
    },

    /**
     * Swap out Repeat Until & Repeat Occurrences fields based on the
     * value of repeat_end_type.
     */
    updateRepeatEndFieldVisibility: function() {
        var endType = this.model.get('repeat_end_type');

        //bail out if end type is not set yet
        if (!endType) {
            return;
        }

        this._toggleRepeatEndField('repeat_count', (endType === 'Occurrences'));
        this._toggleRepeatEndField('repeat_until', (endType === 'Until'));
    },

    /**
     * Hide/show the given field and either save off its value & clear (on hide)
     * or restore its previous value (on show).
     *
     * @param {string} fieldName The name of the field to hide/show
     * @param {boolean} show Whether to show (true) or hide (false)
     * @private
     */
    _toggleRepeatEndField: function(fieldName, show) {
        var value = this.model.get(fieldName),
            lastValue = this.repeatEndLastValues[fieldName];

        if (show) {
            this._showField(fieldName);
            if (!this._isPopulated(value) && this._isPopulated(lastValue)) {
                this.model.set(fieldName, lastValue);
            }
        } else {
            this._hideField(fieldName);
            this.repeatEndLastValues[fieldName] = value;
            if (this._isPopulated(value)) {
                this.model.unset(fieldName);
            }
        }
    },

    /**
     * Show the given field
     *
     * @param {string} fieldName Name of the field to show
     * @private
     */
    _showField: function(fieldName) {
        this._getFieldRecordCellByName(fieldName).show();
    },

    /**
     * Hide the given field
     *
     * @param {string} fieldName Name of the field to hide
     * @private
     */
    _hideField: function(fieldName) {
        this._getFieldRecordCellByName(fieldName).hide();
    },

    /**
     * Checks if a given field is visible
     *
     * @param {string} fieldName
     * @return {boolean} Returns true if the field is visible, false otherwise
     * @private
     */
    _isFieldVisible: function(fieldName) {
        return this._getFieldRecordCellByName(fieldName).is(':visible');
    },

    /**
     * Returns the field cell for a given field name
     *
     * @param {string} fieldName Name of the field to select
     * @return {jQuery} jQuery selected record cell
     * @private
     */
    _getFieldRecordCellByName: function(fieldName) {
        var selector = '.fieldset-field[data-name="' + fieldName + '"]';
        return this.$(selector);
    },

    /**
     * Check if a particular field is populated
     *
     * @param {string|number} value The value to check if it is populated
     * @return {boolean} Returns true if the field is populated
     * @private
     */
    _isPopulated: function(value) {
        return !_.isUndefined(value) && !_.isNull(value) && value !== '';
    },

    /**
     * Custom validator for the `repeat_count`/`repeat_until` field.
     *
     * This validates `repeat_count` is populated when `repeat_end_type` is
     * "Occurrences" and `repeat_until` is populated when `repeat_end_type` is
     * "Until".
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatCountOrUntilRequired: function(fields, errors, callback) {
        var repeatEndType = this.model.get('repeat_end_type'),
            repeatCount = this.model.get('repeat_count'),
            repeatCountIsPopulated = this._isPopulated(repeatCount),
            repeatUntilIsPopulated = this._isPopulated(this.model.get('repeat_until'));

        if (this._isPopulated(this.model.get('repeat_type'))) {
            if (repeatEndType === 'Until' && !repeatUntilIsPopulated) {
                errors.repeat_until = {required: true};
            } else if (repeatEndType === 'Occurrences') {
                if (!repeatCountIsPopulated) {
                    errors.repeat_count = {required: true};
                } else if (repeatCount < this.repeatCountMin) {
                    errors.repeat_count = {minValue: this.repeatCountMin};
                }
            }
        }

        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_count_or_until_required_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"phone": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PhoneField
 * @alias SUGAR.App.view.fields.BasePhoneField
 * @extends View.Fields.Base.BaseField
 */
({
	// Phone Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @override
     * @param options
     */
    initialize: function (options) {
        var serverInfo = app.metadata.getServerInfo();

        this.skypeEnabled = serverInfo.system_skypeout_on ? true : false;

        this._super('initialize', [options]);
    },
    /**
     * @override
     * @param value
     * @return {Mixed}
     */
    format: function (value) {
        if ((this.action === 'list' || this.action === 'detail' || this.action === 'record')
            && this.isSkypeFormatted(value)
            && this.skypeEnabled) {
            this.skypeValue = this.skypeFormat(value);
        }
        return value;
    },
    /**
     * checks if value should be skype formatted + 00 or 011 leading is necessary
     * @param value {String}
     * @return {boolean}
     */
    isSkypeFormatted: function (value) {
        if (_.isString(value)) {
            return value.substr(0, 1) === '+' || value.substr(0, 2) === '00' || value.substr(0, 3) === '011';
        } else {
            return false;
        }
    },
    /**
     * strips extra characters from phone number for skype
     *
     * Document: https://support.skype.com/en/faq/FA12006/how-do-i-script-webpages-to-find-phone-numbers-using-click-to-call
     *
     * @param value {String}
     * @return {string}
     */
    skypeFormat: function (value) {
        if (_.isString(value)) {
            var number = value.replace(/[^\d\(\)\.\-\/ ]/g, '');

            if(null !== number.match(/[\-]/g) && number.match(/[\-]/g).length >= 2) {
                // ensure format is "+CC-NDC-SN"
                number = number.replace(/[^\d\-]/g, '')
                    .replace(/(\d+)\-(\d+)\-([\d\-]+)/g, function($0, $1, $2, $3) {
                        return [$1, $2, $3.replace(/\D/g, '')].join('-');
                    });
            } else if(null !== number.match(/[\.]/g) && number.match(/[\.]/g).length >= 2) {
                // ensure format is "+CC.NDC.SN"
                number = number.replace(/[^\d\.]/g, '')
                    .replace(/(\d+)\.(\d+)\.([\d\.]+)/g, function($0, $1, $2, $3) {
                        return [$1, $2, $3.replace(/\D/g, '')].join('.');
                    });
            } else if(null !== number.match(/\(\D*\d+\D*\)/g)) {
                // ensure format is "+CC(NDC)SN"
                number = number.replace(/[^\d\(\)]+/g, '')
                    .replace(/(\d+)\((\d+)\)([0-9\(\)]+)/g, function($0, $1, $2, $3) {
                        return $1 + '(' + $2 + ')' + $3.replace(/\D/g, '');
                    })
            } else if(null !== number.match(/[\/]/g) && number.match(/[\/]/g).length >= 2) {
                // ensure format is "+CC/NDC/SN"
                number = number.replace(/[^\d\/]/g, '')
                    .replace(/(\d+)\/(\d+)\/([\d\/]+)/g, function($0, $1, $2, $3) {
                        return [$1, $2, $3.replace(/\D/g, '')].join('/');
                    });
            } else if(null !== number.match(/\S+\s+\S+\s+[\S\s]+/g)) {
                // ensure format is "+CC NDC SN"
                number = number.replace(/(\S+)\s+(\S+)\s+([\S\s]+)/g, function($0, $1, $2, $3) {
                    return _.map([$1, $2, $3], function(s) {
                        return s.replace(/\D/g, '');
                    }).join(' ');
                })
            } else {
                number = number.replace(/\D/g, '');
            }
            if(value.substr(0, 1) === '+' || (number.substr(0, 2) !== '00' && number.substr(0, 3) !== '011')) {
                number = '+' + number;
            }
            return number;

        } else if (_.isNumber(value)) {
            if(value.substr(0, 2) !== '00' && value.substr(0, 3) !== '011') {
                value = '+' + value;
            }
        }
        return value;
    }
}) },
"favorite": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FavoriteField
 * @alias SUGAR.App.view.fields.BaseFavoriteField
 * @extends View.Fields.Base.BaseField
 */
({
	// Favorite Field (base) 


    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    'events': {
        'click .btn': 'toggle'
    },

    /**
     * @inheritdoc
     *
     * The favorite is always a readonly field.
     */
    initialize: function(options) {
        options.def.readonly = true;
        // We change the field name to be 'my_favorite' because that's the name in
        // the vardefs and thus in the model attributes. Since the model listens
        // to `my_favorite` for several events ('change:my_favorite',
        // 'acl:change:my_favorite', 'error:validation:my_favorite', ...), the
        // names need to be equal.
        options.def.name = 'my_favorite';

        this._super('initialize', [options]);
    },

    /**
     * Check first if the module has favoritesEnabled before rendering it.
     *
     * @private
     */
    _render: function() {
        // can't favorite something without an id
        if (!this.model.get('id')) {
            return null;
        }
        if (!app.metadata.getModule(this.model.module).favoritesEnabled) {
            app.logger.error("Trying to use favorite field on a module that doesn't support it: '" + this.model.module + "'.");
            return null;
        }
        return app.view.Field.prototype._render.call(this);
    },

    /**
     * Function called for each click on the star icon (normally acts as toggle
     * function).
     *
     * If the star is checked, copy all the source fields to target ones
     * based on the mapping definition of this field. Otherwise, restore all the
     * values of the modified fields by this copy widget.
     *
     * @param {Event} evt
     *   The event (expecting click event) that triggered the checkbox status
     *   change.
     */
    toggle: function(evt) {
        var self = this,
            star = $(evt.currentTarget);

        var options = {
            silent: true,
            alerts: false
        };
        //when we toggle favorite icon on list view we need to update the view to actually see the changes
        if (self.view && self.view.action === 'list') {
            options.success = function() {
                self._refreshListView();
            };
        }

        if (this.model.favorite(!this.model.isFavorite(), options) === false) {
            app.logger.error("Unable to set '" + this.model.module + "' record '" + this.model.id + "' as favorite");
            return;
        }
        if (this.model.isFavorite()) {
            star.addClass('active')
                .attr('aria-pressed', true);
            this.model.trigger("favorite:active");
        }
        else {
            star.removeClass('active')
                .attr('aria-pressed', false);
        }
    },

    /**
     * @inheritdoc
     *
     * @return {Boolean}
     */
    format: function() {
        return this.model.isFavorite();
    },

    /**
     * On model save success, this function gets called to refresh the list
     * view.
     *
     * {@link View.Fields.Base.FavoriteField} is using about the same method.
     *
     * @private
     */
    _refreshListView: function() {
        var filterPanelLayout = this.view;
        //Try to find the filterpanel layout
        while (filterPanelLayout && filterPanelLayout.name !== 'filterpanel') {
            filterPanelLayout = filterPanelLayout.layout;
        }
        //If filterpanel layout found and not disposed, then pick the value from the quicksearch input and
        //trigger the filtering
        if (filterPanelLayout && !filterPanelLayout.disposed && this.collection) {
            filterPanelLayout.applyLastFilter(this.collection, 'favorite');
        }
    }
}) },
"range": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RangeField
 * @alias SUGAR.App.view.fields.BaseRangeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Range Field (base) 

    /**
     * holder for the field tag, so we can get at it easily
     */
    fieldTag: '.rangeSlider',

    /**
     * Object that maps the sliderType from metadata, to the appropriate noUiSlider settings.
     * The number of handles this slider has can be set in metadata by specifying sliderType to be as follows:
     * - 'single' - a single slider, the value of the field will just be the integer value of the slide
     * - 'upper' - a single slider, visually connected to the upper range, the value of the field will be {min: <value of slide>, max: this.rangeMax}
     * - 'lower' - a single slider, visually connected to the lower range, the value of the field will be {min: this.rangeMin, max: <value of slide>}
     * - 'double' - a double slider, the value of the field will be [<value of lower slide>, <value of upper slide>]
     * - 'connected' - a double slider, visually connected together, the value of the field will be {min: <value of lower slide>, max: <value of upper slide>}
     */
    _sliderTypeSettings: {
        single: {handles: 1, connect: false},
        upper: {handles: 1, connect: 'upper'},
        lower: {handles: 1, connect: 'lower'},
        'double': {handles: 2, connect: false},
        connected: {handles: 2, connect: true}
    },

    /**
     * Renders this field.  This is where the noUiSlider gets added.
     * @param value
     * @private
     */
    _render: function(value) {
        app.view.Field.prototype._render.call(this);

        this._setupSlider(this.$el.find(this.fieldTag));
    },

    /**
     * Unformats a value for storing in a model.
     *
     * Cleans up the value to store it in a model based on the sliderType
     * @param {Mixed} value The value to unformat.
     * @return {Mixed} Unformatted value based on sliderType:
     * - single - integer value
     * - double - array of two integer values
     * - upper, lower, connected - a range as {min, max}.
     */
    unformat: function(value) {
        var sliderType = this.def.sliderType || 'single';

        switch(sliderType) {
            case 'single':
                return _.first(value);
            case 'upper':
                return {
                    min: _.first(value),
                    max: this.def.maxRange || 100
                };
            case 'lower':
                return {
                    min: this.def.minRange || 0,
                    max: _.last(value)
                };
            case 'double':
                return [
                    _.isNaN(_.first(value))?this.def.minRange || 0: _.first(value),
                    _.isNaN(_.last(value))?this.def.maxRange || 100:_.last(value)
                ];
            case 'connected':
            default:
                return {
                    min: _.isNaN(_.first(value))?this.def.minRange || 0: _.first(value),
                    max: _.isNaN(_.last(value))?this.def.maxRange || 100:_.last(value)
                };
        }
    },

    /**
     * Formats a value for display.
     *
     * Converts the field stored in the model for a slider type, into a value usable by noUiSlider widget
     * @param {Mixed} value The value to format.
     * @return {Mixed} Formatted value.
     */
    format: function(value) {
        var sliderType = this.def.sliderType || 'single';

        switch(sliderType) {
            case 'single':
                return [ value || this.def.rangeMin || 0 ];
            case 'upper':
                return [ value.min || this.def.rangeMin || 0 ];
            case 'lower':
                return [ value.max || this.def.rangeMax || 100 ];
            case 'double':
                return value;
            case 'connected':
            default:
                if(value) {
                    return [ value.min || this.def.rangeMin || 0, value.max || this.def.rangeMax || 100];
                }
        }
        return [this.def.rangeMin || 0, this.def.rangeMax || 100];
    },

    /**
     * Sets up the noUiSlider jquery widget on the given jQuery element.
     * @param jqel a jquery element, i. e. $.find(this.fieldTag)
     * @private
     */
    _setupSlider: function(jqel) {

        jqel.noUiSlider('init', {
            knobs: this._calculateHandles(),
            connect: this._setupHandleConnections(this.def.sliderType || 'single'),
            scale: this._setupSliderEndpoints(),
            start: this._setupSliderStartPositions(),
            change: this._sliderChange,
            end: this._sliderChangeComplete,
            field: this
        });

        if(!this.def.hideStyle){
            this._addStyle(jqel);
        }


        if(this.def.enabled == false || this.def.view != 'edit') {
            jqel.noUiSlider('disable');
        }
    },

    /**
     * Adds the style elements to the slider fields
     * @param jqel the jQuery wrapped element that has a noUiSlider attached to it.
     */
    _addStyle: function(jqel) {
        var start = this._setupSliderStartPositions(),
            endpoints = this._setupSliderEndpoints();
        jqel.append(function(){
            var html = "",
                segments = 11,
                w = $(this).width(),
                segmentWidth = w/(segments-1),
                acum = 0;

            for(i=0;i<segments;i++) {
                acum = (segmentWidth * i)-2;
                html += "<div class='ticks' style='left:"+acum+"px'></div>";
            }
            return html;

        })
        .find('.noUi-handle div').each(function(index){
            if(i>1) {i=0;}
            $(this).append('<div class="tooltip fade top in infoBox"><div class="tooltip-arrow"></div><div class="tooltip-inner">' + start[i] + '%'+'</div></div>');
            i++;
        });

        this.$('.noUiSliderEnds').attr('data-content-before', _.first(endpoints) + '%').attr('data-content-after', _.last(endpoints) + '%')
    },

    /**
     * Used to calculate the number of sliders for this field by the sliderType set in metadata.
     * @return {integer} The number of handles for the slider
     * @private
     */
    _calculateHandles: function() {
        var sliderType = this.def.sliderType || 'single';

        return this._sliderTypeSettings[sliderType].handles;
    },

    /**
     * Used to set up the graphical connections for the handles based on the slider type
     * @param sliderType the value from metadata.  Valid options are 'single', 'upper', 'lower', 'double', 'connected'
     * @return {string || bool} The value to pass as the 'connect' setting for the noUiSlider jquery widget
     * @private
     */
    _setupHandleConnections: function(sliderType) {
        var sliderType = this.def.sliderType || 'single';

        return this._sliderTypeSettings[sliderType].connect;
    },

    /**
     * Calculates the min and max range for the sliders.
     * @return {array} the min and max setting for the range field that will be pass as the noUiSlider scale
     * @private
     */
    _setupSliderEndpoints: function() {
        var minRange = this.def.minRange || 0,
            maxRange = this.def.maxRange || 100;

        return [minRange, maxRange];
    },

    /**
     * Used to get the starting positions for the sliders to pass to the noUiSlider widget.
     * @return {integer || array} the start values contained in the model for the field.  Falls back on minRange from
     * metadata if the model is empty/undefined, or 0 if no model value and minRange is undefined in metadata.
     * @private
     */
    _setupSliderStartPositions: function() {
        var value;

        if (this.model) {
            value = this.model.get(this.name);
        }

        if (_.isUndefined(value) || (_.isArray(value) && _.isEmpty(value))) {
            return [ this.def.minRange || 0, this.def.maxRange || 100 ];
        }

        return this.format(value);
    },

    /**
     * Gets the value for the jquery slider widget and cleans it up to be used by the view
     * @param jqel the jquery element that has the noUiSlider attached to it.
     * @return {array} for sliderType set to 'single', an array with a single value, for all others, an array of two values.
     */
    getSliderValues: function(jqel) {
        var value = jqel.noUiSlider('value');

        return this.unformat(value);
    },

    /**
     * The function that gets called whenever the sliders are in the process of getting moved/changed.
     *
     * The context of `this` is the noUiSlider from which the function was activated. The field is passed through the
     * settings and can be accessed using `this.data('settings').field` for any necessary access to the controller, model, etc...
     *
     * The model will get updated with this method if updateOn is set to 'change' or 'both' in the field metadata.
     *
     * @param type The type of change that moved the slider.  This will be 'click' when the slider is clicked to a point
     * on the range, 'move' when the slider is updated via the move method (i. e. by the linked slider delegates), or
     * 'slide' when the handle is dragged to a value.
     * @private
     */
    _sliderChange: function(type) {
        var field = this.data('api').options.field,
            values;

        if(field.def.updateOn && (field.def.updateOn == 'change' || field.def.updateOn == 'both')) {
            field.model.set(field.name, field.getSliderValues(this));
        }

        if(!field.def.hideStyle) {
            values = this.noUiSlider( 'value' );
            this.find('.noUi-lowerHandle .infoBox .tooltip-inner').text(values[0]+"%");
            this.find('.noUi-upperHandle .infoBox .tooltip-inner').text(values[1]+"%");
        }

        // disables the hook if moved by another slider, to prevent circular references
        if(type != 'move' && _.isFunction(field.sliderChangeDelegate)) {
            field.sliderChangeDelegate(field.getSliderValues(this));
        }
    },

    /**
     * The function that gets called whenever the slider change is complete.
     *
     * The context of `this` is the noUiSlider from
     * which the function was activated. The field is passed through the settings and can be accessed using
     * `this.data('settings').field` for any necessary access to the controller, model, etc...
     *
     * The model will get updated with this method if updateOn is set to 'done' or 'both' in the field metadata.
     *
     * @param type The type of change that moved the slider.  This will be 'click' when the slider is clicked to a point
     * on the range, 'move' when the slider is updated via the move method (i. e. by the linked slider delegates), or
     * 'slide' when the handle is dragged to a value.
     * @private
     */
    _sliderChangeComplete: function(type) {
        var field = this.data('api').options.field;

        if(field.def.updateOn && (field.def.updateOn == 'done' || field.def.updateOn == 'both')) {
            field.model.set(field.name, field.getSliderValues(this));
        }

        // if this is set, this hook will be called when slider is done moving.
        if(_.isFunction(field.sliderDoneDelegate)) {
            field.sliderDoneDelegate(field.getSliderValues(this));
        }
    }

}) },
"rowactions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RowactionsField
 * @alias SUGAR.App.view.fields.BaseRowactionsField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Rowactions Field (base) 

    extendsFrom: 'ActiondropdownField',

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        //FIXME: SC-3372 Actions should not be based on `this.view.action`

        // check to see if this is a create subpanel
        var isCreate = this.context.get('isCreateSubpanel') || false,
            shouldHide = (this.view.action === 'list' && this.action === 'edit');
        // if this is a create subpanel, trump other logic as rowactions needs to be shown on edit
        if (isCreate || !shouldHide) {
            this.show();
        } else {
            this.hide();
        }
    }
}) },
"collection-count": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CollectionCountField
 * @alias SUGAR.App.view.fields.BaseCollectionCountField
 * @extends View.Fields.Base.BaseField
 */
({
	// Collection-count Field (base) 

    events: {
        'click [data-action="count"]': 'fetchCount'
    },

    /**
     * Fetches the total amount of filtered records from the collection, and
     * renders the field to show the new (or cached) total.
     */
    fetchCount: function() {
        if (_.isNull(this.collection.total)) {
            app.alert.show('fetch_count', {
                level: 'process',
                title: app.lang.get('LBL_LOADING'),
                autoClose: false
            });
        }

        this.collection.fetchTotal({
            success: _.bind(function() {
                if (!this.disposed) {
                    this.updateCount();
                }
            }, this),
            complete: function() {
                app.alert.dismiss('fetch_count');
            }
        });
    },

    /**
     * Updates {@link #countLabel the count label} and renders this field.
     *
     * @param {number} [options] Optional hash of values to use for the `length`
     *   and `hasMore` properties. Use this if you want to customize what this
     *   field should display.
     * @param {number} [options.length] The length of values.
     * @param {boolean} [options.hasMore] `true` if there are more values to be
     *   fetched or paginated, `false` if we've fetched everything.
     */
    updateCount: function(options) {
        this._setCountLabel(options);
        this.render();
    },

    /**
     * Returns the label for the count in the headerpane.
     *
     * If you would like to customize these, the following labels are being
     * used: `TPL_LIST_HEADER_COUNT`, `TPL_LIST_HEADER_COUNT_PARTIAL`,
     * `TPL_LIST_HEADER_COUNT_TOTAL`, and `TPL_LIST_HEADER_COUNT_TOOLTIP`.
     *
     * There are several ways the total count label is represented, depending on
     * the state of `this.collection`. If the collection contains all the
     * records, the label will display `this.collection.length`, for example:
     *
     *     (17)
     *
     * If `this.collection.total` exists and is cached, the label will display
     * in the form:
     *
     *     (20 of 50)
     *
     * Otherwise, the returned label will include the link to fetch the total:
     *
     *     (20 of <a data-action="count">21+</a>)
     *
     * @protected
     * @param {number} [options] Optional hash of values to use for the `length`
     *   and `hasMore` properties. Use this if you want to customize what this
     *   field should display.
     * @param {number} [options.length] The length of values. Defaults to
     *   `this.collection.length`.
     * @param {boolean} [options.hasMore] `true` if there are more values to be
     *   fetched or paginated, `false` if we've fetched everything. Defaults to
     *   `false`.
     * @return {string|Handlebars.SafeString} The label to use for the list view
     *   count.
     */
    _setCountLabel: function(options) {
        // Default properties.
        options = options || {};
        var length = this.collection.length;
        var fullyFetched = this.collection.next_offset <= 0;
        // Override default properties with passed-in values.
        length = !_.isUndefined(options.length) ? options.length : length;
        fullyFetched = !_.isUndefined(options.hasMore) ? !options.hasMore : fullyFetched;

        if (!length && !this.collection.dataFetched) {
            return this.countLabel = '';
        }

        var tplKey = 'TPL_LIST_HEADER_COUNT_TOTAL';
        var context = {num: length};

        if (fullyFetched) {
            tplKey = 'TPL_LIST_HEADER_COUNT';
        } else if (!_.isNull(this.collection.total)) {
            context.total = this.collection.total;
        } else {
            var tooltipLabel = app.lang.get('TPL_LIST_HEADER_COUNT_TOOLTIP', this.module);
            // FIXME: When SC-3681 is ready, we will no longer have the need for
            // this link, since the total will be displayed by default.
            context.total = new Handlebars.SafeString(
                '<a href="javascript:void(0);" data-action="count" rel="tooltip" data-placement="right" title="' + tooltipLabel + '" role="button" tabindex="0">' +
                Handlebars.Utils.escapeExpression(
                    app.lang.get('TPL_LIST_HEADER_COUNT_PARTIAL', this.module, {num: context.num + 1})
                ) + '</a>'
            );
        }

        // FIXME: When SC-3681 is ready, remove the SafeString call.
        return this.countLabel = new Handlebars.SafeString(app.lang.get(tplKey, this.module, context));
    },

    /**
     * @override
     *
     * Re-renders the field when the attached collection is `reset`. Also
     * handles executing a request for the total count when a `pagination` event
     * occurs on the context. We do this on `pagination` because it is a
     * user-initiated action - if we request the count on `reset` as well it
     * would decrease performance.
     */
    bindDataChange: function() {
        if (!this.collection) {
            return;
        }

        this.listenTo(this.collection, 'remove reset', function() {
            if (!this.disposed) {
                this.updateCount();
            }
        });
        this.listenTo(this.context, 'paginate', function() {
            if (!this.disposed) {
                this.fetchCount();
            }
        });
        this.listenTo(this.context, 'refresh:count', function(hasAmount, properties) {
            if (!this.disposed) {
                this.updateCount(properties);
            }
        });
    }
}) },
"fullname": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FullnameField
 * @alias SUGAR.App.view.fields.BaseFullnameField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Fullname Field (base) 

    extendsFrom: 'FieldsetField',

    /**
     * Mapping name field name to format initial
     *
     * @property {Object}
     */
    formatMap: {
        'f': 'first_name',
        'l': 'last_name',
        's': 'salutation'
    },

    /**
     * @inheritdoc
     * Sort the dependant fields by the user locale format order.
     */
    initialize: function(options) {
        var formatPlaceholder = app.user.getPreference('default_locale_name_format') || '';
        this._super('initialize', [options]);
        if (!this.module) {
            app.logger.error('Fullname field requires a module');
            this.dispose();
            return;
        }

        var meta = app.metadata.getModule(this.module);
        this.formatMap = meta.formatMap || this.formatMap;

        this.def.fields = _.reduce(formatPlaceholder.split(''), function(fields, letter) {
            // only letters a-z may be significant in the format,
            // everything else is translated verbatim
            if (letter >= 'a' && letter <= 'z' && this.formatMap[letter]) {
                var fieldMeta = meta.fields[this.formatMap[letter]];
                if (fieldMeta) {
                    // clone because we'd rewrite it later and we don't want to mess with actual metadata
                    fields.push(_.clone(fieldMeta));
                }
            }
            return fields;
        }, [], this);
        this.def.fields = app.metadata._patchFields(this.module, meta, this.def.fields);

        if (this.def && this.def.link && app.acl.hasAccessToModel('view', this.model)) {
            var action = this.def.route && this.def.route.action ? this.def.route.action : '';
            //If `this.template` resolves to `base/list.hbs`, that template expects an
            //initialized `this.href`. That's normally handled by the `base.js` controller,
            //but, in this case, since `fullname.js` is controller, we must handle here.
            this.href = '#' + app.router.buildRoute(this.module || this.context,
                this.model.id, action, this.def.bwcLink);
        }
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        var template = app.template.getField(
            this.type,
            this.view.name + '-' + this.tplName,
            this.model.module);
        //SP-1719: The view-combined template should also follow the view's custom template.
        if (!template && this.view.meta && this.view.meta.template) {
            template = app.template.getField(
                this.type,
                this.view.meta.template + '-' + this.tplName,
                this.model.module);
        }
        this.template = template || this.template;
    },

    /**
     * @inheritdoc
     * Format name parts to current user locale.
     */
    format: function() {
        return app.utils.getRecordName(this.model);
    },

    /**
     * @override
     */
    _isErasedField: function() {
        if (!this.model) {
            return false;
        }

        return app.utils.isNameErased(this.model);
    },

    /**
     * @override
     * Note that the parent bindDataChange (from FieldsetField) is an empty function
     */
    bindDataChange: function() {
        if (this.model) {
            // As detail templates don't contain Sidecar Fields,
            // we need to rerender this field in order to visualize the changes
            this.model.on("change:" + this.name, function() {
                if (this.action !== 'edit') {
                    this.render();
                }
            }, this);
            // When a child field changes, we need to update the full_name value
            _.each(this.def.fields, function(field) {
                this.model.on("change:" + field.name, this.updateValue, this);
            }, this);
        }
    },

    /**
     * Update the value of this parent field when a child changes
     */
    updateValue: function() {
        this.model.set(this.name, this.format());
    },

    /**
     * Called by record view to set max width of inner record-cell div
     * to prevent long names from overflowing the outer record-cell container
     */
    setMaxWidth: function(width) {
        this.$('.record-cell').children().css({'max-width': width});
    },

    /**
     * Return the width of padding on inner record-cell
     */
    getCellPadding: function() {
        var padding = 0,
            $cell = this.$('.record-cell');

        if (!_.isEmpty($cell)) {
            padding = parseInt($cell.css('padding-left'), 10) + parseInt($cell.css('padding-right'), 10);
        }

        return padding;
    },

    _render: function() {
        // FIXME: This will be cleaned up by SC-3478.
        if (this.view.name === 'preview') {
            this.def.link = _.isUndefined(this.def.link) ? true : this.def.link;
        }
        this._super('_render');
    }
}) },
"event-status": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EventStatusField is a field for Meetings/Calls that show the status field of the model as a badge field.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.EventStatusField
 * @alias SUGAR.App.view.fields.BaseEventStatusField
 * @extends View.Fields.Base.BadgeSelectField
 */
({
	// Event-status Field (base) 

    extendsFrom: 'BadgeSelectField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * An object where its keys map to specific status and color to matching
         * CSS classes.
         */
        this.statusClasses = {
            'Held': 'label-success',
            'Not Held': 'label-important',
            'Planned': 'label-pending'
        };

        this.type = 'badge-select';
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        var action = this.action || this.view.action;
        if (action === 'edit') {
            this.type = 'enum';
        }

        this._super('_loadTemplate');
        this.type = 'badge-select';
    }
}) },
"email-attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EmailAttachmentsField
 * @alias SUGAR.App.view.fields.BaseEmailAttachmentsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Email-attachments Field (base) 

    /**
     * The selector for accessing the Select2 field when in edit mode. The
     * Select2 field is where the attachments are displayed.
     *
     * @property {string}
     */
    fieldTag: 'input.select2',

    /**
     * The selector for accessing the file input field when in edit mode.
     *
     * @property {string}
     */
    _fileTag: 'input[type=file]',

    /**
     * A collection of models that represent promises for an attachment that is
     * being retrieved asynchronously. Each placeholder model's cid can be used
     * to determine which request is associated with that placeholder.
     *
     * @property {Data.BeanCollection}
     */
    _placeholders: null,

    /**
     * Keeps track of active requests so that they can be aborted if the user
     * cancels an action. The key of a request is the unique number of the
     * placeholder associated with that request, so that requests can be
     * singled out by their placeholder and removed from this object without
     * affecting other active requests.
     *
     * @property {Object}
     */
    _requests: null,

    /**
     * @inheritdoc
     *
     * Adds events for uploading a file when the file input changes and
     * downloading a file when a file link is clicked in detail mode.
     *
     * Adds listeners for the `email_attachments:file` and
     * `email_attachments:document` events that are triggered on the view to
     * add attachments. `email_attachments:file` will launch the file picker
     * dialog. `email_attachments:document` accepts a document to attach.
     */
    initialize: function(options) {
        var events = {};

        events['change ' + this._fileTag] = '_uploadFile';
        events['click [data-action=download]'] = '_downloadFile';
        this.events = _.extend({}, this.events, options.def.events, events);
        this.plugins = _.union(this.plugins || [], ['CollectionFieldLoadAll', 'ListEditable']);
        this._super('initialize', [options]);

        this.listenTo(this.view, 'email_attachments:file', this._openFilePicker);
        this.listenTo(this.view, 'email_attachments:document', this._attachDocument);

        this._placeholders = app.data.createBeanCollection('Notes');
        this._requests = {};
    },

    /**
     * @inheritdoc
     *
     * @fires change:<field_name> on the model when placeholder attachments are
     * added or removed. Internally, this causes the field to be rendered with
     * the updated placeholders. And it avoids an expensive full render when
     * in edit mode.
     * @fires <field_name>:under_max_total_bytes on the model when the total
     * bytes of all attachments is under the maximum from the
     * max_aggregate_email_attachments_bytes configuration. The total bytes,
     * maximum allowed bytes, and bytes remaining under the limit (positive)
     * are passed as parameters.
     * @fires <field_name>:over_max_total_bytes on the model when the total
     * bytes of all attachments exceeds the maximum from the
     * max_aggregate_email_attachments_bytes configuration. The total bytes,
     * maximum allowed bytes, and bytes remaining under the limit (negative)
     * are passed as parameters.
     */
    bindDataChange: function() {
        /**
         * Sums the bytes for each attachment in the collection.
         *
         * @param {Data.BeanCollection} attachments
         * @return {int}
         */
        function getTotalBytes(attachments) {
            var bytes;

            if (!(attachments instanceof app.BeanCollection)) {
                return 0;
            }

            bytes = attachments.reduce(function(total, attachment) {
                var fileSize = attachment.get('file_size');

                if (_.isNaN(fileSize) || !_.isNumber(fileSize)) {
                    try {
                        fileSize = parseInt(fileSize, 10) || 0;
                    } catch (err) {
                        // If failed conversion, treat attachment as 0 bytes.
                        fileSize = 0;
                    }
                }

                return total + fileSize;
            }, 0);

            return bytes;
        }

        if (this.model) {
            this.listenTo(this.model, 'change:' + this.name, function() {
                var $el = this.$(this.fieldTag);
                var maxBytes = app.config.maxAggregateEmailAttachmentsBytes;
                var totalBytes;
                var bytesRemaining;

                if (_.isEmpty($el.data('select2'))) {
                    this.render();
                } else {
                    $el.select2('data', this.getFormattedValue());
                }

                totalBytes = getTotalBytes(this.model.get(this.name));
                bytesRemaining = maxBytes - totalBytes;

                if (bytesRemaining > 0) {
                    this.model.trigger(this.name + ':under_max_total_bytes', totalBytes, maxBytes, bytesRemaining);
                } else {
                    this.model.trigger(this.name + ':over_max_total_bytes', totalBytes, maxBytes, bytesRemaining);
                }
            });
        }

        if (this._placeholders) {
            this.listenTo(this._placeholders, 'update', function() {
                this.model.trigger('change:' + this.name);
            });
        }
    },

    /**
     * @inheritdoc
     *
     * Prevents the Select2 dropdown from opening, as the Select2 field is used
     * as a container only.
     *
     * Removes an attachment when an item is removed from the Select2 field.
     */
    bindDomChange: function() {
        var $el = this.$(this.fieldTag);

        $el.on('select2-opening', function(event) {
            event.preventDefault();
        });

        $el.on('select2-removed', _.bind(function(event) {
            this.model.get(this.name).remove(event.val) || this._placeholders.remove(event.val);
        }, this));
    },

    /**
     * Returns `true` if there are any attachments or placeholders.
     * {@link BaseEmailsCreateView} uses this method to determine whether to
     * hide or show the field as it changes.
     *
     * @return {boolean}
     */
    isEmpty: function() {
        return this.model.get(this.name).isEmpty() && this._placeholders.isEmpty();
    },

    /**
     * @inheritdoc
     *
     * Initializes Select2 when in edit mode and disables all but the delete
     * and backspace keys in the Select2 input field.
     */
    _render: function() {
        var $el;
        var select2Input;

        /**
         * Returns `true` when the event occurs for the delete and backspace
         * keys and `false` for all other keys.
         *
         * @param {Object} event DOM event.
         * @return {boolean}
         */
        var isDeleteKey = function(event) {
            return event.keyCode == 8 || event.keyCode == 46;
        };

        this._super('_render');

        $el = this.$(this.fieldTag);

        if ($el.length > 0) {
            $el.select2({
                multiple: true,
                data: this.getFormattedValue(),
                initSelection: _.bind(function(element, callback) {
                    callback(this.getFormattedValue());
                }, this),
                containerCssClass: 'select2-choices-pills-close',
                containerCss: {
                    width: '100%'
                },
                width: 'off',
                /**
                 * Use `cid` as a choice's ID. Some models are not yet synchronized
                 * and can only be identified by their `cid`. All models have a
                 * `cid`.
                 *
                 * See [Select2 Documentation](https://select2.github.io/select2/#documentation).
                 *
                 * @param {Object} choice
                 * @return {null|string|number}
                 */
                id: function(choice) {
                    return _.isEmpty(choice) ? null : choice.cid;
                },
                /**
                 * Formats an attachment object for rendering.
                 *
                 * See [Select2 Documentation](https://select2.github.io/select2/#documentation).
                 *
                 * @param {Object} choice
                 * @return {string}
                 */
                formatSelection: _.bind(function(choice) {
                    var $selection = '<span class="ellipsis-value ellipsis_inline" title="' + choice.name + '">' +
                        choice.name + '</span>';

                    if (this._placeholders.get(choice.cid)) {
                        $selection += '<span class="ellipsis-extra"><i class="fa fa-refresh fa-spin"></i></span>';
                    } else {
                        $selection += '<span class="ellipsis-extra">(' + choice.file_size + ')</span>';
                    }

                    $selection = '<span data-id="' + choice.cid + '">' + $selection + '</span>';

                    return $selection;
                }, this),
                /**
                 * Don't escape a choice's markup since we built the HTML.
                 *
                 * See [Select2 Documentation](https://select2.github.io/select2/#documentation).
                 *
                 * @param {string} markup
                 * @return {string}
                 */
                escapeMarkup: function(markup) {
                    return markup;
                }
            }).select2('val', []);

            select2Input = this.$('.select2-input');

            if (select2Input) {
                select2Input.keypress(isDeleteKey);
                select2Input.keyup(isDeleteKey);
                select2Input.keydown(isDeleteKey);
            }

            if (this.isDisabled()) {
                $el.select2('disable');
            }
        }

        return this;
    },

    /**
     * Returns the file input field.
     *
     * Used for mocking the file input field so that its value can be set
     * programmatically. Stubbing `this.$` for only the parameter
     * `this._fileTag` is not possible; it would cause `this.$` to be stubbed
     * for all calls.
     *
     * @return {jQuery}
     * @private
     */
    _getFileInput: function() {
        return this.$(this._fileTag);
    },

    /**
     * @inheritdoc
     *
     * Select2 expects an array of objects to display. The attachments marked
     * for removal are excluded. The attributes of the remaining attachments
     * and placeholders are returned. Each model's `cid` is returned as that is
     * the `id` that Select2 is using. Each model's `file_url` is returned if
     * the attachment has an `id`. The model's `file_size` is returned as a
     * human-readable string, by way of {@link Utils#getReadableFileSize}.
     */
    format: function(value) {
        var urlAttributes = {
            module: 'Notes',
            field: 'filename'
        };
        var urlOptions = {
            htmlJsonFormat: false,
            passOAuthToken: false,
            cleanCache: true,
            forceDownload: true
        };

        value = value instanceof app.BeanCollection ? value.models : value;
        value = _.map(_.union(value || [], this._placeholders.models), function(model) {
            var attachment = _.extend({cid: model.cid}, model.toJSON());

            attachment.file_url = attachment.id ?
                app.api.buildFileURL(_.extend({}, urlAttributes, {id: attachment.id}), urlOptions) :
                null;
            attachment.file_size = app.utils.getReadableFileSize(attachment.file_size);

            return attachment;
        });

        this.tooltip = _.pluck(value, 'name').join(', ');

        return value;
    },

    /**
     * @inheritdoc
     *
     * Destroys the Select2 element.
     */
    unbindDom: function() {
        this.$(this.fieldTag).select2('destroy');
        this._super('unbindDom');
    },

    /**
     * @inheritdoc
     *
     * Aborts any active requests. Stops listening to events on the view.
     */
    _dispose: function() {
        _.each(this._requests, function(request) {
            if (request && request.uid) {
                app.api.abortRequest(request.uid);
            }
        });

        this._requests = null;
        this.stopListening(this.view);
        this._super('_dispose');
    },

    /**
     * Makes a request to download the file based on the URL identified in the
     * attributes of the current target of the event.
     *
     * @param {Object} event DOM event.
     * @param {Object} event.currentTarget The current target of the event.
     * @private
     */
    _downloadFile: function(event) {
        var url = this.$(event.currentTarget).data('url');

        if (this.disposed === true) {
            return;
        }

        if (!_.isEmpty(url)) {
            app.api.fileDownload(url, {}, {iframe: this.getFieldElement()});
        }
    },

    /**
     * Launches the file picker dialog.
     *
     * @private
     */
    _openFilePicker: function() {
        if (this.disposed === true) {
            return;
        }

        this._getFileInput().click();
    },

    /**
     * Uploads the file selected from the file picker as a temporary file.
     *
     * A placeholder attachment is added to the Select2 field while the file is
     * being uploaded.
     *
     * @private
     */
    _uploadFile: function() {
        var $file = this._getFileInput();
        var ajaxParams = {
            temp: true,
            iframe: true,
            deleteIfFails: true,
            htmlJsonFormat: true
        };
        var note;
        var placeholder;
        var val = $file.val();

        if (_.isEmpty(val)) {
            return;
        }

        placeholder = this._addPlaceholderAttachment(val.split('\\').pop());
        note = app.data.createBean('Notes');
        this._requests[placeholder.cid] = note.uploadFile('filename', $file, {
            success: _.bind(this._handleFileUploadSuccess, this),
            error: _.bind(this._handleFileUploadError, this),
            complete: _.bind(function() {
                // Clear the file input field.
                $file.val(null);
                this._removePlaceholderAttachment(placeholder);
            }, this)
        }, ajaxParams);
    },

    /**
     * Handles a successful response from the API for uploading the file.
     *
     * The relevant data is taken from the record and added as an attachment.
     * An error is shown to the user if the record does not have a GUID.
     *
     * @param {Object} data The data from a successful API response.
     * @param {Object} data.record The record representing the temporary Notes
     * object.
     * @param {string} data.record.id The GUID of the uploaded file.
     * @private
     */
    _handleFileUploadSuccess: function(data) {
        var file;
        var error;

        if (this.disposed === true) {
            return;
        }

        if (!data.record || !data.record.id) {
            error = new Error('Temporary file has no GUID');
            app.logger.error(error.message);
            app.alert.show('upload_error', {
                level: 'error',
                autoClose: true,
                messages: app.lang.get('ERROR_UPLOAD_FAILED')
            });

            // Track errors attaching a file.
            app.analytics.trackEvent('email_attachment', 'upload_error', error);
        } else {
            file = app.data.createBean('Notes', {
                _link: 'attachments',
                filename_guid: data.record.id,
                name: data.record.filename || data.record.name,
                filename: data.record.filename || data.record.name,
                file_mime_type: data.record.file_mime_type,
                file_size: data.record.file_size,
                file_ext: data.record.file_ext
            });
            this.model.get(this.name).add(file, {merge: true});

            // Track attaching a file.
            app.analytics.trackEvent('email_attachment', 'attached_file', file);
        }
    },

    /**
     * Handles an error response from the API for uploading the file.
     *
     * If the error status is 'request_too_large' or 413, then an error is
     * shown to the user indicating that the error was due to exceeding the
     * maximum filesize. Otherwise, the error is handled by the framework.
     *
     * @param {HttpError} error AJAX error.
     * @private
     */
    _handleFileUploadError: function(error) {
        if (this.disposed === true) {
            return;
        }

        // Track errors attaching a file.
        app.analytics.trackEvent('email_attachment', 'upload_error', error);

        if (error && (error.error === 'request_too_large' || error.status == 413)) {
            // Mark the error as having been handled so that it doesn't get
            // handled again.
            error.handled = true;
            app.alert.show(error.error, {
                level: 'error',
                autoClose: true,
                messages: app.lang.get('ERROR_MAX_FILESIZE_EXCEEDED')
            });
        }

        if (_.isFunction(app.api.defaultErrorHandler)) {
            app.api.defaultErrorHandler(error);
        }
    },

    /**
     * Called when the Document selection drawer is closed. If a Document was
     * selected, then the Document is fetched.
     *
     * The Document must be fetched because it is unlikely that the model
     * retrieved for {@link BaseSelectionListView} contains all of the data that
     * is needed. A placeholder attachment is added to the Select2 field while
     * the Document is being retrieved.
     *
     * @param {Data.Bean} doc The selected Document.
     * @private
     */
    _attachDocument: function(doc) {
        var placeholder;
        var placeholderName;

        if (this.disposed === true) {
            return;
        }

        placeholderName = app.utils.getRecordName(doc) || app.lang.getModuleName(doc.module);
        placeholder = this._addPlaceholderAttachment(placeholderName);
        this._requests[placeholder.cid] = doc.fetch({
            success: _.bind(this._handleDocumentFetchSuccess, this),
            error: function(error) {
                // Track errors attaching a document.
                app.analytics.trackEvent('email_attachment', 'doc_error', error);
            },
            complete: _.bind(function() {
                this._removePlaceholderAttachment(placeholder);
            }, this)
        });
    },

    /**
     * Handles a successful response from the API for fetching the Document.
     *
     * The relevant data is taken from the record and added as an attachment.
     *
     * @param {Object} doc The fetched record.
     * @private
     */
    _handleDocumentFetchSuccess: function(doc) {
        var file;

        if (this.disposed === true) {
            return;
        }

        file = app.data.createBean('Notes', {
            _link: 'attachments',
            upload_id: doc.get('document_revision_id'),
            name: doc.get('filename') || doc.get('name'),
            filename: doc.get('filename') || doc.get('name'),
            file_mime_type: doc.get('latest_revision_file_mime_type'),
            file_size: doc.get('latest_revision_file_size'),
            file_ext: doc.get('latest_revision_file_ext'),
            file_source: 'DocumentRevisions'
        });
        this.model.get(this.name).add(file, {merge: true});

        // Track attaching a document.
        app.analytics.trackEvent('email_attachment', 'attached_doc', file);
    },

    /**
     * Adds a placeholder attachment to the Select2 field.
     *
     * @param {string} name The display name for the placeholder attachment.
     * @return {Data.Bean} The placeholder model.
     * @private
     */
    _addPlaceholderAttachment: function(name) {
        return this._placeholders.add({name: name});
    },

    /**
     * Removes a placeholder attachment from the Select2 field and aborts the
     * associated request, if it is active.
     *
     * @param {Data.Bean} placeholder The placeholder model.
     * @private
     */
    _removePlaceholderAttachment: function(placeholder) {
        var request = this._requests[placeholder.cid];

        this._placeholders.remove(placeholder);

        if (request && request.uid) {
            // Abort the request if it is still active.
            app.api.abortRequest(request.uid);
            delete this._requests[placeholder.cid];
        }
    }
}) },
"teamset": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TeamsetField
 * @alias SUGAR.App.view.fields.BaseTeamsetField
 * @extends View.Fields.Base.RelateField
 */
({
	// Teamset Field (base) 

    extendsFrom: 'RelateField',

    events: {
        'click .btn[name=add]': 'addItem',
        'click .btn[name=remove]': 'removeItem',
        'click .btn[name=primary]': 'setPrimaryItem',
        'change input.select2': 'inputChanged'
    },
    plugins: ['FieldDuplicate', 'TbACLs'],

    /**
     * HTML tag of the append team checkbox.
     *
     * @property {String}
     */
    appendTeamTag: 'input[name=append_team]',

    /**
     * Group fit class.
     *
     * @property {String}
     */
    fitGroupClass: 'three',

    /**
     * Button fit class.
     *
     * @property {String}
     */
    fitButtonClass: 'third',

    initialize: function (options) {
        this._super('initialize', [options]);
        /**
         * @inheritdoc
         */
        this._allow_single_deselect = false;

        /**
         * @inheritdoc
         */
        this._minChars = 1;

        this._currentIndex = 0;
        this.model.on("change:team_name_type", this.appendTeam, this);
    },

    /**
     * @inheritdoc
     *
     * Binds append team checkbox change for massupdate.
     */
    bindDomChange: function() {
        var $el = this.$(this.appendTeamTag);
        if ($el.length) {
            $el.on('change', _.bind(function() {
                this.appendTeamValue = $el.prop('checked');
                this.model.set('team_name_type', this.appendTeamValue ? '1' : '0');
            }, this));
        }
        this._super('bindDomChange');
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$(this.appendTeamTag).off();
        this._super('unbindDom');
    },

    /**
     * Handler on copy teamset values from one model to another.
     *
     * Prevent unchecking last team in team set in order to force the existence
     * of at least one checked team. If primary team is unchecked the next
     * checked team is defined as primary. Set up `checked` property for
     * current team and render field. Returns `false` to prevent processing
     * of teamset field copy cause all logic is implemented in this method.
     *
     * Called from {@link app.plugins._beforeFieldDuplicate}.
     */
    beforeFieldDuplicate: function(params) {

        if (!params.model || !params.data) {
            return false;
        }

        if (this.name !== params.data.fieldName ||
            params.model.get('id') !== this.model.get('id')
        ) {
            return true;
        }

        var checked = params.data.checked || false,
            teamId = params.data.recordItemId || null,
            teams = this.model.get(this.name),
            team = _.findWhere(teams, {'id': teamId}),
            primaryTeam = _.findWhere(teams, {'primary': true}),
            checkedTeams = _.where(teams, {'checked': true}),
            newPrimaryTeam = null;

        if (checked === false && checkedTeams.length === 1) {
            if (!this.disposed) {
                this.render();
            }
            return false;
        }

        if (checked === false && primaryTeam === team) {
            newPrimaryTeam = _.find(checkedTeams, function(item) {
                return item.id !== team.id;
            });
            if (newPrimaryTeam) {
                team.primary = false;
                newPrimaryTeam.primary = true;
            }
        }

        if (team) {
            team.checked = checked;
        }

        if (!this.disposed) {
            this.render();
        }
        return false;
    },

    /**
     * Handler to format field for `merge-duplicate` view.
     *
     * For teamset field we override value to have set of teams from all models
     * for primary record in merge-duplicate view.
     *
     * Called from {@link app.plugins._formatFieldForDuplicate}.
     */
    formatFieldForDuplicate: function() {
        if (_.isUndefined(this.view.generatedValues) ||
            _.isUndefined(this.view.generatedValues.teamsets)
        ) {
            return;
        }

        var allTeams = this.view.generatedValues.teamsets[this.name];

        if (!(this.view.collection instanceof Backbone.Collection)) {
            return;
        }

        _.each(this.view.collection.models, function(model) {
            var teamIds = _.compact(_.pluck(model.get(this.name), 'id')),
                primaryTeam = _.findWhere(model.get(this.name), {primary: true}),
                teams = [];

            _.each(allTeams, function(team) {
                if (model === this.view.primaryRecord || _.contains(teamIds, team.id)) {
                    var extendedTeam = _.extend(
                        app.utils.deepCopy(team),
                        {
                            checked: (model === this.view.primaryRecord && _.contains(teamIds, team.id) === true),
                            primary: (primaryTeam && primaryTeam.id === team.id)
                        }
                    );
                    if (this.isTBAEnabled) {
                        extendedTeam.selected = (
                            _.contains(teamIds, team.id) === true &&
                            _.where(model.get(this.name), {id: team.id})[0].selected
                        );
                    }
                    teams.push(extendedTeam);
                } else {
                    teams.push({
                        checked: false,
                        primary: false
                    });
                }
            }, this);
            model.set(this.name, teams, {silent: true});
        }, this);
    },

    /**
     * Handler to unformat field for `merge-duplicate` view.
     *
     * For teamset field we should exclude teams that are not selected before
     * save primary record.
     *
     * Called from {@link app.plugins._unformatFieldForDuplicate}.
     */
    unformatFieldForDuplicate: function() {
        if (!this.view.primaryRecord) {
            return;
        }

        this.view.primaryRecord.set(
            this.name,
            _.where(this.view.primaryRecord.get(this.name), {'checked': true}),
            {silent: true}
        );
    },

    /**
     * Changes default behavior when doing inline editing on a List view.  We want to
     * load 'list' template instead of 'edit' template because this keeps the teamset widget
     * read-only during inline editing. See SP-1197.
     * Overrides templates for `merge-duplicate` view.
     * @override
     * @private
     */
    _loadTemplate: function() {
        this._super("_loadTemplate");

        if (!_.isUndefined(this.isTBAEnabled) && this.isTBAEnabled) {
            this.fitGroupClass = 'four';
            this.fitButtonClass = 'fourth';
        }

        var template = app.template.getField(
            this.type,
            this.view.name + '-' + this.tplName,
            this.model.module);

        if (!template && this.view.meta && this.view.meta.template) {
            template = app.template.getField(
                this.type,
                this.view.meta.template + '-' + this.tplName,
                this.model.module);
        }

        // If we're loading edit template on List view switch to detail template instead
        if (!template && this.view.action === 'list' && _.contains(['edit','detail'], this.tplName)) {
            this.template = app.template.getField(
                this.type,
                'list',
                this.module, this.tplName
            ) || app.template.empty;
            this.tplName = 'list';
        }

        this.template = template || this.template;
    },

    /**
     * @inheritdoc
     * Add ability to edit and save an invalid team set.
     */
    _render: function () {
        var self = this;

        if (_.isEmpty(this.value) && this.action == 'edit' && this._checkAccessToAction(this.action)) {
            // Leave an empty team set on list view in case of cancel.
            this.value = app.utils.deepCopy(app.user.getPreference('default_teams'));
            this._updateAndTriggerChange(this.value);
        }
        this._super('_render');

        if (this.tplName === 'edit') {
            this.$(this.fieldTag).each(function (index, el) {
                var plugin = $(el).data("select2");
                // If there is a plugin but no team index, set it
                if (!_.isUndefined(plugin) && _.isUndefined(plugin.setTeamIndex)) {
                    plugin.setTeamIndex = function () {
                        self._currentIndex = $(this).data("index");
                    };
                    plugin.opts.element.on("select2-open", plugin.setTeamIndex);
                }
            });
        }
    },

    /**
     * Called to update value when a selection is made from options view dialog
     * @param model New value for teamset
     */
    setValue: function (model) {
        if (!model) {
            return;
        }
        var index = this._currentIndex,
            team = this.value;
        team[index || 0].id = model.id;
        team[index || 0].name = model.value;
        this._updateAndTriggerChange(team);
    },

    /**
     * @override
     */
    _isErasedField: function() {
        if (!this.model) {
            return false;
        }

        return !this.model.get(this.name) && _.contains(this.model.get('_erased_fields'), this.name);
    },

    format: function (value) {
        if (this.model.isNew() && (_.isEmpty(value) || this.model.get(this.name) != value)) {
            //load the default team setting that is specified in the user profile settings
            if (_.isEmpty(value)) {
                //Here default_teams with "selected teams" are copied from user to module.
                //This "teams" will be send to server with "selected" options
                value = app.utils.deepCopy(app.user.getPreference("default_teams"));
                //If TBA not enabled for module "selected" can be set to false.
                _.each(value, function(team, index, list) {
                    if (!_.isUndefined(team.selected) && !this.isTBAEnabled) {
                        team.selected = false;
                    }
                }, this);
                this.model.setDefault(this.name, value);
            }
        }
        value = app.utils.deepCopy(value);
        if (!_.isArray(value)) {
            value = [
                {
                    name: value
                }
            ];
        }
        // FIXME: SC-3836 will replace special-casing view names/actions via
        // action based templates.
        if (this.view.action === 'list' && this.view.name !== 'merge-duplicates' && this.view.name !== 'audit') {
            //Display primary team in list view
            var primaryTeam = _.find(value, function (team) {
                return team.primary;
            });
            // If there is no primary team discovered return an empty string
            return !_.isUndefined(primaryTeam) && !_.isUndefined(primaryTeam.name) ? primaryTeam.name : "";
        }
        // Place the add button as needed
        if (_.isArray(value) && !_.isEmpty(value)) {
            _.each(value, function(team, index, list) {
                delete team.remove_button;
                if (!team.add_button && index === list.length - 1) {
                    team.add_button = true;
                } else {
                    delete team.add_button;
                }
            });

            // number of valid teams
            var numTeams = _.filter(value, function (team) {
                return !_.isUndefined(team.id);
            }).length;
            // Show remove button for all unset combos and only set combos if there are more than one
            _.each(value, function (team) {
                if (_.isUndefined(team.id) || numTeams > 1) {
                    team.remove_button = true;
                }
            });
        }
        return value;
    },

    /**
     * Validates for equality on id and primary properties
     * since other attributes are used for rendering.
     *
     * @override
     */
    equals: function(other) {
        var validateMap = function(item) {
            return {
                id: item.id,
                primary: item.primary
            };
        };
        return _.isEqual(
            _.map(this.getFormattedValue(), validateMap),
            _.map(other.getFormattedValue(), validateMap)
        );
    },

    addTeam: function () {
        this.value.push({});
        this._currentIndex++;
        this._updateAndTriggerChange(this.value);
    },
    removeTeam: function (index) {
        // Do not remove last team.
        if (index === 0 && this.value.length === 1) {
            return;
        }
        if (this._currentIndex === this.value.length - 1) {
            this._currentIndex--;
        }
        //Pick first team to be Primary if we're removing Primary team
        var removed = this.value.splice(index, 1);
        if (removed && removed.length > 0 && removed[0].primary) {
            this.setPrimary(0);
        }
        this._updateAndTriggerChange(this.value);
    },
    appendTeam: function () {
        var appendTeam = this.model.get("team_name_type");
        if (appendTeam !== "1") {
            var primaryTeam = _.find(this.value, function (team) {
                return team.primary;
            }, this);
            if (_.isEmpty(primaryTeam)) {
                this.setPrimary(0);
            }
        }
    },
    setPrimary: function (index) {
        var previousPrimary = null,
            appendTeam = this.model.get("team_name_type");
        _.each(this.value, function (team, i) {
            if (team.primary && appendTeam === "1") {
                previousPrimary = i;
            }
            team.primary = false;
        });
        //If this team is set, then allow it to turn primary
        if (previousPrimary !== index && this.value[index].name) {
            this.value[index].primary = true;
        }
        this._updateAndTriggerChange(this.value);
        return (this.value[index]) ? this.value[index].primary : false;
    },
    //Forcing change event since backbone isn't picking up on changes within an object within the array.
    inputChanged: function (evt) {
        this._updateAndTriggerChange(this.value);
    },
    /**
     * @inheritdoc
     * Restore the select2 focus location after refresh the dom.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function() {
                var teamList = this.model.get(this.name);

                if (!_.isUndefined(teamList) && (this._currentIndex !== teamList.length - 1)) {
                    this._currentIndex = teamList.length - 1;
                }

                this.render();

                var $fieldTag = this.$(this.fieldTag);
                if (!_.isEmpty($fieldTag.data('select2'))) {
                    this.$($fieldTag.get(this._currentIndex)).focus();
                }
            }, this);
        }
    },
    /**
     * Forcing change event on value update since backbone isn't picking up on changes within an object within the array.
     * @param value New value for teamset field
     * @private
     */
    _updateAndTriggerChange: function (value) {
        // SP-1437: No Warning message when update with Team field only

        // The following is provided for your convenience should you wish to learn more about
        // Backbone Model .changedAttributes() not showing all changes.
        // For a list of the actual third party software used in this Sugar product,
        // please visit http://support.sugarcrm.com/06_Customer_Center/11_Third_Party_Software/.
        //
        // http://stackoverflow.com/questions/17221680/backbone-model-changedattributes-not-showing-all-changes
        _.each(value, function(team) {
            // "add_button" and "remove_button" are JS elements, don't track them.
            delete team.add_button;
            delete team.remove_button;
        });
        this.model.unset(this.name, {silent: true}).set(this.name, value);//force changedAttributes
        this.model.trigger('change');
    },
    addItem: _.debounce(function (evt) {
        var index = $(evt.currentTarget).data('index');
        //Only allow adding a Team when ones been selected (SP-534)
        if (!index || this.value[index].id) {
            this.addTeam();
        }
    }, 0),
    removeItem: _.debounce(function (evt) {
        var index = $(evt.currentTarget).data('index');
        if (_.isNumber(index)) {
            this.removeTeam(index);
        }
    }, 0),
    setPrimaryItem: _.debounce(function (evt) {
        var index = $(evt.currentTarget).data('index');

        //Don't allow setting to primary until user's selected an actual team (SP-530)
        if (!this.value[index] || !this.value[index].id) {
            return;
        }
        this.$(".btn[name=primary]").removeClass("active");
        if (this.setPrimary(index)) {
            this.$(".btn[name=primary][data-index=" + index + "]").addClass("active");
        }
    }, 0)
}) },
"relate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Relate field provides a link to a module that is set in the definition of
 * this field metadata.
 *
 * This field requires at least the follow definitions to be exist in the
 * field:
 *
 * ```
 * array(
 *     'name' => 'account_name',
 *     'rname' => 'name',
 *     'id_name' => 'account_id',
 *     'module' => 'Accounts',
 *     'link' => true,
 *     //...
 * ),
 * ```
 *
 * The field also support a `populate_list` to update other fields in the
 * current model from other fields of the selected model.
 *
 * ```
 * array(
 *     //...
 *     'populate_list' => array(
 *         'populate_list' => array(
 *         'billing_address_street' => 'primary_address_street',
 *         'billing_address_city' => 'primary_address_city',
 *         'billing_address_state' => 'primary_address_state',
 *         'billing_address_postalcode' => 'primary_address_postalcode',
 *         'billing_address_country' => 'primary_address_country',
 *         'phone_office' => 'phone_work',
 *         //...
 *
 *     ),
 * )
 * ```
 *
 * This field allows you to configure the minimum chars that trigger a search
 * when using the typeahead feature.
 *
 * ```
 * array(
 *     //...
 *     'minChars' => 3,
 * )
 * ```
 *
 * TODO: we have a mix of properties here with camelCase and underscore.
 * Needs to be addressed.
 *
 * @class View.Fields.Base.RelateField
 * @alias SUGAR.App.view.fields.BaseRelateField
 * @extends View.Fields.Base.BaseField
 */
({
	// Relate Field (base) 

    fieldTag: 'input.select2',

    /**
     * Initializes field and binds all function calls to this
     * @param {Object} options
     */
    initialize: function(options) {
        /**
         * Boolean used for the 'allowClear' select2 option.
         *
         * @property {boolean}
         * @protected
         */
        this._allow_single_deselect = true;
        /**
         * Minimum input characters to trigger the search. Used for
         * `minimumInputLength` select2 option.
         *
         * @property {number}
         * @protected
         */
        this._minChars = options.def.minChars || 1;
        /**
         * Separator used by select2 to separate values. Used for `separator`
         * select2 option.
         *
         * @property {string}
         * @protected
         */
        this._separator = '|';
        /**
         * Maximum number of records the user can select.
         *
         * @property {number}
         * @protected
         */
        this._maxSelectedRecords = 20;

        if (_.property('link')(options.def) && !_.isBoolean(options.def.link)) {
            app.logger.warn('The `link` property passed in the viewDefs must be a boolean. Hence, `link`' +
                ' will be set to `true` by default.');
        }

        this._super('initialize', [options]);

        // A relate field displays a link by default.
        this.viewDefs = _.defaults(this.viewDefs || {}, {link: true});
        /**
         * The template used for a pill in case of multiselect field.
         *
         * @property {Function}
         * @private
         */
        this._select2formatSelectionTemplate = app.template.getField('relate', 'pill', this.module);

        var populateMetadata = this._getPopulateMetadata();

        if (_.isEmpty(populateMetadata)) {
            return;
        }
        _.each(this.def.populate_list, function(target, source) {
            if (_.isUndefined(populateMetadata.fields[source])) {
                app.logger.error('Fail to populate the related attributes: attempt to access undefined key - ' +
                this.getSearchModule() + '::' + source);
            }
        }, this);

        this._createSearchCollection();
    },

    /**
     * Gets the proper module's metadata to use during auto populating fields
     *
     * @return {*|Object}
     * @protected
     */
    _getPopulateMetadata: function() {
        return app.metadata.getModule(this.getSearchModule());
    },

    /**
     * Creates a Filters BeanCollection to easily apply filters.
     * The user must have `list` access to the search module to create a
     * {@link Data.Base.FiltersBeanCollection}.
     *
     * @protected
     */
    _createFiltersCollection: function(options) {
        var searchModule = this.getSearchModule();

        if (!app.acl.hasAccess('list', searchModule)) {
            app.logger.debug('No "list" access to ' + searchModule + ' so skipping the creation of filter.');
            return;
        }

        if (app.metadata.getModule('Filters') && searchModule) {
            this.filters = app.data.createBeanCollection('Filters');
            this.filters.setModuleName(searchModule);
            this.filters.setFilterOptions(this.getFilterOptions());
            this.filters.load(options);
        }
    },
    /**
     * Creates a {@link Data.BeanCollection} for the search results pertaining
     * to the search module.
     *
     * @protected
     */
    _createSearchCollection: function() {
        var searchModule = this.getSearchModule();
        if (searchModule && app.metadata.getModule(searchModule)) {
            this.searchCollection = app.data.createBeanCollection(searchModule);
        } else {
            this.searchCollection = null;
        }
    },

    /**
     * Bind the additional keydown handler on select2
     * search element (affected by version 3.4.3).
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    bindKeyDown: function(callback) {
        var $dropdown = this.$(this.fieldTag);
        $dropdown.on('keydown.record', {field: this}, callback);
        var plugin = $dropdown.data('select2');
        if (plugin) {
            plugin.focusser.on('keydown.record', {field: this}, callback);
            plugin.search.on('keydown.record', {field: this}, callback);
        }
    },

    /**
     * Unbind the additional keydown handler.
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    unbindKeyDown: function(callback) {
        var $dropdown = this.$(this.fieldTag);
        $dropdown.off('keydown.record', callback);
        var plugin = $dropdown.data('select2');
        if (plugin) {
            plugin.search.off('keydown.record', callback);
        }
    },

    focus: function() {
        if (this.action !== 'disabled') {
            //Need to defer to ensure that all the related elements have finished
            //rendering before attempting to open the dropdown.
            _.defer(_.bind(function() {
                this.$(this.fieldTag).first().select2('open');
            }, this));
        }
    },

    /**
     * //FIXME: We shouldn't have this method. SC-4121 will address this.
     * Creates the css classes to set to the select2 plugin.
     *
     * @return {string}
     * @private
     */
    _buildCssClasses: function() {
        var cssClasses = [];
        if (this.view.name === 'recordlist') {
            cssClasses.push('select2-narrow');
        }
        if (this.type === 'parent') {
            cssClasses.push('select2-parent');
        }
        if (this.def.isMultiSelect) {
            cssClasses.push('select2-choices-pills-close same-size-pills');
        }
        return cssClasses.join(' ');
    },

    /**
     * Renders relate field
     */
    _render: function() {
        var searchModule = this.getSearchModule();
        this._updateErasedPlaceholder();

        this._super('_render');

        //FIXME remove check for tplName SC-2608
        switch(this.tplName) {
            case 'edit':
            case 'massupdate':
                // `searchModule` can be undefined for a parent field when there
                // is no value set (ie in create mode). In that case, we don't
                // want to render the dropdown disabled.
                if (!_.isUndefined(searchModule)) {
                    if (!app.acl.hasAccess('list', searchModule) ||
                        !_.contains(app.metadata.getModuleNames(), searchModule)) {
                        this._renderDisabledDropdown();
                        break;
                    }
                }
                if (_.isUndefined(this.filters)) {
                    this._createFiltersCollection({
                        success: _.bind(function() {
                            if (!this.disposed) {
                                this._renderEditableDropdown();
                            }
                        }, this)
                    });
                } else {
                    this._renderEditableDropdown();
                }
                break;
            case 'disabled':
                this._renderDisabledDropdown();
                break;
        }
        return this;
    },

    /**
     * Renders the editable dropdown using the `select2` plugin.
     *
     * Since a filter may have to be applied on the field, we need to fetch
     * the list of filters for the current module before rendering the dropdown
     * (and enabling the searchahead feature that requires the filter
     * definition).
     *
     * @private
     */
    _renderEditableDropdown: function() {
        var self = this;
        var $dropdown = this.$(this.fieldTag);

        $dropdown.select2(this._getSelect2Options())
            .on('select2-open', _.bind(this._onSelect2Open, this))
            .on('searchmore', function() {
                $(this).select2('close');
                self.openSelectDrawer();
            })
            .on('change', _.bind(this._onSelect2Change, this));

        var plugin = $dropdown.data('select2');
        if (plugin && plugin.focusser) {
            plugin.focusser.on('select2-focus', _.bind(_.debounce(this.handleFocus, 0), this));
        }
    },

    /**
     * Renders the dropdown in disabled mode.
     *
     * @private
     */
    _renderDisabledDropdown: function() {
        var loadingLabel = app.lang.get('LBL_LOADING', this.module);
        var $dropdown = this.$(this.fieldTag);

        $dropdown.select2({
            width: '100%',
            initSelection: function(el, callback) {
                var $el = $(el),
                    id = $el.val(),
                    text = $el.data('rname');
                callback({id: id, text: text});
            },
            formatInputTooShort: function() {
                return '';
            },
            formatSearching: function() {
                return loadingLabel;
            },
            placeholder: this.getPlaceHolder(),
            allowClear: this._allow_single_deselect,
            minimumInputLength: this._minChars,
            query: _.bind(this.search, this)
        });
        $dropdown.select2('disable');
    },

    /**
     * Handler for when the select2 dropdown change event
     *
     * @param e
     * @private
     */
    _onSelect2Change: function(e) {
        var $el = $(e.target);
        var plugin = $el.data('select2');
        var id = e.val;

        if (_.isUndefined(id)) {
            return;
        }

        // For multiselect fields, we update the data-rname attributes
        // so it stays in sync with the id list, and allows us to use
        // 'setValue' method. The use of 'setValue' method is required
        // to re-render the field.
        if (this.def.isMultiSelect) {
            var dataRname = plugin.opts.element.data('rname');
            dataRname = dataRname ? dataRname.split(this._separator) : [];
            var ids = $el.select2('val');

            if (e.added) {
                dataRname.push(e.added.text);
            } else if (e.removed) {
                dataRname = _.without(dataRname, e.removed.text);
            } else {
                return;
            }
            var models = _.map(ids, function(id, index) {
                return {id: id, value: dataRname[index]};
            });

            this.setValue(models);
            return;
        }

        var value = (id) ? plugin.selection.find('span').text() : $el.data('rname');
        var collection = plugin.context;
        var attributes = {};
        if (collection && !_.isEmpty(id)) {
            // if we have search results use that to set new values
            var model = collection.get(id);
            attributes.id = model.id;
            attributes.value = model.get(this.getRelatedModuleField());
            _.each(model.attributes, function(value, field) {
                if (app.acl.hasAccessToModel('view', model, field)) {
                    attributes[field] = attributes[field] || model.get(field);
                }
            });
        } else if (e.currentTarget.value && value) {
            // if we have previous values keep them
            attributes.id = value;
            attributes.value = e.currentTarget.value;
        } else {
            // default to empty
            attributes.id = '';
            attributes.value = '';
        }

        this.setValue(attributes);
    },

    /**
     * Entry point for child classes to hook in and add/update to the base select2 options
     *
     * @return {{}}
     * @protected
     */
    _getSelect2Options: function() {
        return _.extend({}, {
            width: this.view.name === 'recordlist' ? 'off' : '100%',
            dropdownCssClass: _.bind(this._buildCssClasses, this),
            multiple: !!this.def.isMultiSelect,
            containerCssClass: _.bind(this._buildCssClasses, this),
            separator: this._separator,
            initSelection: _.bind(this._onInitSelect, this),
            formatInputTooShort: function() {
                return '';
            },
            formatSelection: _.bind(this._onFormatSelection, this),
            formatSearching: app.lang.get('LBL_LOADING', this.module),
            placeholder: this.getPlaceHolder(),
            allowClear: this._allow_single_deselect,
            minimumInputLength: this._minChars,
            maximumSelectionSize: 20,
            query: _.bind(this.search, this)
        });
    },

    /**
     * Callback for select2 `initSelection` property.
     *
     * @param {HTMLElement} el The select2 element that stores values.
     * @param {Function} callback select2 callback to initialize the plugin.
     * @private
     */
    _onInitSelect: function(el, callback) {
        var $el = $(el),
            id = $el.val(),
            text = $el.data('rname');

        if (!this.def.isMultiSelect) {
            return callback({id: id, text: text});
        }
        var ids = id.split(this._separator);
        text = text.split(this._separator);
        callback(_.map(ids, function(value, index) {
            return {id: value, text: text[index]};
        }));
    },

    /**
     * Callback for select2 `formatSelection` property.
     *
     * @param {Object} obj object containing the item name.
     * @return {string} A string containing template for a pill.
     *
     * @private
    */
    _onFormatSelection: function(obj) {
        var ctx = {};
        //TODO We should investigate why it's sometimes `text` and
        //sometimes `id` and make it always same if possible.
        ctx.text = obj.text || obj.id;
        return this._select2formatSelectionTemplate(ctx);
    },

    /**
     * Callback when select2 plugin opens.
     * @private
     * @param {Event} e The `click` event.
     */
    _onSelect2Open: function(e) {
        var plugin = this.$(e.currentTarget).data('select2');
        if (plugin.searchmore) {
            return;
        }
        var label = app.lang.get('LBL_SEARCH_AND_SELECT_ELLIPSIS', this.module);
        var $tpl = $('<div/>').addClass('select2-result-label').html(label);
        var onMouseDown = function() {
            plugin.opts.element.trigger($.Event('searchmore'));
            plugin.close();
        };
        var $content = $('<li class="select2-result">').append($tpl).mousedown(onMouseDown);
        plugin.searchmore = $('<ul class="select2-results">').append($content);
        plugin.dropdown.append(plugin.searchmore);
    },

    /**
     * Builds the route for the relate module's record.
     * @param {String} module The related module.
     * @param {String} id The record id to link to.
     *
     * TODO since base.js has a build href, we should try to reuse code or
     * extend this one from other "link" field
     */
    buildRoute: function(module, id) {
        if (_.isUndefined(id) || !this.viewDefs.link) {
            return;
        }

        var oldModule = module;
        // This is a workaround until bug 61478 is resolved to keep parity with 6.7
        if (module === 'Users' && this.context.get('module') !== 'Users') {
            module = 'Employees';
        }

        if (_.isEmpty(module)) {
            return;
        }

        var relatedRecord = this.model.get(this.fieldDefs.link);
        var action = this.viewDefs.route ? this.viewDefs.route.action : 'view';

        if (relatedRecord && app.acl.hasAccess(action, oldModule, {acls: relatedRecord._acl})) {
            this.href = '#' + app.router.buildRoute(module, id);
            //FIXME SC-6128 will remove this deprecated block.
        } else if (!relatedRecord) {
            this.href = this.href = '#' + app.router.buildRoute(module, id);
        } else {
            // if no access to module, remove the href
            this.href = undefined;
        }
    },

    // Derived controllers can override these if related module and id in another
    // place.
    _buildRoute: function () {
        this.buildRoute(this.getSearchModule(), this._getRelateId());
    },
    _getRelateId: function () {
        return this.model.get(this.def.id_name);
    },

    /**
     * @inheritdoc
     *
     * When there is no value set and we are in a create view, we try to check
     * if the parent context module matches this relate field. If it matches,
     * we pre-populate with that data.
     *
     * FIXME: the relate field should use this method to pre-populate the
     * values without touching the model or else we need to use silent to
     * prevent the warning of unsaved changes, consequently we can't bind
     * events like `change` to it.
     *
     * TODO: the model might not have the field that we are relating to. On
     * those corner cases, we need to fetch from the server that information.
     *
     * @return {String} This field's value. Need to change to object with all
     *   data that we need to render the field.
     */
    format: function(value) {

        var parentCtx = this.context && this.context.parent,
            setFromCtx;

        if (value) {
            /**
             * Flag to indicate that the value has been set from the context
             * once, so if later the value is unset, we don't set it again on
             * {@link #format}.
             *
             * @type {boolean}
             * @protected
             */
            this._valueSetOnce = true;
        }

        // This check sees if we should populate the field from the context.
        // Note that this is a different condition from if we should populate
        // the field from a parent model.
        //
        // Also note that readonly fields are not automatically populated from
        // the context.
        setFromCtx = value === null && !this.fieldDefs.readonly &&
            !this._valueSetOnce && parentCtx && _.isEmpty(this.context.get('model').link) &&
            this.view instanceof app.view.views.BaseCreateView &&
            parentCtx.get('module') === this.def.module &&
            this.module !== this.def.module;

        if (setFromCtx) {
            this._valueSetOnce = true;
            var model = parentCtx.get('model');
            // FIXME we need a method to prevent us from doing this
            this.def.auto_populate = true;
            // FIXME the setValue receives a model but not a backbone model...
            this.setValue(model.toJSON());
            // FIXME we need to iterate over the populated_ that is causing
            // unsaved warnings when doing the auto populate.
        }

        if (!this.def.isMultiSelect && this.action !== 'edit' && !this.context.get('create')) {
            this._buildRoute();
        }

        var idList = this.model.get(this.def.id_name);
        if (_.isArray(value)) {
            this.formattedRname = value.join(this._separator);
            this.formattedIds = idList.join(this._separator);
        } else {
            this.formattedRname = value;
            this.formattedIds = idList;
        }

        return value;
    },

    /**
     * Sets the value in the field.
     *
     * @param {Object|Array} models The source models attributes.
     */
    setValue: function(models) {
        if (!models) {
            return;
        }
        var isErased = false;
        var updateRelatedFields = true,
            values = {};
        if (_.isArray(models)) {
            // Does not make sense to update related fields if we selected
            // multiple models
            updateRelatedFields = false;
        } else {
            models = [models];
        }

        values[this.def.id_name] = [];
        values[this.def.name] = [];
        if (this.fieldDefs.link) {
            values[this.fieldDefs.link] = [];
        }

        _.each(models, _.bind(function(model) {
            values[this.def.id_name].push(model.id);
            //FIXME SC-4196 will fix the fallback to `formatNameLocale` for person type models.
            values[this.def.name].push(model[this.getRelatedModuleField()] ||
                app.utils.formatNameLocale(model) || model.value);
            if (this.fieldDefs.link) {
                values[this.fieldDefs.link].push(model);
            } else {
                isErased = app.utils.isNameErased(app.data.createBean(model._module, model));
            }
        }, this));

        // If it's not a multiselect relate, we get rid of the array.
        if (!this.def.isMultiSelect) {
            values[this.def.id_name] = values[this.def.id_name][0];
            values[this.def.name] = values[this.def.name][0];
            if (this.fieldDefs.link) {
                values[this.fieldDefs.link] = values[this.fieldDefs.link][0];
            } else {
                this._nameIsErased = isErased;
            }
        }

        //In case of selecting an erased value twice, we need to force a re-render to show the erased placeolder.
        var forceUpdate = _.isEmpty(this.model.get(this.def.name)) && _.isEmpty(values[this.def.name]);

        this.model.set(values);

        if (updateRelatedFields) {
            //Force an update to the link field as well so that SugarLogic and other listeners can react
            if (this.fieldDefs.link && _.isEmpty(values[this.fieldDefs.link]) && forceUpdate) {
                this.model.trigger('change:' + this.fieldDefs.link);
            }
            this.updateRelatedFields(models[0]);
        }

        if (forceUpdate) {
            this._updateField();
        }
    },

    _updateErasedPlaceholder: function() {
        //Handle erased field placehilders
        // Show a custom placeholder if the field's content has been erased
        if (this._isErasedField()) {
            this.hasErasedPlaceholder = true;
        } else {
            this.hasErasedPlaceholder = false;
        }
    },

    /**
     * Handles update of related fields.
     *
     * @param {Object} model The source model attributes.
     */
    updateRelatedFields: function(model) {
        var newData = {},
            self = this;
        _.each(this.def.populate_list, function(target, source) {
            source = _.isNumber(source) ? target : source;
            if (!_.isUndefined(model[source]) && app.acl.hasAccessToModel('edit', this.model, target)) {
                var before = this.model.get(target),
                    after = model[source];

                if (before !== after) {
                    newData[target] = model[source];
                }
            }
        }, this);

        if (_.isEmpty(newData)) {
            return;
        }

        // if this.def.auto_populate is true set new data and doesn't show alert message
        if (!_.isUndefined(this.def.auto_populate) && this.def.auto_populate == true) {
            // if we have a currency_id, set it first to trigger the currency conversion before setting
            // the values to the model, this prevents double conversion from happening
            if (!_.isUndefined(newData.currency_id)) {
                this.model.set({currency_id: newData.currency_id});
                delete newData.currency_id;
            }
            this.model.set(newData);
            return;
        }

        // load template key for confirmation message from defs or use default
        var messageTplKey = this.def.populate_confirm_label || 'TPL_OVERWRITE_POPULATED_DATA_CONFIRM',
            messageTpl = Handlebars.compile(app.lang.get(messageTplKey, this.getSearchModule())),
            fieldMessageTpl = app.template.getField(
                this.type,
                'overwrite-confirmation',
                this.model.module),
            messages = [],
            relatedModuleSingular = app.lang.getModuleName(this.def.module);

        _.each(newData, function(value, field) {
            var before = this.model.get(field),
                after = value;

            if (before !== after) {
                var def = this.model.fields[field];
                messages.push(fieldMessageTpl({
                    before: before,
                    after: after,
                    field_label: app.lang.get(def.label || def.vname || field, this.module)
                }));
            }
        }, this);

        app.alert.show('overwrite_confirmation', {
            level: 'confirmation',
            messages: messageTpl({
                values: new Handlebars.SafeString(messages.join(', ')),
                moduleSingularLower: relatedModuleSingular.toLowerCase()
            }),
            onConfirm: function() {
                // if we have a currency_id, set it first to trigger the currency conversion before setting
                // the values to the model, this prevents double conversion from happening
                if (!_.isUndefined(newData.currency_id)) {
                    self.model.set({currency_id: newData.currency_id});
                    delete newData.currency_id;
                }
                self.model.set(newData);
            }
        });
    },

    /**
     * @override
     */
    _isErasedField: function() {
        if (!this.model) {
            return false;
        }

        var def = this.fieldDefs;
        var link = this.model.get(def.link);

        if (link) {
            var recordField = app.metadata.getField({
                module: def.module,
                name: def.rname
            });

            if (recordField && recordField.type === 'fullname') {
                return app.utils.isNameErased(app.data.createBean(def.module, link));
            } else {
                return _.contains(link._erased_fields, def.rname);
            }
        } else {
            return this._nameIsErased || this._super('_isErasedField');
        }
    },

    /**
     * Opens the selection drawer.
     *
     * Note that if the field definitions have a `filter_relate` property, it
     * will open the drawer and filter by this relate field.
     *
     *     @example a Revenue Line Item is associated to an account and to an
     *      opportunity. If I want to open a drawer to select an opportunity
     *      with an initial filter that filters opportunities by the account
     *      associated to the revenue line item, in the field definitions I can
     *      specify:
     *      ```
     *      'filter_relate' => array(
     *          'account_id' => 'account_id',
     *      ),
     *      ```
     *      The key is the field name in the Revenue Line Items record,
     *      the value is the field name in the Opportunities record.
     */
    openSelectDrawer: function() {
        var layout = 'selection-list';
        var context = {
            module: this.getSearchModule(),
            fields: this.getSearchFields(),
            filterOptions: this.getFilterOptions()
        };

        if (!!this.def.isMultiSelect) {
            layout = 'multi-selection-list';
            _.extend(context, {
                preselectedModelIds: _.clone(this.model.get(this.def.id_name)),
                maxSelectedRecords: this._maxSelectedRecords,
                isMultiSelect: true
            });
        }

        app.drawer.open({
            layout: layout,
            context: context
        }, _.bind(this.setValue, this));
    },

    /**
     * Gets the list of fields to search by in the related module.
     *
     * @return {Array} The list of fields.
     */
    getSearchFields: function() {
        return _.union(['id', this.getRelatedModuleField()], _.keys(this.def.populate_list || {}));
    },

    /**
     * Gets the related field name in the related module record.
     *
     * Falls back to `name` if not defined.
     *
     * @return {String} The field name.
     */
    getRelatedModuleField: function() {
        return this.def.rname || 'name';
    },

    /**
     * @inheritdoc
     *
     * We need this empty so it won't affect refresh the select2 plugin
     */
    bindDomChange: function () {
    },

    /**
     * Gets the correct module to search based on field/link defs.
     *
     * If both `this.def.module` and `link.module` are empty, fall back onto the
     * metadata manager to get the proper module as a last resort.
     *
     * @return {String} The module to search on.
     */
    getSearchModule: function () {
        // If we have a module property on this field, use it
        if (this.def.module) {
            return this.def.module;
        }

        // No module in the field def, so check if there is a module in the def
        // for the link field
        var link = this.fieldDefs.link && this.model.fields && this.model.fields[this.fieldDefs.link] || {};
        if (link.module) {
            return link.module;
        }

        // At this point neither the def nor link field def have a module... let
        // metadata manager try find it
        return app.data.getRelatedModule(this.model.module, this.fieldDefs.link);
    },
    getPlaceHolder: function () {
        var searchModule = this.getSearchModule(),
            searchModuleLower = searchModule.toLocaleLowerCase(),
            module = app.lang.getModuleName(searchModule, {defaultValue: searchModuleLower});

        return app.lang.get('LBL_SEARCH_SELECT_MODULE', this.module, {
            module: new Handlebars.SafeString(module)
        });
    },

    /**
     * Formats the filter options.
     *
     * @param {Boolean} force `true` to force retrieving the filter options
     *   whether or not it is available in memory.
     * @return {Object} The filter options.
     */
    getFilterOptions: function(force) {
        if (this._filterOptions && !force) {
            return this._filterOptions;
        }
        this._filterOptions = new app.utils.FilterOptions()
            .config(this.def)
            .setInitialFilter(this.def.initial_filter || '$relate')
            .populateRelate(this.model)
            .format();
        return this._filterOptions;
    },

    /**
     * Builds the filter definition to pass to the request when doing a quick
     * search.
     *
     * It will combine the filter definition for the search term with the
     * initial filter definition. Both are optional, so this method may return
     * an empty filter definition (empty `array`).
     *
     * @param {String} searchTerm The term typed in the quick search field.
     * @return {Array} The filter definition.
     */
    buildFilterDefinition: function(searchTerm) {
        if (!app.metadata.getModule('Filters') || !this.filters) {
            return [];
        }
        var filterBeanClass = app.data.getBeanClass('Filters').prototype,
            filterOptions = this.getFilterOptions() || {},
            filter = this.filters.collection.get(filterOptions.initial_filter),
            filterDef,
            populate,
            searchTermFilter,
            searchModule;

        if (filter) {
            populate = filter.get('is_template') && filterOptions.filter_populate;
            filterDef = filterBeanClass.populateFilterDefinition(filter.get('filter_definition') || {}, populate);
            searchModule = filter.moduleName;
        }

        searchTermFilter = filterBeanClass.buildSearchTermFilter(searchModule || this.getSearchModule(), searchTerm);

        return filterBeanClass.combineFilterDefinitions(filterDef, searchTermFilter);
    },

    /**
     * Searches for related field.
     * @param event
     */
    search: _.debounce(function(query) {
        var term = query.term || '',
            self = this,
            searchModule = this.getSearchModule(),
            params = {},
            limit = self.def.limit || 5,
            relatedModuleField = this.getRelatedModuleField();

        if (query.context) {
            params.offset = this.searchCollection.next_offset;
        }
        params.filter = this.buildFilterDefinition(term);

        this.searchCollection.fetch({
            //Don't show alerts for this request
            showAlerts: false,
            update: true,
            remove: _.isUndefined(params.offset),
            reset: _.isUndefined(params.offset),
            fields: this.getSearchFields(),
            context: self,
            params: params,
            limit: limit,
            success: function(data) {
                var fetch = {results: [], more: data.next_offset > 0, context: data};
                if (fetch.more) {
                    var fieldEl = self.$(self.fieldTag),
                    //For teamset widget, we should specify which index element to be filled in
                        plugin = (fieldEl.length > 1) ? $(fieldEl.get(self._currentIndex)).data("select2") : fieldEl.data("select2"),
                        height = plugin.searchmore.children("li:first").children(":first").outerHeight(),
                    //0.2 makes scroll not to touch the bottom line which avoid fetching next record set
                        maxHeight = height * (limit - .2);
                    plugin.results.css("max-height", maxHeight);
                }
                _.each(data.models, function (model, index) {
                    if (params.offset && index < params.offset) {
                        return;
                    }
                    fetch.results.push({
                        id: model.id,
                        text: model.get(relatedModuleField) + ''
                    });
                });
                if (query.callback && _.isFunction(query.callback)) {
                    query.callback(fetch);
                }
            },
            error: function() {
                if (query.callback && _.isFunction(query.callback)) {
                    query.callback({results: []});
                }
                app.logger.error("Unable to fetch the bean collection.");
            }
        });
    }, app.config.requiredElapsed || 500),

    /**
     * @inheritdoc
     * Avoid rendering process on select2 change in order to keep focus.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change', function() {
                this.getFilterOptions(true);
            }, this);

            this.model.on('change:' + this.name, this._updateField, this);
        }
    },

    _updateField: function() {
        if (this.disposed) {
            return;
        }
        var $dropdown = this.$(this.fieldTag);
        if (!_.isEmpty($dropdown.data('select2'))) {
            var value = this.model.get(this.def.name);
            value = _.isArray(value) ? value.join(this._separator) : value;
            value = value ? value.trim() : value;
            if (this._isErasedField()) {
                value = app.lang.getAppString('LBL_VALUE_ERASED');
            }

            $dropdown.data('rname', value);

            // `id` can be an array of ids if the field is a multiselect.
            var id = this.model.get(this.def.id_name);
            if (_.isEqual($dropdown.select2('val'), id)) {
                return;
            }

            $dropdown.select2('val', id);
        } else {
            this.render();
        }
    },


    unbindDom: function() {
        this.$(this.fieldTag).select2('destroy');
        app.view.Field.prototype.unbindDom.call(this);
    }

}) },
"status": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.StatusField
 * @alias SUGAR.App.view.fields.BaseStatusField
 * @extends View.Fields.Base.BaseField
 */
({
	// Status Field (base) 

    /**
     * Additional CSS Classes to be added to hbs
     */
    cssClasses: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.buildCSSClasses();
    },

    /**
     * Gets the field value and sets cssClasses
     */
    buildCSSClasses: function() {
        var status = this.model.get(this.name);
        if (status) {
            status = status.replace(' ', '_');
            this.cssClasses = 'field_' + this.name + '_' + status;
        }
    }
}) },
"float": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FloatField
 * @alias SUGAR.App.view.fields.BaseFloatField
 * @extends View.Fields.Base.BaseField
 */
({
	// Float Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     *
     * Unformats the float based on userPreferences (grouping/decimal separator).
     * If we weren't able to parse the value, the original value is returned.
     *
     * @param {String} value the formatted value based on user preferences.
     * @return {Number|String} the unformatted value, or original string if invalid.
     */
    unformat: function(value) {
        var unformattedValue = app.utils.unformatNumberStringLocale(value);

        // if we got a number back and we have a precision we should round to that precision as that is what will
        // be stored in the db, this is needed just in case SugarLogic is used on this field's value
        if (_.isFinite(unformattedValue) && this.def && this.def.precision) {
            unformattedValue = app.math.round(unformattedValue, this.def.precision, true);
        }
        // if unformat failed, return original value
        return _.isFinite(unformattedValue) ? unformattedValue : value;

    },

    /**
     * @inheritdoc
     *
     * Formats the float based on user preferences (grouping separator).
     * If the field definition has `disabled_num_format` as `true` the value
     * won't be formatted. Also, if the value isn't a finite float it will
     * return `undefined`.
     *
     * @param {Number} value the float value to format as per user preferences.
     * @return {String|undefined} the formatted value based as per user
     *   preferences.
     */
    format: function(value) {
        if (this.def.disable_num_format || _.isNull(value)|| _.isUndefined(value) || _.isNaN(value)) {
            return value;
        }

        var number_grouping_separator = app.user.getPreference('number_grouping_separator') || ',';
        var decimal_separator = app.user.getPreference('decimal_separator') || '.';

        if (_.isUndefined(this.def.precision) || !this.def.precision) {
            return app.utils.addNumberSeparators(
                value.toString(),
                number_grouping_separator,
                decimal_separator
            );
        }

        return app.utils.formatNumber(
            value,
            this.def.precision,
            this.def.precision,
            number_grouping_separator,
            decimal_separator
        );
    }
}) },
"module": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ModuleField
 * @alias SUGAR.App.view.fields.BaseModuleField
 * @extends View.Fields.Base.BaseField
 */
({
	// Module Field (base) 

    format: function(value){
        value = app.lang.getModuleName(value, {plural: true});
        return value;
    }
}) },
"enum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EnumField
 * @alias SUGAR.App.view.fields.BaseEnumField
 * @extends View.Fields.Base.BaseField
 */
({
	// Enum Field (base) 

    fieldTag: 'input.select2',

    /**
     * HTML tag of the append value checkbox.
     *
     * @property {String}
     */
    appendValueTag: 'input[name=append_value]',

    /**
     * Whether this field is in the midst of fetching options for its dropdown.
     *
     * @type {Boolean}
     */
    isFetchingOptions: false,

    /**
     * The dropdown elements.
     *
     *     @example The format of the object is:
     *     ```
     *     {
     *         "key1": "value1",
     *         "key2": "value2",
     *         "key3": "value3"
     *     }
     *     ```
     *
     * @type {Object}
     */
    items: null,

    /**
     * The keys of dropdown elements and their index in the related
     * `app_list_keys` array.
     *
     *     @example The format of the object is:
     *     ```
     *     {
     *         "key1": 1,
     *         "key2": 0,
     *         "key3": 2
     *     }
     *     ```
     *
     * If no `app_list_keys` entry, or if elements in the expected order, the
     * object will be empty.
     *
     * @type {Object}
     */
    _keysOrder: null,

    /**
     * @inheritdoc
     */
    initialize: function() {
        this._super('initialize', arguments);

        //Reset the availible options based on the user's access and the model's values
        if (_.isString(this.def.options)) {
            var self = this;

            this.listenTo(this.model, "sync", function(model){
                var options = app.lang.getAppListStrings(self.def.options);
                if (options) {
                    self.items = self._filterOptions(options);
                }
            });
        }
    },

    /**
     * @inheritdoc
     *
     * Returns the direction of the field depending on the nature of the first
     * option when the language direction is `rtl`.
     */
    direction: function() {
        if (_.isEmpty(this.items) || app.lang.direction !== 'rtl') {
            return;
        }

        var firstOption = _.values(this.items)[0];
        return app.utils.isDirectionRTL(firstOption) ? 'rtl' : 'ltr';
    },

    /**
     * Bind the additional keydown handler on select2
     * search element (affected by version 3.4.3).
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    bindKeyDown: function(callback) {
        var $el = this.$(this.fieldTag);
        if ($el) {
            $el.on('keydown.record', {field: this}, callback);
            var plugin = $el.data('select2');
            if (plugin) {
                if (plugin.focusser) {
                    plugin.focusser.on('keydown.record', {field: this}, callback);
                }
                plugin.search.on('keydown.record', {field: this}, callback);
            }
        }
    },

    /**
     * Unbind the additional keydown handler.
     *
     * Invoked from {@link app.plugins.Editable}.
     * @param {Function} callback Callback function for keydown.
     */
    unbindKeyDown: function(callback) {
        if (this.$el) {
            var $el = this.$(this.fieldTag);
            if ($el) {
                $el.off('keydown.record', callback);
                var plugin = $el.data('select2');
                if (plugin) {
                    plugin.search.off('keydown.record', callback);
                }
            }
        }
    },

    /**
     * @override
     * @protected
     * @chainable
     */
    _render: function() {
        var self = this;
        if (!this.items || _.isEmpty(this.items)) {
            this.loadEnumOptions(false, function() {
                self.isFetchingOptions = false;
                //Re-render widget since we have fresh options list
                if(!this.disposed){
                    this.render();
                }
            });
            if (this.isFetchingOptions){
                // Set loading message in place of empty DIV while options are loaded via API
                this.$el.html('<div class="select2-loading">' + app.lang.get('LBL_LOADING') + '</div>');
                return this;
            }
        }
        //Use blank value label for blank values on multiselects
        if (this.def.isMultiSelect && !_.isUndefined(this.items['']) && this.items[''] === '') {
            var obj = {};
            _.each(this.items, function(value, key) {
               // Only work on key => value pairs that are not both blank
               if (key !== '' && value !== '') {
                   obj[key] = value;
               }
            }, this);
            this.items = obj;
        }
        this.items = this._filterOptions(this.items);
        var optionsKeys = _.isObject(this.items) ? _.keys(this.items) : [],
            defaultValue = this._checkForDefaultValue(this.model.get(this.name), optionsKeys);

        app.view.Field.prototype._render.call(this);
        // if displaying the noaccess template, just exit the method
        if (this.tplName == 'noaccess') {
            return this;
        }
        var select2Options = this.getSelect2Options(optionsKeys);
        var $el = this.$(this.fieldTag);
        //FIXME remove check for tplName SC-2608
        if (this.tplName === 'edit' || this.tplName === 'list-edit' || this.tplName === 'massupdate') {
            $el.select2(select2Options);
            var plugin = $el.data('select2');

            if (plugin && this.dir) {
                plugin.container.attr('dir', this.dir);
                plugin.results.attr('dir', this.dir);
            }

            if (plugin && plugin.focusser) {
                plugin.focusser.on('select2-focus', _.bind(_.debounce(this.handleFocus, 0), this));
            }
            $el.on('change', function(ev) {
                var value = ev.val;
                if (_.isUndefined(value)) {
                    return;
                }
                if (self.model) {
                    self.model.set(self.name, self.unformat(value));
                }
            });
            if (this.def.isMultiSelect && this.def.ordered) {
                $el.select2('container').find('ul.select2-choices').sortable({
                    containment: 'parent',
                    start: function() {
                        $el.select2('onSortStart');
                    },
                    update: function() {
                        $el.select2('onSortEnd');
                    }
                });
            }
        } else if (this.tplName === 'disabled') {
            $el.select2(select2Options);
            $el.select2('disable');
        }
        //Setup selected value in Select2 widget
        if (!_.isUndefined(this.value)) {
            // To make pills load properly when autoselecting a string val
            // from a list val needs to be an array
            if (!_.isArray(this.value)) {
                this.value = [this.value];
            }
            // Trigger the `change` event only if we automatically set the
            // default value.
            $el.select2('val', this.value, !!defaultValue);
        }

        if (this.tplName === 'detail') {
            $('.select2-drop').select2('close');
        }

        return this;
    },

    /**
     * Sets the model value to the default value if required
     * @private
     */
    _checkForDefaultValue: function(currentValue, optionsKeys){

        // Javascript keys function returns strings even if keys are numbers.  The parameter optionsKeys
        // is obtained by _.keys() operation on an object. Even if the object keys were numeric originally,
        // optionsKeys will be an array of strings. Hence we need to cast currentValue to a string
        // for comparison sake.
        if ((typeof currentValue !== 'undefined') && (currentValue !== null)) {
            currentValue = currentValue.toString();
        }

        var action = this.action || this.view.action;
        //After rendering the dropdown, the selected value should be the value set in the model,
        //or the default value. The default value fallbacks to the first option if no other is selected
        //or the selected value is not available in the list of items,
        //if the user has write access to the model for the field we are currently on.
        //This should be done only if available options are loaded, otherwise the value in model will be reset to
        //default even if it's in available options but they are not loaded yet
        if (!this.def.isMultiSelect
            && !_.isEmpty(this.items)
            && !(this.model.has(this.name) && optionsKeys.indexOf(currentValue) > -1)
            && app.acl.hasAccessToModel('write', this.model, this.name)
            && (action == 'edit' || action == 'create')
        ) {
            var defaultValue = this._getDefaultOption(optionsKeys);
            //Forecasting uses backbone model (not bean) for custom enums so we have to check here
            if (_.isFunction(this.model.setDefault)) {
                this.model.setDefault(this.name, defaultValue);
            }
        }
    },

    /**
     * Called when focus on inline editing
     */
    focus: function () {
        //We must prevent focus for multi select otherwise when inline editing the dropdown is opened and it is
        //impossible to click on a pill `x` icon in order to remove an item
        if(this.action !== 'disabled' && !this.def.isMultiSelect) {
            this.$(this.fieldTag).select2('open');
        }
    },

    /**
     * Load the options for this field and pass them to callback function.  May be asynchronous.
     * @param {Boolean} fetch (optional) Force use of Enum API to load options.
     * @param {Function} callback (optional) Called when enum options are available.
     */
    loadEnumOptions: function(fetch, callback, error) {
        var self = this;
        var _module = this.getLoadEnumOptionsModule();
        var _itemsKey = 'cache:' + _module + ':' + this.name + ':items';

        this.items = this.def.options || this.context.get(_itemsKey);

        fetch = fetch || false;

        if (fetch || !this.items) {
            this.isFetchingOptions = true;
            var _key = 'request:' + _module + ':' + this.name;
            //if previous request is existed, ignore the duplicate request
            if (this.context.get(_key)) {
                var request = this.context.get(_key);
                request.xhr.done(_.bind(function(o) {
                    if (this.items !== o) {
                        this.items = o;
                        callback.call(this);
                    }
                }, this));
            } else {
                var request = app.api.enumOptions(_module, self.name, {
                    success: function(o) {
                        if(self.disposed) { return; }
                        if (self.items !== o) {
                            self.items = o;
                            self.context.set(_itemsKey, self.items);
                        }
                    },
                    error: function(e) {
                        if (self.disposed) {
                            return;
                        }

                        if (error) {
                            error(e);
                        }

                        // Continue to use Sugar7's default error handler.
                        if (_.isFunction(app.api.defaultErrorHandler)) {
                            app.api.defaultErrorHandler(e);
                        }

                        self.items = {'': app.lang.get('LBL_NO_DATA', self.module)};
                    },
                    complete: function() {
                        if (!self.disposed) {
                            self.context.unset(_key);
                            callback.call(self);
                        }
                    }
                });
                this.context.set(_key, request);
            }
        } else if (_.isString(this.items)) {
            this.items = app.lang.getAppListStrings(this.items);
        }
    },

    /**
     * Allow overriding of what module is used for loading the enum options
     *
     * @return {string}
     */
    getLoadEnumOptionsModule: function() {
        return this.module;
    },

    /**
     * Helper function for generating Select2 options for this enum
     * @param {Array} optionsKeys Set of option keys that will be loaded into Select2 widget
     * @return {Object} Select2 options, refer to Select2 documentation for what each option means
     */
    getSelect2Options: function(optionsKeys){
        var select2Options = {};
        select2Options.allowClear = _.indexOf(optionsKeys, "") >= 0;
        select2Options.transformVal = _.identity;

        /* From http://ivaynberg.github.com/select2/#documentation:
         * Initial value that is selected if no other selection is made
         */
        if(!this.def.isMultiSelect) {
            select2Options.placeholder = app.lang.get("LBL_SEARCH_SELECT");
        }

        /* From http://ivaynberg.github.com/select2/#documentation:
         * "Calculate the width of the container div to the source element"
         */
        select2Options.width = this.def.enum_width ? this.def.enum_width : '100%';

        /* Because the select2 dropdown is appended to <body>, we need to be able
         * to pass a classname to the constructor to allow for custom styling
         */
        select2Options.dropdownCssClass = this.def.dropdown_class ? this.def.dropdown_class : '';

        /* To get the Select2 multi-select pills to have our styling, we need to be able
         * to either pass a classname to the constructor to allow for custom styling
         * or set the 'select2-choices-pills-close' if the isMultiSelect option is set in def
         */
        select2Options.containerCssClass = this.def.container_class ? this.def.container_class : (this.def.isMultiSelect ? 'select2-choices-pills-close' : '');

        /* Because the select2 dropdown is calculated at render to be as wide as container
         * to make it differ the dropdownCss.width must be set (i.e.,100%,auto)
         */
        if (this.def.dropdown_width) {
            select2Options.dropdownCss = { width: this.def.dropdown_width };
        }

        /* All select2 dropdowns should only show the search bar for fields with 7 or more values,
         * this adds the ability to specify that threshold in metadata.
         */
        select2Options.minimumResultsForSearch = this.def.searchBarThreshold ? this.def.searchBarThreshold : 7;

        /* If is multi-select, set multiple option on Select2 widget.
         */
        if (this.def.isMultiSelect) {
            select2Options.multiple = true;
        }

        /* If we need to define a custom value separator
         */
        select2Options.separator = this.def.separator || ',';
        if (this.def.separator) {
            select2Options.tokenSeparators = [this.def.separator];
        }

        select2Options.initSelection = _.bind(this._initSelection, this);
        select2Options.query = _.bind(this._query, this);
        select2Options.sortResults = _.bind(this._sortResults, this);

        return select2Options;
    },

    /**
     * Set the option selection during select2 initialization.
     * Also used during drag/drop in multiselects.
     * @param {Selector} $ele Select2 element selector
     * @param {Function} callback Select2 data callback
     * @private
     */
    _initSelection: function($ele, callback){
        var data = [];
        var options = _.isString(this.items) ? app.lang.getAppListStrings(this.items) : this.items;
        options = this.items = this._filterOptions(options);
        var values = $ele.val();
        if (this.def.isMultiSelect) {
            values = values.split(this.def.separator || ',');
        }
        _.each(_.pick(options, values), function(value, key){
            data.push({id: key, text: value});
        }, this);
        if(data.length === 1){
            callback(data[0]);
        } else {
            callback(data);
        }
    },

    /**
     * Returns dropdown list options which can be used for editing
     *
     * @param {Object} Dropdown list options
     * @return {Object}
     * @private
     */
    _filterOptions: function (options) {
        var currentValue,
            syncedVal,
            newOptions = {},
            filter = app.metadata.getEditableDropdownFilter(this.def.options);

        /**
         * Flag to indicate that the options have already been filtered and do
         * not need to be sorted.
         *
         * @type {boolean}
         */
        this.isFiltered = !_.isEmpty(filter);

        if (!this.isFiltered) {
            return options;
        }

        if (!_.contains(this.view.plugins, "Editable")) {
            return options;
        }
        //Force the current value(s) into the availible options
        syncedVal = this.model.getSynced();
        currentValue = _.isUndefined(syncedVal[this.name]) ? this.model.get(this.name) : syncedVal[this.name];
        if (_.isString(currentValue)) {
            currentValue = [currentValue];
        }

        var currentIndex = {};

        // add current values to the index in case if current model is saved to the server in order to prevent data loss
        if (!this.model.isNew()) {
            _.each(currentValue, function(value) {
                currentIndex[value] = true;
            });
        }

        //Now remove the disabled options
        if (!this._keysOrder) {
            this._keysOrder = {};
        }
        _.each(filter, function(val, index) {
            var key = val[0],
                visible = val[1];
            if ((visible || key in currentIndex) && !_.isUndefined(options[key]) && options[key] !== false) {
                this._keysOrder[key] = index;
                newOptions[key] = options[key];
            }
        }, this);

        return newOptions;
    },

    /**
     * Adapted from eachOptions helper in hbt-helpers.js
     * Select2 callback used for loading the Select2 widget option list
     * @param {Object} query Select2 query object
     * @private
     */
    _query: function(query){
        var options = _.isString(this.items) ? app.lang.getAppListStrings(this.items) : this.items;
        var data = {
            results: [],
            // only show one "page" of results
            more: false
        };
        if (_.isObject(options)) {
            _.each(options, function(element, index) {
                var text = "" + element;
                //additionally filter results based on query term
                if(query.matcher(query.term, text)){
                    data.results.push({id: index, text: text});
                }
            });
        } else {
            options = null;
        }
        query.callback(data);

        // Special hack for Firefox bug http://stackoverflow.com/questions/13040897/firefox-scrollbar-resets-incorrectly
        $(this.$(this.fieldTag).data('select2').results[0]).scrollTop(1).scrollTop(0);
    },

    /**
     * Sort the dropdown items.
     *
     * - If `def.sort_alpha` is `true`, return the dropdown items sorted
     * alphabetically.
     * - If {@link Core.Language#getAppListKeys} is defined for
     * `this.def.options`, return the items in this order.
     * - Otherwise, fall back to the default behavior and just return the
     * `results`.
     *
     * This method is the implementation of the select2 `sortResults` option.
     * See {@link http://ivaynberg.github.io/select2/ official documentation}.
     *
     * @param {Array} results The list of results `{id: *, text: *}.`
     * @param {jQuery} container jQuery wrapper of the node that should contain
     *  the representation of the result.
     * @param {Object} query The query object used to request this set of
     *  results.
     * @return {Array} The list of results {id: *, text: *} sorted.
     * @private
     */
    _sortResults: function(results, container, query) {
        var sortedResults;

        if (this.def.sort_alpha) {
            sortedResults = _.sortBy(results, function(item) {
                return item.text;
            });
            return sortedResults;
        }

        // Do not sort if options have already been filtered; or if the key ordering is empty,
        // we should not change the order as the options were generated by a function.
        if (this.isFiltered && _.isEmpty(this._keysOrder)) {
            return results;
        }

        this._setupKeysOrder();
        // If the key ordering is empty, we should not change the order as the options were generated by a function.
        if (_.isEmpty(this._keysOrder)) {
            return results;
        }

        return _.sortBy(results, function(item) {
            return this._keysOrder[item.id];
        }, this);
    },

    _setupKeysOrder: function() {
        var keys;
        var orderedKeys;
        var filteredOrderedKeys;
        var visibilityGrid;

        if (!_.isEmpty(this._keysOrder)) {
            return;
        }

        visibilityGrid = this.def.visibility_grid || {};

        var hasTrigger = visibilityGrid.values && visibilityGrid.trigger && this.model.has(visibilityGrid.trigger);

        // in case we have visibility grid, build keys according to its order
        if (hasTrigger) {
            var trigger = this.model.get(visibilityGrid.trigger);
            var _gridKeysOrder = visibilityGrid.values[trigger];

            if (_gridKeysOrder) {
                this._keysOrder = _.reduce(_gridKeysOrder, function(memo, value, index) {
                    memo[value] = index;
                    return memo;
                }, {});

                return;
            }
        } else {
            keys = _.keys(this.items);
            this._keysOrder = {};

            orderedKeys = _.map(app.lang.getAppListKeys(this.def.options), function(appListKey) {
                return appListKey.toString();
            });

            filteredOrderedKeys = _.intersection(orderedKeys, keys);

            if (!_.isEqual(filteredOrderedKeys, keys)) {
                _.each(filteredOrderedKeys, function(key, index) {
                    return this._keysOrder[key] = index;
                }, this);
            }
        }
    },

    /**
     * Helper function for retrieving the default value for the selection
     * @param {Array} optionsKeys Set of option keys that will be loaded into Select2 widget
     * @return {string} The default value
     */
    _getDefaultOption: function (optionsKeys) {
        //  Return the default if it's available in the definition.
        if (this.def && (!_.isEmptyValue(this.def.default)) ) {
            return this.def.default;
        } else {
            this._setupKeysOrder();
            var invertedKeysOrder = _.invert(this._keysOrder);
            //Check if we have a keys order, and that the sets of keys match
            if (!_.isEmpty(invertedKeysOrder) && _.isEmpty(_.difference(_.keys(this._keysOrder), optionsKeys))) {
                return _.first(invertedKeysOrder);
            }
            return _.first(optionsKeys);
        }
    },

    /**
     *  Convert select2 value into model appropriate value for sync
     *
     * @param value Value from select2 widget
     * @return {String|Array} Unformatted value as String or String Array
     */
    unformat: function(value) {
        if (this.def.isMultiSelect && _.isArray(value)) {
            var possibleKeys = _.keys(this.items);
            if (!this.def.ordered) {
                // if it's not ordered, i.e. sortable, force order
                value = _.intersection(possibleKeys, value);
            } else {
                // no need to force order, just keep valid keys
                value = _.intersection(value, possibleKeys);
            }
            return value;
        }

        if (this.def.isMultiSelect && _.isNull(value)) {
            return [];  // Returning value that is null equivalent to server.  Backbone.js won't sync attributes with null values.
        } else {
            return value;
        }
    },

    /**
     * Convert server value into one appropriate for display in widget
     *
     * @param value
     * @return {Array} Value for select2 widget as String Array
     */
    format: function(value){
        if (this.def.isMultiSelect && _.isArray(value) && _.indexOf(value, '') > -1) {
            value = _.clone(value);

            // Delete empty values from the select list
            delete value[''];
        }
        if(this.def.isMultiSelect && _.isString(value)){
            return this.convertMultiSelectDefaultString(value);
        } else {
            return value;
        }
    },

    /**
     * Converts multiselect default strings into array of option keys for template
     * @param {String} defaultString string of the format "^option1^,^option2^,^option3^"
     * @return {Array} of the format ["option1","option2","option3"]
     */
    convertMultiSelectDefaultString: function(defaultString) {
        var result = defaultString.split(",");
        _.each(result, function(value, key) {
            // Remove empty values in the selection
            if (value !== '^^') {
                result[key] = value.replace(/\^/g,"");
            }
        });
        return result;
    },

    /**
     * @inheritdoc
     * Avoid rendering process on select2 change in order to keep focus.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function() {
                if (_.isEmpty(this.$(this.fieldTag).data('select2'))) {
                    this.render();
                } else {
                    this.$(this.fieldTag).select2('val', this.format(this.model.get(this.name)));
                }
            }, this);
        }
    },

    /**
     * Override to remove default DOM change listener, we use Select2 events instead
     * Binds append value checkbox change for massupdate.
     *
     * @override
     */
    bindDomChange: function() {
        var $el = this.$(this.appendValueTag);
        if ($el.length) {
            $el.on('change', _.bind(function() {
                this.appendValue = $el.prop('checked');
                //FIXME: Should use true booleans (SC-2828)
                this.model.set(this.name + '_replace', this.appendValue ? '1' : '0');
            }, this));
        }
    },

    /**
     * @override
     */
    unbindDom: function() {
        this.$(this.appendValueTag).off();
        this.$(this.fieldTag).select2('destroy');
        this._super('unbindDom');
    },

    /**
     * @override
     */
    unbindData: function() {
        var _key = 'request:' + this.module + ':' + this.name;
        this.context.unset(_key);
        app.view.Field.prototype.unbindData.call(this);
    },

    /**
     * Need to check not only if there is no value, but if there is a value and
     * it is an empty array.
     *
     * @override
     */
    _isErasedField: function() {
        if (!this.model) {
            return false;
        }

        var value = this.model.get(this.name);

        return (!value || _.isArray(value) && _.isEmpty(value)) &&
            _.contains(this.model.get('_erased_fields'), this.name);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.unbindKeyDown();
        var $el = this.$(this.fieldTag);
        var plugin = $el.data('select2');
        if (plugin) {
            plugin.close();
        }
        this._super('_dispose');
    }
}) },
"text": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TextField
 * @alias SUGAR.App.view.fields.BaseTextField
 * @extends View.Fields.Base.BaseField
 */
({
	// Text Field (base) 

    /**
     * @inheritdoc
     *
     * Format the value to a string.
     * Return an empty string for undefined, null and object types.
     * Convert boolean to 1 or 0.
     * Convert array, int and other types to a string.
     *
     * @param {mixed} value to format
     * @return {string} the formatted value
     */
    format: function(value) {
        if (_.isString(value)) {
            return value;
        }

        if (_.isUndefined(value) || 
            _.isNull(value) ||
            (_.isObject(value) && !_.isArray(value))
        ) {
            return '';
        }

        if (_.isBoolean(value)) {
            return value === true ? '1' : '0';
        }

        return value.toString();
    },

    /**
     * @inheritdoc
     *
     * Trim whitespace from value.
     */
    unformat: function(value) {
        return value.trim();
    }
}) },
"sidebartoggle": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Sidebar toggle field that is used in the RHS layout toggle (show/hide).
 *
 * Some events have been deprecated in 7.2 and removed.
 * List of changes:
 *
 * - `sidebarRendered` has been removed. Now, when the field renders it calls
 *    {@link Layout.Default#isSidePaneVisible} directly to get the current
 *    state.
 *
 * - `toggleSidebar` has been removed. Triggers `sidebar:toggle` instead.
 *
 * - `toggleSidebarArrows` has been removed. Listens to `sidebar:state:changed`
 *    instead.
 *
 * - `openSidebarArrows` has been removed. Listens to `sidebar:state:changed`
 *    instead.
 *
 * - The app event `app:toggle:sidebar` has been removed. Listen to
 *   `sidebar:state:changed` instead.
 *
 * @class View.Fields.Base.SidebartoggleField
 * @alias SUGAR.App.view.fields.BaseSidebartoggleField
 * @extends View.Fields.Base.BaseField
 */
({
	// Sidebartoggle Field (base) 

    events: {
        'click': 'toggle'
    },

    /**
     * Store the current `open` or `close` state
     *
     * @type {String}
     */
    _state: 'open',

    /**
    * @inheritdoc
    */
    _render: function() {

        /**
        * Sets the appropriate aria-label value depending on current _state property
        *
        * @property {string}
        */
        this.ariaLabel = this._state === 'open' ?
            app.lang.get('LBL_DASHLET_MINIMIZE', this.module) :
            app.lang.get('LBL_DASHLET_MAXIMIZE', this.module);
        this.ariaLabel += ' ' + app.lang.get('LBL_DASHBOARD', this.module);

        /**
        * Sets the appropriate font awesome icon class name depending on current _state property
        *
        * @property {string}
        */
        this.iconClass = 'fa-angle-double-' + (this._state === 'open' ? 'right' : 'left');

        /**
        * Stores tooltips placement value according to the direction of
        * language being used.
        *
        * @property {string}
        */
        this.dataPlacement = app.lang.direction === 'rtl' ? 'right' : 'left';

        this._super('_render');

        return this;
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout && _.isFunction(defaultLayout.isSidePaneVisible)) {
            this.toggleState(defaultLayout.isSidePaneVisible() ? 'open' : 'close');
            this.listenTo(defaultLayout, 'sidebar:state:changed', this.toggleState);
        }

        //shortcut keys
        app.shortcuts.register({
            id: 'Sidebar:Toggle',
            keys: 't',
            component: this,
            description: 'LBL_SHORTCUT_SIDEBAR_TOGGLE',
            handler: this.toggle
        });
    },

    /**
     * Toggle the `open` or `close` class of the icon.
     *
     * @param {String} [state] The state. Possible values: `open` or `close`.
     */
    toggleState: function(state) {
        if (state !== 'open' && state !== 'close') {
            state = (this._state === 'open') ? 'close' : 'open';
        }
        this._state = state;
        if (!this.disposed) {
            this.render();
        }
    },

    /**
     * Toggle the sidebar.
     *
     * @param {Event} event The `click` event.
     */
    toggle: function(event) {
        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            defaultLayout.trigger('sidebar:toggle');
        }
    }
}) },
"parent": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ParentField
 * @alias SUGAR.App.view.fields.BaseParentField
 * @extends View.Fields.Base.RelateField
 */
({
	// Parent Field (base) 

    extendsFrom: 'RelateField',
    fieldTag: 'input.select2[name=parent_name]',
    typeFieldTag: 'select.select2[name=parent_type]',
    plugins: ['FieldDuplicate'],

    /**
     * @inheritDoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //FIXME: BR-4575 will remove this.
        this.fieldDefs = _.extend(this.fieldDefs || {}, {link: 'parent'});

        /**
         * A hash of available modules in the parent type dropdown matching
         * the modules names with their label.
         *
         * @property {Object}
         * @private
         */
        this._modules = app.lang.getAppListStrings(this.def.options);

        /**
         * The hash of available modules in the parent type dropdown, filtered
         * according to list acls.
         *
         * @property {Object}
         */
        this.moduleList = {};

        this._filterModuleList(this._modules);
    },

    _isErasedField: function() {
        if (this.model && this.model.has('parent')) {
            var link = this.model.get('parent');
            if (_.isEmpty(link._erased_fields)) {
                return false;
            }
            var parentType = link.parent_type || this.model.get('parent_type');
            if (parentType) {
                return app.utils.isNameErased(app.data.createBean(parentType, link));
            }
        }

        return false;
    },

    /**
     * Calls {@link View.Fields.Base.RelateField#_render} and renders the select2
     * module dropdown.
     *
     * @inheritDoc
     */
    _render: function() {
        var self = this;
        var moduleName = this.getSearchModule();
        var module = _.pick(this._modules, moduleName);
        if (module && !app.acl.hasAccess('list', moduleName)) {
            this.noAccessModule = {key: moduleName, value: module[moduleName]};
        }

        this._super("_render");

        /**
         * Only allow modification of the select2 functionality under the specified templates
         */
        var allowedTpls = ['edit', 'massupdate'];
        if (_.contains(allowedTpls, this.tplName)) {
            var inList = (this.view.name === 'recordlist') ? true : false;

            this.$(this.typeFieldTag).select2({
                dropdownCssClass: inList?'select2-narrow':'',
                containerCssClass: inList?'select2-narrow':'',
                width: inList?'off':'100%',
                minimumResultsForSearch: 5
            }).on('change', function(e) {
                var module = e.val;
                if (self.noAccessModule && module !== self.noAccessModule) {
                    delete self.noAccessModule;
                }
                self.setValue({
                    id: '',
                    value: '',
                    module: module
                });
                self.$(self.fieldTag).select2('val', '');
            }).on('select2-focus', _.bind(_.debounce(this.handleFocus, 0), this));

            var domParentTypeVal = this.$(this.typeFieldTag).val();
            if(this.model.get(this.def.type_name) !== domParentTypeVal) {
                this.model.setDefault(this.def.type_name, domParentTypeVal);
                this._createSearchCollection();
            }

            if(app.acl.hasAccessToModel('edit', this.model, this.name) === false) {
                this.$(this.typeFieldTag).select2("disable");
            } else {
                this.$(this.typeFieldTag).select2("enable");
            }
        } else if(this.tplName === 'disabled'){
            this.$(this.typeFieldTag).select2('disable');
        }
        return this;
    },
    _getRelateId: function() {
         return this.model.get("parent_id");
     },
    format: function(value) {
        var module;
        this.def.module = this.getSearchModule();

        if (this.def.module) {
            module = app.lang.getModuleName(this.def.module);
        }

        this.context.set('record_label', {
            field: this.name,
            label: (this.tplName === 'detail') ? module : app.lang.get(this.def.label, this.module)
        });

        var parentCtx = this.context && this.context.parent,
            setFromCtx;

        if (value) {
            this._valueSetOnce = true;
        }

        setFromCtx = !value && !this._valueSetOnce && parentCtx && _.isEmpty(this.context.get('model').link) &&
            this.view instanceof app.view.views.BaseCreateView &&
            _.contains(_.keys(app.lang.getAppListStrings(this.def.parent_type)), parentCtx.get('module')) &&
            this.module !== this.def.module;

        if (setFromCtx) {
            this._valueSetOnce = true;
            var model = parentCtx.get('model');
            // FIXME we need a method to prevent us from doing this
            // FIXME the setValue receives a model but not a backbone model...
            var attributes = model.toJSON();
            attributes.silent = true;
            this.setValue(attributes);
            value = this.model.get(this.name);

            // FIXME we need to iterate over the populated_ that isn't working now
        }

        return this._super('format', [value]);

    },

    /**
     * Filters the module list according to list acls.
     *
     * @param {Object} A hash of module names matching with their label.
     * @private
     */
    _filterModuleList: function(modules) {
        var filteredModules = _.filter(_.keys(modules), function(module) {
            return app.acl.hasAccess('list', module);
        });
        this.moduleList = _.pick(modules, filteredModules);
    },

    /**
     * @override
     */
    setValue: function(models) {
        if (!models) {
            return;
        }
        models = _.isArray(models) ? models : [models];
        _.each(models, _.bind(function(model) {

            var silent = model.silent || false,
            // FIXME we shouldn't make this assumption and this method should
            // receive a true Backbone.Model or Data.Bean
                module = model.module || model._module;


            if (app.acl.hasAccessToModel(this.action, this.model, this.name)) {
                if (module) {
                    this.model.set('parent_type', module, {silent: silent});
                    this._createSearchCollection();
                }
                // only set when we have an id on the model, as setting undefined
                // is causing issues with the warnUnsavedChanges() method
                if (!_.isUndefined(model.id)) {
                    // FIXME we shouldn't rely on model.value... and hack the full_name here until we fix it properly
                    // SC-4196 will fix this.
                    var value = model.value || model[this.def.rname || 'name'] || model['full_name'] ||
                        app.utils.formatNameLocale(model);
                    var forceUpdate = _.isEmpty(this.model.get(this.def.name)) && _.isEmpty(value);
                    this.model.set(
                        {
                            'parent_id': model.id,
                            'parent_name': value,
                            'parent': model
                        },
                        {silent: silent}
                    );
                    if (forceUpdate) {
                        this._updateField();
                    }
                }
            }
        }, this));


        // TODO we should support the auto populate of other fields like we do on normal relate.js
    },
    /**
     * Is this module available as an option to be set as parent type?
     * @param module {string}
     * @return {boolean}
     */
    isAvailableParentType: function(module) {
        var moduleFound = _.find(this.$(this.typeFieldTag).find('option'), function(dom) {
            return $(dom).val() === module;
        });
        return !!moduleFound;
    },
    getSearchModule: function() {
        return this.model.get('parent_type') || this.$(this.typeFieldTag).val();
    },
    getPlaceHolder: function() {
        return  app.lang.get('LBL_SEARCH_SELECT', this.module);
    },
    unbindDom: function() {
        this.$(this.typeFieldTag).select2('destroy');
        this._super("unbindDom");
    },

    /**
     * @inheritdoc
     * Avoid rendering process on select2 change in order to keep focus.
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        if (this.model) {
            this.model.on('change:parent_type', function() {
                var plugin = this.$(this.typeFieldTag).data('select2');
                if (_.isEmpty(plugin) || !plugin.searchmore) {
                    this.render();
                } else {
                    this.$(this.typeFieldTag).select2('val', this.model.get('parent_type'));
                }
            }, this);
        }
    },

    /**
     * Handler to refresh search collection when merging duplicates.
     *
     * Called from {@link app.plugins.FieldDuplicate#_onFieldDuplicate}
     */
    onFieldDuplicate: function() {
        if (_.isEmpty(this.searchCollection) ||
            this.searchCollection.module !== this.getSearchModule()
        ) {
            this._createSearchCollection();
        }
    },

    /**
     * We do not support this field for preview edit
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if (this.view.name === 'preview' && this.action !== 'erased') {
            this.template = app.template.getField('parent', 'detail', this.model.module);
        }
    }
}) },
"link-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * "Link" button used in selection list for linking existing records.
 *
 * @class View.Fields.Base.LinkButtonField
 * @alias SUGAR.App.view.fields.BaseLinkButtonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Link-button Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.massCollection = this.context.get('mass_collection');
        if (!this.massCollection) {
            return;
        }

        this.listenTo(this.massCollection, 'add remove', function() {
            this.setDisabled(this.massCollection.length === 0);
        });

        if (this.massCollection.length === 0) {
            this.setDisabled(true);
        }
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this.type = 'rowaction';
        this._super('_loadTemplate');
        this.type = 'link-button';
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.stopListening(this.massCollection);
        this._super('unbind');
    }
}) },
"quickcreate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.QuickcreateField
 * @alias SUGAR.App.view.fields.BaseQuickcreateField
 * @extends View.Fields.Base.BaseField
 */
({
	// Quickcreate Field (base) 

    events: {
        'click .actionLink[data-event="true"]' : '_handleActionLink'
    },

    plugins: ['LinkedModel'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        //Listen to create view model changes to keep track of unsaved changes
        app.events.on('create:model:changed', this.createModelChanged, this);
        this.on('linked-model:create', this._prepareCtxForReload, this);
    },

    /**
     * Changes properties on the context so that its collection can be
     * re-fetched.
     *
     * FIXME: This will be removed when SC-4775 is implemented.
     *
     * @private
     */
    _prepareCtxForReload: function() {
        this.context.resetLoadFlag();
        this.context.set('skipFetch', false);
    },

    /**
     * Keeps track of if the create view's model has changed.
     * @param hasChanged
     */
    createHasChanges: false,
    createModelChanged: function(hasChanged) {
        this.createHasChanges = hasChanged;
    },
    /**
     * When menu item is clicked, warn if open drawers, reset drawers and open create
     * @param evt
     * @private
     */
    _handleActionLink: function(evt) {
        var $actionLink = $(evt.currentTarget),
            module = $actionLink.data('module'),
            moduleMeta = app.metadata.getModule(this.context.get('module'));
        this.actionLayout = $actionLink.data('layout');
        if (this.createHasChanges) {
            app.alert.show('send_confirmation', {
                level: 'confirmation',
                messages: 'LBL_WARN_UNSAVED_CHANGES',
                onConfirm: _.bind(function() {
                    app.drawer.reset(false);
                    this.createRelatedRecord(module);
                }, this)
            });
        } else {
            // TODO: SP-1568 - We don't yet deal with bwc model changed attributes so
            // this will navigate to new create page WITHOUT alert for unsaved changes
            this.createRelatedRecord(module);
        }
    },
    /**
     * Route to Create Related record UI for a BWC module.
     *
     * @param {String} module Module name.
     */
    routeToBwcCreate: function(module) {
        var context = this.getRelatedContext(module);
        if (context) {
            app.bwc.createRelatedRecord(module, this.context.get('model'), context.link);
        } else {
            var route = app.bwc.buildRoute(module, null, 'EditView');
            app.router.navigate(route, {trigger: true});
        }
    },

    /**
     * Returns context link and module name
     * if possible to create a record with context.
     *
     * @param {String} module Module name.
     * @return {Array|undefined}
     */
    getRelatedContext: function(module) {
        var meta = app.metadata.getModule(module),
            context;

        if (meta && meta.menu.quickcreate.meta.related) {
            var parentModel = this.context.get('model');

            if (parentModel.isNew()) {
                return;
            }

            context = _.find(
                meta.menu.quickcreate.meta.related,
                function(metadata) {
                    return metadata.module === parentModel.module;
                }
            );
        }

        return context;
    },

    /**
     * Open the appropriate quick create layout in a drawer
     *
     * @param {String} module Module name.
     */
    openCreateDrawer: function(module) {
        var relatedContext = this.getRelatedContext(module),
            model = null;

        if (relatedContext) {
            model = this.createLinkModel(this.context.get('model'), relatedContext.link);
        }
        app.drawer.open({
            layout: this.actionLayout || 'create',
            context: {
                create: true,
                module: module,
                model: model
            }
        }, _.bind(function (refresh, model) {
            if (refresh) {
                // When user quick creates a model he has no access, it loads the 404 page so we need to redirect him to
                // his previous page manually
                if (model && !model.id) {
                    app.router.refresh();
                    return;
                }
                if (model && relatedContext) {
                    // Refresh the subpanel.
                    this.context.trigger('panel-top:refresh', relatedContext.link);
                    return;
                }
                //Check main context to see if it needs to be updated
                this._loadContext(app.controller.context, module);
                //Also check child contexts for updates
                if (app.controller.context.children) {
                    _.each(app.controller.context.children, function(context){
                        this._loadContext(context, module);
                    }, this);
                }
            }
        }, this));
    },
    /**
     * Conditionally load context if it is for given module
     * @param context Context to load
     * @param module Module name to check
     * @private
     */
    _loadContext: function(context, module){
        var collection = context.get('collection');
        if (collection && collection.module === module) {
            var options = {
                //Don't show alerts for this request, background update
                showAlerts: false
            };
            context.resetLoadFlag({recursive: false});
            context.set('skipFetch', false);
            context.loadData(options);
        }
    }
}) },
"radioenum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RadioenumField
 * @alias SUGAR.App.view.fields.BaseRadioenumField
 * @extends View.Fields.Base.EnumField
 */
({
	// Radioenum Field (base) 

    // On list-edit template,
    // we want the radio buttons to be replaced by a select so each method must call the EnumField method instead.
    extendsFrom: 'EnumField',
    plugins: ["ListEditable"],
    fieldTag: "input",

    _render: function(){
        this.loadEnumOptions(false, function() {
                if (!this.disposed) {
                    this.render();
                }
            }
        );
        app.view.Field.prototype._render.call(this);
        if(this.tplName === 'list-edit') {
            this._super("_render");
        }
    },
    bindDomChange: function() {
        if (this.tplName === 'list-edit') {
            this._super("bindDomChange");
        } else {
            if (!(this.model instanceof Backbone.Model)) return;
            var self = this;
            var el = this.$el.find(this.fieldTag);
            el.on("change", function() {
                self.model.set(self.name, self.unformat(self.$(self.fieldTag+":radio:checked").val()));
            });
        }
    },
    format: function(value) {
        if (this.tplName === 'list-edit') {
            return this._super("format", [value]);
        } else {
            return app.view.Field.prototype.format.call(this, value);
        }
    },
    unformat: function(value) {
        if (this.tplName === 'list-edit') {
            return this._super("unformat", [value]);
        } else {
            return app.view.Field.prototype.unformat.call(this, value);
        }
    },
    decorateError: function(errors) {
        if (this.tplName === 'list-edit') {
            return this._super("decorateError", [errors]);
        } else {

            var errorMessages = [],
                $tooltip;

            // Add error styling
            this.$el.closest('.record-cell').addClass('error');
            this.$el.addClass('error');
            // For each error add to error help block
            _.each(errors, function(errorContext, errorName) {
                errorMessages.push(app.error.getErrorString(errorName, errorContext));
            });
            this.$(this.fieldTag).last().closest('p').append(this.exclamationMarkTemplate(errorMessages));
            $tooltip = this.$('.error-tooltip');
            if (_.isFunction($tooltip.tooltip)) {
                var tooltipOpts = { container: 'body', placement: 'top', trigger: 'click' };
                $tooltip.tooltip(tooltipOpts);
            }
        }
    },
    clearErrorDecoration: function() {
        if (this.tplName === 'list-edit') {
            return this._super("clearErrorDecoration");
        } else {
            var ftag = this.fieldTag || '';
            // Remove previous exclamation then add back.
            this.$('.add-on').remove();
            this.$el.removeClass(ftag);
            this.$el.removeClass("error");
            this.$el.closest('.record-cell').removeClass("error");
        }
    }
}) },
"copy": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.CopyField
 * @alias SUGAR.App.view.fields.BaseCopyField
 * @extends View.Fields.Base.BaseField
 */
({
	// Copy Field (base) 

    'events': {
        'click button': 'copyOnce'
    },

    _initialValues: null,
    _fields: null,
    _inSync: false,

    /**
     * Initializes the copy field component.
     *
     * Initializes the initialValues and fields properties.
     * Enables sync by default.
     *
     * @inheritdoc
     */
    initialize: function(options) {

        this._super('initialize', [options]);
        this._initialValues = {};
        this._fields = {};

        if (_.isUndefined(this.def.sync)) {
            this.def.sync = true;
        }

        this.before('render', function() {
            this.setDisabled(!this.hasAccess());
            return true;
        }, this);
    },

    /**
     * Function called for each click on checkbox (normally acts as toggle
     * function).
     *
     * If the checkbox is checked, copy all the source fields to target ones
     * based on the mapping definition of this field and disable target fields.
     * Otherwise, restore all the values of the modified fields by this copy
     * widget and enable target fields.
     *
     */
    toggle: function() {
        this.sync(this.$fieldTag.is(':checked'));
    },

    sync: function(enable) {

        enable = this.hasAccess() && (_.isUndefined(enable) || enable);

        if (this._inSync === enable) {
            return;
        }
        this._inSync = enable;

        if (!enable) {
            this.syncCopy(false);
            this.restore();
            return;
        }

        _.each(this.def.mapping, function(target, source) {
            this.copy(source, target);
            var field = this.getField(target);
            if (!_.isUndefined(field)) {
                field.setDisabled(true);
            }
        }, this);

        this.syncCopy(true);
    },

    /**
     * Function called for each click on button (normally acts as copy once).
     *
     * If the button is pressed, copy all the source fields to target ones
     * based on the mapping definition of this field.
     *
     * @param {Event} evt
     *   The event (expecting a click event) that triggers the copy once.
     */
    copyOnce: function(evt) {

        _.each(this.def.mapping, function(target, source) {
            this.copy(source, target);
        }, this);
    },

    /**
     * Copies the source field value to the target field.
     *
     * Store the initial value of the target field to be able to restore it
     * after. Copy the source field value to the target field.
     *
     * @param {View.Field} from
     *   The source field to get the value from.
     * @param {View.Field} to
     *   The target field to set the value to.
     */
    copy: function(from, to) {

        if (!this.model.has(from)) {
            return;
        }

        if (_.isUndefined(this._initialValues[to])) {
            this._initialValues[to] = this.model.get(to);
        }

        if (app.acl.hasAccessToModel('edit', this.model, to)) {
            this.model.set(to, this.model.get(from));
        }
    },

    /**
     * Restores all the initial value of the fields that were modified by this
     * copy command.
     */
    restore: function() {

        _.each(this._initialValues, function(value, field) {
            this.model.set(field, value);
        }, this);

        _.each(this.def.mapping, function(target, source) {
            var field = this.getField(target);
            if (!_.isUndefined(field)) {
                field.setDisabled(false);
            }
        }, this);

        this._initialValues = {};
    },

    /**
     * Enables or disables the sync copy only if the field has the `sync`
     * definition to set to TRUE.
     *
     * @param {Boolean} enable
     *   TRUE to keep the mapping fields in sync, FALSE otherwise.
     */
    syncCopy: function(enable) {

        if (!this.def.sync) {
            return;
        }

        if (!enable) {
            this.model.off(null, this.copyChanged, this);
            return;
        }

        var events = _.map(_.keys(this.def.mapping), function(field) {
            return 'change:' + field;
        });
        this.model.on(events.join(' '), this.copyChanged, this);
    },

    /**
     * Callback for the syncCopy binding.
     *
     * @param {Backbone.Model} model
     *   The model that was changed.
     * @param {*} value
     *   The value of the field that was changed.
     */
    copyChanged: function(model, value) {
        _.each(model.changedAttributes(), function(newValue, field) {
            model.set(this.def.mapping[field], model.get(field));
        }, this);
    },

    /**
     * Get the field with the supplied name.
     *
     * Cache the fields locally to be faster on next request of the same field.
     *
     * @param {String} name
     *   The name of the field to search for.
     *
     * @return {View.Field}
     *   The field with the name given.
     */
    getField: function(name) {

        if (_.isUndefined(this._fields[name])) {
            this._fields[name] = _.find(this.view.fields, function(field) {
                return field.name == name;
            });
        }

        return this._fields[name];
    },

    unformat: function(value) {
        // TODO this should change once we save this in the db
        return null;
    },

    /**
     * @inheritdoc
     *
     * @return {Boolean}
     */
    format: function(value) {
        if (_.isNull(value)) {
            // TODO this should change to the value once we get it from the model
            return this._inSync;
        }
        return value;
    },
    /**
     * Binds DOM changes to a model.
     */
    bindDomChange: function() {

        if (!(this.model instanceof Backbone.Model)) return;

        var self = this;
        var el = this.$fieldTag = this.$el.find(this.fieldTag);
        el.on("change", function() {
          self.toggle();
        });
    },
    /**
     * @inheritdoc
     *
     * This will make the fields in sync if it is on by default.
     */
    bindDataChange: function() {

        // TODO this field should be saved on the DB so we don't have this hack
        if (this.model && this.def.sync) {

            var active = !_.isUndefined(this.def['default']) ? this.def['default'] : true;
            if (!active && this.model.isNew()) {
                return;
            }

            var inSync = this.model.isNew() || _.all(this.def.mapping, function(target, source) {
                return this.model.has(source) && this.model.get(source) === this.model.get(target);
            }, this);
            this.sync(inSync);
        }
    },

    /**
     * Determine if ACLs allow for the copy to show
     * ACL check should return true if there is access to read target and edit
     * source for at least to one mapped field
     * @return {Boolean}
     */
    hasAccess: function() {
        return _.some(this.def.mapping || [], function(toField, fromField) {
            return app.acl.hasAccessToModel('read', this.model, fromField) &&
                app.acl.hasAccessToModel('edit', this.model, toField);
        }, this);
    }
}) },
"actionmenu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Actionmenu is an {@link View.Fields.Base.ActiondropdownField actiondropdown}
 * with a checkbox as the default action.
 *
 * Supported Properties:
 *
 * - {Boolean} disable_select_all_alert Boolean telling if we should show the
 *   'select all' and 'clear all' alerts when all checkboxes are checked.
 *   `true` to hide alerts. `false` to display them. Defaults to `false`.
 *
 * @class View.Fields.Base.ActionmenuField
 * @alias SUGAR.App.view.fields.BaseActionmenuField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Actionmenu Field (base) 

    extendsFrom: 'ActiondropdownField',

    /** Initializes the actionmenu field.
     *
     * Sets the property no_default_action to `true` because the checkbox will
     * always be the default action and it's handled separately.
     * See {@link View.Fields.Base.ActiondropdownField} for properties
     * documentation.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.events = _.extend({}, this.events, {
            'click [data-check=all]': 'checkAll',
            'click [data-check=one]': 'check'
        });

        this.def.no_default_action = true;
        this.def.css_class = this.def.css_class + ' actionmenu';
        /**
         * The checkbox tag.
         *
         * @property {string}
         */
        this.fieldTag = 'input[type=checkbox]';

        /**
         * The mass collection the actionmenu field is related to.
         *
         * @property {Data.BeanCollection} massCollection
         */
        this.massCollection = this.context.get('mass_collection');

        this.def.disable_select_all_alert = !!this.def.disable_select_all_alert;

        if (this.options.viewName === 'list-header') {
            this.isCheckAllCheckbox = true;
        }

        if (this.isCheckAllCheckbox) {
            app.shortcuts.register({
                id: 'SelectAll:Checkbox',
                keys: 'mod+a',
                component: this,
                description: 'LBL_SHORTCUT_SELECT_ALL',
                handler: function() {
                    if (!this.isDisabled()) {
                        this.$('[data-check=all]:visible').click();
                    }
                }
            });
            app.shortcuts.register({
                id: 'SelectAll:Dropdown',
                keys: 'm',
                component: this,
                description: 'LBL_SHORTCUT_OPEN_MASS_ACTION',
                handler: function() {
                    var $dropdown = this.$(this.actionDropDownTag);
                    if ($dropdown.is(':visible') && !$dropdown.hasClass('disabled')) {
                        $dropdown.click();
                    }
                }
            });
        }
    },

    /**
     * Calls {@link #toggleSelect} to help pass the information to the context.
     */
    check: function() {
        var $checkbox = this.$(this.fieldTag);
        var isChecked = $checkbox.is(':checked');
        this.toggleSelect(isChecked);
    },

    /**
     * Sends an event to the context to add or remove the model from the mass
     * collection.
     *
     * @param {boolean} checked `true` to pass the model to the mass collection,
     *   `false` to remove it.
     */
    toggleSelect: function(checked) {
        var event = !!checked ? 'mass_collection:add' : 'mass_collection:remove';
        this.context.trigger(event, this.model);
    },

    /**
     * Selects or unselects all records that are in the current collection.
     *
     * @param {Event} The `click` or `keydown` event.
     */
    checkAll: function(event) {
        var $checkbox = this.$(this.fieldTag);
        if ($(event.target).hasClass('checkall') || event.type === 'keydown') {
            $checkbox.prop('checked', !$checkbox.is(':checked'));
        }
        var isChecked = $checkbox.is(':checked');
        this.toggleAll(isChecked);
    },

    /**
     * Sends an event to the context to add or remove all models from the mass
     * collection.
     *
     * @param {boolean} checked `true` to pass all models in the collection to
     *   the mass collection, `false` to remove them.
     *
     *
     * FIXME : Doing this way is slow to check all checkboxes when there
     * are more than 20. We should check checkboxes before adding records to
     * the mass collection SC-4079 will address this problem.
     */
    toggleAll: function(checked) {
        var event = checked ? 'mass_collection:add:all' : 'mass_collection:remove:all';
        this.context.trigger(event, this.model);
    },

    /**
     * Binds mass collection events to a record row checkbox.
     *
     * @private
     */
    _bindModelChangeEvents: function() {
        this.massCollection.on('add', function(model) {
            if (this.model && model.id === this.model.id) {
                this.$(this.fieldTag).prop('checked', true);
            }
        }, this);

        this.massCollection.on('remove', function(model) {
            if (this.model && model.id === this.model.id) {
                this.$(this.fieldTag).prop('checked', false);
            }
        }, this);

        this.massCollection.on('reset', function() {
            this.$(this.fieldTag).prop('checked', !!this.massCollection.get(this.model.id));
        }, this);
    },

    /**
     * Binds mass collection events to 'select-all' checkbox, the one used to check/
     * uncheck all record row checkboxes.
     *
     * @private
     */
    _bindAllModelChangeEvents: function() {
        // Checks/selects the actionmenu checkbox if the checkboxes of each
        // row are all checked.
        this.massCollection.on('all:checked', function() {
            if (this.collection.length !== 0) {
                this.$(this.fieldTag).prop('checked', true);
            }
        }, this);

        // Unchecks/deselects the actionmenu checkbox if the checkboxes of
        // each row are NOT all checked.
        this.massCollection.on('not:all:checked', function() {
            this.$(this.fieldTag).prop('checked', false);
        }, this);

        this.massCollection.on('add', this._onMassCollectionAddAll, this);
        this.massCollection.on('remove reset', this._onMassCollectionRemoveResetAll, this);
    },

    /**
     * Handler for the {@link Bean.Collection massCollection} `add` event.
     *
     * @private
     */
    _onMassCollectionAddAll: function() {
        this.setDropdownDisabled(false);
        if (!this.def.disable_select_all_alert) {
            this.context.trigger('toggleSelectAllAlert');
            this.setButtonsDisabled(this.dropdownFields);
        }
    },

    /**
     * Handler for the {@link Bean.Collection massCollection} `remove` and
     * `reset` events.
     *
     * @private
     */
    _onMassCollectionRemoveResetAll: function() {
        var massCollectionIds = _.pluck(this.massCollection.models, 'id');
        var viewCollectionIds = _.pluck(this.collection.models, 'id');
        if (this.massCollection.length === 0) {
            this.setDropdownDisabled(true);
            //massCollection.models could only have 'id' as an attribute,
            //so we need to compare ids instead of models directly.
        } else if (_.intersection(massCollectionIds, viewCollectionIds).length !== 0) {
            this.setDropdownDisabled(false);
            this.$(this.fieldTag).prop('checked', true);
        }
        if (!this.def.disable_select_all_alert) {
            this.context.trigger('toggleSelectAllAlert');
            this.setButtonsDisabled(this.dropdownFields);
        }
    },

    /**
     * @override
     *
     * Binds events on the collection, and updates the checkboxes
     * consequently.
     */
    bindDataChange: function() {
        if (this.isCheckAllCheckbox) {
            // Listeners on the checkAll/uncheckAll checkbox.
            this._bindAllModelChangeEvents();
            this.action_enabled = this.massCollection.length > 0;
            this.tabIndex = this.action_enabled ? 0 : -1;
        } else {
            // Listeners for each record selection.
            this._bindModelChangeEvents();
        }

        this.massCollection.on('massupdate:estimate', this.onTotalEstimate, this);
    },

    /**
     * Toggles the actionmenu buttons according to the buttons definition and
     * the number of selected records.
     *
     * @param {Object} fields List of the view's fields.
     * @param {number} massCollectionLength The number of selected records.
     */
    setButtonsDisabled: function(fields) {
        _.each(fields, function(field) {
            if (field.def.minSelection || field.def.maxSelection) {
                var min = field.def.minSelection || 0,
                    max = field.def.maxSelection || this.massCollection.length;
                if (this.massCollection.length < min || this.massCollection.length > max) {
                    field.setDisabled(true);
                } else {
                    field.setDisabled(false);
                }
            }
        }, this);
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');
        if (this.view.action === 'list' && this.action === 'edit') {
            this.template = app.template.empty;
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (!this.isCheckAllCheckbox) {
            // If the model is in the mass collection, make sure the checkbox
            // is checked.
            if (this.massCollection.get(this.model.id)) {
                this.selected = true;
            } else {
                delete this.selected;
            }
        }

        this._super('_render');

        if (this.isCheckAllCheckbox && !this.def.disable_select_all_alert) {
            this.setButtonsDisabled(this.dropdownFields);
            this.setDropdownDisabled(this.massCollection.length === 0);
        }
    },

    /**
     * Since we don't have a default action button we don't need
     * to render anything here. See {@link View.Fields.Base.ActiondropdownField#_renderFields}.
     *
     * @override
     * @protected
     */
    _renderFields: $.noop,

    /**
     * Update the dropdown usability while the total count is estimating.
     */
    onTotalEstimate: function() {
        this.setDropdownDisabled(!this.massCollection.fetched);
    },

    /**
     * Disable the dropdown action.
     *
     * @param {Boolean} [disable] `true` to disable the dropdown action, `false`
     * to enable it.
     */
    setDropdownDisabled: function(disable) {
        this.$(this.actionDropDownTag)
            .toggleClass('disabled', disable)
            .attr('aria-haspopup', !disable)
            .attr('tabindex', disable ? -1 : 0);
    },

    /**
     * @inheritdoc
     */
    _getChildFieldsMeta: function() {
        // We only get the fields (the dropdown actions) metadata for the
        // checkAll/uncheckAll checkbox. Actionmenu fields tied to a model are
        // a simple checkbox and don't have metadata.
        if (this.model.id) {
            return;
        }
        return this._super('_getChildFieldsMeta');
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        if (this.massCollection) {
            var modelId = this.model.cid,
                cid = this.view.cid;
            this.massCollection.off(null, null, this);
            if (modelId) {
                this.massCollection.off(null, null, modelId);
            }
            if (cid) {
                this.massCollection.off(null, null, cid);
            }
        }
        this._super('unbindData');
    }
}) },
"forecast-pareto-chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastParetoChartField
 * @alias SUGAR.App.view.fields.BaseForecastParetoChartField
 * @extends View.Fields.Base.BaseField
 */
({
	// Forecast-pareto-chart Field (base) 

    /**
     * The data from the server
     */
    _serverData: undefined,

    /**
     * The open state of the sidepanel
     */
    state: "open",

    /**
     * Visible state of the preview window
     */
    preview_open: false,

    /**
     * Is the dashlet collapsed or not
     */
    collapsed: false,

    /**
     * Throttled Set Server Data call to prevent it from firing multiple times right in a row.
     */
    throttledSetServerData: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.once('render', function() {
            this.renderChart();
        }, this);

        this._super('initialize', [options]);

        // we need this if because Jasmine breaks with out as you can't define a view with a layout in Jasmine Test
        // @see BR-1217
        if (this.view.layout) {
            // we need to listen to the context on the layout for this view for when it collapses
            this.view.layout.on('dashlet:collapse', this.handleDashletCollapse, this);
            this.view.layout.context.on('dashboard:collapse:fire', this.handleDashletCollapse, this);
            // We listen to this event to call the chart resize method
            // because the size of the dashlet can change in the dashboard.
            this.view.layout.context.on('dashlet:draggable:stop', this.handleDashletCollapse, this);
        }

        // Localization parameters for the system
        this.locale = SUGAR.charts.getSystemLocale();
        this.throttledSetServerData = _.throttle(this._setServerData, 1000);
        this.barTooltipTemplate = app.template.getField(this.type, 'bartooltiptemplate', this.module);
        this.lineTooltipTemplate = app.template.getField(this.type, 'linetooltiptemplate', this.module);
        this.quotaTooltipTemplate = app.template.getField(this.type, 'quotatooltiptemplate', this.module);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        app.events.on('preview:open', function() {
            this.preview_open = true;
        }, this);
        app.events.on('preview:close', function() {
            this.preview_open = false;
            this.renderDashletContents();
        }, this);

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.listenTo(defaultLayout, 'sidebar:state:changed', function(state) {
                this.state = state;
                this.renderDashletContents();
            });
        }

        this.model.on('change', function(model) {
            var changed = _.keys(model.changed);
            if (!_.isEmpty(_.intersection(['user_id', 'display_manager', 'timeperiod_id'], changed))) {
                this.renderChart();
            }
        }, this);

        this.model.on('change:group_by change:dataset change:ranges', this.renderDashletContents, this);
    },

    /**
     * Utility method to check is the dashlet is visible
     *
     * @return {boolean}
     */
    isDashletVisible: function() {
        return (!this.disposed && this.state === 'open' &&
                !this.preview_open && !this.collapsed && !_.isUndefined(this._serverData));
    },

    /**
     * Utility method to resize dashlet with check for visibility
     *
     * @return {boolean}
     */
    resize: function() {
        if (this.isDashletVisible() && this.paretoChart && _.isFunction(this.paretoChart.update)) {
            this.paretoChart.update();
        }
    },

    /**
     * Utility method to render the chart if the dashlet is visible
     *
     * @return {boolean}
     */
    renderDashletContents: function() {
        if (this.isDashletVisible()) {
            this.convertDataToChartData();
            this.generateD3Chart();

            return true;
        }

        return false;
    },

    /**
     * Utility method since there are two event listeners
     *
     * @param {Boolean} collapsed       Is this dashlet collapsed or not
     */
    handleDashletCollapse: function(collapsed) {
        this.collapsed = collapsed;

        this.renderDashletContents();
    },

    /**
     * Attach and detach a resize method to the print event
     * @param {string} The state of print handling.
     */
    handlePrinting: function(state) {
        var self = this,
            mediaQueryList = window.matchMedia && window.matchMedia('print'),
            pausecomp = function(millis) {
                // www.sean.co.uk
                var date = new Date(),
                    curDate = null;
                do {
                    curDate = new Date();
                } while (curDate - date < millis);
            },
            printResize = function(mql) {
                if (mql.matches) {
                    self.paretoChart.width(640).height(320).update();
                    // Pause for a second to let chart finish rendering
                    pausecomp(200);
                } else {
                    browserResize();
                }
            },
            browserResize = function() {
                self.paretoChart.width(null).height(null).update();
            };

        if (state === 'on') {
            if (window.matchMedia) {
                mediaQueryList.addListener(printResize);
            } else if (window.attachEvent) {
                window.attachEvent('onbeforeprint', printResize);
                window.attachEvent('onafterprint', printResize);
            } else {
                window.onbeforeprint = printResize;
                window.onafterprint = browserResize;
            }
        } else {
            if (window.matchMedia) {
                mediaQueryList.removeListener(printResize);
            } else if (window.detachEvent) {
                window.detachEvent('onbeforeprint', printResize);
                window.detachEvent('onafterprint', printResize);
            } else {
                window.onbeforeprint = null;
                window.onafterprint = null;
            }
        }
    },

    /**
     * @inheritdoc
     * Clean up!
     */
    unbindData: function() {
        // we need this if because Jasmine breaks with out as you can't define a view with a layout in Jasmine Test
        // @see BR-1217
        if (this.view.layout) {
            this.view.layout.off('dashlet:collapse', null, this);
            this.view.layout.context.off('dashboard:collapse:fire', null, this);
            this.view.layout.context.off('dashlet:draggable:stop', null, this);
        }
        app.events.off(null, null, this);
        this._super('unbindData');
    },

    /**
     * Render the chart for the first time
     *
     * @param {Object} [options]        Options from the dashlet loaddata call
     */
    renderChart: function(options) {
        if (this.disposed || !this.triggerBefore('chart:pareto:render') ||
            _.isUndefined(this.model.get('timeperiod_id')) ||
            _.isUndefined(this.model.get('user_id'))
        ) {
            return;
        }

        this._serverData = undefined;

        this.chartId = this.cid + '_chart';
        this.paretoChart = sucrose.charts.paretoChart()
            .margin({top: 0, right: 10, bottom: 0, left: 10})
            .showTitle(false)
            .tooltips(true)
            .direction(app.lang.direction)
            .tooltipQuota(_.bind(function(key, x, y, e, graph) {
                // Format the value using currency class and user settings
                var point = {};
                point.key = e.key;
                point.y = app.currency.formatAmountLocale(y, app.currency.getBaseCurrencyId());
                return this.quotaTooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .tooltipLine(_.bind(function(key, x, y, e, graph) {
                // Format the value using currency class and user settings
                var point = {};
                point.key = key;
                point.y = app.currency.formatAmountLocale(y, app.currency.getBaseCurrencyId());
                return this.lineTooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .tooltipBar(_.bind(function(key, x, y, e, graph) {
                // Format the value using currency class and user settings
                var point = {};
                point.lbl = this.model.get('group_by') === 'probability' ?
                    (app.lang.get('LBL_OW_PROBABILITY', 'Forecasts') + ' (%)') :
                    app.lang.get('LBL_SALES_STAGE', 'Forecasts');
                point.key = key;
                point.y = app.currency.formatAmountLocale(y, app.currency.getBaseCurrencyId());
                //TODO: check all percent precision
                //TODO: should % be in template?
                point.x = sucrose.utility.numberFormat(x, 1, false, this.locality) + '%';
                return this.barTooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .colorData('default')
            .colorFill('default')
            .yValueFormat(function(d) {
                //TODO: is this correct?
                var f = d3sugar.formatPrefix(',.0', 1000);
                return app.currency.getCurrencySymbol(app.currency.getBaseCurrencyId()) + f(d);
            })
            .quotaValueFormat(function(d) {
                //TODO: is this correct?
                var f = d3sugar.formatPrefix(',.2', 1000);
                return app.currency.getCurrencySymbol(app.currency.getBaseCurrencyId()) + f(d);
            })
            //TODO: only do barClick if dashlet in Forecasts intelligence pane
            .seriesClick(function(data, eo, chart, container) {
                var d = eo.series,
                    selectedSeries = eo.seriesIndex;

                d.disabled = !d.disabled;

                chart.dispatch.call('tooltipHide', this);

                if (!chart.stacked()) {
                    data.filter(function(d) {
                        return d.series === selectedSeries && d.type === 'line';
                    }).map(function(d) {
                        d.disabled = !d.disabled;
                        return d;
                    });
                }

                // if there are no enabled data series, enable them all
                if (!data.filter(function(d) {
                    return !d.disabled && d.type === 'bar';
                }).length) {
                    data.map(function(d) {
                        d.disabled = false;
                        container.selectAll('.sc-series').classed('disabled', false);
                        return d;
                    });
                }

                container.call(chart);
            })
            .id(this.chartId)
            .strings({
                barLegend: {
                    close: app.lang.get('LBL_CHART_BAR_LEGEND_CLOSE', 'Forecasts'),
                    open: app.lang.get('LBL_CHART_BAR_LEGEND_OPEN', 'Forecasts')
                },
                lineLegend: {
                    close: app.lang.get('LBL_CHART_LINE_LEGEND_CLOSE', 'Forecasts'),
                    open: app.lang.get('LBL_CHART_LINE_LEGEND_OPEN', 'Forecasts')
                },
                noData: app.lang.get('LBL_CHART_NO_DATA'),
                noLabel: app.lang.get('LBL_CHART_NO_LABEL')
            })
            .locality(this.locale);

        this.locality = this.paretoChart.locality();

        this.paretoChart.displayNoData = _.bind(function(state) {
            this.$('[data-content="chart"]').toggleClass('hide', state);
            this.$('[data-content="nodata"]').toggleClass('hide', !state);
        }, this);

        // just on the off chance that no options param is passed in
        options = options || {};
        options.success = _.bind(function(data) {
            if(this.model) {
                this.model.set({
                    title: data.title
                });
                this._serverData = data;
                if (data.error) {
                    app.alert.show('chart_error', {
                        level: 'error',
                        messages: data.error
                    });

                    if (!_.isEmpty(this.paretoChart)) {
                        this.paretoChart.displayNoData(true);
                    }

                    this.trigger('chart:pareto:rendered');
                } else {
                    if (!_.isEmpty(this.paretoChart)) {
                        this.paretoChart.displayNoData(false);
                    }

                    this.convertDataToChartData();
                    this.generateD3Chart();
                }
            }
        }, this);

        var read_options = {};
        if (this.model.has('no_data') && this.model.get('no_data') === true) {
            read_options['no_data'] = 1;
        }

        // if this is a manager view, send the target_quota param to the endpoint
        if(this.model.get('display_manager')) {
            read_options['target_quota'] = (this.model.get('show_target_quota')) ? 1 : 0;
        }

        var url = app.api.buildURL(this.buildChartUrl(), null, null, read_options);

        app.api.call('read', url, {}, options);
    },

    /**
     * Generate the D3 Chart Object
     */
    generateD3Chart: function() {
        var params = this.model.toJSON();

        // clear out the current chart before a re-render
        if (!_.isEmpty(this.paretoChart)) {
            $(window).off('resize.' + this.sfId);
            d3sugar.select('#' + this.chartId + ' svg').remove();
        }

        this.paretoChart.stacked(!params.display_manager);

        if (this.d3Data.data.length > 0) {
            // if the chart element is hidden by a previous render, but has data now, show it
            this.$('.sc-chart').toggleClass('hide', false);
            this.$('.block-footer').toggleClass('hide', true);

            // After the .call(paretoChart) line, we are selecting the text elements for the Y-Axis
            // only so we can custom format the Y-Axis values
            d3sugar.select('#' + this.chartId)
                .append('svg')
                .datum(this.d3Data)
                .call(this.paretoChart);

            $(window).on('resize.' + this.sfId, _.debounce(_.bind(this.resize, this), 100));
            this.handlePrinting('on');

            this.$('.sc-chart').on('click', _.bind(function(e) {
                this.paretoChart.dispatch.call('chartClick', this);
            }, this));
        } else {
            this.$('.sc-chart').toggleClass('hide', true);
            this.$('.block-footer').toggleClass('hide', false);
        }

        this.trigger('chart:pareto:rendered');
    },

    /**
     * Utility method to determine which data we need to parse,
     */
    convertDataToChartData: function() {
        if(this.state == 'closed' || this.preview_open || this.collapsed || _.isUndefined(this._serverData)) {
            return -1;
        }

        if (this.model.get('display_manager')) {
            this.convertManagerDataToChartData();
        } else {
            this.convertRepDataToChartData(this.model.get('group_by'));
        }
    },

    /**
     * Parse the Manager Data and set the d3Data object
     */
    convertManagerDataToChartData: function() {
        var dataset = this.model.get('dataset'),
            records = this._serverData.data,
            chartData = {
                'properties': {
                    'name': this._serverData.title,
                    'quota': parseFloat(this._serverData.quota),
                    'yDataType': 'currency',
                    'xDataType': 'string',
                    'quotaLabel': app.lang.get((this.model.get('show_target_quota')) ? 'LBL_QUOTA_ADJUSTED' : 'LBL_QUOTA', 'Forecasts'),
                    'groupData': records.map(function(record, i) {
                        return {
                            group: i,
                            l: record.name,
                            t: parseFloat(record[dataset]) + parseFloat(record[dataset + '_adjusted'])
                        };
                    })
                },
                'data': []
            },
            disabledKeys = this.getDisabledChartKeys(),
            barData = [dataset, dataset + '_adjusted'].map(function(ds, seriesIdx) {
                var vals = records.map(function(rec, recIdx) {
                        return {
                            series: seriesIdx,
                            x: recIdx + 1,
                            y: parseFloat(rec[ds]),
                            y0: 0
                        };
                    }),
                    label = this._serverData.labels['dataset'][ds];

                return {
                    disabled: (_.contains(disabledKeys, label)),
                    key: label,
                    series: seriesIdx,
                    type: 'bar',
                    values: vals,
                    valuesOrig: vals
                };
            }, this),
            lineData = [dataset, dataset + '_adjusted'].map(function(ds, seriesIdx) {
                var vals = records.map(function(rec, recIdx) {
                        return {
                            series: seriesIdx,
                            x: recIdx + 1,
                            y: parseFloat(rec[ds])
                        };
                    }),
                    addToLine = 0,
                    label = this._serverData.labels['dataset'][ds];

                _.each(vals, function(val, i, list) {
                    list[i].y += addToLine;
                    addToLine = list[i].y;
                });

                return {
                    disabled: (_.contains(disabledKeys, label)),
                    key: label,
                    series: seriesIdx,
                    type: 'line',
                    values: vals,
                    valuesOrig: vals
                };
            }, this);

        if(this.model.get('show_target_quota')) {
            // add target quota to chart data
            chartData.properties.targetQuota = +this._serverData.target_quota;
            chartData.properties.targetQuotaLabel = app.lang.get('LBL_QUOTA', 'Forecasts');
        }

        chartData.data = barData.concat(lineData);
        this.d3Data = chartData;
    },

    /**
     * Convert the Rep Data and set the d3Data Object
     *
     * @param {string} type     What we are dispaying
     */
    convertRepDataToChartData: function(type) {
        // clear any NaNs
        _.each(this._serverData.data, function(point) {
            if (_.has(point, 'likely') && isNaN(point.likely)) {
                point.likely = 0;
            }
            if (_.has(point, 'best') && isNaN(point.best)) {
                point.best = 0;
            }
            if (_.has(point, 'worst') && isNaN(point.worst)) {
                point.worst = 0;
            }
        });

        var dataset = this.model.get('dataset'),
            ranges = this.model.get('ranges'),
            seriesIdx = 0,
            barData = [],
            lineVals = this._serverData['x-axis'].map(function(axis, i) {
                return { series: seriesIdx, x: i + 1, y: 0 };
            }),
            line = {
                'key': this._serverData.labels.dataset[dataset],
                'type': 'line',
                'series': seriesIdx,
                'values': [],
                'valuesOrig': []
            },
            chartData = {
                'properties': {
                    'name': this._serverData.title,
                    'quota': parseFloat(this._serverData.quota),
                    'yDataType': 'currency',
                    'xDataType': 'datetime',
                    'quotaLabel': app.lang.get('LBL_QUOTA', 'Forecasts'),
                    'groupData': this._serverData['x-axis'].map(function(item, i) {
                        return {
                            'group': i,
                            'l': item.label,
                            't': 0
                        };
                    })
                },
                'data': []
            },
            records = this._serverData.data,
            data = (!_.isEmpty(ranges)) ? records.filter(function(rec) {
                return _.contains(ranges, rec.forecast);
            }) : records,
            disabledKeys = this.getDisabledChartKeys();

        _.each(this._serverData.labels[type], function(label, value) {
            var td = data.filter(function(d) {
                return (d[type] == value);
            });

            if (!_.isEmpty(td)) {
                var barVal = this._serverData['x-axis'].map(function(axis, i) {
                        return { series: seriesIdx, x: i + 1, y: 0, y0: 0 };
                    }),
                    axis = this._serverData['x-axis'];

                // loop though all the data and map it to the correct x series
                _.each(td, function(record) {
                    for (var y = 0; y < axis.length; y++) {
                        if (record.date_closed_timestamp >= axis[y].start_timestamp &&
                            record.date_closed_timestamp <= axis[y].end_timestamp) {
                            // add the value
                            var val = parseFloat(record[dataset]);
                            barVal[y].y += val;
                            chartData.properties.groupData[y].t += val;
                            lineVals[y].y += val;
                            break;
                        }
                    }
                }, this);

                barData.push({
                    disabled: (_.contains(disabledKeys, label)),
                    key: label,
                    series: seriesIdx,
                    type: 'bar',
                    values: barVal,
                    valuesOrig: app.utils.deepCopy(barVal)
                });

                // increase the series
                seriesIdx++;
            }
        }, this);

        if (!_.isEmpty(barData)) {
            // fix the line
            var addToLine = 0;
            _.each(lineVals, function(val, i, list) {
                list[i].y += addToLine;
                addToLine = list[i].y;
            });

            line.values = lineVals;
            line.valuesOrig = app.utils.deepCopy(lineVals);

            barData.push(line);
            chartData.data = barData;
        }

        this.d3Data = chartData;
    },

    /**
     * Look at the current chart if it exists and return the keys that are currently
     * disabled they can still be disabled when the chart is re-rendered
     *
     * @return {Array}
     */
    getDisabledChartKeys: function() {
        var currentChartData = d3sugar.select('#' + this.chartId + ' svg').data();
        var disabledBars = (!_.isUndefined(currentChartData[0])) ?
                _.filter(currentChartData[0].data, function(d) {
                    return (!_.isUndefined(d.disabled) && d.disabled === true);
                }) : [];

        return (!_.isEmpty(disabledBars)) ? _.map(disabledBars, function(d) {
            return d.key;
        }) : [];
    },

    /**
     * Accepts params object and builds the proper endpoint url for charts
     *
     * @return {String} has the proper structure for the chart url.
     */
    buildChartUrl: function() {
        var baseUrl = this.model.get('display_manager') ? 'ForecastManagerWorksheets' : 'ForecastWorksheets';
        return baseUrl + '/chart/' + this.model.get('timeperiod_id') + '/' + this.model.get('user_id');
    },

    /**
     * Do we have serverData yet?
     * @return {boolean}
     */
    hasServerData: function() {
        return !_.isUndefined(this._serverData);
    },

    /**
     * Return the data that was passed back from the server
     * @return {Object}
     */
    getServerData: function() {
        return this._serverData;
    },

    /**
     *
     * @param {Object} data
     * @param {Boolean} [adjustLabels]
     */
    setServerData: function(data, adjustLabels) {
        this.throttledSetServerData(data, adjustLabels);
    },

    /**
     * This method is called by the _.throttle call in initialize
     *
     * @param {Object} data
     * @param {Boolean} [adjustLabels]
     * @private
     */
    _setServerData: function(data, adjustLabels) {
        this._serverData = data;

        if (adjustLabels === true) {
            this.adjustProbabilityLabels();
        }
        this.renderDashletContents();
    },

    /**
     * When the Probability Changes on the Rep Worksheet, The labels in the chart data need to be updated
     * to Account for the potentially new label.
     */
    adjustProbabilityLabels: function() {
        var probabilities = _.unique(_.map(this._serverData.data, function(item) {
            return item.probability;
        })).sort();

        this._serverData.labels.probability = _.object(probabilities, probabilities);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.handlePrinting('off');
        $(window).off('resize.' + this.sfId);
        this.$('.sc-chart').off('click');
        this._super('_dispose');
    }

}) },
"file": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.FileField
 * @alias SUGAR.App.view.fields.BaseFileField
 * @extends View.Fields.Base.BaseField
 */
({
	// File Field (base) 

    fieldTag: 'input[type=file]',
    supportedImageExtensions: {
        'image/jpeg': 'jpg',
        'image/png': 'png',
        'image/gif': 'gif'
    },
    events: {
        'click [data-action=download]': 'startDownload',
        'click [data-action=delete]': 'deleteFile'
    },
    fileUrl: '',
    plugins: ['File', 'FieldDuplicate'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME: This needs an API instead. SC-3369 should address this.
        app.error.errorName2Keys['tooBig'] = 'ERROR_MAX_FILESIZE_EXCEEDED';
        app.error.errorName2Keys['uploadFailed'] = 'ERROR_UPLOAD_FAILED';

        if (this.model) {
            this.model.addValidationTask('file_upload_' + this.cid, _.bind(this._doValidateFile, this));
        }
    },

    /**
     * Validator for the file field. If the field is required and has no value,
     * it will fail validation prior to performing a file upload. If there is a
     * value, it will perform a file upload to the temporary folder (required in
     * order to test uploads for files that are potentially larger than
     * `upload_max_filesize` in php.ini).
     *
     * @param {Object} fields The list of fields to validate.
     * @param {Object} errors The errors object during this validation task.
     * @param {Function} callback The callback function to continue validation.
     */
    _doValidateFile: function(fields, errors, callback) {
        var fieldName = this.name,
            $field = this.$(this.fieldTag);

        if ($field.length === 0) {
            callback(null, fields, errors);
            return;
        }

        var val = $field.val();
        if (_.isEmpty(val)) {
            if (this.def.required) {
                errors[fieldName] = errors[fieldName] || {};
                errors[fieldName].required = true;
            }
            callback(null, fields, errors);
            return;
        }

        var ajaxParams = {
            temp: true,
            iframe: true,
            deleteIfFails: false,
            htmlJsonFormat: true
        };

        app.alert.show('upload', {
            level: 'process',
            title: app.lang.get('LBL_UPLOADING'),
            autoclose: false
        });

        this.model.uploadFile(fieldName, $field, {
            success:_.bind(this._doValidateFileSuccess, this, fields, errors, callback),
            error:_.bind(this._doValidateFileError, this, fields, errors, callback)
        }, ajaxParams);
    },

    /**
     * Success callback for the {@link #_doValidateFile} function.
     *
     * @param {Object} fields The list of fields to validate.
     * @param {Object} errors The errors object during this validation task.
     * @param {Function} callback The callback function to continue validation.
     * @param {Object} data File data returned from the successful file upload.
     */
    _doValidateFileSuccess: function(fields, errors, callback, data) {
        app.alert.dismiss('upload');

        var guid = data.record && data.record.id;
        if (!guid) {
            app.logger.error('Temporary file uploaded has no GUID.');
            this._doValidateFileError(fields, errors, callback, data);
            return;
        }

        var fieldName = this.name;
        // Add the guid to the list of fields to set on the model.
        if (!this.model.fields[fieldName + '_guid']) {
            this.model.fields[fieldName + '_guid'] = {
                type: 'file_temp',
                group: fieldName
            };
        }
        this.model.set(fieldName + '_guid', guid);

        // Update filename of the model with the value from response,
        // since it may have been modified on the server side
        this.model.set(fieldName, data.record[fieldName]);

        callback(null, fields, errors);
    },

    /**
     * Error callback for the {@link #_doValidateFile} function.
     *
     * @param {Object} fields The list of fields to validate.
     * @param {Object} errors The errors object during this validation task.
     * @param {Function} callback The callback function to continue validation.
     * @param {Object} resp Error object returned from the API.
     */
    _doValidateFileError: function(fields, errors, callback, resp) {
        app.alert.dismiss('upload');

        var errors = errors || {},
            fieldName = this.name;
        errors[fieldName] = {};

        switch (resp.error) {
            case 'request_too_large':
                errors[fieldName].tooBig = true;
                break;
            default:
                errors[fieldName].uploadFailed = true;
        }
        this.model.unset(fieldName + '_guid');
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // Remove specific validation task from the model.
        this.model.removeValidationTask('file_upload_' + this.cid);
        this._super('_dispose');
    },

    /**
     * Handler for delete file control
     *
     * Calls api to remove attached file from the model and
     * clear value and shows input[type=file] to upload new file
     * @param {Event} e
     */
    deleteFile: function(e) {
        var self = this;

        if (this.model.isNew()) {
            this.model.unset(this.name);
            if (this.disposed) {
                return;
            }
            this.render();
            return;
        }

        app.alert.show('delete_file_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_FILE_DELETE_CONFIRM', self.module),
            onConfirm: function() {
                var data = {
                        module: self.module,
                        id: self.model.id,
                        field: self.name
                    },
                    callbacks = {
                        success: function() {
                            self.model.set(self.name, '');
                            self.model.save({}, {
                                //Show alerts for this request
                                showAlerts: {
                                    'process': true,
                                    'success': {
                                        messages: app.lang.get('LBL_FILE_DELETED', self.module)
                                    }
                                },
                                fields: [self.name]
                            });
                            if (self.disposed) {
                                return;
                            }
                            // Because delete button is enabled in edit mode only and
                            // bindDataChange is overrided to prevent rendering field
                            // in edit mode call render method manually
                            self.render();
                        },
                        error: function(data) {
                            // refresh token if it has expired
                            app.error.handleHttpError(data, {});
                        }
                    };
                app.api.file('delete', data, null, callbacks, {htmlJsonFormat: false});
            }
        });
    },

    /**
     * @inheritdoc
     */
    setMode: function(name) {
        if (!_.isEmpty(this._errors)) {
            if (this.action === 'edit') {
                this.clearErrorDecoration();
                this.decorateError(this._errors);
                return;
            }
        }

        this._super('setMode', [name]);
    },

    /**
     * @inheritdoc
     *
     * Override field templates for merge-duplicate view.
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');
        if (this.view.name === 'merge-duplicates') {
            this.template = app.template.getField(this.type,
                'merge-duplicates-' + this.tplName,
                this.module, this.tplName
            ) || app.template.empty;
            this.tplName = 'list';
        }
    },

    /**
     * Handler to refresh field state.
     *
     * Called from {@link app.plugins._onFieldDuplicate}.
     */
    onFieldDuplicate: function() {
        if (this.disposed ||
            this.view.name !== 'merge-duplicates' ||
            this.options.viewName !== 'edit'
        ) {
            return;
        }
        this.render();
    },

    _render: function() {
        // This array will contain objects accessible in the view
        this.model = this.model || this.view.model;
        app.view.Field.prototype._render.call(this);
        return this;
    },
    format: function(value) {
        var attachments = [];
        // Not the same behavior either the value is a string or an array of files
        if (_.isArray(value)) {
            // If it's an array, we get the uri for each files in the response
            _.each(value, function(file) {
                var fileObj = {
                    name: file.name,
                    url: this.formatUri(file.uri)
                };
                attachments.push(fileObj);
            }, this);
        } else if (value) {
            // If it's a string, build the uri with the api library
            var urlOpts = {
                    module: this.module,
                    id: this.model.id,
                    field: this.name
                },
                fileObj = this._createFileObj(value, urlOpts);
            attachments.push(fileObj);
        }
        // Cannot be a hard check against "list" since subpanel-list needs this too
        return attachments;
    },

    /**
     * Creates a file object
     * @param {string} value The file name
     * @param {Object} urlOpts URL options
     * @return {Object} The created file object
     * @return {string} return.name The file name
     * @return {string} return.docType The document type
     * @return {string} return.mimeType The file's MIME type
     * @return {string} return.url The file resource url
     * @private
     */
    _createFileObj: function (value, urlOpts) {
        var isImage = this._isImage(this.model.get('file_mime_type')),
            forceDownload = !isImage,
            mimeType = isImage ? 'image' : '',
            docType = this.model.get('doc_type');
        return {
            name: value,
            mimeType: mimeType,
            docType: docType,
            url: app.api.buildFileURL(urlOpts,
                {
                    htmlJsonFormat: false,
                    passOAuthToken: false,
                    cleanCache: true,
                    forceDownload: forceDownload
                })
        };
    },

    /**
     * This is overridden by portal in order to prepend site url
     * @param {String} uri
     * @return {string} formatted uri
     */
    formatUri: function(uri) {
        return uri;
    },

    startDownload: function(e) {
        var uri = this.$(e.currentTarget).data('url');

        app.api.fileDownload(uri, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    /**
     * @inheritdoc
     *
     * Overrides `change` event for file field.
     * We should call `render` method when change event is triggered if:
     * 1. it is not duplicate-merge view and field isn't in edit mode. If it is
     * in edit mode we cannot set a value of a type `file` input.
     * 2. it is duplicate-merge view and field is in edit mode. Because
     * for this view we display file field as label (not input[type=file])
     * in edit mode we should update view on change.
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }
        this.model.on('change:' + this.name, function() {
            // Clear any errors on the field if we are changing the value.
            this._errors = {};
            this.clearErrorDecoration();
            if (_.isUndefined(this.options.viewName) || this.options.viewName !== 'edit') {
                this.render();
            }
            // check if other fields want use the name of the file
            if (!_.isUndefined(this.def.populate_list)) {
                _.each(this.def.populate_list, function(field) {
                    if (!this.model.get(field) && app.acl.hasAccessToModel('edit', this.model, field)) {
                        this.model.set(field, this.model.get(this.name));
                    }
                }, this);
            }
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Because input file uses full local path to file as value,
     * value can contains directory names.
     * Unformat value to have file name only in it.
     */
    unformat: function (value) {
        return value.split('/').pop().split('\\').pop();
    },

    /**
     * Check if input mime type is an image or not.
     *
     * @param {String} mime type.
     * @return {Boolean} true if mime type is an image.
     * @private
     */
    _isImage: function(mimeType) {
        return !!this.supportedImageExtensions[mimeType];
    }
}) },
"url": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.UrlField
 * @alias SUGAR.App.view.fields.BaseUrlField
 * @extends View.Fields.Base.BaseField
 */
({
	// Url Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super("initialize", arguments);
        //Generated URL's should not be editable
        if (app.utils.isTruthy(this.def.gen)) {
            this.def.readonly = true;
        }
    },

    format:function(value){
        if (value && !value.match(/^([a-zA-Z]+):\/\//)) {
            value = "http://" + value;
        }
        return value;
    },
    unformat:function(value){
        value = (value!='' && value!='http://') ? value.trim() : "";
        return value;
    },
    getFieldElement: function() {
        return this.$('a');
    },
    _render: function() {
        this.def.link_target = _.isUndefined(this.def.link_target) ? '_blank' : this.def.link_target;
        app.view.Field.prototype._render.call(this);
    }
}) },
"html": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.HtmlField
 * @alias SUGAR.App.view.fields.BaseHtmlField
 * @extends View.Fields.Base.BaseField
 */
({
	// Html Field (base) 

    fieldSelector: '.htmlareafield', //iframe selector

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     *
     * The html area is always a readonly field.
     * (see htmleditable for an editable html field)
     */
    initialize: function(options) {
        options.def.readonly = true;
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     *
     * Set the name of the field on the iframe as well as the contents
     *
     * @private
     */
    _render: function() {
        app.view.Field.prototype._render.call(this);

        this._getFieldElement().attr('name', this.name);
        this.setViewContent();
    },

    /**
     * Sets read only html content in the iframe
     */
    setViewContent: function(){
        var value = this.value || this.def.default_value;
        var field = this._getFieldElement();
        if(field && field.get(0) && !_.isEmpty(field.get(0).contentDocument)) {
            if(field.contents().find('body').length > 0){
                field.contents().find('body').html(value);
            }
        }
    },

    /**
     * Finds iframe element in the field template
     *
     * @return {HTMLElement} element from field template
     * @private
     */
    _getFieldElement: function() {
        return this.$el.find(this.fieldSelector);
    }

}) },
"source": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.SourceField
 * @alias SUGAR.App.view.fields.BaseSourceField
 * @extends View.Fields.Base.BaseField
 */
({
	// Source Field (base) 

    /**
     * @inheritdoc
     * Format source field based on what model is received.
     */
    format: function(value) {
        var subject = value ? value.subject : null;

        if (!subject) {
            return '';
        }

        // Try to create a link for the source field
        this.buildRoute(subject._module, subject.id);

        // When we receive full data (name & module & id), return name
        if (subject._module && subject.id && subject.name) {
            return subject.name;
        }

        // If data is incomplete, fall back to label
        var labelValue = this._getValidLabelValue(this.module, subject._type);

        if (labelValue) {
            return labelValue;
        }

        // If no label found, fall back to name
        if (subject.name) {
            return subject.name;
        }

        // Worst case scenario: try to display the id of the source or empty string
        return subject.id ? subject.id : '';
    },

    /**
     * Builds the route for the source model.
     * @param {string} module The module to link to.
     * @param {string} id The record id to link to.
     */
    buildRoute: function(module, id) {
        if (_.isUndefined(module) || _.isUndefined(id) || _.isEmpty(module)) {
            return;
        }

        var oldModule = module;
        if (module === 'Users') {
            module = 'Employees';
        }

        if (app.acl.hasAccess('view', oldModule)) {
            this.href = '#' + app.router.buildRoute(module, id);
        } else {
            this.href = undefined;
        }
    },

    /**
     * Dynamically generate label for model in case, and if the label is
     * defined return label value or null.
     * @param {Object} module Current audit module.
     * @param {string} type Source type.
     * @return {string|null} Label value or null if the label is not found.
     * @private
     */
    _getValidLabelValue: function(module, type) {
        var fullLabel = 'LBL_AUDIT_SUBJECT_' + type.toUpperCase();
        var labelValue =  app.lang.get(fullLabel, module);

        // If we get the same value from translate, return null
        return fullLabel === labelValue ? null : labelValue;
    }
}) },
"pdfaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.PdfactionField
 * @alias SUGAR.App.view.fields.BasePdfactionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Pdfaction Field (base) 

    extendsFrom: 'RowactionField',
    events: {
        'click [data-action=link]': 'linkClicked',
        'click [data-action=download]': 'downloadClicked',
        'click [data-action=email]': 'emailClicked'
    },

    /**
     * PDF Template collection.
     *
     * @type {Data.BeanCollection}
     */
    templateCollection: null,

    /**
     * Visibility property for available template links.
     *
     * @property {Boolean}
     */
    fetchCalled: false,

    /**
     * @inheritdoc
     * Create PDF Template collection in order to get available template list.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.templateCollection = app.data.createBeanCollection('PdfManager');
        this._fetchTemplate();
    },

    /**
     * @inheritdoc
     *
     * Prevents the "Email PDF" button from rendering if the user
     * doesn't have a valid email configuration or the user chooses to use an
     * external email client. RFC 2368 suggests only the "subject" and "body"
     * headers are safe headers and that other, unsafe headers do not need to
     * be supported by the "mailto" implementation. We cannot guarantee that
     * the "mailto" implementation for the user will allow for adding a PDF
     * attachment. To be consistent with existing application behavior, the
     * "Email PDF" option should be hidden for users when they cannot use the
     * internal email client.
     *
     * @private
     */
    _render: function() {
        var emailClientPreference = app.user.getPreference('email_client_preference');
        if (!this.templateCollection.length > 0 ||
            (this.def.action === 'email' && emailClientPreference.type !== 'sugar')) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Define proper filter for PDF template list.
     * Fetch the collection to get available template list.
     * @private
     */
    _fetchTemplate: function() {
        this.fetchCalled = true;
        var collection = this.templateCollection;
        collection.filterDef = {'$and': [{
            'base_module': this.module
        }, {
            'published': 'yes'
        }]};
        collection.fetch();
    },

    /**
     * Build email pdf link url.
     *
     * @param {String} templateId PDF Template id.
     * @return {string} Email pdf url.
     * @private
     */
    _buildEmailLink: function(templateId) {
        return '#' + app.bwc.buildRoute(this.module, null, 'sugarpdf', {
            'sugarpdf': 'pdfmanager',
            'record': this.model.id,
            'pdf_template_id': templateId,
            'to_email': '1'
        });
    },

    /**
     * Handle the button click event.
     * Stop event propagation in order to keep the dropdown box.
     *
     * @param {Event} evt Mouse event.
     */
    linkClicked: function(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        if (this.templateCollection.dataFetched) {
            this.fetchCalled = !this.fetchCalled;
        } else {
            this._fetchTemplate();
        }
        this.render();
    },

    /**
     * Handles email pdf link.
     *
     * @param {Event} evt Mouse event.
     */
    emailClicked: function(evt) {
        var templateId = this.$(evt.currentTarget).data('id');
        app.router.navigate(this._buildEmailLink(templateId), {
            trigger: true
        });
    },

    /**
     * Build download link url.
     *
     * @param string templateId PDF Template id.
     * @return string Link url.
     * @private
     */
    _buildDownloadLink: function(templateId) {
        var urlParams = $.param({
            'action': 'sugarpdf',
            'module': this.module,
            'sugarpdf': 'pdfmanager',
            'record': this.model.id,
            'pdf_template_id': templateId
        });
        return '?' + urlParams;
    },

    /**
     * Handles download pdf link.
     *
     * Authenticate in bwc mode before triggering the download.
     *
     * @param {Event} evt The `click` event.
     */
    downloadClicked: function(evt) {
        var $target = this.$(evt.currentTarget);
        var templateId = $target.data('id');

        app.alert.show('generating_pdf', {
            level: 'process',
            title: app.lang.get('LBL_GENERATING_PDF')
        });

        app.bwc.login(null, _.bind(function() {
            this._triggerDownload(this._buildDownloadLink(templateId));
        }, this));
    },

    /**
     * Download the file once authenticated in bwc mode.
     *
     * @param string url The file download url.
     * @protected
     */
    _triggerDownload: function(url) {
        app.api.fileDownload(url, {
            success: function() {
                app.alert.dismiss('generating_pdf');
            },
            error: function(data) {
                // refresh token if it has expired
                app.alert.dismiss('generating_pdf');
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    /**
     * @inheritdoc
     * Bind listener for template collection.
     */
    bindDataChange: function() {
        this.templateCollection.on('reset', this.render, this);
        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     * Dispose safe for templateCollection listeners.
     */
    unbindData: function() {
        this.templateCollection.off(null, null, this);
        this.templateCollection = null;
        this._super('unbindData');
    },

    /**
     * @inheritdoc
     * Check additional access for PdfManager Module.
     */
    hasAccess: function() {
        var pdfAccess = app.acl.hasAccess('view', 'PdfManager');
        return pdfAccess && this._super('hasAccess');
    }
}) },
"selection": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.SelectionField
 * @alias SUGAR.App.view.fields.BaseSelectionField
 * @extends View.Fields.Base.BaseField
 */
({
	// Selection Field (base) 

    events: {
        'click input.selection': 'toggleSelect'
    },
    toggleSelect: function(evt) {
        var $el = $(evt.currentTarget).is(":checked");
        if($el) {
            this.check();
        } else {
            this.uncheck();
        }
    },
    check: function() {
        if(this.model) {
            this.context.set('selection_model', this.model);
        }
    },
    uncheck: function() {
        if(this.model) {
            this.context.unset('selection_model');
        }
    },
    bindDomChange: function() {
        //don't update the row's model & re-render, this is just a mechanism for selecting a row
    }
}) },
"link-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * "Link existing record" action used in Subpanels.
 *
 * It needs to be sticky so that we keep things lined up nicely.
 *
 * @class View.Fields.Base.LinkActionField
 * @alias SUGAR.App.view.fields.BaseLinkActionField
 * @extends View.Fields.Base.StickyRowactionField
 */
({
	// Link-action Field (base) 

    extendsFrom: 'StickyRowactionField',
    events: {
        'click a[name=select_button]': 'openSelectDrawer'
    },

    /**
     * Click handler for the select action.
     *
     * Opens a drawer for selecting records to link to the current record.
     */
    openSelectDrawer: function() {
        if (this.isDisabled()) {
            return;
        }

        app.drawer.open(
            this.getDrawerOptions(),
            _.bind(this.selectDrawerCallback, this)
        );
    },

    /**
     * Format drawer options used by {@link #openSelectDrawer}.
     *
     * By default it uses {@link View.Layouts.Base.SelectionListLayout} layout.
     * You can extend this method if you need to pass more or different options.
     *
     * @return {Object}
     * @return {string} return.module The module to select records from.
     * @return {Object} return.parent The parent context of the selection list
     *                                context to pass to the drawer.
     * @return {Data.Bean} return.recParentModel The current record to link to.
     * @return {string} return.recLink The relationship link.
     * @return {View.View} return.recView The view for the selection list.
     * @return {Backbone.Model} return.filterOptions The filter options object.
     * */
    getDrawerOptions: function() {
        var parentModel = this.context.get('parentModel');
        var linkModule = this.context.get('module');
        var link = this.context.get('link');

        var filterOptions = new app.utils.FilterOptions().config(this.def);
        filterOptions.setInitialFilter(this.def.initial_filter || '$relate');
        filterOptions.populateRelate(parentModel);

        return {
            layout: 'multi-selection-list-link',
            context: {
                module: linkModule,
                recParentModel: parentModel,
                recLink: link,
                recContext: this.context,
                recView: this.view,
                independentMassCollection: true,
                filterOptions: filterOptions.format()
            }
        };
    },

    /**
     * Callback method used when the drawer is closed.
     *
     * If a record has been selected, it makes a request to the server to link
     * it to the parent record.
     * On success, it refreshes the subpanel collection so the new record
     * appears in the subpanel.
     *
     * Finally, it expands the subpanel context by setting the `collapsed`
     * property to `false`.
     *
     * @param {Data.Bean} model The selected record to link to parent record.
     */
    selectDrawerCallback: function(model) {
        if (!model) {
            return;
        }

        var parentModel = this.context.get('parentModel');
        var link = this.context.get('link');

        var relatedModel = app.data.createRelatedBean(parentModel, model.id, link),
            options = {
                //Show alerts for this request
                showAlerts: true,
                relate: true,
                success: _.bind(function() {
                    //We've just linked a related, however, the list of records from
                    //loadData will come back in DESC (reverse chronological order
                    //with our newly linked on top). Hence, we reset pagination here.
                    this.context.get('collection').resetPagination();
                    this.context.set('collapsed', false);
                }, this),
                error: function() {
                    app.alert.show('server-error', {
                        level: 'error',
                        messages: 'ERR_GENERIC_SERVER_ERROR'
                    });
                }
            };
        relatedModel.save(null, options);
    },

    /**
     * Check if link action should be disabled or not.
     *
     * The side effect of linking another record on a required relationship is
     * that the record could be already linked to a record and in that case we
     * would delete this existing link.
     *
     * @return {boolean} `true` if it should be disabled, `false` otherwise.
     * @override
     */
    isDisabled: function() {
        if (this._super('isDisabled')) {
            return true;
        }
        var link = this.context.get('link'),
            parentModule = this.context.get('parentModule'),
            required = app.utils.isRequiredLink(parentModule, link);
        return required;
    }
}) },
"fieldset": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * A fieldset is a field that contains one or more child fields.
 * The hbs template sets the placeholders of child fields but the creation of
 * child fields reside in the controller.
 *
 * Accessibility is checked against each child field as well as the fieldset.
 * We do not hide the fieldset in the event that the fieldset is accessible and
 * all child fields are not.
 *
 * Supported properties:
 *
 * - {Array} fields List of fields that are part of the fieldset.
 * - {boolean} show_child_labels Set to `true` to show labels on child fields in
 * the record view.
 * - {boolean} inline Set to `true` to render the fieldset inline.
 * - {boolean} equal_spacing When in inline mode, setting `true` will make the
 * fields inside fieldsets to have equal spacing, rather than being left aligned.
 *
 * Example usage:
 *
 *      array(
 *          'name' => 'date_entered_by',
 *          'type' => 'fieldset',
 *          'label' => 'LBL_DATE_ENTERED',
 *          'fields' => array(
 *              array(
 *                  'name' => 'date_entered',
 *              ),
 *              array(
 *                  'type' => 'label',
 *                  'default_value' => 'LBL_BY',
 *              ),
 *              array(
 *                  'name' => 'created_by_name',
 *              ),
 *          )
 *      )
 *
 * @class View.Fields.Base.FieldsetField
 * @alias SUGAR.App.view.fields.BaseFieldsetField
 * @extends View.Fields.Base.BaseField
 */
({
	// Fieldset Field (base) 

    /**
     * Initializes the fieldset field component.
     *
     * Initializes the fields property.
     *
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * Children fields that are created as part of this field.
         *
         * @property {Array}
         */
        this.fields = [];

        var inlineTag = this.def.inline ? '-inline' : '';
        this.def.css_class = (this.def.css_class ? this.def.css_class + ' fieldset' :
            'fieldset') + inlineTag;

        if (this.def.equal_spacing && this.def.inline) {
            this.def.css_class += ' fieldset-equal';
        }
    },

    /**
     * @inheritdoc
     *
     * Looks for the fallback template as specified by the view. Returns the
     * `detail` template if it's not found.
     * FIXME: SC-3363 This should be the default behavior in `field.js`.
     */
    _getFallbackTemplate: function(viewName) {
        if (_.contains(this.fallbackActions, viewName)) {
            return viewName;
        }
        if (app.template.get('f.' + this.type + '.' + this.view.fallbackFieldTemplate)) {
            return this.view.fallbackFieldTemplate;
        }
        return 'detail';
    },

    /**
     * @inheritdoc
     *
     * Loads the `record-detail` template if the view is `record`.
     * FIXME: This is a quick hack and will be fixed by SC-3364.
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if ((this.view.name === 'record' || this.view.name === 'create'
            || this.view.name === 'create-nodupecheck' || this.view.name === 'pmse-case')
            && this.type === 'fieldset' && !_.contains(this.fallbackActions, this.action)) {

            this.template = app.template.getField('fieldset', 'record-detail', this.model.module);
        }
    },

    /**
     * @inheritdoc
     *
     * If current fieldset is not readonly, it always falls back to false
     * (nodata unsupportable).
     * If current fieldset is readonly and all dependant fields contains empty
     * data set, then it falls back to true.
     *
     * @return {Boolean} true if this fieldset is readonly and all the data
     * fields are empty.
     */
    showNoData: function() {

        if (!this.def.readonly) {
            return false;
        }

        return !_.some(this.fields, function(field) {
            return field.name && field.model.has(field.name);
        });
    },

    /**
     * @inheritdoc
     *
     * We set the result from `field.getPlaceholder()` into a property named
     * `placeholder` for each of the child fields. These placeholders help us
     * render the child fields when placed in the hbs file.
     */
    _render: function() {
        var fields = this._getChildFields();
        _.each(fields, function(field) {
            field.placeholder = field.getPlaceholder();
        }, this);

        this.focusIndex = 0;

        this._super('_render');

        this._renderFields(fields);

        return this;
    },

    /**
     * Renders the children fields in their respective placeholders.
     *
     * @param {Array} fields The children fields.
     * @protected
     */
    _renderFields: function(fields) {
        // In terms of performance it is better to search the DOM once for
        // all the fieldset fields, than to search the DOM for each field.
        // That's why we cache the DOM elements in the `fieldElems` hash and pass
        // them to {@link Backbone.View#setElement}.
        var fieldElems = {};

        this.$('span[sfuuid]').each(function() {
            var $this = $(this);
            var sfId = $this.attr('sfuuid');
            fieldElems[sfId] = $this;
        });

        _.each(fields, function(field) {
            field.setElement(fieldElems[field.sfId]);
            field.render();
        }, this);
    },

    /**
     * Gets the child field definitions that are defined in the metadata.
     *
     * @return {Object} Metadata of the child fields.
     * @protected
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.fields);
    },

    /**
     * Creates the children fields that are specified in the definitions.
     *
     * @return {Array} Children fields that are created.
     * @protected
     */
    _getChildFields: function() {
        if (!_.isEmpty(this.fields)) {
            return this.fields;
        }

        var metaFields = this._getChildFieldsMeta();
        if (metaFields) {
            _.each(metaFields, function(fieldDef) {
                var field = app.view.createField({
                    def: fieldDef,
                    view: this.view,
                    nested: true,
                    viewName: this.options.viewName,
                    model: this.model
                });
                this.fields.push(field);
                field.parent = this;
            }, this);
        }
        return this.fields;
    },

    /**
     * @inheritdoc
     */
    clearErrorDecoration: function() {
        _.each(this.fields, function(field) {
            field.clearErrorDecoration();
        });

        this._super('clearErrorDecoration');
    },

    /**
     * The tab handler.
     *
     * Focus on the next child field. Skips disabled fields.
     *
     * @return {boolean} `true` if this method should be called upon the next tab.
     */
    focus: function() {
        // this should be zero but lets make sure
        if (this.focusIndex < 0 || !this.focusIndex) {
            this.focusIndex = 0;
        }

        if (this.focusIndex >= this.fields.length) {
            // done focusing our inputs return false
            this.focusIndex = -1;
            return false;
        } else {
            // this field is disabled skip ahead
            if (this.fields[this.focusIndex] && this.fields[this.focusIndex].isDisabled()) {
                this.focusIndex++;
                return this.focus();
            }
            // if the next field returns true its not done focusing so don't
            // increment to the next field
            if (_.isFunction(this.fields[this.focusIndex].focus) && this.fields[this.focusIndex].focus()) {
            } else {
                var field = this.fields[this.focusIndex];
                var $el = field.$(field.fieldTag + ':first');
                $el.focus().val($el.val());
                this.focusIndex++;
            }
            return true;
        }
    },

    /**
     * Fieldsets need to reset the action of its individual fields as well
     *
     * @protected
     * @override
     */
    _resetAction: function() {
        this._super('_resetAction');
        _.each(this.fields, function(field) {
            field._resetAction();
        });
    },

    /**
     * @inheritdoc
     */
    setDisabled: function(disable) {
        disable = _.isUndefined(disable) ? true : disable;
        this._super('setDisabled', [disable]);
        _.each(this.fields, function(field) {
            field.setDisabled(disable);
        }, this);
    },

    /**
     * @inheritdoc
     */
    setViewName: function(view) {
        this._super('setViewName', [view]);
        _.each(this.fields, function(field) {
            field.setViewName(view);
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Set action name of child fields of this field set.
     * Reset current focus index to the first item when it switches to different mode.
     */
    setMode: function(name) {
        this.focusIndex = 0;

        //Set the mode on child fields without rendering
        _.each(this.fields, function(field) {
            var oldAction = field._previousAction || field.action;
            field._removeViewClass(oldAction);
            if (field.isDisabled()) {
                field._previousAction = name;
            } else {
                field.action = name;
            }
        });

        //The _super 'setMode' would render all child fields.
        this._super('setMode', [name]);
    },

    /**
     * @inheritdoc
     *
     * We need this empty so it won't affect the nested fields that have the
     * same `fieldTag` of this fieldset due the usage of `find()` method.
     */
    bindDomChange: function() {
    },

    /**
     * @inheritdoc
     *
     * Keep empty because you cannot set a value of a type `fieldset`.
     */
    bindDataChange: function() {
        var removeNoData = _.debounce(function() {
            if (this.disposed) {
                return;
            }

            if (this.action === 'nodata') {
                this.setMode('detail');
            }
        }, 100);

        _.each(this._getChildFields(), function(field) {
            this.model.on('change:' + field.name, removeNoData, this);
        }, this);
    },

    /**
     * @inheritdoc
     *
     * We need this empty so it won't affect the nested fields that have the
     * same `fieldTag` of this fieldset due the usage of `find()` method.
     */
    unbindDom: function() {
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        //fields inside fieldset need to be disposed before the fielset itself is disposed.
        _.each(this.fields, function(field) {
            field.parent = null;
            field.dispose();
        });
        this.fields = null;
        app.view.Field.prototype._dispose.call(this);
    }
}) },
"change-password": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Widget for changing a password.
 *
 * It does not require old password confirmation.
 *
 * @class View.Fields.Base.ChangePasswordField
 * @alias SUGAR.App.view.fields.BaseChangePasswordField
 * @extends View.Fields.Base.BaseField
 */
({
	// Change-password Field (base) 

    fieldTag: 'input:not(:disabled)',

    events: {
        'click .togglePasswordFields': 'togglePasswordFields'
    },

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        app.view.Field.prototype.initialize.call(this, options);
        /**
         * Manually adds the validation error label to errorName2Keys
         * @type {string}
         */
        app.error.errorName2Keys['confirm_password'] = 'ERR_REENTER_PASSWORDS';
        this._extendModel();
    },

    /**
     * Extends the model
     * - adds a validation task _doValidatePasswordConfirmation : handle the password confirmation validation
     * - revertAttributes : to unset temporary attributes _new_password and _confirm_password
     */
    _extendModel: function() {
        // _hasChangePasswordModifs is a flag to make sure model methods are overriden only once
        if (this.model && !this.model._hasChangePasswordModifs) {
            // Make a copy of the model
            var _proto = _.clone(this.model);

            // This is the flag to make sure we do extend model only once
            this.model._hasChangePasswordModifs = true;

            /**
             * Validates new password and confirmation match
             *
             * @param {Object} fields Hash of field definitions to validate.
             * @param {Object} errors Error validation errors
             * @param {Function} callback Async.js waterfall callback
             */
            this.model._doValidatePasswordConfirmation = function(fields, errors, callback) {
                // Find any change password field
                var changePasswordFields = _.filter(fields, function(field) {
                    return field.type === 'change-password' || field.type === 'change-my-password';
                });
                _.each(changePasswordFields, function(field) {
                    // Get the new password and the confirmation
                    var password = this.get(field.name + '_new_password'),
                        confirmation = this.get(field.name + '_confirm_password');

                    /**
                     * Passwords don't match
                     */
                    if (password !== confirmation) {
                        // Adds the validation error
                        // confirm_password is added to errorName2Keys on initialize
                        errors[field.name] = errors[field.name] || {};
                        errors[field.name]['confirm_password'] = true;
                        if (this.showPopupAlerts) {
                            app.alert.show('passwords_mismatch', {
                                level: 'error',
                                messages: app.lang.get('ERR_REENTER_PASSWORDS'),
                                autoClose: true,
                                autoCloseDelay: 5000,
                            });
                        }
                    } else if (!errors[field.name]) {
                        /**
                         * Passwords match
                         */
                        this.unset(field.name + '_current_password'); //Needs to be cleared for change-my-password
                        if (password !== '') {
                            this.unset(field.name + '_new_password');
                            this.unset(field.name + '_confirm_password');
                            this.set(field.name, password);
                        }
                    }
                }, this);

                callback(null, fields, errors);
            };

            /**
             * Adds the validation task to the model
             * @override
             * @param options
             */
            this.model.addValidationTask('password_confirmation_' + this.cid, _.bind(this.model._doValidatePasswordConfirmation, this.model));

            /**
             * Unsets new password and confirmation values on revertAttributes
             * @override
             * @param options
             */
            this.model.revertAttributes = function(options) {
                // Find any change password field
                var attrs = _.clone(this.attributes);
                _.each(attrs, function(value, attr) {
                    if (attr.match('_new_password') || attr.match('_confirm_password')) {
                        this.unset(attr);
                    }
                }, this);
                // Call the old method
                _proto.revertAttributes.call(this, options);
            };
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (this.model) {
            this.newPassword = this.model.get(this.name + '_new_password');
            this.confirmPassword = this.model.get(this.name + '_confirm_password');
            // Decides to display inputs or the link
            this.showPasswordFields = this.showPasswordFields ||
                //Show password fields if the formatted value is empty
                !this.format(this.value) ||
                //Show password fields if they aren't empty
                !!(this.newPassword || this.confirmPassword);
        }
        app.view.Field.prototype._render.call(this);
        this.showPasswordFields = false;
        this.$inputs = this.$(this.fieldTag);
        this.focusIndex = 0;
        return this;
    },

    /**
     * Sets an arbitrary value just to display stars on detail view
     * @override
     * @param {Boolean} value
     * @return {string} value
     */
    format: function(value) {
        if (value === true) return 'value_setvalue_set';
        return value;
    },

    /**
     * Reset the arbitrary value
     * @override
     * @param {String} value
     * @return {Mixed} value boolean is the value is not set
     */
    unformat: function(value) {
        if (value === 'value_setvalue_set') return true;
        return value;
    },

    /**
     * Sets a password attribute on the model of this field.
     *
     * @private
     * @param {Event} evt The event object.
     */
    _setPasswordAttribute: function(evt) {
        var $el = this.$(evt.currentTarget);
        var attr = $el.attr('name');
        var val = $el.val();

        this.model.set(this.name + '_' + attr, this.unformat(val));
    },

    /**
     * @override
     */
    bindDomChange: function() {
        if (!(this.model instanceof Backbone.Model)) return;

        this.$('input[name=new_password]').on('change.' + this.cid, _.bind(this._setPasswordAttribute, this));

        var self = this;
        this.$('input[name=confirm_password]').on('change.' + this.cid, function() {
            var val = self.unformat($(this).val());
            self.model.set(self.name + '_confirm_password', val);
            self.model.set(self.name, val);
        });

        this.$('input[name=new_password], input[name=confirm_password]').on('focus.' + this.cid, _.bind(this.handleFocus, this));
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$('input[name=new_password], input[name=confirm_password]')
            .off('change.' + this.cid)
            .off('focus.' + this.cid);
        this._super('unbindDom');
    },

    /**
     * @return {Boolean} `true` if there is another input to focus, `false` if
     *   it is the last input already.
     */
    focus: function() {
        if (!this.$inputs.length) {
            this.togglePasswordFields();
        }
        // this should be zero but lets make sure
        if (this.focusIndex < 0) {
            this.focusIndex = 0;
        }

        if (this.focusIndex >= this.$inputs.length) {
            // done focusing our inputs return false
            this.focusIndex = -1;
            return false;
        } else {
            // focus the next item in our list of inputs
            this.$inputs[this.focusIndex].focus();
            this.focusIndex++;
            return true;
        }
    },

    /**
     * Displays inputs for the new password and the confirmation
     * @param event
     */
    togglePasswordFields: function(event) {
        this.showPasswordFields = true;
        this.render();
    },

    /**
     * Remove validation on the model.
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('password_confirmation_' + this.cid);
        this._super('_dispose');
    }
}) },
"date": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.DateField
 * @alias SUGAR.App.view.fields.BaseDateField
 * @extends View.Fields.Base.BaseField
 */
({
	// Date Field (base) 

    /**
     * @inheritdoc
     */
    fieldTag: 'input[data-type=date]',

    /**
     * @inheritdoc
     */
    events: {
        'hide': 'handleHideDatePicker'
    },

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // FIXME SC-1692: Remove this when SC-1692 gets in
        this._initPlugins();
        this._super('initialize', [options]);
        this._initEvents();
        this._initDefaultValue();
        this._initPlaceholderAttribute();

        /**
         * If a date picker has been initialized on the field or not.
         *
         * @type {boolean}
         * @private
         */
        this._hasDatePicker = false;
    },

    /**
     * Initialize plugins.
     *
     * @chainable
     * @protected
     * @template
     *
     * FIXME SC-1692: Remove this when SC-1692 gets in.
     */
    _initPlugins: function() {
        return this;
    },

    /**
     * Initialize events.
     *
     * @chainable
     * @protected
     * @template
     */
    _initEvents: function() {
        return this;
    },

    /**
     * If we're creating a new model and a valid `display_default` property was
     * supplied (e.g.: `next friday`) we'll use it as a date instead.
     *
     * @chainable
     * @protected
     */
    _initDefaultValue: function() {
        if (!this.model.isNew() || this.model.get(this.name) || !this.def.display_default) {
            return this;
        }

        var value = app.date.parseDisplayDefault(this.def.display_default);
        if (!value) {
            return this;
        }

        value = this.unformat(
            app.date(value).format(
                app.date.convertFormat(this.getUserDateFormat())
            )
        );

        this.model.setDefault(this.name, value);

        return this;
    },

    /**
     * Initializes the field's placeholder attribute.
     *
     * Placeholder attribute can be used in different ways. Based on metadata
     * settings one can do:
     *
     *     // ...
     *     array(
     *         'name' => 'my_date_field',
     *         'type' => 'date',
     *         'placeholder' => 'TPL_MY_PLACEHOLDER',
     *         // ...
     *     )
     *     // ...
     *
     * Where `TPL_MY_PLACEHOLDER` is able to receive the `format` flag such as:
     *
     *     'TPL_MY_PLACEHOLDER' => 'Accepts the {{format}} format'
     *
     * If none supplied, user date format is used instead
     * {@link #getUserDateformat}.
     *
     * @chainable
     * @protected
     */
    _initPlaceholderAttribute: function() {
        var placeholder = app.date.toDatepickerFormat(this.getUserDateFormat());

        this.fieldPlaceholder = this.def.placeholder && app.lang.get(
            this.def.placeholder,
            this.module,
            {format: placeholder}
        ) || placeholder;

        return this;
    },

    /**
     * Return user date format.
     *
     * @return {String} User date format.
     */
    getUserDateFormat: function() {
        return app.user.getPreference('datepref');
    },

    /**
     * Set up date picker.
     *
     * We rely on the library to confirm that the date picker is only created
     * once.
     *
     * @protected
     */
    _setupDatePicker: function() {
        var $field = this.$(this.fieldTag),
            userDateFormat = this.getUserDateFormat(),
            options = {
                format: app.date.toDatepickerFormat(userDateFormat),
                languageDictionary: this._patchPickerMeta(),
                weekStart: parseInt(app.user.getPreference('first_day_of_week'), 10)
            };

        var appendToTarget = this._getAppendToTarget();
        if (appendToTarget) {
            options['appendTo'] = appendToTarget;
        }

        $field.datepicker(options);
        this._hasDatePicker = true;
    },

    /**
     * Retrieve an element against which the date picker should be appended to.
     *
     * FIXME: find a proper way to do this and avoid scrolling issues SC-2739
     *
     * @return {jQuery/undefined} Element against which the date picker should
     *   be appended to, `undefined` if none.
     * @private
     */
    _getAppendToTarget: function() {
        var component = this.closestComponent('main-pane') ||
            this.closestComponent('drawer') ||
            this.closestComponent('preview-pane');

        if (component) {
            return component.$el;
        }

        return;
    },

    /**
     * Date picker doesn't trigger a `change` event whenever the date value
     * changes we need to override this method and listen to the `hide` event.
     *
     * Plus, we're using the `hide` event instead of the `changeDate` event
     * because the latter doesn't track copy/paste of dates whether from
     * keyboard or mouse and it also doesn't track field clearance through
     * keyboard, e.g.: selecting date text and press cmd+x.
     *
     * All invalid values are cleared from fields without triggering an event
     * because `this.model.set()` could have been already empty thus not
     * triggering a new event and not calling the default code of
     * `bindDomChange()`.
     *
     * Undefined model values will not be replaced with empty string to prevent
     * unnecessary unsaved changes warnings.
     */
    handleHideDatePicker: function() {
        var $field = this.$(this.fieldTag);

        // If we partially delete date from date picker and click outside the field, it will return undefined value.
        // But we need to use empty string as the only one negative value.
        var value = this.unformat($field.val()) || '';

        if (!value) {
            $field.val(value);
        }

        if (_.isEmptyValue(value) && _.isUndefined(this.model.get(this.name))) {
            return;
        }

        this.model.set(this.name, value);
    },

    /**
     * {@override}
     *
     * Parent method isn't called 'cause `handleHideDatePicker()` already takes
     * care of unformatting the value.
     */
    bindDomChange: function() {
        if (this._inDetailMode()) {
            return;
        }
        
        if (this.action === 'edit') {
            var $field = this.$(this.fieldTag);

            $field.on('focus', _.bind(this.handleFocus, this));

            $('.main-pane, .flex-list-view-content').on('scroll.' + this.cid, _.bind(function() {
                // make sure the dom element exists before trying to place the datepicker
                if (this._getAppendToTarget()) {
                    $field.datepicker('place');
                }
            }, this));
        }
    },

    /**
     * Determine if the field is currently in a read-only (detail) mode.
     *
     * @return {boolean}
     * @protected
     */
    _inDetailMode: function() {
        return this.action !== 'edit' && this.action !== 'massupdate';
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this._super('unbindDom');

        if (this._inDetailMode()) {
            return;
        }

        if (this.action === 'edit') {
            $('.main-pane, .flex-list-view-content').off('scroll.' + this.cid);

            var $field = this.$(this.fieldTag),
                datePicker = $field.data('datepicker');
            if (datePicker && !datePicker.hidden) {
                // todo: when SC-2395 gets implemented change this to 'remove' not 'hide'
                $field.datepicker('hide');
            }
        }
    },

    /**
     * Patches our `dom_cal_*` metadata for use with date picker plugin since
     * they're very similar.
     *
     * @private
     */
    _patchPickerMeta: function() {
        var pickerMap = [], pickerMapKey, calMapIndex, mapLen, domCalKey,
            calProp, appListStrings, calendarPropsMap, i, filterIterator;

        appListStrings = app.metadata.getStrings('app_list_strings');

        filterIterator = function(v, k, l) {
            return v[1] !== "";
        };

        // Note that ordering here is used in following for loop
        calendarPropsMap = ['dom_cal_day_long', 'dom_cal_day_short', 'dom_cal_day_min', 'dom_cal_month_long', 'dom_cal_month_short'];

        for (calMapIndex = 0, mapLen = calendarPropsMap.length; calMapIndex < mapLen; calMapIndex++) {

            domCalKey = calendarPropsMap[calMapIndex];
            calProp  = appListStrings[domCalKey];

            // Patches the metadata to work w/datepicker; initially, "calProp" will look like:
            // {0: "", 1: "Sunday", 2: "Monday", 3: "Tuesday", 4: "Wednesday", 5: "Thursday", 6: "Friday", 7: "Saturday"}
            // But we need:
            // ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
            if (!_.isUndefined(calProp) && !_.isNull(calProp)) {
                // Reject the first 0: "" element and then map out the new language tuple
                // so it's back to an array of strings
                calProp = _.filter(calProp, filterIterator).map(function(prop) {
                    return prop[1];
                });
                //e.g. pushed the Sun in front to end (as required by datepicker)
                calProp.push(calProp);
            }
            switch (calMapIndex) {
                case 0:
                    pickerMapKey = 'day';
                    break;
                case 1:
                    pickerMapKey = 'daysShort';
                    break;
                case 2:
                    pickerMapKey = 'daysMin';
                    break;
                case 3:
                    pickerMapKey = 'months';
                    break;
                case 4:
                    pickerMapKey = 'monthsShort';
                    break;
            }
            pickerMap[pickerMapKey] = calProp;
        }
        return pickerMap;
    },

    /**
     * Formats date value according to user preferences.
     *
     * @param {String} value Date value to format.
     * @return {String/undefined} Formatted value or `undefined` if value is an
     *   invalid date.
     */
    format: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value);

        if (!value.isValid()) {
            return;
        }

        return value.formatUser(true);
    },

    /**
     * Unformats date value for storing in model.
     *
     * @return {String/undefined} Unformatted value or `undefined` if value is
     *   an invalid date.
     */
    unformat: function(value) {
        if (!value) {
            return value;
        }

        value = app.date(value, app.date.convertFormat(this.getUserDateFormat()), true);

        if (!value.isValid()) {
            return;
        }

        return value.formatServer(true);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (this._hasDatePicker) {
            this.$(this.fieldTag).datepicker('hide');
        }

        this._super('_render');

        if (this.tplName !== 'edit' && this.tplName !== 'massupdate') {
            this._hasDatePicker = false;
            return;
        }

        this._setupDatePicker();
    },

    /**
     * Focus on the date field.
     */
    focus: function() {
        this.$(this.fieldTag).datepicker('focusShow');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // FIXME: new date picker versions have support for plugin removal/destroy
        // we should do the upgrade in order to prevent memory leaks

        if (this._hasDatePicker) {
            $(window).off('resize', this.$(this.fieldTag).data('datepicker').place);
        }

        this._super('_dispose');
    }
}) },
"vcard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Unlink row action used in subpanels and dashlets.
 *
 * @class View.Fields.Base.VcardField
 * @alias SUGAR.App.view.fields.BaseVcardField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Vcard Field (base) 

    extendsFrom: 'RowactionField',

    initialize: function(options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    /**
     * Downloads the vCard from the Rest API.
     *
     * First we do an ajax call to the `ping` API. This will check if the token
     * hasn't expired before we append it to the URL of the VCardDownload.
     *
     */
    rowActionSelect: function() {
        var url = app.api.buildURL(this.model.module, 'vcard', {id: this.model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the vCard download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    bindDataChange: function() {
        if (this.model) {
            this.model.on('change', this.render, this);
        }
    }
}) },
"editrecurrencesbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EditrecurrencesbuttonField is a field for Meetings/Calls for the ability editing all recurring events for a parent record
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.EditrecurrencesbuttonField
 * @alias SUGAR.App.view.fields.BaseEditrecurrencesbuttonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Editrecurrencesbutton Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * @inheritdoc
     *
     * Button should be hidden if meeting displayed is not recurring
     */
    _render: function() {
        if (_.isEmpty(this.model.get('repeat_type'))) {
            this.hide();
        } else {
            this._super('_render');
        }
    },

    /**
     * Re-render the field when the status on the record changes.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:repeat_type', this.render, this);
        }
    },

    /**
     * Event handler for editing all recurring records of a series
     * @inheritdoc
     */
    rowActionSelect: function() {
        this.context.trigger('all_recurrences:edit');
    }
}) },
"sticky-rowaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Sticky Rowaction does not disappear when user does not have access.
 *
 * It becomes disabled instead. This allows us to keep things lined up nicely
 * in Subpanel.
 *
 * @class View.Fields.Base.StickyRowactionField
 * @alias SUGAR.App.view.fields.BaseStickyRowactionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Sticky-rowaction Field (base) 

    extendsFrom: 'RowactionField',
    /**
     * @param options
     * @override
     */
    initialize: function(options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';  //TODO Hack that loads rowaction templates.  I hope to remove this when SP-966 is fixed.
    },
    /**
     * We always render StickyRowactions and instead set disable class when the user has no access
     * @private
     */
    _render: function() {
        if(this.isDisabled()){
            if(_.isUndefined(this.def.css_class) || this.def.css_class.indexOf('disabled') === -1){
                this.def.css_class = (this.def.css_class) ? this.def.css_class + " disabled" : "disabled";
            }
            //Remove event listeners on this action since it is disabled
            this.undelegateEvents();
        }
        // this can't be inside the isDisabled if block above because css_class can be set to 'disabled' by metadata
        if (!_.isUndefined(this.def.css_class) && this.def.css_class.indexOf('disabled') !== -1) {
            this.tabIndex = -1;
        }

        this._super("_render");
    },
    /**
     * Essentially the replacement of 'hasAccess' method for implementors of StickyRowactionField.
     * Used to determine if this rowaction should be rendered in a disabled state because the user lacks permission, etc.
     *
     * This is a default implementation disables when the user lacks access.
     * @return {boolean}
     */
    isDisabled: function(){
        return !this._super("hasAccess");
    },
    /**
     * Forces StickyRowaction to be rendered and visible in Actiondropdowns.
     * @return {boolean} `true` always
     */
    hasAccess: function(){
        return true;
    }

}) },
"email-text": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EmailTextField
 * @alias SUGAR.App.view.fields.BaseEmailTextField
 * @extends View.Fields.Base.BaseField
 */
({
	// Email-text Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    // The purpose of email-text is to provide a simpler textfield email
    // when our main email widget is overkill. For example, the first time
    // login wizard uses email-text. Note that the email mutated is the
    // primary_address email.
    initialize: function(options) {
        options     = options || {};
        options.def = options.def || {};
        if (_.isUndefined(options.def.link)) {
            options.def.link = true;
        }

        this._super('initialize', [options]);
    },
   /**
     * Formats for display
     * If we have a proper email value from model we parse out just
     * the primary address part since we're using a simple text field.
     * @param  {Object} value The value retrieved from model for email
     * @return {Object}       Normalized email value for simple field
     */
    format: function(value) {
        if(_.isArray(value)) {
            var primaryEmail = _.find(value, function(email) {
                return email.primary_address && email.primary_address !== "0";
            });
            return primaryEmail ? primaryEmail.email_address : '';
        }
        return value;
    },
    /**
     * Prepares email for going back to API
     * @param  {Object} value The value
     * @return {Object}       API ready value for email
     */
    unformat: function(value) {
        var self = this,
            emails = this.model.get('email'),
            changed = false;
        if(!_.isArray(emails)){emails = [];}
        _.each(emails, function(email, index) {
            // If we find a primary address and its email_address is different
            if(email.primary_address &&
                email.primary_address !== "0" &&
                email.email_address !== value)
            {
                changed = true;
                emails[index].email_address = value;
            }
        }, this);
        // If brand new email we push a primary address
        if (emails.length == 0) {
            emails.push({
                email_address:   value,
                primary_address: "1",
                hasAnchor:       false,
                _wasNotArray:    true
            });
            changed = true;
        }
        if (changed) {
            this.model.set(this.name, emails);
            this.model.trigger('change:' + this.name, this, emails);
        }
        return emails;
    }
}) },
"change-my-password": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Widget for changing a password.
 *
 * It does not require old password confirmation.
 *
 * @class View.Fields.Base.ChangeMyPasswordField
 * @alias SUGAR.App.view.fields.BaseChangeMyPasswordField
 * @extends View.Fields.Base.ChangePasswordField
 */
({
	// Change-my-password Field (base) 

    extendsFrom: 'ChangePasswordField',

    /**
     * @inheritdoc
     */
    fieldTag: 'input',

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        this._super("initialize", [options]);
        /**
         * Manually adds the validation error label to errorName2Keys
         * @type {string}
         */
        app.error.errorName2Keys['current_password'] = 'ERR_PASSWORD_MISMATCH';
        app.error.errorName2Keys['new_password'] = 'ERR_ENTER_NEW_PASSWORD';

        this.__extendModel();
    },


    /**
     * Extends the model (note that the model is already extended by ChangePasswordField)
     * - adds a validation task _doValidateCurrentPassword : handle the current password validation
     * - revertAttributes : to unset temporary attributes _current_password
     */
    __extendModel: function() {

        // _hasChangePasswordModifs is a flag to make sure model methods are overriden only once
        if (this.model && !this.model._hasChangeMyPasswordModifs) {
            // Make a copy of the model
            var _proto = _.clone(this.model);

            // This is the flag to make sure we do override methods only once
            this.model._hasChangeMyPasswordModifs = true;

            /**
             * Validates current password against server
             *
             * @param {Object} fields Hash of field definitions to validate.
             * @param {Object} errors Error validation errors
             * @param {Function} callback Async.js waterfall callback
             * @private
             */
            this.model._doValidateCurrentPassword = function(fields, errors, callback) {
                // Find the change my password field
                var field = _.find(fields, function(field) {
                    return field.type === 'change-my-password';
                });

                // change-my-password field was not changed, so
                // don't attempt to validate password
                if (!field) {
                    callback(null, fields, errors);
                    return;
                }

                //Get the current password
                var current = this.get(field.name + '_current_password');
                var password = this.get(field.name + '_new_password'),
                    confirmation = this.get(field.name + '_confirm_password');

                if (_.isEmpty(current) && _.isEmpty(password) && _.isEmpty(confirmation)) {
                    callback(null, fields, errors);
                    return;
                }
                //current is non-empty but we haven't put new/confirm passwords
                if (!_.isEmpty(current) && _.isEmpty(password) && _.isEmpty(confirmation)) {
                    errors[field.name] = errors[field.name] || {};
                    errors[field.name]['new_password'] = true;
                    callback(null, fields, errors);
                    return;
                }
                //Validate current password
                var alertOptions = {
                    title: app.lang.get("LBL_VALIDATING"),
                    level: "process"
                };
                app.alert.show('validation', alertOptions);

                app.api.verifyPassword(current, {
                    success: function(data) {
                        if(!data || !data.valid) {
                            errors[field.name] = errors[field.name] || {};
                            errors[field.name]['current_password'] = true;
                        }
                    },
                    error: function(error) {
                        errors[field.name] = errors[field.name] || {};
                        errors[field.name]['current_password'] = true;
                    },
                    /**
                     * After check is done, close alert and trigger the completion of the validation to the editor
                     */
                    complete: function() {
                        app.alert.dismiss('validation');
                        callback(null, fields, errors);
                    }
                });
            };
            this.model.addValidationTask('current_password_' + this.cid, _.bind(this.model._doValidateCurrentPassword, this.model));

            this.model.revertAttributes = function(options) {
                // Find any change password field
                var attrs = _.clone(this.attributes);
                _.each(attrs, function(value, attr) {
                    if (attr.match('_current_password')) {
                        this.unset(attr);
                    }
                }, this);
                // Call the old method
                _proto.revertAttributes.call(this, options);
            };
        }
    },

    /**
     * @override
     * @param {Boolean} value
     * @return {string} value
     */
    format: function(value) {
        if (this.action === 'edit') {
            this.currentPassword = this.model.get(this.name + '_current_password');
            value = '';
        } else if (value === true) {
            value = 'value_setvalue_set';
        }
        return value;
    },

    /**
     * @override
     */
    decorateError: function (errors) {
        var ftag = this.fieldTag;
        if (errors['current_password']) {
            this.fieldTag = 'input[name=current_password]';
            app.view.Field.prototype.decorateError.call(this, {current_password: true});
        }
        errors = _.omit(errors, 'current_password');
        if (!_.isEmpty(errors)) {
            this.fieldTag = 'input[name!=current_password]';
            app.view.Field.prototype.decorateError.call(this, errors);
        }
        this.fieldTag = ftag;
    },

    /**
     * @override
     */
    clearErrorDecoration: function () {
        var self = this,
            ftag = this.fieldTag || '',
            $ftag = this.$(ftag);
        // Remove previous exclamation then add back.
        this.$('.add-on').remove();

        //Not all inputs are necessarily wrapped so check each individually
        $ftag.each(function(index, el) {
            var isWrapped = self.$(el).parent().hasClass('input-append');
            if (isWrapped) {
                self.$(el).unwrap();
            }
        });
        this.$el.removeClass(ftag);
        this.$el.removeClass("error");
        this.$el.closest('.record-cell').removeClass("error");
    },

    /**
     * @override
     */
    bindDomChange: function() {
        this.$('input[name=current_password], input[name=new_password], input[name=confirm_password]').on('change.' + this.cid, _.bind(this._setPasswordAttribute, this));
    },

    /**
     * @inheritdoc
     */
    unbindDom: function() {
        this.$('input[name=current_password]').off('change.' + this.cid);
        this._super('unbindDom');
    },

    /**
     * Remove validation on the model.
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('current_password_' + this.cid);
        this._super('_dispose');
    }

}) },
"repeat-count": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * RepeatCount field is a special int field for Meetings/Calls that adds
 * max validation (which can't be done via metadata due to config value)
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatCountField
 * @alias SUGAR.App.view.fields.BaseRepeatCountField
 * @extends View.Fields.Base.IntField
 */
({
	// Repeat-count Field (base) 

    extendsFrom: 'IntField',

    /**
     * @property {int} defaultCount
     *
     * The number of occurrences to use as a default in the UI when creating a
     * new record.
     */
    defaultCount: 10,

    /**
     * @inheritdoc
     *
     * Add custom max value validation. The value of the field is defaulted in
     * the UI when creating a new record.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        // setting type & def.type so number validator will run
        this.type = this.def.type = 'int';

        this.def['default'] = this.def['default'] || this.defaultCount;

        this.model.addValidationTask(
            'repeat_count_max_validator_' + this.cid,
            _.bind(this._doValidateRepeatCountMax, this)
        );
    },

    /**
     * @inheritdoc
     *
     * Always returns an empty string if the value is 0, '0', null, or
     * undefined.
     */
    format: function(value) {
        value = this._super('format', [value]);

        return (value === '0' || value == null) ? '' : value;
    },

    /**
     * @inheritdoc
     *
     * Converts the value to an integer so that the integer representation is
     * always used in the model. If the value cannot be expressed as an number,
     * then it is left untouched. If the value is an empty string, then it is
     * converted to 0.
     */
    unformat: function(value) {
        if (!_.isString(value)) {
            // can't unformat it, so let the validator do the work
            return value;
        }

        // get the unformatted number
        value = this._super('unformat', [value]);

        if (_.isString(value)) {
            // it couldn't be unformatted
            if (value.trim() === '') {
                // it's the equivalent of 0
                value = 0;
            }
        }

        return value;
    },

    /**
     * Custom required validator for the `repeat_count` field.
     *
     * This validates `repeat_count` is not above the max allowed value
     * Since max value is in a config, cannot use sidecar maxValue validator.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatCountMax: function(fields, errors, callback) {
        var repeatCount = parseInt(this.model.get(this.name), 10),
            maxRepeatCount = app.config.calendar.maxRepeatCount;

        if (repeatCount > maxRepeatCount) {
            errors[this.name] = {'maxValue': maxRepeatCount};
        }
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_count_max_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"rowaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Rowaction is a button that when selected will trigger a Backbone Event.
 *
 * @class View.Fields.Base.RowactionField
 * @alias SUGAR.App.view.fields.BaseRowactionField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Rowaction Field (base) 

    extendsFrom: 'ButtonField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.def.events = _.extend({}, options.def.events, {
            'click .rowaction': 'rowActionSelect'
        });
        this._super('initialize', [options]);
    },

    /**
     * Triggers event provided at this.def.event on the view's context object by default.
     * Can be configured to trigger events on 'view' itself or the view's 'layout'.
     *
     * @see View.Fields.Base.RowactionField#getTarget
     * @param {Event} evt The click event.
     */
    rowActionSelect: function(evt) {
        var eventName = $(evt.currentTarget).data('event') || this.def.event;

        if (eventName) {
            this.getTarget().trigger(eventName, this.model, this, evt);
        }
    },

    /**
     * Returns the target on which the event should be triggered.
     *
     * @return {Core.Context} By default, the event should be triggered on the
     * context.
     * @return {View.View} The event should be triggered on the view.
     * @return {View.Layout} The event should be triggered on the layout.
     */
    getTarget: function() {
        var target;

        switch (this.def.target) {
            case 'view':
                target = this.view;
                break;
            case 'layout':
                target = this.view.layout;
                break;
            default:
                target = this.view.context;
        }

        return target;
    }
}) },
"participants": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * ParticipantsField is a field for Meetings/Calls that manages the invitees of an event
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.ParticipantsField
 * @alias SUGAR.App.view.fields.BaseParticipantsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Participants Field (base) 

    fieldTag: 'input.select2',

    plugins: ['SearchForMore'],

    events: {
        'click button[data-action=addRow]': 'addRow',
        'click button[data-action=removeRow]:not(.disabled)': 'removeRow',
        'click button[data-action=previewRow]:not(.disabled)': 'previewRow',
        'click button[data-action=show-more]': 'showMore'
    },

    placeholder: 'LBL_SEARCH_SELECT',

    // Number of hours before the meeting start datetime that will be the beginning
    // of the free/busy schedule timeline.
    timelineStart: 4,
    // Number of hours to display on free/busy schedule timeline.
    timelineLength: 9,
    // Regular Expression that parses module and ID from url
    moduleAndIdParserRegExp: new RegExp('/v\\d+/([^/]+)/([^/]+)/freebusy'),

    /**
     * @inheritdoc
     *
     * View.Fields.Base.ParticipantsField#placeholder can be overridden via
     * options.
     *
     * Adds a delay to the View.Fields.Base.ParticipantsField#addRow,
     * View.Fields.Base.ParticipantsField#removeRow,
     * View.Fields.Base.ParticipantsField#previewRow, and
     * View.Fields.Base.ParticipantsField#search methods so that these event
     * handlers do not execute too frequently.
     */
    initialize: function(options) {
        var fieldValue;

        this.addRow = _.debounce(this._addRowImmediately, 200);
        this.removeRow = _.debounce(this._removeRowImmediately, 200);
        this.previewRow = _.debounce(this._previewRowImmediately, 200);
        this.search = _.debounce(this.search, app.config.requiredElapsed || 500);

        this._super('initialize', [options]);

        // translate the placeholder
        this.placeholder = app.lang.get(this.def.placeholder || this.placeholder, this.module);

        if (this.model.isNew()) {
            try {
                fieldValue = this.getFieldValue();
            } catch (e) {
                // create a new virtual collection
                this.model.set(this.name, []);
            }
        }

        // get template for timeline header
        this.timelineHeaderTemplate = app.template.getField(this.type, 'timeline-header.partial', this.module);

        // get template for search result formatting
        this.searchResultTemplate = app.template.getField(this.type, 'search-result.partial', this.module);

        // caches the string "More {{field label}}..." for use in the template
        this.showMoreTemplate = app.lang.get('LBL_SHOW_MORE_GENERIC', this.module, {name: this.label});

        // adjust the start and end date/time indicator on the scheduler to fit the resized window
        $(window).on('resize.' + this.cid, _.bind(this.adjustStartAndEnd, this));
    },

    /**
     * @inheritdoc
     */
    getFieldElement: function() {
        return this.$(this.fieldTag);
    },

    /**
     * Returns the collection stored for this field.
     *
     * @throws An exception when the value is not a collection
     * @return {VirtualCollection}
     */
    getFieldValue: function() {
        var value = this.model.get(this.name);

        if (!(value instanceof app.BeanCollection)) {
            throw 'the value must be a BeanCollection';
        }

        return value;
    },

    /**
     * @inheritdoc
     *
     * Renders the field anytime the collection is changed. Updates the
     * scheduler UI anytime the start date or end date changes on the model.
     * Attempts to hide the show more button anytime the collection is
     * synchronized.
     */
    bindDataChange: function() {
        this.model.on('change:' + this.name, this.render, this);
        this.model.on('change:date_start', function() {
            this.clearFreeBusyInformationCache();
            this.renderTimelineInfo();
        }, this);
        this.model.on('change:date_end', this.adjustStartAndEnd, this);
        this.model.on('sync:' + this.name, this.hideShowMoreButton, this);

        // Fetch free/busy information again on save to get the latest.
        this.model.on('sync', function() {
            this.clearFreeBusyInformationCache();
            this.fetchFreeBusyInformation();
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Adds the selected record to the collection.
     */
    bindDomChange: function() {
        var onChange = _.bind(function(event) {
            try {
                this.getFieldValue().add(event.added.attributes);
            } catch (e) {
                app.logger.warn(e);
            }
        }, this);

        this.getFieldElement().on('change', onChange);
    },

    /**
     * @inheritdoc
     *
     * Destroys the Select2 element.
     */
    unbindDom: function() {
        this._super('unbindDom');
        this.getFieldElement().select2('destroy');
    },

    /**
     * @inheritdoc
     *
     * @chainable
     * @private
     */
    _render: function() {
        var $el;

        this._super('_render');

        $el = this.getFieldElement();
        $el.select2({
            allowClear: false,
            formatInputTooShort: '',
            formatSearching: app.lang.get('LBL_LOADING', this.module),
            formatResult: _.bind(this.formatSearchResult, this),
            minimumInputLength: 1,
            query: _.bind(this.search, this),
            selectOnBlur: false
        });
        this.addSearchForMoreButton($el);

        this._renderWithNewRow();

        this.renderTimelineInfo();

        this.hideShowMoreButton();

        return this;
    },

    /**
     * Called by {@link #_render} to handle the visibility of the new
     * participant row during rendering of the field.
     *
     * The select2 widget is hidden by default and never shown unless in edit
     * mode. The select2 widget is shown after render if in edit mode and the
     * collection is empty.
     *
     * If the select2 widget is shown, the delete button is disabled to prevent
     * users from deleting the row and putting the field in a state where new
     * participants cannot be added without re-rendering.
     */
    _renderWithNewRow: function() {
        var value;

        this.$('[name=newRow]').hide();

        if (this.action !== 'edit') {
            return;
        }

        try {
            value = this.getFieldValue();

            if (value.length === 0) {
                this._addRowImmediately();
                this.$('button[data-action=removeRow]').addClass('disabled');
            }
        } catch (e) {
            app.logger.warn(e);
        }
    },

    /**
     * Render timeline header, meeting start and end lines, and fill in busy
     * schedule timeslots.
     */
    renderTimelineInfo: function() {
        var startAndEndDates = this.getStartAndEndDates();

        if ((this.getTimelineBlocks().length > 0) && (!_.isEmpty(startAndEndDates))) {
            this.renderTimelineHeader();
            this.adjustStartAndEnd();
            this.fetchFreeBusyInformation();
        }
    },

    /**
     * Render timeline header. It begins 4 hours before the meeting start datetime
     * and ends 5 hours after.
     */
    renderTimelineHeader: function() {
        var timelineHeader = [],
            startAndEndDates = this.getStartAndEndDates(),
            timeFormat,
            timelineStart;

        if (_.isEmpty(startAndEndDates)) {
            return;
        }

        timeFormat = this.getTimeFormat();
        timelineStart = startAndEndDates.timelineStart;

        for (var index = 0; index < this.timelineLength; index++) {
            timelineHeader.push({
                hour: timelineStart.format(timeFormat),
                alt: (index % 2 === 0)
            });
            timelineStart.add(1, 'hours');
        }

        this.$('[data-render=timeline-header]').html(this.timelineHeaderTemplate(timelineHeader));
    },

    /**
     * Get the time display format for timeline header.
     * @return {string}
     */
    getTimeFormat: function() {
        var timeFormat = app.date.getUserTimeFormat(),
            hourFormat = timeFormat.charAt(0),
            meridiem = '';

        if (hourFormat === 'h') {
            meridiem = timeFormat.substr(-1, 1);
        }

        return (hourFormat + meridiem);
    },

    /**
     * Adjust the start and end overlay on the timeline for all users.
     */
    adjustStartAndEnd: function() {
        var startAndEndDates = this.getStartAndEndDates(),
            timelineBlockStartIndex, //index of timeline block when the meeting starts
            timelineBlockEndIndex, //index of timeline block when the meeting ends
            $timelineBlocks, //all timeline blocks in a given timeline
            $startBlock, //timeline block when the meeting starts
            $endBlock, //timeline block when the meeting ends
            overlayLeft, //left position of the overlay
            overlayWidth = 1, //width of the overlay
            $startEndOverlays = this.$('.start_end_overlay'), //all overlays
            firstUserOverlay, //first user overlay
            firstUserData; //first user module and ID

        if (_.isEmpty(startAndEndDates) || ($startEndOverlays.length === 0)) {
            return;
        }

        // Get timeline blocks that represents the start and end datetime for the meeting
        firstUserOverlay = $startEndOverlays.first();
        firstUserData = firstUserOverlay.closest('.participant').data();
        $timelineBlocks = this.getTimelineBlocks(firstUserData.module, firstUserData.id);

        timelineBlockStartIndex = startAndEndDates.meetingStart.diff(startAndEndDates.timelineStart, 'hours', true) * 4;
        timelineBlockStartIndex = Math.round(timelineBlockStartIndex);

        timelineBlockEndIndex = (startAndEndDates.meetingEnd.diff(startAndEndDates.timelineStart, 'hours', true) * 4) - 1;
        timelineBlockEndIndex = Math.round(timelineBlockEndIndex);

        $startBlock = $timelineBlocks.eq(timelineBlockStartIndex);
        $endBlock = $timelineBlocks.eq(timelineBlockEndIndex);

        if ($endBlock.length === 0) {
            $endBlock = $timelineBlocks.last();
            $startEndOverlays.removeClass('right_border');
        } else {
            $startEndOverlays.addClass('right_border');
        }

        // calculate the left position of the overlay
        overlayLeft = $startBlock.position().left;

        // calculate the width of the overlay for meetings that last more than 0 minutes
        if (timelineBlockEndIndex - timelineBlockStartIndex >= 0) {
            // Note: Need to use getBoundingClientRect() so that we can get subpixel measurements.
            overlayWidth = $endBlock.position().left - overlayLeft + $endBlock.get(0).getBoundingClientRect().width;
            // subtract left and right border width
            overlayWidth -= parseInt(firstUserOverlay.css('border-left-width'), 10) + parseInt(firstUserOverlay.css('border-right-width'), 10);
        }

        $startEndOverlays.css({
            left: overlayLeft + 'px',
            width: overlayWidth + 'px'
        });
    },

    /**
     * Fetch schedules for Users.
     */
    fetchFreeBusyInformation: function() {
        var self = this,
            requests = [],
            startAndEndDates = this.getStartAndEndDates(),
            participants;

        try {
            participants = this.getFieldValue();
        } catch (e) {
            app.logger.warn(e);
            return;
        }

        if (this.freebusy.isFetching() || _.isEmpty(startAndEndDates)) {
            return;
        }

        participants.each(function(participant) {
            var url,
                freeBusyFromCache,
                moduleName = participant.module,
                id = participant.get('id');

            if (moduleName === 'Users') {
                freeBusyFromCache = self.getFreeBusyInformationFromCache(moduleName, id);

                if (freeBusyFromCache) {
                    self.fillInFreeBusyInformation(freeBusyFromCache);
                } else {
                    url = app.api.buildURL(moduleName, 'freebusy', {id: id}, {
                        start: startAndEndDates.timelineStart.formatServer(),
                        end: startAndEndDates.timelineEnd.formatServer()
                    });
                    requests.push({
                        url: url.substring(4) //need to remove "rest" from the URL to be compatible with the bulk API
                    });

                    self.showLoadingOnTimeline(moduleName, id);
                }
            }
        });

        this.freebusy.fetch(requests, {
            success: function(data) {
                if (!self.disposed) {
                    _.each(data, function(response) {
                        self.fillInFreeBusyInformation(response.contents);
                    });
                }
            },
            error: function() {
                app.logger.warn('Error received from server while retrieving free/busy information.');
                app.alert.show('freebusy-error', {
                    level: 'warning',
                    autoClose: true,
                    messages: 'LBL_ERROR_RETRIEVING_FREE_BUSY'
                });
            },
            complete: function(request) {
                var data;
                if (!self.disposed && request.params.data) {
                    data = JSON.parse(request.params.data);
                    _.each(data.requests, function(requestData) {
                        var moduleAndId = self.parseModuleAndIdFromUrl(requestData.url);
                        self.hideLoadingOnTimeline(moduleAndId.module, moduleAndId.id);
                    });
                }
            }
        });
    },

    freebusy: (function() {
        var fetching = false;

        return {
            /**
             * Calls the bulk api to make multiple free/busy GET requests in a single call.
             * @param {Array} requests
             * @param {Object} options
             */
            fetch: function(requests, options) {
                var self = this;
                if (!_.isEmpty(requests)) {
                    options.complete = _.wrap(options.complete, function(func, request) {
                        func(request);
                        self.isFetching(false);
                    }, this);
                    app.api.call('create', app.api.buildURL(null, 'bulk'), {requests: requests}, options);
                    this.isFetching(true);
                }
            },

            /**
             * Is it currently in the process of fetching?
             * @param {boolean} [isFetching] Set whether or not it is currently fetching
             * @return {boolean}
             */
            isFetching: function(isFetching) {
                if (_.isUndefined(isFetching)) {
                    return fetching;
                } else {
                    fetching = isFetching;
                }
            }
        }
    })(),

    /**
     * Fill in the busy slots on the timeline.
     * @param {Object} scheduleInfo - free/busy info from the server
     */
    fillInFreeBusyInformation: function(scheduleInfo) {
        var startAndEndDates = this.getStartAndEndDates(),
            timelineStart = startAndEndDates.timelineStart,
            timelineEnd = startAndEndDates.timelineEnd;

        if (!scheduleInfo || _.isEmpty(startAndEndDates)) {
            return;
        }

        this.cacheFreeBusyInformation(scheduleInfo);
        this.getTimelineBlocks(scheduleInfo.module, scheduleInfo.id).removeClass('busy');

        _.each(scheduleInfo.freebusy, function(busy) {
            var busyStartDate = app.date(busy.start),
                busyEndDate = app.date(busy.end);

            if (busyStartDate.isBefore(timelineEnd) && !busyEndDate.isBefore(timelineStart)) {
                this.setAsBusy(busy, scheduleInfo.module, scheduleInfo.id);
            }
        }, this);
    },

    /**
     * Mark the timeslot as busy.
     * @param {Object} busy - start and end datetime that should be marked as busy
     * @param {string} moduleName
     * @param {string} id
     */
    setAsBusy: function(busy, moduleName, id) {
        var startAndEndDates = this.getStartAndEndDates(),
            busyStartDate = app.date(busy.start),
            busyEndDate = app.date(busy.end),
            diffInHours,
            $timelineBlocks = this.getTimelineBlocks(moduleName, id);

        if (_.isEmpty(startAndEndDates)) {
            return;
        }

        // To optimize, we set the busyStartDate as the beginning of the timeline.
        if (busyStartDate.isBefore(startAndEndDates.timelineStart)) {
            busyStartDate = app.date(startAndEndDates.timelineStart);
        }

        // Shift Start and End Times backward/forward to the next 15 minute interval as needed
        busyStartDate.subtract(busyStartDate.minutes() % 15, 'minutes');
        if (busyEndDate.minutes() % 15 > 0) {
            busyEndDate.add((15 - (busyEndDate.minutes() % 15)), 'minutes');
        }

        while (busyStartDate.isBefore(busyEndDate) && busyStartDate.isBefore(startAndEndDates.timelineEnd)) {
            diffInHours = busyStartDate.diff(startAndEndDates.timelineStart, 'hours', true);

            if (diffInHours >= 0) {
                $timelineBlocks.eq(diffInHours * 4).addClass('busy');
            }

            busyStartDate.add(15, 'minutes');
        }
    },

    /**
     * Get timeline start and end datetime and meeting start and end datetimes.
     * Returns empty object if the meeting start and end datetimes are invalid.
     * @return {Object}
     */
    getStartAndEndDates: function() {
        var dateStartString = this.model.get('date_start'),
            dateEndString = this.model.get('date_end'),
            durationHours = this.model.get('duration_hours'),
            durationMins = this.model.get('duration_minutes'),
            meetingStart,
            meetingEnd,
            result = {};

        // must have date_start, but if we don't have date_end we need to have at least
        // duration_hours or duration_minutes to judge an end time
        if (!dateStartString ||
            (!dateEndString && !(_.isFinite(durationHours) || _.isFinite(durationMins)))) {
            return result;
        }

        meetingStart = app.date(dateStartString);

        // if we don't have the date_end string, create it from the duration times
        if (dateEndString) {
            meetingEnd = app.date(dateEndString);
        } else {
            meetingEnd = app.date(meetingStart)
                .add(durationHours || 0, 'hours')
                .add(durationMins || 0, 'minutes');
        }


        if (!meetingStart.isAfter(meetingEnd)) {
            result.meetingStart = meetingStart;
            result.meetingEnd = meetingEnd;
            result.timelineStart = app.date(meetingStart).subtract(this.timelineStart, 'hours').minutes(0);
            result.timelineEnd = app.date(result.timelineStart).add(this.timelineLength, 'hours').minutes(0);
        }

        return result;
    },

    /**
     * Get timeline timeslots for a given module and ID. If moduleName and ID are
     * not specified, return timeslots for all timelines.
     * @param {string} moduleName (optional)
     * @param {string} id (optional)
     * @return {jQuery}
     */
    getTimelineBlocks: function(moduleName, id) {
        var selector;

        if (moduleName && id) {
            selector = '[data-module=' + moduleName + '][data-id=' + id + ']';
        } else {
            selector = '.participant';
        }

        selector += ' .times .timeblock span';

        return this.$(selector);
    },

    /**
     * Cache free/busy data received from the server.
     * @param {Object} data - the free/busy data from the server
     */
    cacheFreeBusyInformation: function(data) {
        if (_.isUndefined(this._freeBusyCache)) {
            this._freeBusyCache = [];
        } else {
            this._freeBusyCache = _.reject(this._freeBusyCache, function(freebusy) {
                return (freebusy.id === data.id) && (freebusy.module === data.module);
            });
        }

        this._freeBusyCache.push(data);
    },

    /**
     * Get free/busy data from cache.
     * @param {string} moduleName
     * @param {string} id
     * @return {Object}
     */
    getFreeBusyInformationFromCache: function(moduleName, id) {
        return _.findWhere(this._freeBusyCache, {
            module: moduleName,
            id: id
        });
    },

    /**
     * Clear free/busy data cache.
     */
    clearFreeBusyInformationCache: function() {
        this._freeBusyCache = [];
    },

    /**
     * Show loading message on timeline.
     * @param {string} moduleName
     * @param {string} id
     */
    showLoadingOnTimeline: function(moduleName, id) {
        this.$('[data-module=' + moduleName + '][data-id=' + id + '] .times')
            .addClass('loading')
            .find('[data-toggle=loading]')
            .removeClass('hide');
    },

    /**
     * Hide loading message on timeline.
     * @param {string} moduleName
     * @param {string} id
     */
    hideLoadingOnTimeline: function(moduleName, id) {
        this.$('[data-module=' + moduleName + '][data-id=' + id + '] .times')
            .removeClass('loading')
            .find('[data-toggle=loading]')
            .addClass('hide');
    },

    /**
     * Get module name and ID from URL.
     * @param {string} url
     * @return {Object}
     */
    parseModuleAndIdFromUrl: function(url) {
        var moduleAndId = {},
            parsed = this.moduleAndIdParserRegExp.exec(url);

        if (parsed) {
            moduleAndId.module = parsed[1];
            moduleAndId.id = parsed[2];
        }

        return moduleAndId;
    },

    /**
     * @inheritdoc
     *
     * Converts the models found in the collection to ones that can be used in
     * the templates.
     *
     * @param {VirtualCollection} value
     * @return {Object} Array of models with view properties defined
     * @return {string} return.accept_status The translated string
     * indicating the model's accept status
     * @return {string} return.accept_class The CSS class representing
     * the model's accept status per Twitter Bootstrap's label component
     * @return {string} return.avatar The URL where the model's avatar
     * can be downloaded or undefined if one does not exist
     * @return {boolean} return.deletable Whether or not the model can
     * be removed from the collection
     * @return {boolean} return.last Whether or not the model is the
     * last one in the collection
     * @return {Object} return.preview Preview information for model
     * @return {boolean} return.preview.enabled Whether or not preview
     * is enabled for the model
     * @return {string} return.preview.label The tooltip to be shown for
     * the model when hovering over the preview button
     */
    format: function(value) {
        var acceptStatus, acceptStatusFieldName, deletable, i, preview, rows, self;

        self = this;

        acceptStatusFieldName = 'accept_status_' + this.module.toLowerCase();
        acceptStatus = function(participant) {
            var status = {};

            switch (participant.get(acceptStatusFieldName)) {
                case 'accept':
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_ACCEPT';
                    status.css_class = 'success';
                    break;
                case 'decline':
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_DECLINE';
                    status.css_class = 'important';
                    break;
                case 'tentative':
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_TENTATIVE';
                    status.css_class = 'warning';
                    break;
                default:
                    status.label = 'LBL_CALENDAR_EVENT_RESPONSE_NONE';
                    status.css_class = '';
            }

            return status;
        };

        deletable = function(participant) {
            if (participant.deletable === false) {
                return false;
            }

            return participant.id !== self.model.get('assigned_user_id');
        };

        preview = function(participant) {
            var isBwc, moduleMetadata, preview;

            isBwc = false;
            preview = {
                enabled: true,
                label: 'LBL_PREVIEW'
            };

            moduleMetadata = app.metadata.getModule(participant.module);
            if (moduleMetadata) {
                isBwc = moduleMetadata.isBwcEnabled;
            }

            if (isBwc) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_BWC_TOOLTIP';
            } else if (_.isEmpty(participant.module) || _.isEmpty(participant.id)) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_DISABLED_NO_RECORD';
            } else if (!app.acl.hasAccess('view', participant.module)) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_DISABLED_NO_ACCESS';
            }

            return preview;
        };

        try {
            i = 1;
            rows = value.length;
            value = value.map(function(participant) {
                var attributes;
                var isNameErased = app.utils.isNameErased(participant);

                attributes = {
                    accept_status: acceptStatus(participant),
                    deletable: deletable(participant),
                    email: app.utils.getPrimaryEmailAddress(participant),
                    last: (rows === i++),
                    preview: preview(participant),
                    isNameErased: isNameErased,
                    name: isNameErased ? app.lang.get('LBL_VALUE_ERASED', participant.module) :
                        app.utils.getRecordName(participant),
                    module: participant.module
                };

                if (!_.isEmpty(participant.get('picture'))) {
                    attributes.avatar = app.api.buildFileURL({
                        module: participant.module,
                        id: participant.id,
                        field: 'picture'
                    });
                }

                return _.extend({}, participant.attributes, attributes);
            });
        } catch (e) {
            app.logger.warn(e);
            value = [];
        }

        return value;
    },

    /**
     * Displays the search and select to add a new participant.
     *
     * Hides the [+] button.
     *
     * @private
     * @param {Event} [event]
     */
    _addRowImmediately: function(event) {
        this.$('.participants-schedule').addClass('new');
        this.$('[name=newRow]').css('display', 'table-row');

        if (event) {
            $(event.currentTarget).hide();
        }

        this.getFieldElement().select2('open');
        this.adjustStartAndEnd();
    },

    /**
     * Removes the row where the [-] button was clicked.
     *
     * The participant is removed from the collection if it is an participant
     * row. Otherwise, the search and select row is hidden and the [+] is shown
     * again.
     *
     * @private
     * @param {Event} event
     */
    _removeRowImmediately: function(event) {
        var id, participants;

        id = $(event.currentTarget).data('id');

        if (id) {
            try {
                participants = this.getFieldValue();
                participants.remove(participants.get(id));
            } catch (e) {
                app.logger.warn(e);
            }
        } else {
            this.$('[name=newRow]').hide();
            this.$('button[data-action=addRow]').show();
            this.$('.participants-schedule').removeClass('new');
            this.adjustStartAndEnd();
        }
    },

    /**
     * Shows or hides the preview of the participant.
     *
     * @private
     * @param {Event} event
     */
    _previewRowImmediately: function(event) {
        var data, model, success;

        success = _.bind(function(model) {
            model.module = data.module;
            app.events.trigger('preview:render', model);
        }, this);

        data = $(event.currentTarget).data();

        if (data && data.module && data.id) {
            model = app.data.createBean(data.module, {id: data.id});
            model.fetch({
                showAlerts: true,
                success: success,
                params: {
                    erased_fields: true
                }
            });
        }
    },

    /**
     * Loads the next set of participants.
     *
     * The new participants will be rendered once they are added to the
     * collection.
     *
     * @param {Event} event
     */
    showMore: function(event) {
        var options;

        options = {
            fields: this._getRelatedFieldNames(),
            order_by: 'name:asc'
        };

        try {
            this.getFieldValue().paginate(options);
        } catch (e) {
            app.logger.warn(e);
        }
    },

    /**
     * Hides the pagination button if creating a new record -- because there is
     * no need for it -- or if the virtual collection indicates that there are
     * no additional participants to fetch.
     */
    hideShowMoreButton: function() {
        try {
            if (this.model.isNew() || !this.getFieldValue().hasMore()) {
                this.$('[data-action=show-more]').hide();
            }
        } catch (e) {
            app.logger.warn(e);
        }
    },

    /**
     * Searches for more participants that match the query.
     *
     * Matches that already exist in the collection are suppressed. See
     * [Select2](http://ivaynberg.github.io/select2/) for documentation on
     * using the query function.
     *
     * Pagination is disabled.
     *
     * @param {Object} query
     * @param {string} query.term The search term
     * @param {Function} query.callback The callback where data should be
     * passed once it has been loaded
     */
    search: function(query) {
        var data, fields, participants, success;

        data = {
            results: [],
            more: false
        };

        success = function(result) {
            result.each(function(record) {
                var participant = participants.get(record.id);

                if (participant) {
                    app.logger.debug(record.module + '/' + record.id + ' is already in the collection');
                } else {
                    record.text = record.get('name');
                    data.results.push(record);
                }
            });
        };

        try {
            fields = _.union(
                // fields that are needed for the detail, edit, and preview templates
                this._getRelatedFieldNames(),
                // fields for which there may be a match to show
                ['full_name', 'first_name', 'last_name', 'email', 'account_name']
            );

            participants = this.getFieldValue();
            participants.search({
                query: query.term,
                success: success,
                search_fields: ['full_name', 'email', 'account_name'],
                fields: fields,
                complete: function() {
                    query.callback(data);
                }
            });
        } catch (e) {
            app.logger.warn(e);
            query.callback(data);
        }
    },

    /**
     * Returns an array of strings representing the names of related fields.
     *
     * The related fields are defined under `this.def.fields`. Some of these
     * fields may be objects, while others strings.
     *
     * @return {Array}
     * @private
     */
    _getRelatedFieldNames: function() {
        var fields = this.def.fields || [];

        if (fields.length === 0) {
            return [];
        }

        return _.map(fields, function(field) {
            return _.isObject(field) ? field.name : field;
        });
    },

    /**
     * Format the search result for display in select2 result list
     *
     * @param {Data.Bean} bean A bean result
     * @return {string}
     */
    formatSearchResult: function(bean) {
        var nameIsErased = app.utils.isNameErased(bean);
        var result = {
            module: bean.module,
            name: nameIsErased ? app.lang.get('LBL_VALUE_ERASED', bean.module) : app.utils.getRecordName(bean),
            email: app.utils.getPrimaryEmailAddress(bean),
            name_is_erased: nameIsErased
        };

        _.each(bean.searchInfo.highlighted, function(field) {
            result.field_name = app.lang.get(field.label, field.module);
            result.field_value = field.text;
        });

        return this.searchResultTemplate(result);
    },

    /**
     * Remove resize event.
     * @inheritdoc
     * @private
     */
    _dispose: function() {
        $(window).off('resize.' + this.cid);
        this._super('_dispose');
    },

    /**
     * We do not support this field for preview edit
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if (this.view.name === 'preview') {
            this.template = app.template.getField('participants', 'preview', this.model.module);
        }
    }
}) },
"linkfromreportbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * LinkFromReportButton allows user to select a report and relate records to
 * primary record.
 *
 * @class View.Fields.Base.LinkfromreportbuttonField
 * @alias SUGAR.App.view.fields.BaseLinkfromreportbuttonField
 * @extends View.Fields.Base.StickyRowactionField
 */
({
	// Linkfromreportbutton Field (base) 

    extendsFrom: 'StickyRowactionField',
    events: {
        'click a[name=select_button]': 'openSelectDrawer'
    },

    /**
     * Event handler for the select button that opens a
     * {@link View.Layouts.Base.SelectionListLinkLayout} in  a drawer for linking
     * an existing record.
     */
    openSelectDrawer: function() {
        if (this.isDisabled()) {
            return;
        }

        var filteredModule = 'Reports',
            filterOptions = new app.utils.FilterOptions().config(this.def);

        var thisContextModule = this.context.get('module');
        if (thisContextModule !== filteredModule) {
            filterOptions.setLangModules([thisContextModule, filteredModule, 'Filters']);
        }

        app.drawer.open({
            layout: 'selection-list',
            context: {
                module: 'Reports',
                filterOptions: filterOptions.format()
            }
        }, _.bind(this.selectDrawerCallback, this));
    },

    /**
     * Process the report that was selected by the user.
     * @param {Object} model
     */
    selectDrawerCallback: function(model) {
        if (!model || _.isEmpty(model.id)) {
            return;
        }

        if (model.module != this.context.get('module')) {
            app.alert.show('listfromreport-warning', {
                level: 'warning',
                messages: app.lang.get('LBL_LINK_FROM_REPORT_WRONG_MODULE'),
                autoClose: true
            });
            return;
        }

        var recordListUrl = app.api.buildURL('Reports', 'record_list', {id: model.id}),
            self = this;

        app.alert.show('listfromreport_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});

        app.api.call(
            'create',
            recordListUrl,
            null,
            {
                success: _.bind(self.linkRecordList, self),
                error: function(error) {
                    app.alert.dismiss('listfromreport_loading');
                    app.alert.show('server-error', {
                        level: 'error',
                        title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                        messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                    });
                }
            }
        );
    },

    /**
     * Links records from a report to the parent record
     * @param {Object} response
     */
    linkRecordList: function(response) {
        var parentModel = this.context.get('parentModel'),
            parentModule = parentModel.get('module') || parentModel.get('_module'),
            link = this.context.get('link'), action = 'link/' + link + '/add_record_list',
            url = app.api.buildURL(
                parentModule,
                action,
                {
                    id: parentModel.get('id'),
                    relatedId: response.id
                }
            );

        app.api.call('create', url, null, {
            success: _.bind(this.linkSuccessCallback, this),
            error: _.bind(this.linkErrorCallback, this),
            complete: function(data) {
                app.alert.dismiss('listfromreport_loading');
            }
        });
    },

    /**
     * Success callback function for api call
     * @param {Object} results
     */
    linkSuccessCallback: function(results) {
        var message, messageLevel;
        if (results.related_records.success.length > 0) {
            messageLevel = 'success';
            message = app.lang.get('LBL_LINK_FROM_REPORT_SUCCESS', null, {
                reportCount: results.related_records.success.length
            });
        } else {
            messageLevel = 'warning';
            message = app.lang.get('LBL_LINK_FROM_REPORT_NO_DATA');
        }

        app.alert.show('server-success', {
            level: messageLevel,
            messages: message,
            autoClose: true
        });

        this.context.resetLoadFlag();
        this.context.set('skipFetch', false);
        this.context.loadData();
    },

    /**
     * Error callback function for api call
     * @param {Object} error
     */
    linkErrorCallback: function(error) {
        app.alert.show('server-error', {
            level: 'error',
            title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
            messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
        });
    },

    /**
     * Returns false if current user does not have access to Reports module - ACL checks
     * @return {Boolean} true if allow access, false otherwise
     * @override
     */
    isDisabled: function() {
        return !app.acl.hasAccess('view', 'Reports');
    }
}) },
"int": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.IntField
 * @alias SUGAR.App.view.fields.BaseIntField
 * @extends View.Fields.Base.BaseField
 */
({
	// Int Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * Older IE doesn't support Number.MIN_SAFE_INTEGER
     * @private
     */
    _minInt: Number.MIN_SAFE_INTEGER || -9007199254740991,

    /**
     * Older IE doesn't support Number.MAX_SAFE_INTEGER
     * @private
     */
    _maxInt: Number.MAX_SAFE_INTEGER || 9007199254740991,

    /**
     * @inheritdoc
     *
     * Add custom min/max value validation.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        app.error.errorName2Keys.integer = 'ERROR_INT';

        this.model.addValidationTask(
            'min_max_int_validator_' + this.cid,
            _.bind(this._doValidateMinMaxInt, this)
        );
        this.model.addValidationTask(
            'is_pure_integer_validator_' + this.cid,
            _.bind(this._doValidateIntNumber, this)
        );
    },

    /**
     * @inheritdoc
     *
     * Unformats the integer based on userPreferences (grouping separator).
     * If we weren't able to parse the value, `undefined` is returned.
     *
     * @param {String} value the formatted value based on user preferences.
     * @return {Number|undefined} the unformatted value.
     */
    unformat: function(value) {
        value = app.utils.unformatNumberStringLocale(value, false);
        if (!this._isSafeInt(value)) {
            return value;
        }
        return parseFloat(value);
    },

    /**
     * @inheritdoc
     *
     * Formats the integer based on user preferences (grouping separator).
     * If the field definition has `disabled_num_format` as `true` the value
     * won't be formatted. Also, if the value isn't a finite integer it will
     * return `undefined`.
     *
     * @param {Number} value the integer value to format as per user
     *   preferences.
     * @return {String|undefined} the formatted value based as per user
     *   preferences.
     */
    format: function(value) {
        var numberGroupSeparator = '';
        var decimalSeparator = '';
        if (!this._isSafeInt(value)) {
            return value;
        }
        if (!this.def.disable_num_format) {
            numberGroupSeparator = app.user.getPreference('number_grouping_separator') || ',';
            decimalSeparator = app.user.getPreference('decimal_separator') || '.';
        }

        return app.utils.formatNumber(
            value, 0, 0,
            numberGroupSeparator,
            decimalSeparator,
            true
        );
    },

    /**
     * This validates int doesn't exceed min/max value defined in sugar config.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateMinMaxInt: function(fields, errors, callback) {
        var value = this.model.get(this.name);
        var minValue = this._minInt;
        var maxValue = this._maxInt;
        if (!_.isUndefined(app.config.sugarMinInt)) {
            minValue = Math.max(minValue, app.config.sugarMinInt);
        }
        if (!_.isUndefined(app.config.sugarMaxInt)) {
            maxValue = Math.min(maxValue, app.config.sugarMaxInt);
        }
        if (value < minValue) {
            errors[this.name] = {'minValue': minValue};
        } else if (value > maxValue) {
            errors[this.name] = {'maxValue': maxValue};
        }
        callback(null, fields, errors);
    },

    /**
     * This validates int number.
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * */
    _doValidateIntNumber: function(fields, errors, callback) {
        if (this.model) {
            var value = this.model.get(this.name);
        }

        if (!this._isInteger(value)) {
            errors[this.name] = {'integer': true};
        }
        callback(null, fields, errors);
    },

    /**
     * Checks if value is pure integer.
     * @param {string|number} value
     * @return {boolean}
     * */
    _isInteger: function(value) {
        return !value || parseInt(value) === parseFloat(value);
    },

    /**
     * Checks if value is too big to format/unformat.
     *
     * @param {string|number} value
     * @return {boolean}
     * @private
     */
    _isSafeInt: function(value) {
        return (_.isFinite(value) && this._minInt <= value && value <= this._maxInt);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('min_max_int_validator_' + this.cid);
        this._super('_dispose');
    },
}) },
"editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EditablelistbuttonField
 * @alias SUGAR.App.view.fields.BaseEditablelistbuttonField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Editablelistbutton Field (base) 

    events: {
        'click [name=inline-save]' : 'saveClicked',
        'click [name=inline-cancel]' : 'cancelClicked'
    },
    extendsFrom: 'ButtonField',
    initialize: function(options) {
        this._super("initialize", [options]);
        if(this.name === 'inline-save') {
            this.model.off("change", null, this);
            this.model.on("change", function() {
                this.changed = true;
            }, this);
        }
    },
    _loadTemplate: function() {
        app.view.Field.prototype._loadTemplate.call(this);
        if(this.view.action === 'list' && _.indexOf(['edit', 'disabled'], this.action) >= 0 ) {
            this.template = app.template.getField('button', 'edit', this.module, 'edit');
        } else {
            this.template = app.template.empty;
        }
    },
    /**
     * Called whenever validation completes on the model being edited
     * @param {boolean} isValid TRUE if model is valid
     * @private
     */
    _validationComplete : function(isValid){
        if (!isValid) {
            this.setDisabled(false);
            return;
        }
        if (!this.changed) {
            this.cancelEdit();
            return;
        }

        this._save();
    },

    /**
     * Called when the model is successfully saved
     *
     * @param {Data.Bean} model The updated model
     * @private
     */
    _onSaveSuccess: function(model) {
        this.changed = false;
        this.view.toggleRow(model.id, false);
    },

    _save: function() {
        var self = this,
            options = {
                success: _.bind(this._onSaveSuccess, this),
                error: function(model, error) {
                    if (error.status === 409) {
                        app.utils.resolve409Conflict(error, self.model, function(model, isDatabaseData) {
                            if (model) {
                                if (isDatabaseData) {
                                    successCallback(model);
                                } else {
                                    self._save();
                                }
                            }
                        });
                    }
                },
                complete: function() {
                    // remove this model from the list if it has been unlinked
                    if (self.model.get('_unlinked')) {
                        self.collection.remove(self.model, { silent: true });
                        self.collection.trigger('reset');
                        self.view.render();
                    } else {
                        self.setDisabled(false);
                    }
                },
                lastModified: self.model.get('date_modified'),
                //Show alerts for this request
                showAlerts: {
                    'process': true,
                    'success': {
                        messages: app.lang.get('LBL_RECORD_SAVED', self.module)
                    }
                },
                relate: this.model.link ? true : false
            };

        options = _.extend({}, options, this.getCustomSaveOptions(options));

        this.model.save({}, options);
    },

    getCustomSaveOptions: function(options) {
        return {};
    },

    /**
     * Initiates validation on the model with fields that the user has edit
     * access to.
     */
    saveModel: function() {
        this.setDisabled(true);

        var fieldsToValidate = this.view.getFields(this.module, this.model);
        var erasedFields = this.model.get('_erased_fields');
        fieldsToValidate = _.pick(fieldsToValidate, function(fieldInfo, fieldName) {
            return app.acl.hasAccessToModel('edit', this.model, fieldName) &&
                (!_.contains(erasedFields, fieldName) || this.model.get(fieldName) || fieldInfo.id_name);
        }, this);
        this.model.doValidate(fieldsToValidate, _.bind(this._validationComplete, this));
    },

    cancelEdit: function() {
        if (this.isDisabled()) {
            this.setDisabled(false);
        }
        this.changed = false;
        this.model.revertAttributes();
        this.view.clearValidationErrors();
        this.view.toggleRow(this.model.id, false);

        // trigger a cancel event across the parent context so listening components
        // know the changes made in this row are being reverted
        if(this.context.parent) {
            this.context.parent.trigger('editablelist:cancel', this.model);
        }
    },
    saveClicked: function(evt) {
        if (!$(evt.currentTarget).hasClass('disabled')) {
            this.saveModel();
        }
    },
    cancelClicked: function(evt) {
        this.cancelEdit();
    }
}) },
"repeat-days": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Repeat Days of Month is a custom field for Meetings/Calls used to set
 * day(s) of the month for a Monthly recurring record.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatDaysField
 * @alias SUGAR.App.view.fields.BaseRepeatDaysField
 * @extends View.Fields.Base.Field
 */
({
	// Repeat-days Field (base) 

    /**
     * The Enum field with selected dates
     * @type {View.Fields.Base.EnumField}
     */
    select2Field: undefined,

    /**
     * Array of currently selected dates
     * @type {Array}
     */
    selectedDates: undefined,

    /**
     * The select2/enum field sfid
     * @type {String}
     */
    select2SfId: '',

    /**
     * AppListStrings repeat_days_dom values for the template
     * @type {Array}
     */
    datesDom: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.datesDom = app.lang.getAppListStrings('repeat_days_dom');

        this.model.addValidationTask(
            'repeat_days_validator_' + this.cid,
            _.bind(this._doValidateRepeatDays, this)
        );

        this.selectedDates = this.model.get(this.name) || [];
        if (_.isString(this.selectedDates)) {
            this.selectedDates = this.format(this.selectedDates);
        }
    },

    /**
     * @inheritdoc
     */
    setMode: function(name) {
        this._super('setMode', [name]);
        if (!this.model.isNew() && this.action === 'edit') {
            this.getSelect2Field().setMode(name);
            // if this is a create view we don't need to set the options on the model here
            this._updateSelect2SelectedDates(true, false);
            // update calendar dates with a selected class
            this.decorateCalendarDates();
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function(model, value) {
                if (this.action === 'edit' || this.action === 'detail') {
                    var dates = this.model.get(this.name);
                    if (dates) {
                        this.selectedDates = dates;
                        if (_.isString(this.selectedDates)) {
                            this.selectedDates = this.format(this.selectedDates);
                            this.render();
                        }
                    }
                }
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.getSelect2Field().setElement(this.$('div[sfuuid="' + this.select2SfId + '"]'));
        if (_.isEmpty(this.select2Field.items) && this.selectedDates.length) {
            this._updateSelect2SelectedDates(true, false);
        } else {
            this.select2Field.render();
        }

        if (this.action === 'edit' && this.selectedDates.length) {
            this.decorateCalendarDates();
        }

        this._addDateFieldEvents();
    },

    /**
     * Model days format is a string of comma separated numbers (1-31)
     * Select2 needs an array of these values
     *
     * @inheritdoc
     */
    format: function(value) {
        if (!_.isString(value)) {
            return value;
        } else if (value === '') {
            return [];
        } else {
            return _.sortBy(value.split(','), function(num) {
                return parseInt(num);
            });
        }
    },

    /**
     * Select2 array of numeric strings to model comma separated number format
     *
     * @inheritdoc
     */
    unformat: function(value) {
        return _.isArray(value) ? value.join(',') : value;
    },

    /**
     * Adds the click event listeners to the days in the dropdown
     * and adds a change listener to the select2 field
     *
     * @protected
     */
    _addDateFieldEvents: function() {
        this.$('.multi-column-dropdown a[id^="repeat-on-day-"]').on('click', _.bind(this._onDatePicked, this));
        this.select2Field.$el.on('change', _.bind(this._onSelect2Change, this));
        /**
         * Disables dropdown for `Select2`
         */
        this.select2Field.$el.on('select2-opening', _.bind(function(evt) {
            evt.preventDefault();
            this.$('[data-toggle=dropdown]').dropdown('toggle');
        }, this));
    },

    /**
     * Adds the `selected` class to each calendar item in `this.selectedDates`
     */
    decorateCalendarDates: function() {
        if (this.selectedDates.length) {
            _.each(this.selectedDates, function(item) {
                this.$('#repeat-on-day-' + item).addClass('selected');
            }, this);
        }
    },

    /**
     * Handles when a day is picked from the dropdown
     *
     * @param {jQuery.Event} evt The `click` event from the day
     * @protected
     */
    _onDatePicked: function(evt) {
        var $target = $(evt.target),
            isSelected = $target.hasClass('selected'),
            val = $target.text();

        $(evt.target).toggleClass('selected');

        if (isSelected) {
            this.selectedDates = _.without(this.selectedDates, val);
        } else {
            this.selectedDates.push(val);
        }

        this._updateSelect2SelectedDates();
    },

    /**
     * Handles when the select2 field changes from removing an item
     *
     * @param {Select2.Event} evt The Select2 `change` Event
     * @protected
     */
    _onSelect2Change: function(evt) {
        if (evt.removed) {
            this.$('#repeat-on-day-' + evt.removed.id).removeClass('selected');
            this.selectedDates = _.without(this.selectedDates, evt.removed.id);

            if (this.selectedDates.length) {
                this._updateSelect2SelectedDates(false);
            } else {
                this._setSelectedDatesOnModel(null);
                this.select2Field.items = null;
            }
        }
    },

    /**
     * Parses `this.selectedDates` Array into an Object for the select2
     *
     * @param {boolean} [renderField] Optional - True if the select2's _render should be called
     * @param {boolean} [setModelOptions] Optional - True if we should update this.model with the options
     * @protected
     */
    _updateSelect2SelectedDates: function(renderField, setModelOptions) {
        renderField = _.isUndefined(renderField) ? true : renderField;
        setModelOptions = _.isUndefined(setModelOptions) ? true : setModelOptions;

        // sort numerically
        this.selectedDates = _.sortBy(this.selectedDates, function(val) {
            return parseInt(val);
        });

        var items = {};
        _.each(this.selectedDates, function(item) {
            items[item] = item;
        }, this);

        if (setModelOptions) {
            this._setSelectedDatesOnModel(this.selectedDates);
        }
        this.select2Field.items = items;

        if (renderField) {
            this.select2Field.render();
        }
    },

    /**
     * Sets the model with the selected dates in `items`
     *
     * @param {String|Array} items The selected dates to set on the model, converts to String if sent as Array
     * @protected
     */
    _setSelectedDatesOnModel: function(items) {
        if (_.isArray(items)) {
            items = items.toString();
        }

        this.model.set(this.name, items);
    },

    /**
     * If `this.select2Field` has not been created yet, it creates the enum field and returns it,
     * otherwise it just returns the already created field
     *
     * @returns {View.Fields.Base.EnumField}
     */
    getSelect2Field: function() {
        if (this.select2Field) {
            this.select2Field.setMode(this.action);
            return this.select2Field;
        }

        var select2Defs = _.clone(this.def);
        select2Defs.type = 'enum';
        this.select2Field = app.view.createField({
            def: select2Defs,
            model: this.model,
            viewName: 'detail',
            view: this.view
        });
        this.select2SfId = this.select2Field.sfId;
        this.select2Field.setMode(this.action);

        return this.select2Field;
    },

    /**
     * Custom required validator for the `repeat_days` field.
     *
     * This validates `repeat_days` based on the value of `repeat_selector` -
     * if "Each", repeat days must be specified
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatDays: function(fields, errors, callback) {
        var repeatSelector = this.model.get('repeat_selector'),
            repeatDays = this.model.get(this.name);

        if (repeatSelector === 'Each' && (!_.isString(repeatDays) || repeatDays.length < 1)) {
            errors[this.name] = {'required': true};
        }
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_days_validator_' + this.cid);
        this.$('.multi-column-dropdown a[id^="repeat-on-day-"]').off('click');
        // removes 'change' and 'select2-opening' events
        this.select2Field.$el.off();
        this.select2Field.dispose();

        this._super('_dispose');
    }
}) },
"overdue-badge": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EventStatusField is a field for Meetings/Calls that shows a date field as a badge when event is overdue
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.OverdueBadgeField
 * @alias SUGAR.App.view.fields.BaseOverdueBadgeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Overdue-badge Field (base) 

    _render: function() {
        var now = new Date(),
            due_date = this.model.get(this.name),
            date = new Date(due_date);
        this.model.set('overdue', !_.isNull(due_date) && date < now);
        this._super('_render');
    }
}) },
"preview-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Preview-button Field (base) 

    extendsFrom: 'RowactionField',

    /**
     * True if the preview button is for a BWC module, false if not
     * @property {boolean}
     */
    isBwcEnabled: undefined,

    /**
     * Holds the proper tooltip label key
     */
    tooltip: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var fieldModule = options.model.get('_module');
        this.isBwcEnabled = app.metadata.getModule(fieldModule).isBwcEnabled;

        this._super('initialize', [options]);

        if(this.isBwcEnabled) {
            this.tooltip = 'LBL_PREVIEW_BWC_TOOLTIP';
        } else {
            this.tooltip = this.def.tooltip;
        }
    }
}) },
"textarea": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TextareaField
 * @alias SUGAR.App.view.fields.BaseTextareaField
 * @extends View.Fields.Base.BaseField
 */
({
	// Textarea Field (base) 

    /**
     * @inheritdoc
     */
    fieldTag : 'textarea',

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} max_display_chars The maximum number of characters to be
     *   displayed before truncating the field.
     * - {Boolean} collapsed Defines whether or not the textarea detail view
     *   should be collapsed on initial render.
     *
     *     // ...
     *     'settings' => array(
     *         'max_display_chars' => 50,
     *         'collapsed' => false
     *         //...
     *     ),
     *     //...
     *
     * @protected
     * @type {Object}
     */
    _defaultSettings: {
        max_display_chars: 450,
        collapsed: true
    },

    /**
     * State variable that keeps track of whether or not the textarea field
     * is collapsed in detail view.
     *
     * @type {Boolean}
     */
    collapsed: undefined,

    /**
     * Settings after applying metadata settings on top of
     * {@link View.Fields.BaseTextareaField#_defaultSettings default settings}.
     *
     * @protected
     */
    _settings: {},

    /**
     * @inheritdoc
     */
    events: {
        'click [data-action=toggle]': 'toggleCollapsed'
    },

    /**
     * @inheritdoc
     *
     * Initializes settings on the field by calling
     * {@link View.Fields.BaseTextareaField#_initSettings _initSettings}.
     * Also sets {@link View.Fields.BaseTextareaField#collapsed collapsed}
     * to the value in `this._settings.collapsed` (either default or metadata).
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initSettings();
        this.collapsed = this._settings.collapsed;
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Fields.BaseTextareaField} Instance of this field.
     * @protected
     */
    _initSettings: function() {
        this._settings = _.extend({},
            this._defaultSettings,
            this.def && this.def.settings || {}
        );
        return this;
    },

    /**
     * @inheritdoc
     *
     * Prevents editing the textarea field in a list view.
     *
     * @param {String} name The mode to set the field to.
     */
    setMode: function(name) {
        // FIXME: This will be updated pending changes to fields in sidecar,
        // see SC-2608, SC-2776.
        // FIXME: Check on 'merge-duplicates' to identify editable fields
        // see SC-3325
        var isList = (this.tplName === 'list') && _.contains(['edit', 'disabled'], name),
            mode = isList && this.view.name !== 'merge-duplicates' ? this.tplName : name;
        this._super('setMode', [mode]);
    },

    /**
     * @inheritdoc
     *
     * Formatter that always returns the value set on the textarea field. Sets
     * a `short` value for a truncated representation, if the lenght of the
     * value on the field exceeds that of `max_display_chars`. The return value
     * can either be a string, or an object such as {long: 'abc'} or
     * {long: 'abc', short: 'ab'}, for example.
     *
     * @param {String} value The value set on the textarea field.
     * @return {String|Object} The value set on the textarea field.
     */
    format: function(value) {
        // If the tplName is 'edit' then value needs to be a string. Otherwise 
        // send back the object containing `value.long` and, if necessary,
        // `value.short`.
        if (this.tplName !== 'edit') {
            var max = this._settings.max_display_chars;
            value = {long: value};

            if (value.long && value.long.length > max) {
                value.short = value.long.substr(0, max).trim();
            }
        }

        return value;
    },

    /**
     * Toggles the field between displaying the truncated `short` or `long`
     * value for the field, and toggles the label for the 'more/less' link.
     */
    toggleCollapsed: function() {
        this.collapsed = !this.collapsed;
        this.render();
    },

    /**
     * Overrides default implementation so that whitespaces won't be stripped.
     */
    unformat: function(value) {
        return value;
    }
}) },
"repeat-dow": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Repeat Day of Week is a custom field for Meetings/Calls used to set
 * days of the week for a Weekly recurring record.
 *
 * FIXME: This component will be moved out of clients/base folder as part of MAR-2274 and SC-3593
 *
 * @class View.Fields.Base.RepeatDowField
 * @alias SUGAR.App.view.fields.BaseRepeatDowField
 * @extends View.Fields.Base.EnumField
 */
({
	// Repeat-dow Field (base) 

    extendsFrom: 'EnumField',

    defaultOnUndefined: false, //custom default behavior defined below

    /**
     * @inheritdoc
     *
     * Set default value for this field and
     * add validation (required if `repeat_type` is weekly)
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'enum';

        this.def['default'] = this.getDefaultDayOfWeek();

        this.model.addValidationTask(
            'repeat_dow_validator_' + this.cid,
            _.bind(this._doValidateRepeatDow, this)
        );
    },

    /**
     * Get the default day of week (current day of the week)
     *
     * @return {String} Day of the week
     */
    getDefaultDayOfWeek: function() {
        var isoDayOfWeek = app.date().isoWeekday(),
            sugarDayOfWeek = (isoDayOfWeek === 7) ? 0 : isoDayOfWeek;
        return sugarDayOfWeek.toString();
    },

    /**
     * @inheritdoc
     *
     * Model day of week format is a string of numeric characters ('1'-'7')
     * Select2 needs an array of these numeric strings
     */
    format: function(value) {
        return (_.isString(value)) ? value.split('').sort() : value;
    },

    /**
     * @inheritdoc
     *
     * Select2 array of numeric strings to Model numeric string format
     */
    unformat: function(value) {
        return (_.isArray(value)) ? value.sort().join('') : value;
    },

    /**
     * Custom required validator for the `repeat_dow` field.
     *
     * This validates `repeat_dow` based on the value of `repeat_type` -
     * if Weekly repeat type, repeat day of week must be specified
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
    _doValidateRepeatDow: function(fields, errors, callback) {
        var repeatType = this.model.get('repeat_type'),
            repeatDow = this.model.get(this.name);

        if (repeatType === 'Weekly' && (!_.isString(repeatDow) || repeatDow.length < 1)) {
            errors[this.name] = {'required': true};
        }
        callback(null, fields, errors);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.removeValidationTask('repeat_dow_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ChartField
 * @alias SUGAR.App.view.fields.BaseChartField
 * @extends View.Fields.Base.BaseField
 */
({
	// Chart Field (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.chart = null;
        this.chart_loaded = false;
        this.chartType = '';
        this.locale = SUGAR.charts.getSystemLocale();
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:rawChartData', function(model, newChartData) {
            // make sure this.model.get('rawChartData') is not null by checking that
            // the newChartData (data set for the model's rawChartData) is not null
            if (newChartData && this.model.get('rawChartData').values.length > 0) {
                this.displayNoData(false);
                // if the chart already exists, remove it before we generate the new one
                if (this.chart_loaded) {
                    this.$('#d3_' + this.cid + ' svg').remove();
                }
                this.generateD3Chart();
            } else {
                this.displayNoData(true);
            }
        }, this);
    },

    overflowHandler: function(distance) {
        var b = this.view.$el.parents().filter(function() {
            return $(this).css('overflow-y') === 'auto' || $(this).css('overflow-y') === 'scroll';
        }).first();

        b.scrollTop(b.scrollTop() - distance);
    },

    /**
     * Callback function on chart render complete.
     *
     * @param {Function} chart sucrose chart instance
     * @param {Object} params chart display parameters
     * @param {Object} data report data with properties and data array
     */
    chartComplete: function(chart, params, reportData, chartData) {
        this.chart = chart;
        this.chart_loaded = _.isFunction(chart.update);

        if (!this.chart_loaded) {
            return;
        }

        this.view.trigger('chart:complete', chart, params, reportData, chartData);
    },

    /**
     * Generate the D3 Chart Object
     */
    generateD3Chart: function() {
        var id = this.cid;
        var reportData = this.model.get('rawReportData');
        var chartData = this.model.get('rawChartData');
        var params = this.getChartParams(chartData); //NOTE: This is where groupType comes from
        var config = this.getChartConfig(chartData, params);

        var sugarChart = new loadSugarChart(id, chartData, [], config, params, _.bind(function(chart) {
            this.chartComplete(chart, params, reportData, chartData);
        }, this));

        // This event fires when a preview is closed.
        // We listen to this event to call the chart resize method
        // in case the window was resized while the preview was open.
        app.events.on('preview:close', function() {
            if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
                this.resize();
            }
        }, this);
        // This event fires when the dashlet is collapsed or opened.
        // We listen to this event to call the chart resize method
        // in case the window was resized while the dashlet was closed.
        this.view.layout.on('dashlet:collapse', function(collapse) {
            if (!collapse) {
                this.resize();
            }
        }, this);
        // This event fires when the dashlet is dragged and dropped.
        // We listen to this event to call the chart resize method
        // because the size of the dashlet can change in the dashboard.
        this.view.layout.context.on('dashlet:draggable:stop', function() {
            this.resize();
        }, this);
        // Resize chart on window resize.
        // This event also fires when the sidebar is collapsed or opened.
        // We listen to this event to call the chart resize method
        // in case the window was resized while the sidebar was closed.
        $(window).on('resize.' + this.sfId, _.debounce(_.bind(this.resize, this), 100));
        // Resize chart on print.
        this.handlePrinting('on');
        // This on click event is required to dismiss the dropdown legend
        this.$('.sc-chart').on('click', _.bind(function() {
            this.chart.dispatch.call('chartClick', this);
        }, this));
    },

    getChartParams: function(chartData) {
        var chartId = this.cid;
        var chartParams = this.model.get('rawChartParams') || {};
        // Get properties from rawChartData
        var properties = !_.isUndefined(chartData.properties) && Array.isArray(chartData.properties) ?
                chartData.properties[0] :
                {};
        // These params will be overriden the SugarCharts defaults
        var params = {
                chart_type: 'multibar',
                margin: {top: 0, right: 10, bottom: 10, left: 10},
                allowScroll: true,
                module: properties.base_module,
                overflowHandler: _.bind(this.overflowHandler, this),
                baseModule: properties.base_module
            };
        var state = this.context.get('chartState');

        if (!_.isEmpty(chartParams)) {
            params = _.extend(params, chartParams);
        }
        if (!_.isEmpty(state)) {
            params.state = state;
        }

        return params;
    },

    /**
     * Builds the chart config based on the type of chart
     * @return {Mixed}
     */
    getChartConfig: function(chartData, chartParams) {
        var data = chartData || this.model.get('rawChartData');
        var params = chartParams || this.model.get('rawChartParams');
        var chartConfig;
        var chartGroupType;

        // chartData artifact
        if (!_.isEmpty(chartData) && !_.isUndefined(chartData.properties)) {
            data.properties[0].type = params.chart_type;
        }

        switch (params.chart_type) {
            case 'pie chart':
                chartConfig = {
                    pieType: 'basic',
                    chartType: 'pieChart'
                };
                break;

            case 'line chart':
                chartConfig = {
                    lineType: 'grouped',
                    chartType: 'lineChart'
                };
                break;

            case 'funnel chart':
            case 'funnel chart 3D':
                chartConfig = {
                    funnelType: 'basic',
                    chartType: 'funnelChart'
                };
                break;

            case 'gauge chart':
                chartConfig = {
                    gaugeType: 'basic',
                    chartType: 'gaugeChart'
                };
                break;

            case 'stacked group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'barChart'
                };
                break;

            case 'group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'grouped',
                    chartType: 'barChart'
                };
                break;

            case 'bar chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'basic',
                    chartType: 'barChart'
                };
                break;

            case 'horizontal group by chart':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'stacked',
                    chartType: 'barChart'
                };
                break;

            case 'horizontal grouped bar chart':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'grouped',
                    chartType: 'barChart'
                };
                break;
            case 'vertical grouped bar chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'grouped',
                    chartType: 'barChart'
                };
                break;

            case 'horizontal bar chart':
            case 'horizontal':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'basic',
                    chartType: 'barChart'
                };
                break;

            default:
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'barChart'
                };
                break;
        }

        chartConfig.direction = app.lang.direction;

        // chartParams artifact
        chartGroupType = chartConfig.barType ||
            chartConfig.lineType ||
            chartConfig.pieType ||
            chartConfig.funnelType ||
            'basic';
        chartParams.dataType = chartGroupType === 'stacked' ? 'grouped' : chartGroupType;

        this.chartType = chartConfig.chartType;

        return chartConfig;
    },

    /**
     * Checks to see if the chart is available and is displayed before resizing
     */
    resize: function() {
        // If (this.chart_loaded && !this.sidebar_closed && !this.preview_open && !this.dashlet_collapsed) {
        if (!this.chart_loaded) {
            return;
        }
        // This handles the case of preview open and dashlet collapsed.
        // We don't need to handle the case of collapsed sidepane
        // because charts can resize when inside an invisible container.
        // It is being inside a display:none container that causes problems.
        if (!this.view.$el || !this.view.$el.is(':visible')) {
            return;
        }
        if (this.chart.render) {
            this.chart.render();
        } else {
            this.chart.update();
        }
    },

    /**
     * Attach and detach a resize method to the print event
     * @param {string} The state of print handling.
     */
    handlePrinting: function(state) {
        var self = this,
            mediaQueryList = window.matchMedia && window.matchMedia('print'),
            pausecomp = function(millis) {
                // www.sean.co.uk
                var date = new Date(),
                    curDate = null;
                do {
                    curDate = new Date();
                } while (curDate - date < millis);
            },
            printResize = function(mql) {
                if (mql.matches) {
                    if (!_.isUndefined(self.chart.legend) && _.isFunction(self.chart.legend.showAll)) {
                        self.chart.legend.showAll(true);
                    }
                    self.chart.width(640).height(320).update();
                    pausecomp(200);
                } else {
                    browserResize();
                }
            },
            browserResize = function() {
                if (!_.isUndefined(self.chart.legend) && _.isFunction(self.chart.legend.showAll)) {
                    self.chart.legend.showAll(false);
                }
                self.chart.width(null).height(null).update();
            };

        if (state === 'on') {
            if (window.matchMedia) {
                mediaQueryList.addListener(printResize);
            } else if (window.attachEvent) {
                window.attachEvent('onbeforeprint', printResize);
                window.attachEvent('onafterprint', browserResize);
            } else {
                window.onbeforeprint = printResize;
                window.onafterprint = browserResize;
            }
        } else {
            if (window.matchMedia) {
                mediaQueryList.removeListener(printResize);
            } else if (window.detachEvent) {
                window.detachEvent('onbeforeprint', printResize);
                window.detachEvent('onafterprint', browserResize);
            } else {
                window.onbeforeprint = null;
                window.onafterprint = null;
            }
        }
    },

    /**
     * Toggle display of dashlet content and NoData message
     * @param {boolean} state The visibility state of the dashlet content.
     */
    displayNoData: function(state) {
        this.$('[data-content="chart"]').toggleClass('hide', state);
        this.$('[data-content="nodata"]').toggleClass('hide', !state);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.view && this.view.layout) {
            this.view.layout.off(null, null, this);
        }
        if (this.view && this.view.layout) {
            this.view.layout.context.off(null, null, this);
        }
        this.$('.sc-chart').off('click');
        $(window).off('resize.' + this.sfId);
        this.handlePrinting('off');

        app.view.Field.prototype._dispose.call(this);
    }
}) },
"iframe": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.IframeField
 * @alias SUGAR.App.view.fields.BaseIframeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Iframe Field (base) 

    /**
     * @inheritdoc
     *
     * The direction for this field should always be `ltr`.
     */
    direction: 'ltr',

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        if (this.tplName === 'disabled') {
            this.$(this.fieldTag).attr('disabled', 'disabled');
        }
    },

    /**
     * @inheritdoc
     */
    unformat: function(value) {
        value = (value !== '' && value != 'http://') ? value.trim() : '';
        return value;
    },

    /**
     * @inheritdoc
     *
     * Formatter for the iframe field. If the iframe field definition is
     * configured with a generated url (`this.def.gen`) by another field, those
     * field values (defined in curly braces) are parsed from the model and set
     * on the value to be returned. Finally, if the value doesn't contain
     * 'http://' or 'https://', it is prepended on the value before being
     * returned.
     *
     * @param {String} value The value set on the iframe field.
     * @return {String} The formatted iframe value.
     */
    format: function(value) {
        if (_.isEmpty(value)) {
            // Name conflict with iframe's default value def and the list view's
            // default column flag
            value = _.isString(this.def['default']) ? this.def['default'] : undefined;
        }

        if (this.def.gen == '1') {
            var regex = /{(.+?)}/,
                result = null;
            do {
                result = regex.exec(value);
                if (result) {
                    value = value.replace(result[0], this.model.get(result[1]));
                }
            } while (result);
        }

        if (_.isString(value) && !value.match(/^(http|https):\/\//)) {
            value = 'http://' + value.trim();
        }
        return value;
    }
}) },
"language": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.LanguageField
 * @alias SUGAR.App.view.fields.BaseLanguageField
 * @extends View.Fields.Base.EnumField
 */
({
	// Language Field (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.model.setDefault(this.name, this._getDefaultOption());
    },

    /**
     * Ensure we load enum templates
     *
     * @override
     * @private
     */
    _loadTemplate: function() {
        this.type = 'enum';
        app.view.Field.prototype._loadTemplate.call(this);
        this.type = 'language';
    },

    /**
     * @inheritdoc
     * If no value, set the application default language as default value.
     * If edit mode, set the application default language on the model.
     */
    format: function(value) {
        if (!this.items[value]) {
            value = this._getDefaultOption();
            this.model.set(this.name, value);
        }

        return value;
    },

    /**
     * @override
     *
     * @return {string}  The default language as the default value
     */
    _getDefaultOption: function(optionsKeys) {
        return app.lang.getDefaultLanguage();
    },
}) }
}}
,
"views": {
"base": {
"sales-pipeline": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Sales-pipeline View (base) 

    results: {},
    chart: {},
    plugins: ['Dashlet', 'Chart'],

    /**
     * Is the forecast Module setup??
     */
    forecastSetup: 0,

    /**
     * Track if current user is manager.
     */
    isManager: false,

    /**
     * @inheritDoc
     */
    initialize: function(options) {
        this.isManager = app.user.get('is_manager');
        this._initPlugins();
        this._super('initialize', [options]);

        // check to make sure that forecast is configured
        var forecastConfig = app.metadata.getModule('Forecasts', 'config') || {};
        this.forecastSetup = forecastConfig['is_setup'] || 0;
        this.userCurrencyPreference = app.user.getPreference('currency_id');
        this.locale = SUGAR.charts.getUserLocale();
        // create deep copy for tooltip temp use, etc.
        // it will be set to chart.locality() after instantiation
        this.locality = {};
        this.tooltipTemplate = app.template.getView(this.name + '.tooltiptemplate');
    },

    /**
     * {@inheritDoc}
     */
    initDashlet: function(view) {
        var salesStageLabels = app.lang.getAppListStrings('sales_stage_dom');

        if (!this.isManager && this.meta.config) {
            // FIXME: Dashlet's config page is rendered from meta.panels directly.
            // See the "dashletconfiguration-edit.hbs" file.
            this.meta.panels = _.chain(this.meta.panels).filter(function(panel) {
                panel.fields = _.without(panel.fields, _.findWhere(panel.fields, {name: 'visibility'}));
                return panel;
            }).value();
        }

        // get the current timeperiod
        if (this.forecastSetup) {
            app.api.call('GET', app.api.buildURL('TimePeriods/current'), null, {
                success: _.bind(function(currentTP) {
                    this.settings.set({'selectedTimePeriod': currentTP.id}, {silent: true});
                    this.layout.loadData();
                }, this),
                error: _.bind(function() {
                    // Needed to catch the 404 in case there isnt a current timeperiod
                }, this),
                complete: view.options ? view.options.complete : null
            });
        } else {
            this.settings.set({'selectedTimePeriod': 'current'}, {silent: true});
        }

        this.chart = sucrose.charts.funnelChart()
            .showTitle(false)
            .tooltips(true)
            .margin({top: 0})
            .direction(app.lang.direction)
            .tooltipContent(_.bind(function(eo, properties) {
                var point = {};
                var key = this.chart.getKey()(eo);
                var value = this.chart.getValue()(eo);
                var count = this.chart.getCount()(eo);
                point.label = salesStageLabels ? salesStageLabels[key] || key : key;
                point.value = this._formatValue(value);
                point.percent = sucrose.utility.numberFormatPercent(value, properties.total, this.locality);
                point.count = sucrose.utility.numberFormat(count, 0, false, this.locality);
                return this.tooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .colorData('class', {step: 2})
            .fmtValue(_.bind(function(d) {
                var y = d.value || (isNaN(d) ? 0 : d);
                return this._formatValue(y, 0);
            }, this))
            .strings({
                legend: {
                    close: app.lang.get('LBL_CHART_LEGEND_CLOSE'),
                    open: app.lang.get('LBL_CHART_LEGEND_OPEN')
                },
                noData: app.lang.get('LBL_CHART_NO_DATA'),
                noLabel: app.lang.get('LBL_CHART_NO_LABEL')
            })
            .locality(this.locale);

        this.locality = this.chart.locality();
    },

    /**
     * This method is called by the chart model in initDashlet
     *
     * @param {number} d  The numeric value to be formatted
     * @param {number} precision  The level of precision to apply
     * @return {string}  A number formatted with current user settings
     * @private
     */
    _formatValue: function(d, precision) {
        return app.currency.formatAmountLocale(d, this.userCurrencyPreference, precision);
    },

    /**
     * Initialize plugins.
     * Only manager can toggle visibility.
     *
     * @return {View.Views.BaseForecastPipeline} Instance of this view.
     * @protected
     */
    _initPlugins: function() {
        if (this.isManager) {
            this.plugins = _.union(this.plugins, [
                'ToggleVisibility'
            ]);
        }
        return this;
    },

    /**
     * {@inheritDoc}
     */
    bindDataChange: function() {
        this.settings.on('change', function(model) {
            // reload the chart
            if (this.$el && this.$el.is(':visible')) {
                this.loadData({});
            }
        }, this);
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }
        // Clear out the current chart before a re-render
        this.$('svg#' + this.cid).children().remove();

        d3sugar.select('svg#' + this.cid)
            .datum(this.results)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.update);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * @inheritdoc
     *
     * Additional logic on switch visibility event.
     */
    visibilitySwitcher: function() {
        var activeVisibility;
        if (!this.isManager) {
            return;
        }
        activeVisibility = this.getVisibility();
        this.$el.find('[data-action=visibility-switcher]')
            .attr('aria-pressed', function() {
                return $(this).val() === activeVisibility;
            });
    },

    hasChartData: function() {
        return !_.isEmpty(this.results) && this.results.data && this.results.data.length > 0;
    },

    /**
     * @inheritDoc
     */
    loadData: function(options) {
        var timeperiod = this.settings.get('selectedTimePeriod');
        if (timeperiod) {
            var oppsConfig = app.metadata.getModule('Opportunities', 'config');

            if (oppsConfig) {
                var oppsViewBy = oppsConfig['opps_view_by'];
            } else {
                this.results = {};
                this.renderChart();

                return false;
            }

            var url_base = oppsViewBy + '/chart/pipeline/' + timeperiod + '/';

            if (this.isManager) {
                url_base += this.getVisibility() + '/';
            }
            var url = app.api.buildURL(url_base);
            app.api.call('GET', url, null, {
                success: _.bind(function(o) {
                    if (o && o.data) {
                        var salesStageLabels = app.lang.getAppListStrings('sales_stage_dom');

                        // update sales stage labels to translated strings
                        _.each(o.data, function(dataBlock) {
                            if (dataBlock && dataBlock.key && salesStageLabels && salesStageLabels[dataBlock.key]) {
                                dataBlock.key = salesStageLabels[dataBlock.key];
                            }

                        });
                    }
                    this.results = {};
                    this.results = o;
                    this.renderChart();
                }, this),
                error: _.bind(function(o) {
                    this.results = {};
                    this.renderChart();
                }, this),
                complete: options ? options.complete : null
            });
        }
    },

    /**
     * @inheritDoc
     */
    unbind: function() {
        this.settings.off('change');
        this._super('unbind');
    }
}) },
"dashletselect-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletselectHeaderpaneView
 * @alias SUGAR.App.view.views.BaseDashletselectHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Dashletselect-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        "click a[name=cancel_button]": "close"
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //shortcut keys
        app.shortcuts.register({
            id: 'Dashlet:Select:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.click();
                }
            }
        });
    },

    /**
     * Closes the drawer.
     */
    close: function() {
        app.drawer.close();
    }
}) },
"sweetspot-config-list-row": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotConfigListRowView
 * @alias SUGAR.App.view.views.BaseSweetspotConfigListRowView
 * @extends View.View
 */
({
	// Sweetspot-config-list-row View (base) 

    tagName: 'tr',

    className: 'config-list-row',

    events: {
        'click [data-action=add]': 'addRow',
        'click [data-action=remove]': 'removeRow'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.model = app.data.createBean();
        this._super('initialize', [options]);
        this.prepareActionDropdown();
        this.collection.add(options.model);
    },

    /**
     * This method adds all possible Sweet Spot actions to the `action` enum
     * field, so they can be configured by the user.
     */
    prepareActionDropdown: function() {
        var field = _.find(this.meta.fields, function(field) {
            return field.name === 'action';
        });
        var actions = app.metadata.getSweetspotActions();
        var options = {};
        _.each(actions, function(action, id) {
            options[id] = action.name;
        });
        field.options = options;
    },

    /**
     * Adds a {@link View.Views.Base.SweetspotConfigListRowView row view} to the
     * layout.
     */
    addRow: function() {
        this.context.trigger('sweetspot:config:addRow', this);
    },

    /**
     * Removes and disposes this row view from the
     * {@link View.Views.Base.SweetspotConfigListLayout list layout}
     */
    removeRow: function() {
        this.context.trigger('sweetspot:config:removeRow', this);
    }
}) },
"saved-reports-chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SavedReportsChartView
 * @alias SUGAR.App.view.views.BaseSavedReportsChartView
 * @extends View.View
 */
({
	// Saved-reports-chart View (base) 

    plugins: ['Dashlet'],

    events: {
        'click a[name=editReport]': 'editSavedReport'
    },

    /**
     * @inheritdoc
     */
    initDashlet: function(view) {
        // check if we're on the config screen
        if (this.meta.config) {
            this.meta.panels = this.dashletConfig.dashlet_config_panels;
        } else {
            var autoRefresh = this.settings.get('auto_refresh');
            if (autoRefresh > 0) {
                if (this.timerId) {
                    clearTimeout(this.timerId);
                }

                this._scheduleReload(autoRefresh * 1000 * 60);
            }
        }
    },

    /**
     * Schedules chart data reload
     *
     * @param {Number} delay Number of milliseconds which the reload should be delayed for
     * @private
     */
    _scheduleReload: function(delay) {
        this.timerId = setTimeout(_.bind(function() {
            this.context.resetLoadFlag();
            this.loadData({
                success: function() {
                    this._scheduleReload(delay);
                }
            });
        }, this), delay);
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // Holds report data from the server's endpoint once we fetch it
        this.reportData = app.data.createBean();
        this.reportOptions = [];
        this._super('initialize', [options]);
        this.on('chart:complete', this.chartComplete, this);
    },

    /**
     * Route to the bwc edit view of the currently selected Saved Report. If User clicks 'save' or 'cancel' or 'delete'
     * from there, return the user to the current page.
     *
     * @deprecated
     */
    editSavedReport: function() {
        app.logger.warn('View.Views.Base.SavedReportsChartView#editSavedReport' +
            'has been deprecated since 8.0.0.0 and will be removed in a future release');
        var currentTargetId = this.dashModel.get('saved_report_id'),
            params = {
                dashletEdit: 1
            },
            route = app.bwc.buildRoute('Reports', currentTargetId, 'ReportsWizard', params);

        //If this button was clicked too early, the saved_report_id may not be populated. Then we want to return
        //because moving on will result in a php error
        if (!currentTargetId) {
            return;
        }
        app.alert.show('navigate_confirmation', {
            level: 'confirmation',
            messages: 'LBL_NAVIGATE_TO_REPORTS',
            onConfirm: _.bind(function() {
                //Save current location to this so we can use it in the event listener
                this.currentLocation = Backbone.history.getFragment();

                //Add event listener for when the user finishes up the edit
                $(window).one('dashletEdit', _.bind(this.postEditListener, this));

                //Once we've successfully routed to the dashletEdit location,
                //any successive route should be checked. If the user moves away from the edit without
                //either cancelling or finishing the edit, we should forget that we have to come back to the current location
                var dashletEditVisited = false;
                app.router.on('route', function() {
                    var routeLocation = Backbone.history.getFragment();
                    if (routeLocation.indexOf('dashletEdit=1') >= 0) {
                        dashletEditVisited = true;
                    }
                    if (routeLocation.indexOf('dashletEdit=1') < 0 && dashletEditVisited) {
                        app.router.off('route');
                        $(window).off('dashletEdit');
                    }
                });

                //Go to edit page
                app.router.navigate(route, {trigger: true});
            }, this)
        });
    },

    /**
     * Call after the user is done editing the saved report. Return the user to the page that was stored when the
     * event was set
     *
     * @param {Object} jquery event
     */
    postEditListener: function(event) {
        //Go back from whence we came
        if (this.currentLocation) {
            app.router.navigate(this.currentLocation, {trigger: true});
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.meta.config) {
            this.settings.on('change:saved_report_id', function(model) {
                var reportId = model.get('saved_report_id');
                var options;
                if (_.isEmpty(reportId)) {
                    return;
                }
                options = {
                    success: function(data) {
                        var label;
                        this.setChartParams(data, true);
                        // set the title of the dashlet to the report title
                        label = this.$('[name="label"]');
                        if (label.length) {
                            label.val(this.settings.get('label'));
                        }
                    }
                };
                this.getSavedReportById(reportId, options);
            }, this);

            this.settings.on('change:chart_type', function(model) {
                // reset settings xAxisLabel because of line chart
                var reportData = this.reportData.get('rawReportData');
                var chartData = this.reportData.get('rawChartData');
                var axisLabel;
                // report might no be loaded yet
                if (reportData && chartData) {
                    axisLabel = this._getXaxisLabel(
                        reportData.group_defs,
                        chartData.properties[0],
                        model.get('chart_type')
                    );
                    model.set('x_axis_label', axisLabel);
                }
                // toggle display of chart display option controls based on chart type
                this._toggleChartFields();
            }, this);
        }
    },

    /**
     * Check acls to show/hide 'Edit Selected Report' link
     *
     * @deprecated
     */
    updateEditLink: function(reportId) {
        app.logger.warn('View.Views.Base.SavedReportsChartView#updateEditLink' +
            'has been deprecated since 8.0.0.0 and will be removed in a future release');

        var acls = this.reportAcls[reportId || this.settings.get('saved_report_id')],
            showEditLink = !acls || acls['edit'] !== 'no';
        this.$('[name="editReport"]').toggle(showEditLink);
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        options = options || {};
        var reportId = this.settings.get('saved_report_id');

        if (!_.isEmpty(reportId)) {
            // set callback for successful get of report data in getSavedReportById()
            _.extend(options, {
                success: _.bind(function(data) {
                    this.setChartParams(data, false);
                }, this)
            });
            this.getSavedReportById(reportId, options);
        }
    },

    getDefaultSettings: function() {
        // By default, settings only has: label, type, config, module
        // Module is normally null so we want to rehit that
        var settings = _.clone(this.settings.attributes);
        var defaults = {
                allowScroll:     true,
                auto_refresh:    0,
                colorData:       'class',
                config:          true,
                hideEmptyGroups: true,
                reduceXTicks:    true,
                rotateTicks:     true,
                show_controls:   false,
                show_title:      false,
                show_x_label:    false,
                show_y_label:    false,
                showValues:      0,
                staggerTicks:    true,
                wrapTicks:       true,
                x_axis_label:    '',
                y_axis_label:    ''
            };
        return _.defaults(settings, defaults);
    },

    /**
     * Process the chart data from the server
     *
     * @param {Object|String} serverData The Report Data from the server
     * @param {Boolean} [update] Is this an update to the report?
     */
    setChartParams: function(serverData, update) {
        var updated;
        var data;
        var properties;
        var config;
        var params;
        var settings;
        var chartType;

        // only called by bindDataChange when the report id is changed in config panel
        if (!serverData.reportData || !serverData.chartData) {
            if (!this.meta.config && this.chartField) {
                this.chartField.displayNoData(true);
            }
            return;
        }
        updated = _.isUndefined(update) ? false : update;
        data = serverData.reportData;
        properties = serverData.chartData.properties[0];

        config = this.getChartConfig(properties.type); // this is chart type in Report

        // default settings is current settings with defaults
        settings = this.getDefaultSettings();

        // this does what extend/defaults does but we need it for x_axis_label before
        chartType = updated ? config.chartType : settings.chart_type || config.chartType;

        params = {
            label: data.label,
            chart_type: chartType, // this is renamed chart type from Report
            report_title: properties.title,
            show_legend: properties.legend === 'on' ? true : false,
            stacked: config.barType === 'stacked' || config.barType === 'basic' ? true : false,
            x_axis_label: this._getXaxisLabel(data.group_defs, properties, chartType),
            y_axis_label: this._getYaxisLabel(data),
            module: properties.base_module,
            allow_drillthru: properties.allow_drillthru,
            vertical: config.orientation === 'vertical' ? true : false,
            direction: app.lang.direction
        };

        // override settings when new report is selected
        if (updated) {
            _.extend(settings, params);
        } else {
            _.defaults(settings, params);
        }

        // persist the chart settings for use by SugarCharts
        this.reportData.set('rawChartParams', settings);

        // update the settings model for use by chart field
        this.settings.set(settings);

        // update chart state for drillthru
        if (this.context && this.context.get('chartState') && this.context.get('chartLabels')) {
            var newState = this.getChartState(serverData.chartData);
            if (newState) {
                this.context.set('chartState', newState);
            } else {
                this.context.unset('chartState');
                this.context.unset('chartLabels');
            }
        }

        // toggle display of chart display option controls based on chart type
        this._toggleChartFields();
    },

    /**
     * Gets chart state
     * @param {Object} chartData chart data
     * @return {Object} chart state
     */
    getChartState: function(chartData) {
        var chartState = null;
        var chartLabels = this.context.get('chartLabels');
        var config = this.context.get('dashConfig');
        var reportData = this.context.get('reportData');
        switch (config.chart_type) {
            case 'funnel chart':
            case 'pie chart':
                if (reportData.group_defs.length > 1) {
                    var seriesIndex = _.findIndex(chartData.values, function(value) {
                        return value.label === chartLabels.seriesLabel;
                    });
                    if (seriesIndex >= 0) {
                        chartState = {seriesIndex: chartData.values.length - seriesIndex - 1};
                    }
                } else {
                    var seriesIndex = _.indexOf(chartData.label, chartLabels.seriesLabel);
                    if (seriesIndex >= 0) {
                        chartState = {seriesIndex: chartData.label.length - seriesIndex - 1};
                    }
                }
                break;
            case 'horizontal bar chart':
            case 'bar chart':
                if (reportData.group_defs.length > 1) {
                    var seriesIndex = _.findIndex(chartData.values, function(value) {
                        return value.label === chartLabels.seriesLabel;
                    });
                    if (seriesIndex >= 0) {
                        chartState = {groupIndex: seriesIndex, pointIndex: seriesIndex, seriesIndex: seriesIndex};
                    }
                } else {
                    var groupIndex = _.indexOf(chartData.label, chartLabels.groupLabel);
                    if (groupIndex >= 0) {
                        chartState = {groupIndex: groupIndex, pointIndex: groupIndex, seriesIndex: 0};
                    }
                }
                break;
            case 'horizontal group by chart':
            case 'group by chart':
            case 'stacked group by chart':
            case 'horizontal grouped bar chart':
            case 'vertical grouped bar chart':
                if (reportData.group_defs.length > 1) {
                    var groupIndex = _.findIndex(chartData.values, function(value) {
                        return value.label === chartLabels.groupLabel;
                    });
                    var seriesIndex = _.indexOf(chartData.label, chartLabels.seriesLabel);
                    if (groupIndex >= 0 && seriesIndex >= 0) {
                        chartState = {groupIndex: groupIndex, pointIndex: groupIndex, seriesIndex: seriesIndex};
                    }
                } else {
                    var groupIndex = _.indexOf(chartData.label, chartLabels.groupLabel);
                    if (groupIndex >= 0) {
                        chartState = {groupIndex: groupIndex, pointIndex: groupIndex, seriesIndex: groupIndex};
                    }
                }
                break;
            case 'line chart':
                if (reportData.group_defs.length > 1) {
                    var seriesIndex = _.findIndex(chartData.values, function(value) {
                        return value.label === chartLabels.groupLabel;
                    });
                    var groupIndex = _.indexOf(chartData.label, chartLabels.seriesLabel);
                    if (groupIndex >= 0 && seriesIndex >= 0) {
                        chartState = {groupIndex: groupIndex, pointIndex: groupIndex, seriesIndex: seriesIndex};
                    }
                } else {
                    var groupIndex = _.indexOf(chartData.label, chartLabels.groupLabel);
                    if (groupIndex >= 0) {
                        chartState = {groupIndex: groupIndex, pointIndex: 0, seriesIndex: groupIndex};
                    }
                }
                break;
        }
        return chartState;
    },

    /**
     * Builds the chart config based on the type of chart
     * @return {Mixed}
     */
    getChartConfig: function(chartType) {
        var chartConfig;

        switch (chartType) {
            case 'pie chart':
                chartConfig = {
                    chartType: 'pie chart'
                };
                break;

            case 'line chart':
                chartConfig = {
                    lineType: 'grouped',
                    chartType: 'line chart'
                };
                break;

            case 'funnel chart 3D':
                chartConfig = {
                    chartType: 'funnel chart'
                };
                break;

            case 'gauge chart':
                chartConfig = {
                    chartType: 'gauge chart'
                };
                break;

            case 'stacked group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'group by chart'
                };
                break;

            case 'group by chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'grouped',
                    chartType: 'group by chart'
                };
                break;

            case 'bar chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'basic',
                    chartType: 'group by chart'
                };
                break;

            case 'horizontal group by chart':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'stacked',
                    chartType: 'horizontal group by chart'
                };
                break;

            case 'horizontal bar chart':
            case 'horizontal':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'basic',
                    chartType: 'horizontal group by chart'
                };
                break;

            case 'horizontal grouped bar chart':
                chartConfig = {
                    orientation: 'horizontal',
                    barType: 'grouped',
                    chartType: 'horizontal group by chart'
                };
                break;
            case 'vertical grouped bar chart':
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'grouped',
                    chartType: 'group by chart'
                };
                break;

            default:
                chartConfig = {
                    orientation: 'vertical',
                    barType: 'stacked',
                    chartType: 'bar chart'
                };
                break;
        }

        return chartConfig;
    },

    /**
     * Callback function on chart render complete.
     *
     * @param {Function} chart sucrose chart instance
     * @param {Object} params chart display parameters
     * @param {Object} reportData report data with properties and data array
     */
    chartComplete: function(chart, params, reportData, chartData) {
        if (!_.isFunction(chart.seriesClick) || !params.allow_drillthru) {
            return;
        }

        // This seriesClick callback overrides the default set
        // in sugarCharts for use in the Report module charts
        chart.seriesClick(_.bind(function(data, eo, chart, labels) {
            var state = SUGAR.charts.buildChartState(eo, labels);
            if (!_.isFinite(state.seriesIndex)) {
                return;
            }

            if (params.chart_type === 'line chart') {
                params.groupLabel = SUGAR.charts.extractSeriesLabel(state, data);
                params.seriesLabel = SUGAR.charts.extractGroupLabel(state, labels);
            } else {
                params.seriesLabel = SUGAR.charts.extractSeriesLabel(state, data);
                params.groupLabel = SUGAR.charts.extractGroupLabel(state, labels);
            }

            chart.clearActive();
            if (chart.cellActivate) {
                chart.cellActivate(state);
            } else if (chart.seriesActivate) {
                chart.seriesActivate(state);
            } else {
                chart.dataSeriesActivate(eo);
            }
            // keep track of chart state for refresh
            // needed for drillthru chart only
            if (this.context.get('chartState')) {
                this.context.set('chartState', state);
                var chartLabels = {
                    groupLabel: params.groupLabel,
                    seriesLabel: params.seriesLabel
                };
                this.context.set('chartLabels', chartLabels);
            }
            chart.dispatch.call('tooltipHide', this);

            this._handleFilter(chart, params, state, reportData, chartData);
        }, this));
    },

    /**
     * Handle either navigating to target module or update list view filter.
     *
     * @param {Function} chart sucrose chart instance
     * @param {Object} params chart display parameters
     * @param {Object} state chart display and data state
     * @param {Object} reportData report data as returned from API
     * @param {Object} chartData chart data with properties and data array
     * @protected
     */
    _handleFilter: function(chart, params, state, reportData, chartData) {
        var module = params.baseModule;
        var reportId = this.settings.get('saved_report_id');

        var enums;
        var groupDefs;
        var drawerContext;

        app.alert.show('listfromreport_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});

        if (this.$el.parents('.drawer.active').length === 0) {
            enums = SUGAR.charts.getEnums(reportData);
            groupDefs = SUGAR.charts.getGrouping(reportData);
            drawerContext = {
                chartData: chartData,
                chartModule: module,
                chartState: state,
                dashModel: null,
                dashConfig: params,
                enumsToFetch: enums,
                filterOptions: {
                    auto_apply: false
                },
                groupDefs: groupDefs,
                layout: 'drillthrough-drawer',
                module: 'Reports',
                reportData: reportData,
                reportId: reportId,
                skipFetch: true,
                useSavedFilters: true
            };

            chart.clearActive();
            this.openDrawer(drawerContext);
        } else {
            this.updateList(params, state);
        }
    },

    /**
     * Open a drill through drawer with list and dashlet replica.
     *
     * @param {Object} drawerContext drillthrough content and display parameters
     */
    openDrawer: function(drawerContext) {
        var currentModule = app.drawer.context.get('module');

        // This needs to set to target module for Merge to show the target module fields
        app.drawer.context.set('module', drawerContext.chartModule);

        app.drawer.open({
            layout: 'drillthrough-drawer',
            context: drawerContext
        }, _.bind(function() {
            if (currentModule) {
                // reset the drawer module
                app.drawer.context.set('module', currentModule);
            }
        }, this, currentModule));
    },

    /**
     * Update the record list in drill through drawer.
     *
     * @param {Object} params chart display parameters
     * @param {Object} state chart display and data state
     */
    updateList: function(params, state) {
        var drawer = this.closestComponent('drawer').getComponent('drillthrough-drawer');
        drawer.context.set('dashConfig', params);
        drawer.context.set('chartState', state);
        drawer.updateList();
    },

    /**
     * Returns the x-axis label based on report data
     * @return {String}
     */
    _getXaxisLabel: function(groups, properties, chartType) {
        return chartType === 'line chart' ?
            properties.seriesName || _.last([].concat(groups)).label :
            properties.groupName || _.first([].concat(groups)).label;
    },

    /**
     * Returns the y-axis label based on report data
     * @return {String}
     */
    _getYaxisLabel: function(data) {
        var label = '';
        if (data && data.summary_columns) {
            _.each(data.summary_columns, function(column) {
                if (!_.isUndefined(column.group_function)) {
                    label = column.label;
                }
            });
        }
        return label;
    },

    /**
     * Makes a call to filter api to get all reports with chart stored in the saved_reports table
     *
     * @deprecated
     */
    getAllReportsWithCharts: function() {
        app.logger.warn('View.Views.Base.SavedReportsChartView#getAllReportsWithCharts' +
            'has been deprecated since 8.0.0.0 and will be removed in a future release');
        var params = {
                fields: 'id,name,module,report_type,content,chart_type,assigned_user_id',
                order_by: 'name:asc',
                filter: [{chart_type: {$not_equals: 'none'}}],
                // get all reports with charts
                max_num: -1
            },
            url = app.api.buildURL('Reports', null, null, params);

        app.api.call('read', url, null, {
            success: _.bind(this.parseAllSavedReports, this)
        });
    },

    /**
     * Parses items passed back from filter api endpoint into enum options
     *
     * @param {Array} reports an array of saved reports returned from the endpoint
     * @deprecated
     */
    parseAllSavedReports: function(reports) {
        app.logger.warn('View.Views.Base.SavedReportsChartView#parseAllSavedReports' +
            'has been deprecated since 8.0.0.0 and will be removed in a future release');

        reports = reports.records || [];
        this.reportOptions = {};
        this.reportAcls = {};

        _.each(reports, function(report) {
            if (app.acl.hasAccess('view', report.module)) {
                // build the reportOptions key/value pairs
                this.reportOptions[report.id] = report.name;
                this.reportAcls[report.id] = report._acl;
            }
        }, this);

        // find the saved_report_id field
        var reportsField = _.find(this.fields, function(field) {
            return field.name == 'saved_report_id';
        });

        if (reportsField) {
            // set the initial saved_report_id to the first report in the list
            // if there are reports to show and we have not already saved this
            // dashlet yet with a report ID
            if (reports && (!this.settings.has('saved_report_id') || _.isEmpty(this.settings.get('saved_report_id')))) {
                this.settings.set('saved_report_id', _.first(reports).id);
            }

            // set field options and render
            reportsField.items = this.reportOptions;
            reportsField._render();

            // check acls to show or hide 'Edit Selected Report' link
            this.updateEditLink();
        }
    },

    /**
     * Makes a call to Reports/:id/chart to fetch specific saved report data
     *
     * @param {String} reportId the ID for the report we're looking for
     */
    getSavedReportById: function(reportId, options) {
        var dt = this.layout.getComponent('dashlet-toolbar');
        if (dt) {
            // manually set the icon class to spiny
            this.$('[data-action=loading]').removeClass(dt.cssIconDefault).addClass(dt.cssIconRefresh);
        }
        var useSavedFilters = this.context && this.context.get('useSavedFilters') ? 'true' : 'false';
        var url = app.api.buildURL('Reports/' + reportId + '/chart?use_saved_filters=' + useSavedFilters);
        app.api.call('read', url, null, {
            success: _.bind(function(serverData) {
                if (options && options.success) {
                    // options.success is usually setChartParams()
                    // defines this.reportData 'rawChartParams';
                    options.success.apply(this, arguments);
                }

                this.reportData.set('rawReportData', serverData.reportData);
                // set reportData's rawChartData to the chartData from the server
                // this will trigger chart.js' change:rawChartData and the chart will update
                this.reportData.set('rawChartData', serverData.chartData);
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        // if we're in config, or if the chartField doesn't exist yet... render
        // otherwise do not render again as this destroys and re-draws the chart and looks awful
        if (this.meta.config || _.isUndefined(this.chartField)) {
            this._super('_render');
        }
    },

    /**
     * Handle the display of the chart display option controls based on chart type
     *
     * @private
     */
    _toggleChartFields: function() {
        if (this.meta.config) {

            var xOptionsFieldset = this.getField('x_label_options'),
                tickDisplayMethods = this.getField('tickDisplayMethods'),
                yOptionsFieldset = this.getField('y_label_options'),
                showValuesField = this.getField('showValues'),
                groupDisplayOptions = this.getField('groupDisplayOptions'),
                stackedField = this.getField('stacked'),
                showDimensionOptions = false,
                showBarOptions = false,
                showTickOptions = false,
                showStacked = false,
                xOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_XAXIS_LABEL'),
                yOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_YAXIS_LABEL');

            switch (this.settings.get('chart_type')) {
                case 'pie chart':
                case 'gauge chart':
                case 'funnel chart 3D':
                    showDimensionOptions = false;
                    showBarOptions = false;
                    break;

                case 'line chart':
                    showDimensionOptions = true;
                    showBarOptions = false;
                    break;

                case 'stacked group by chart':
                case 'horizontal group by chart':
                case 'group by chart':
                case 'vertical grouped bar chart':
                case 'horizontal grouped bar chart':
                    showDimensionOptions = true;
                    showBarOptions = true;
                    showStacked = true;
                    break;

                case 'vertical bar chart':
                case 'vertical':
                case 'bar chart':
                case 'horizontal bar chart':
                case 'horizontal':
                    showDimensionOptions = true;
                    showBarOptions = true;
                    showStacked = false;
                    break;

                default:
                    showDimensionOptions = false;
                    showBarOptions = false;
            }

            if (showDimensionOptions) {
                switch (this.settings.get('chart_type')) {
                    case 'horizontal group by chart':
                    case 'horizontal grouped bar chart':
                    case 'horizontal bar chart':
                    case 'horizontal':
                        showTickOptions = false;
                        xOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_YAXIS_LABEL');
                        yOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_XAXIS_LABEL');
                        break;
                    case 'line chart':
                        showTickOptions = true;
                        break;
                    default:
                        showTickOptions = true;
                        xOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_XAXIS_LABEL');
                        yOptionsLabel = app.lang.get('LBL_CHART_CONFIG_SHOW_YAXIS_LABEL');
                }
            }

            if (xOptionsFieldset) {
                xOptionsFieldset.$el.closest('.record-cell').toggleClass('hide', !showDimensionOptions);
                xOptionsFieldset.$el.closest('.record-cell').find('.record-label').text(xOptionsLabel);
                yOptionsFieldset.$el.closest('.record-cell').find('.record-label').text(yOptionsLabel);
            }
            if (tickDisplayMethods) {
                tickDisplayMethods.$el.closest('.record-cell').toggleClass('hide', !showDimensionOptions || !showTickOptions);
                tickDisplayMethods.$el.find('.disabled').find('input').prop( 'checked', true ).prop('disabled', true);
            }

            if (yOptionsFieldset) {
                yOptionsFieldset.$el.closest('.record-cell').toggleClass('hide', !showDimensionOptions);
            }

            if (showValuesField) {
                showValuesField.$el.closest('.record-cell').toggleClass('hide', !showBarOptions);
            }
            if (groupDisplayOptions) {
                groupDisplayOptions.$el.closest('.record-cell').toggleClass('hide', !showBarOptions);
                if (stackedField) {
                    stackedField.$el.toggleClass('hide', !showStacked);
                }
            }

        }
    },

    /**
     * Handle the conditional display of settings input field based on checkbox toggle state
     *
     * @param {Object} toggle a checkbox control that determines display state of field
     * @param {Object} dependent the input field that holds the setting value
     * @private
     */
    _toggleDepedent: function(toggle, dependent) {
        var inputField = dependent.$el.find(dependent.fieldTag),
            enabled = this.settings.get(toggle.name),
            value = enabled ? this.settings.get(dependent.name) : '';
        inputField
            .prop('disabled', !enabled)
            .val(value);
    },

    /**
     * @inheritdoc
     * When rendering fields, get a reference to the chart field if we don't have one yet
     */
    _renderField: function(field) {
        this._super('_renderField', [field]);

        // Manage display state of fieldsets with toggle
        if (this.meta.config) {

            if (!_.isUndefined(field.def.toggle)) {
                var toggle = this.getField(field.def.toggle),
                    dependent = this.getField(field.def.dependent);

                this._toggleDepedent(toggle, dependent);

                this.settings.on('change:' + toggle.name, _.bind(function(event) {
                    this._toggleDepedent(toggle, dependent);
                }, this));
                this.settings.on('change:' + dependent.name, _.bind(function(event) {
                    this._toggleDepedent(toggle, dependent);
                }, this));
            }
        }

        // hang on to a reference to the chart field
        if (_.isUndefined(this.chartField) && field.name === 'chart') {
            this.chartField = field;
        }
    }
}) },
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.RecordlistView
 * @alias SUGAR.App.view.views.BaseRecordlistView
 * @extends View.Views.Base.FlexListView
 */
({
	// Recordlist View (base) 

    extendsFrom: 'FlexListView',
    plugins: [
        'SugarLogic',
        'ReorderableColumns',
        'ResizableColumns',
        'ListColumnEllipsis',
        'ErrorDecoration',
        'Editable',
        'MergeDuplicates',
        'Pagination',
        'MassCollection'
    ],

    /**
     * List of current inline edit models.
     *
     * @property
     */
    toggledModels: null,

    rowFields: {},

    contextEvents: {
        "list:editall:fire": "toggleEdit",
        "list:editrow:fire": "editClicked",
        "list:deleterow:fire": "warnDelete"
    },

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        //Grab the record list of fields to display from the base metadata
        var recordListMeta = this._initializeMetadata(options);
        //Allows sub-views to override and use different view metadata if desired
        options.meta = this._filterMeta(_.extend({}, recordListMeta, options.meta || {}), options);
        this._super("initialize", [options]);

        //Extend the prototype's events object to setup additional events for this controller
        this.events = _.extend({}, this.events, {
            'click [name=inline-cancel]' : 'resize',
            'keydown': '_setScrollPosition'
        });

        this.toggledModels = {};

        this._addAdditionalFields();

        this._currentUrl = Backbone.history.getFragment();

        this._bindEvents();
    },

    /**
     * Bind various events that are associated with this view.
     *
     * @protected
     */
    _bindEvents: function() {
        this.on('render render:rows', this._setRowFields, this);

        //fire resize scroll-width on column add/remove
        this.on('list:toggle:column', this.resize, this);
        this.on('mergeduplicates:complete', this.refreshCollection, this);
        this.on('field:focus:location', this.setPanelPosition, this);

        if (this.layout) {
            this.layout.on('list:mergeduplicates:fire', this.mergeDuplicatesClicked, this);

            // We listen for if the search filters are opened or not. If so, when
            // user clicks show more button, we treat this as a search, otherwise,
            // normal show more for list view.
            this.layout.on('list:filter:toggled', this.filterToggled, this);

            // The `MassCollection` plugin triggers these events when it shows an
            // alert and the table height changes.
            this.layout.on('list:alert:show list:alert:hide', this._refreshReorderableColumns, this);
        }

        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before('route', this.beforeRouteDelete, this);
        $(window).on('beforeunload.delete' + this.cid, _.bind(this.warnDeleteOnRefresh, this));
    },

    /**
     * Update the filter enable status.
     *
     * @param {Boolean} isOpened Value whether the filter is opened.
     */
    filterToggled: function(isOpened) {
        this.context.set('filterOpened', isOpened);
    },

    /**
     * Add the opened filter options to the paginate query.
     * Please see the {@link Pagination#getNextPagination} for detail.
     *
     * @return {Object} Pagination fetch options.
     */
    getPaginationOptions: function() {
        // If in "search mode" (the search filter is toggled open) set q:term param
        var options = this.context.get('filterOpened') ? this.getSearchOptions() : {};

        return options;
    },

    /**
     * Add the previous typed search term.
     *
     * @return {Object} Pagination fetch options.
     */
    getSearchOptions: function() {
        var collection, options, previousTerms, term = '';
        collection = this.context.get('collection');

        // If we've made a previous search for this module grab from cache
        if (app.cache.has('previousTerms')) {
            previousTerms = app.cache.get('previousTerms');
            if (previousTerms) {
                term = previousTerms[this.module];
            }
        }
        // build search-specific options and return
        options = {
            params: {
                q: term
            },
            fields: collection.fields ? collection.fields : this.collection
        };
        return options;
    },

    /**
     * Retrieve the metadata of the recordlist view
     *
     * @return {Object}
     * @private
     */
    _initializeMetadata: function() {
        return app.metadata.getView(null, 'recordlist') || {};
    },

    /**
     * Filters the given meta removing non-applicable portions
     * @param {Object} meta data to be filtered
     * @return {Object}
     * @private
     */
    _filterMeta : function(meta, options) {
        // Don't show the update calc field option if the module has no calculated
        // fields or the user is not a dev for that module
        var context = options.context;
        var isDeveloper = app.acl.hasAccess("developer", context.get("module"));
        var hasCalcFields = context && context.get("model") && !!_.find(context.get("model").fields, function(def) {
            return def && def.calculated && def.calculated != "false";
        });
        // Used in sanitizing subpanel row actions for Tags module
        var isTagsParent = options.context.get('parentModule') === 'Tags';

        if ((!isDeveloper || !hasCalcFields) && meta.selection && meta.selection.actions) {
            meta.selection.actions = _.reject(meta.selection.actions, function(action) {
                return action.name == "calc_field_button";
            });
        }

        // Handle Tags module specific rules. Yes, this is dirty, but given how
        // Subpanels on Tags need to be treated, this is just about the only way
        // to do this
        if (isTagsParent && meta.rowactions && meta.rowactions.actions) {
            // Tags does not support Unlinking of records in subpanels, so we
            // need to traverse the row actions array of options.meta and, if
            // any of the rowactions is a type unlink-action we need to remove
            // it from the rowactions array
            meta.rowactions.actions = _.reject(meta.rowactions.actions, function(row) {
                return row.type === 'unlink-action';
            });
        }

        return meta;
    },

    /**
     * Refresh the current collection set.
     */
    refreshCollection: function() {
        this.collection.fetch();
    },

    addActions:function () {
        if (this.actionsAdded) return;
        this._super("addActions");
        if(_.isUndefined(this.leftColumns[0])){
            //Add blank left column to contain favorite and inline-cancel buttons
            this.leftColumns.push({
                'type':'fieldset',
                'label': '',
                'sortable': false,
                'fields': []
            });
        }
        //Add Favorite to left
        this.addFavorite();

        //Add Save & Cancel
        var firstLeftColumn = this.leftColumns[0];
        if (firstLeftColumn && _.isArray(firstLeftColumn.fields)) {
            //Add Cancel button to left
            firstLeftColumn.fields.push({
                type: 'editablelistbutton',
                label: 'LBL_CANCEL_BUTTON_LABEL',
                name: 'inline-cancel',
                css_class: 'btn-link btn-invisible inline-cancel ellipsis_inline'
            });
            this.leftColumns[0] = firstLeftColumn;
        }
        var firstRightColumn = this.rightColumns[0];
        if (firstRightColumn && _.isArray(firstRightColumn.fields)) {
            //Add Save button to right
            firstRightColumn.css_class = 'overflow-visible';
            firstRightColumn.fields.push({
                type: 'editablelistbutton',
                label: 'LBL_SAVE_BUTTON_LABEL',
                name: 'inline-save',
                css_class: 'btn-primary ellipsis_inline'
            });
            this.rightColumns[0] = firstRightColumn;
        }
        this.actionsAdded = true;
    },

    /**
     * Add favorite column
     */
    addFavorite: function() {
        var favoritesEnabled = app.metadata.getModule(this.module, "favoritesEnabled");
        if (favoritesEnabled !== false
            && this.meta.favorite && this.leftColumns[0] && _.isArray(this.leftColumns[0].fields)) {
            this.leftColumns[0].fields.push({type:'favorite'});
        }
    },

    /**
     * Set, or reset, the collection of fields that contains each row.
     *
     * This function is invoked when the view renders. It will update the row
     * fields once the `Pagination` plugin successfully fetches new records.
     *
     * @private
     */
    _setRowFields: function() {
        this.rowFields = {};
        _.each(this.fields, function(field) {
            if (field.model && field.model.id && _.isUndefined(field.parent)) {
                this.rowFields[field.model.id] = this.rowFields[field.model.id] || [];
                this.rowFields[field.model.id].push(field);
            }
        }, this);
    },

    /**
     * Stores the current scrolling position of the list content when tab key is
     * pressed.
     *
     * @param {Event} event The keydown event.
     * @private
     */
    _setScrollPosition: function(event) {
        if (event.keyCode === 9) {
            var $flexListContent = this.$('.flex-list-view-content');
            $flexListContent.data('previousScrollLeftValue', $flexListContent.scrollLeft());
        }
    },

    /**
     * Retrieves the location of the edges of the list viewport and caches it
     * to `this._bordersPosition`.
     *
     * @return {Object} Object with properties:
     * @return {number} return.left the position left edge.
     * @return {number} return.right the position right edge.
     * @private
     */
    _getBordersPosition: function() {
        if (!this._bordersPosition) {

            /**
             * Object containing the location of left and right edges of the
             * list viewport.
             *
             * @property {Object} _bordersPosition
             * @property {number} _bordersPosition.left The left offset of the
             *   left edge of the viewport.
             * @property {number} _bordersPosition.right The left offset of the
             *   right edge of the viewport.
             * @private
             */
            this._bordersPosition = {};
            var thSelector = {};
            var $scrollPanel = this.$('.flex-list-view-content');
            var rtl = app.lang.direction === 'rtl';

            thSelector.left = rtl ? 'last' : 'first';
            thSelector.right = rtl ? 'first' : 'last';
            this._bordersPosition.left = $scrollPanel.find('thead tr:first th:' + thSelector.left).outerWidth();
            this._bordersPosition.right = $scrollPanel.find(
                'thead tr:first th:' + thSelector.right).children().position().left;
        }
        return this._bordersPosition;
    },

    /**
     * Sets the position of the current list panel.
     *
     * Doesn't adjust panel position if the focused field is fully visible in
     * the viewport.
     *
     * @param {Object} location Position of the focused element relative to its
     *   viewport.
     * @param {number} location.left The distance between the left
     *   border of the focused field and the left border of the viewport.
     * @param {number} location.right The distance between the right
     *   side of the focused field and the left border of the viewport.
     */
    setPanelPosition: function(location) {
        var bordersPosition = this._getBordersPosition();
        var fieldLeft = location.left;
        var fieldRight = location.right;
        if (fieldRight <= bordersPosition.right && fieldLeft >= bordersPosition.left) {
            return;
        }
        this._scrollToMakeFieldVisible(bordersPosition.left, bordersPosition.right, location);
    },

    /**
     * Scrolls the list horizontally to make the clicked field fully visible.
     *
     * @param {number} leftBorderPosition Position of the left edge of the
     *   list viewport.
     * @param {number} rightBorderPosition Position of the right edge of the
     *   list viewport.
     * @param {Object} location Position of the focused element relative to its
     *   viewport.
     * @param {number} location.left The distance between the left
     *   border of the focused field and the left border of the viewport.
     * @param {number} location.right The distance between the right
     *   side of the focused field and the left border of the viewport.
     * @private
     */
    _scrollToMakeFieldVisible: function(leftBorderPosition, rightBorderPosition, location) {
        var $scrollPanel = this.$('.flex-list-view-content');
        var scrollPosition = $scrollPanel.scrollLeft();
        var fieldLeft = location.left;
        var fieldRight = location.right;
        var fieldPadding = location.fieldPadding;
        var distanceToScroll;

        if (fieldLeft < leftBorderPosition) {
            distanceToScroll = fieldLeft - leftBorderPosition - fieldPadding;
        } else if (rightBorderPosition < fieldRight) {
            distanceToScroll = fieldRight - rightBorderPosition + fieldPadding;
        } else {
            return;
        }
        if (app.lang.direction === 'rtl' && $.support.rtlScrollType === 'reverse') {
            distanceToScroll = - distanceToScroll;
        }
        $scrollPanel.scrollLeft(scrollPosition + distanceToScroll);
    },

    /**
     * Delete the model once the user confirms the action
     */
    deleteModel: function() {
        var self = this,
            model = this._modelToDelete;

        model.destroy({
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: self.getDeleteMessages(self._modelToDelete).success
                }
            },
            success: function() {
                var redirect = self._targetUrl !== self._currentUrl;
                self._modelToDelete = null;
                self.collection.remove(model, { silent: redirect });
                if (redirect) {
                    self.unbindBeforeRouteDelete();
                    //Replace the url hash back to the current staying page
                    app.router.navigate(self._targetUrl, {trigger: true});
                    return;
                }
                app.events.trigger("preview:close");
                if (!self.disposed) {
                    self.render();
                }

                self.layout.trigger("list:record:deleted", model);
            }
        });
    },

    /**
     * Pre-event handler before current router is changed
     *
     * @return {Boolean} true to continue routing, false otherwise
     */
    beforeRouteDelete: function () {
        if (this._modelToDelete) {
            this.warnDelete(this._modelToDelete);
            return false;
        }
        return true;
    },

    /**
     * Formats the messages to display in the alerts when deleting a record.
     *
     * @param {Data.Bean} model The model concerned.
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getDeleteMessages: function(model) {
        var messages = {};
        var name = Handlebars.Utils.escapeExpression(this._getNameForMessage(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' "' + name + '"';

        messages.confirmation = app.utils.formatString(
            app.lang.get('NTC_DELETE_CONFIRMATION_FORMATTED', this.module),
            [context]
        );
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    },

    /**
     * Retrieves the name of a record
     *
     * @param {Data.Bean} model The model concerned.
     * @return {string} name of the record.
     */
    _getNameForMessage: function(model) {
        return app.utils.getRecordName(model);
    },

    /**
     * Popup dialog message to confirm delete action
     *
     * @param {Backbone.Model} model the bean to delete
     */
    warnDelete: function(model) {
        var self = this;
        this._modelToDelete = model;

        self._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (self._targetUrl !== self._currentUrl) {
            app.router.navigate(self._currentUrl, {trigger: false, replace: true});
        }

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: self.getDeleteMessages(model).confirmation,
            onConfirm: _.bind(self.deleteModel, self),
            onCancel: function() {
                self._modelToDelete = null;
            }
        });
    },

    /**
     * Popup browser dialog message to confirm delete action
     *
     * @return {String} the message to be displayed in the browser dialog
     */
    warnDeleteOnRefresh: function() {
        if (this._modelToDelete) {
            return this.getDeleteMessages(this._modelToDelete).confirmation;
        }
    },

    /**
     * {@link app.plugins.view.editable}
     * Compare with last fetched data and return true if model contains changes.
     * if model contains changed attributes,
     * check whether those are among the editable fields or not.
     *
     * @return {Boolean} True if current inline edit model contains unsaved changes.
     */
    hasUnsavedChanges: function() {
        var firstKey = _.first(_.keys(this.rowFields)),
            formFields = [];

        _.each(this.rowFields[firstKey], function(field) {
            if (field.name) {
                formFields.push(field.name);
            }
            //Inspect fieldset children fields
            if (field.def.fields) {
                formFields = _.chain(field.def.fields)
                    .pluck('name')
                    .compact()
                    .union(formFields)
                    .value();
            }
        }, this);
        return _.some(_.values(this.toggledModels), function(model) {
            var changedAttributes = model.changedAttributes(model.getSynced());

            if (_.isEmpty(changedAttributes)) {
                return false;
            }
            var unsavedFields = _.intersection(_.keys(changedAttributes), formFields);
            return !_.isEmpty(unsavedFields);
        }, this);
    },

    /**
     * Handles merge button.
     */
    mergeDuplicatesClicked: function() {
        this.mergeDuplicates(this.context.get('mass_collection'));
    },

    /**
     * Toggle the selected model's fields when edit is clicked.
     *
     * @param {Backbone.Model} model Selected row's model.
     */
    editClicked: function(model, field) {
        // If a field is locked, we don't allow inline editing. Instead show an alert that links
        // to the record view or editview to make changes there.
        if (!_.isEmpty(model.get('locked_fields'))) {
            this._showLockedFieldWarning(model);
            return;
        }
        if (field.def.full_form) {
            var parentModel = this.context.parent.get('model');
            var link = this.context.get('link');

            // `app.bwc.createRelatedRecord` navigates to the BWC EditView if an
            // id is passed to it.
            app.bwc.createRelatedRecord(this.module, parentModel, link, model.id);
        } else {
            this.toggleRow(model.id, true);
            //check to see if horizontal scrolling needs to be enabled
            this.resize();
        }
        if (!_.isEqual(model.attributes, model._syncedAttributes)) {
            model.setSyncedAttributes(model.attributes);
        }
    },

    /**
     * Show a warning alert about locked fields on the model. The warning will
     * link to the Sidecar record view in edit mode or BWC edit view
     *
     * @param {Backbone.Model} model the model for the row we are editing
     * @private
     */
    _showLockedFieldWarning: function(model) {
        var route = app.router.buildRoute(model.module, model.id, 'edit');
        var recordName = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model));
        var message = app.lang.get(
            'LBL_LOCKED_FIELD_INLINE_EDIT',
            model.module,
            {link: new Handlebars.SafeString('<a href="javascript:void(0);">' + recordName + '</a>')}
        );
        var module = app.metadata.getModule(model.module);
        app.alert.show('locked_field_inline_edit', {
            level: 'warning',
            messages: message,
            autoClose: false,
            onLinkClick: function() {
                app.alert.dismiss('locked_field_inline_edit');
                var trigger = module.isBwcEnabled;
                if (!trigger) {
                    // We need to load the view here to add lockedFieldWarning to the context
                    // for sidecar modules
                    app.controller.loadView({
                        layout: 'record',
                        module: model.module,
                        modelId: model.id,
                        action: 'edit',
                        lockedFieldsWarning: false
                    });
                }
                app.router.navigate(route, {trigger: trigger});
            }
        });
    },

    /**
     * Toggle editable selected row's model fields.
     *
     * @param {String} modelId Model Id.
     * @param {Boolean} isEdit True for edit mode, otherwise toggle back to list mode.
     */
    toggleRow: function(modelId, isEdit) {
        if (isEdit) {
            this.toggledModels[modelId] = this.collection.get(modelId);
        } else {
            delete this.toggledModels[modelId];
        }
        this.$('tr[name=' + this.module + '_' + modelId + ']').toggleClass('tr-inline-edit', isEdit);
        this.toggleFields(this.rowFields[modelId], isEdit);
    },

    /**
     * Detach the event handlers for warning delete
     */
    unbindBeforeRouteDelete: function() {
        app.routing.offBefore("route", this.beforeRouteDelete, this);
        $(window).off("beforeunload.delete" + this.cid);
    },

    /**
     * @override
     * @private
     */
    _dispose: function(){
        this.unbindBeforeRouteDelete();
        this._super('_dispose');
        this.rowFields = null;
    },

    /**
     * Adds additional fields to the context.
     *
     * @private
     */
    _addAdditionalFields: function() {
        if (this.meta.favorite) {
            this.context.addFields(['my_favorite']);
        }

        if (this.meta.following) {
            this.context.addFields(['following']);
        }
    },

    /**
     * Register keyboard shortcuts.
     */
    registerShortcuts: function() {
        var clickButton = function($button) {
            if ($button.is(':visible') && !$button.hasClass('disabled')) {
                $button.click();
            }
        };

        this._super('registerShortcuts');

        app.shortcuts.register({
            id: 'List:Inline:Edit',
            keys: 'e',
            component: this,
            description: 'LBL_SHORTCUT_EDIT_SELECTED',
            handler: function() {
                var self = this;
                if (this.$('.selected [name=inline-cancel]:visible').length === 0) {
                    this.$('.selected [data-toggle=dropdown]:visible').click();
                    this.$('.selected [name=edit_button]:visible').click();
                    _.defer(function() {
                        self.$('.selected input:first').focus();
                    });
                }
            }
        });

        app.shortcuts.register({
            id: 'List:Delete',
            keys: 'd',
            component: this,
            description: 'LBL_SHORTCUT_RECORD_DELETE',
            handler: function() {
                if (this.$('.selected [name=inline-cancel]:visible').length === 0) {
                    this.$('.selected [data-toggle=dropdown]:visible').click().blur();
                    this.$('.selected [name=delete_button]:visible').click();
                }
            }
        });

        app.shortcuts.register({
            id: 'List:Inline:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CANCEL_INLINE_EDIT',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('.selected [name=inline-cancel]'),
                    $focusedInlineEditRow = $(event.target).closest('.tr-inline-edit');

                if ($cancelButton.length > 0) {
                    clickButton($cancelButton);
                } else if ($focusedInlineEditRow.length > 0) {
                    clickButton($focusedInlineEditRow.find('[name=inline-cancel]'));
                }
            }
        });

        app.shortcuts.register({
            id: 'List:Inline:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('.selected [name=inline-save]'),
                    $focusedInlineEditRow = $(event.target).closest('.tr-inline-edit');

                if ($saveButton.length > 0) {
                    clickButton($saveButton);
                } else if ($focusedInlineEditRow.length > 0) {
                    clickButton($focusedInlineEditRow.find('[name=inline-save]'));
                }
            }
        });

        app.shortcuts.register({
            id: 'List:Favorite',
            keys: 'f a',
            component: this,
            description: 'LBL_SHORTCUT_FAVORITE_RECORD',
            handler: function() {
                this.$('.selected .fa-favorite:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'List:Follow',
            keys: 'f o',
            component: this,
            description: 'LBL_SHORTCUT_FOLLOW_RECORD',
            handler: function() {
                this.$('.selected [data-toggle=dropdown]:visible').click().blur();
                this.$('.selected [name=follow_button]:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'List:Preview',
            keys: 'p',
            component: this,
            description: 'LBL_SHORTCUT_PREVIEW_SELECTED',
            handler: function() {
                clickButton(this.$('.selected [data-event="list:preview:fire"]:visible'));
            }
        });

        app.shortcuts.register({
            id: 'List:Select',
            keys: 'x',
            component: this,
            description: 'LBL_SHORTCUT_MARK_SELECTED',
            handler: function() {
                var $checkbox = this.$('.selected input[type=checkbox]:first');
                if ($checkbox.is(':visible') && !$checkbox.hasClass('disabled')) {
                    $checkbox.get(0).click();
                }
            }
        });
    },

    /**
     * @inheritdoc
     *
     * Unsets `_bordersPosition` because the value changes on resize and will
     * have to be recalculated if the user toggles inline edit mode.
     */
    resize: function() {
        this._super('resize');
        this._bordersPosition = null;
    },

    /**
     * Refreshes the `ReorderableColumns` when the table height changes.
     *
     * The `ReorderableColumns` plugin listens to the window `resize` event to
     * update and position the handlers correctly.
     *
     * @private
     */
    _refreshReorderableColumns: function() {
        $(window).resize();
    }
}) },
"dashablelist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Dashablelist is a dashlet representation of a module list view. Users can
 * build dashlets of this type for any accessible and approved module with
 * their choice of columns from the list view for their chosen module.
 *
 * Options:
 * {String}  module             The module from which the records are
 *                              retrieved.
 * {String}  label              The string (i18n or hard-coded) representing
 *                              the dashlet name that the user sees.
 * {Array}   display_columns    The field names of the columns to include in
 *                              the list view.
 * {String}  filter_id          Filter to be applied, defaults to:
 *                              'assigned_to_me'.
 * {Integer} limit              The number of records to retrieve for the list
 *                              view.
 * {Integer} auto_refresh       How frequently (in minutes) that the dashlet
 *                              should refresh its data collection.
 *
 * Example:
 * <pre><code>
 * // ...
 * array(
 *     'module'          => 'Accounts',
 *     'label'           => 'LBL_MODULE_NAME',
 *     'display_columns' => array(
 *         'name',
 *         'phone_office',
 *         'billing_address_country',
 *     ),
 *     'filter_id'       => 'assigned_to_me',
 *     'limit'           => 15,
 *     'auto_refresh'    => 5,
 * ),
 * //...
 * </code></pre>
 *
 * Note that there are two concepts of "intelligence" for this dashlet.
 *
 * The intelligence property on the controller `this.intelligent` indicates
 * if the dashlet is allowed to link to a record.
 *
 * The intelligent setting retrieved by `this.settings.get('intelligent')` is
 * only relevant if the intelligence property `this.intelligent` is true. This
 * setting indicates if the dashlet is actively linking to a record.
 *
 * @class View.Views.Base.DashablelistView
 * @alias SUGAR.App.view.views.BaseDashablelistView
 * @extends View.Views.Base.ListView
 */
({
	// Dashablelist View (base) 

    extendsFrom: 'ListView',

    dataView: '',

    /**
     * The plugins used by this view.
     */
    plugins: ['Dashlet', 'Pagination'],

    /**
     * We want to load field `list` templates
     */
    fallbackFieldTemplate: 'list',

    /**
     * The default settings for a list view dashlet.
     *
     * @property {Object}
     */
    _defaultSettings: {
        limit: 5,
        filter_id: 'assigned_to_me',
        intelligent: '0'
    },

    /**
     * Modules that are permanently blacklisted so users cannot configure a
     * dashlet for these modules.
     *
     * @property {Array}
     */
    moduleBlacklist: [
        'Home',
        'Forecasts',
        'ProductCategories',
        'ProductTemplates',
        'ProductTypes',
        'UserSignatures',
        'OutboundEmail'
    ],

    /**
     * Module Additions
     *
     * When a specific module is allowed, we should add these other modules that are
     * not first class modules.
     *
     * @property {Array}
     */
    additionalModules: {
        'Project': ['ProjectTask']
    },

    /**
     * Cache of the modules a user is allowed to see.
     *
     * The keys are the module names and the values are the module names after
     * resolving them against module and/or app strings. The cache logic can be
     * seen in {@link BaseDashablelistView#_getAvailableModules}.
     *
     * @property {Object}
     */
    _availableModules: {},

    /**
     * Cache of the fields found in each module's list view definition.
     *
     * This hash is multi-dimensional. The first set of keys are the module
     * names and the values are objects where the keys are the field names and
     * the values are the field names after resolving them against module
     * and/or app strings. The cache logic can be seen in
     * {@link BaseDashablelistView#_getAvailableColumns}.
     *
     * @property {Object}
     */
    _availableColumns: {},

    /**
     * Flag indicates if dashlet is intelligent.
     *
     * If the dashlet is intelligent, it can be linked to a record on the main
     * context, e.g. on the Record View.
     */
    intelligent: null,

    /**
     * Flag indicates if a module is available for display.
     */
    moduleIsAvailable: true,

    /**
     * Flag indicates if dashlet filter is accessible.
     */
    filterIsAccessible: true,

    /**
     * @inheritdoc
     *
     * Append lastStateID on metadata in order to active user cache.
     */
    initialize: function(options) {
        options.meta = _.extend({}, options.meta, {
            last_state: {
                id: 'dashable-list'
            }
        });
        this.checkIntelligence();
        this._super('initialize', [options]);
        this._noAccessTemplate = app.template.get(this.name + '.noaccess');
    },

    /**
     * Check if dashlet can be intelligent.
     *
     * A dashlet is considered intelligent when the data relates to the current
     * record.
     *
     * @return {String} Whether or not the dashlet can be intelligent.
     */
    checkIntelligence: function() {
        var isIntelligent = app.controller.context.get('layout') === 'record' &&
            !_.contains(this.moduleBlacklist, app.controller.context.get('module'));
        this.intelligent = isIntelligent ? '1' : '0';
        return this.intelligent;
    },

    /**
     * Show/hide `linked_fields` field.
     *
     * @param {String} visible '1' to show the field, '0' to hide it.
     * @param {String} [intelligent='1'] Whether the dashlet is in intelligent
     *   mode or not.
     */
    setLinkedFieldVisibility: function(visible, intelligent) {
        var field = this.getField('linked_fields'),
            fieldEl;
        if (!field) {
            return;
        }
        intelligent = (intelligent === false || intelligent === '0') ? '0' : '1';
        fieldEl = this.$('[data-name=linked_fields]');
        if (visible === '1' && intelligent === '1' && !_.isEmpty(field.items)) {
            fieldEl.show();
        } else {
            fieldEl.hide();
        }
    },

    /**
     * Must implement this method as a part of the contract with the Dashlet
     * plugin. Kicks off the various paths associated with a dashlet:
     * Configuration, preview, and display.
     *
     * @param {String} view The name of the view as defined by the `oninit`
     *   callback in {@link DashletView#onAttach}.
     */
    initDashlet: function(view) {
        if (this.meta.config) {
            // keep the display_columns and label fields in sync with the selected module when configuring a dashlet
            this.settings.on('change:module', function(model, moduleName) {
                var label = (model.get('filter_id') === 'assigned_to_me') ? 'TPL_DASHLET_MY_MODULE' : 'LBL_MODULE_NAME';
                model.set('label', app.lang.get(label, moduleName, {
                    module: app.lang.getModuleName(moduleName, {plural: true})
                }));

                // Re-initialize the filterpanel with the new module.
                this.dashModel.set('module', moduleName);
                this.dashModel.set('filter_id', 'assigned_to_me');
                this.layout.trigger('dashlet:filter:reinitialize');

                this._updateDisplayColumns();
                this.updateLinkedFields(moduleName);
            }, this);
            this.settings.on('change:intelligent', function(model, intelligent) {
                this.setLinkedFieldVisibility('1', intelligent);
            }, this);
            this.on('render', function() {
                var isVisible = !_.isEmpty(this.settings.get('linked_fields')) ? '1' : '0';
                this.setLinkedFieldVisibility(isVisible, this.settings.get('intelligent'));
            }, this);
        }
        this._initializeSettings();
        this.metaFields = this._getColumnsForDisplay();

        if (this.settings.get('intelligent') == '1') {

            var link = this.settings.get('linked_fields'),
                model = app.controller.context.get('model'),
                module = this.settings.get('module'),
                options = {
                    link: {
                        name: link,
                        bean: model
                    }
                };
            this.collection = app.data.createBeanCollection(module, null, options);
            this.collection.setOption('relate', true);
            this.context.set('collection', this.collection);
            this.context.set('link', link);
        } else {
            this.context.unset('link');
        }

        this.before('render', function() {
            if (!this.moduleIsAvailable) {
                this.$el.html(this._noAccessTemplate());
                return false;
            }
            if (!this.filterIsAccessible) {
                this._displayNoFilterAccess();
                return false;
            }
        });

        // the pivot point for the various dashlet paths
        if (this.meta.config) {
            this._configureDashlet();
            this.listenTo(this.layout, 'init', this._addFilterComponent);
            this.listenTo(this.layout.context, 'filter:add', this.updateDashletFilterAndSave);
            this.layout.before('dashletconfig:save', function() {
                this.saveDashletFilter();
                // NOTE: This prevents the drawer from closing prematurely.
                return false;
            }, this);

        } else if (this.moduleIsAvailable) {
            var filterId = this.settings.get('filter_id');
            if (!filterId || this.meta.preview) {
                this._displayDashlet();
                return;
            }

            var filters = app.data.createBeanCollection('Filters');
            filters.setModuleName(this.settings.get('module'));
            filters.load({
                success: _.bind(function() {
                    if (this.disposed) {
                        return;
                    }
                    var filter = filters.collection.get(filterId);
                    var filterDef = filter && filter.get('filter_definition');
                    if (_.isUndefined(filterDef)) {
                        this.filterIsAccessible = false;
                        this._displayNoFilterAccess();
                    } else {
                        this._displayDashlet(filterDef);
                    }
                }, this),
                error: _.bind(function() {
                    if (this.disposed) {
                        return;
                    }
                    this._displayDashlet();
                }, this)
            });
        }
    },

    /**
     * Display a message when dashlet filter is not accessible.
     */
    _displayNoFilterAccess: function() {
        var template = app.template.get(this.name + '.nofilteraccess');
        var noFilterAccessSupportUrl = app.help.getMoreInfoHelpURL('nofilter', 'listviewdashlet');
        this.$el.html(template({noFilterAccessSupportUrl: noFilterAccessSupportUrl}));
        var listBottom = this.layout.getComponent('list-bottom');
        if (listBottom) {
            listBottom.hide();
        }
    },

    /**
     * @inheritdoc
     * Don't load data if dashlet filter is not accessible.
     */
    loadData: function(options) {
        if (!this.filterIsAccessible) {
            if (options && _.isFunction(options.complete)) {
                options.complete();
            }
            return;
        }
        this._super('loadData', [options]);
    },

    /**
     * Fetch the next pagination records.
     */
    showMoreRecords: function() {
        // Show alerts for this request
        this.getNextPagination();
    },

    /**
     * Returns a custom label for this dashlet.
     *
     * @return {string}
     */
    getLabel: function() {
        var module = this.settings.get('module') || this.context.get('module'),
            moduleName = app.lang.getModuleName(module, {plural: true});
        return app.lang.get(this.settings.get('label'), module, {module: moduleName});
    },

    /**
     * This function is invoked by the `dashletconfig:save` event. If the dashlet
     * we are saving is a dashable list, it initiates the save process for a new
     * filter on the appropriate module's list view, otherwise, it takes the
     * `currentFilterId` stored on the context, and saves it on the dashlet.
     *
     * @param {Bean} model The dashlet model.
     */
    saveDashletFilter: function() {
        // Accessing the dashableconfiguration context.
        var context = this.layout.context;

        if (context.editingFilter) {
            // We are editing/creating a new filter
            if (!context.editingFilter.get('name')) {
                context.editingFilter.set('name', app.lang.get('LBL_DASHLET') +
                    ': ' + this.settings.get('label'));
            }
            // Triggers the save on `filter-rows` which then triggers
            // `filter:add` which then calls `updateDashletFilterAndSave`
            context.trigger('filter:create:save');
        } else {
            // We are saving a dashlet with a predefined filter
            var filterId = context.get('currentFilterId'),
                obj = {id: filterId};
            this.updateDashletFilterAndSave(obj);
        }
    },

    /**
     * This function is invoked by the `filter:add` event. It saves the
     * filter ID on the dashlet model prior to saving it, for later reference.
     *
     * @param {Bean} filterModel The saved filter model.
     */
    updateDashletFilterAndSave: function(filterModel) {
        // We need to save the filter ID on the dashlet model before saving
        // the dashlet.
        var id = filterModel.id || filterModel.get('id');
        this.settings.set('filter_id', id);
        this.dashModel.set('filter_id', id);

        var componentType = this.dashModel.get('componentType') || 'view';

        // Adding a new dashlet requires componentType to be set on the model.
        if (!this.dashModel.get('componentType')) {
            this.dashModel.set('componentType', componentType);
        }

        app.drawer.close(this.dashModel);
        // The filter collection is not shared amongst views and therefore
        // changes to this collection on different contexts (list views and
        // dashlets) need to be kept in sync.
        app.events.trigger('dashlet:filter:save', this.dashModel.get('module'));
    },

    /**
     * Certain dashlet settings can be defaulted.
     *
     * Builds the available module cache by way of the
     * {@link BaseDashablelistView#_setDefaultModule} call. The module is set
     * after "filter_id" because the value of "filter_id" could impact the value
     * of "label" when the label is set in response to the module change while
     * in configuration mode (see the "module:change" listener in
     * {@link BaseDashablelistView#initDashlet}).
     *
     * @private
     */
    _initializeSettings: function() {
        if (this.intelligent === '0') {
            _.each(this.dashletConfig.panels, function(panel) {
                panel.fields = panel.fields.filter(function(el) {return el.name !== 'intelligent'; });
            }, this);
            this.settings.set('intelligent', '0');
            this.dashModel.set('intelligent', '0');
        } else {
            if (_.isUndefined(this.settings.get('intelligent'))) {
                this.settings.set('intelligent', this._defaultSettings.intelligent);
            }
        }
        this.setLinkedFieldVisibility('1', this.settings.get('intelligent'));
        if (!this.settings.get('limit')) {
            this.settings.set('limit', this._defaultSettings.limit);
        }
        if (!this.settings.get('filter_id')) {
            this.settings.set('filter_id', this._defaultSettings.filter_id);
        }
        this._setDefaultModule();
        if (!this.settings.get('label')) {
            this.settings.set('label', 'LBL_MODULE_NAME');
        }
    },

    /**
     * Sets the default module when a module isn't defined in the dashlet's
     * view definition.
     *
     * If the module was defined but it is not in the list of available modules
     * in config mode, then the view's module will be used.
     * @private
     */
    _setDefaultModule: function() {
        var availableModules = _.keys(this._getAvailableModules()),
            module = this.settings.get('module') || this.context.get('module');

        if (_.contains(availableModules, module)) {
            this.settings.set('module', module);
        } else if (this.meta.config) {
            module = this.context.parent.get('module');
            if (_.contains(this.moduleBlacklist, module)) {
                module = _.first(availableModules);
                // On 'initialize' model is set to context's model - that model can have no access at all
                // and we'll result in 'no-access' template after render. So we change it to default model.
                this.model = app.data.createBean(module);
            }
            this.settings.set('module', module);
        } else {
            this.moduleIsAvailable = false;
        }
    },

    /**
     * Update the display_columns attribute based on the current module defined
     * in settings.
     *
     * This will mark, as selected, all fields in the module's list view
     * definition. Any existing options will be replaced with the new options
     * if the "display_columns" DOM field ({@link EnumField}) exists.
     *
     * @private
     */
    _updateDisplayColumns: function() {
        var availableColumns = this._getAvailableColumns(),
            columnsFieldName = 'display_columns',
            columnsField = this.getField(columnsFieldName);
        if (columnsField) {
            columnsField.items = availableColumns;
        }
        this.settings.set(columnsFieldName, _.keys(availableColumns));
    },

    /**
     * Update options for `linked_fields` based on current selected module.
     * If there are no options field is hidden.
     *
     * @param {String} moduleName Name of selected module.
     */
    updateLinkedFields: function(moduleName) {
        var linked = this.getLinkedFields(moduleName),
            displayColumn = this.getField('linked_fields'),
            intelligent = this.dashModel.get('intelligent');
        if (displayColumn) {
            displayColumn.items = linked;
            this.setLinkedFieldVisibility('1', intelligent);
        } else {
            this.setLinkedFieldVisibility('0', intelligent);
        }
        this.settings.set('linked_fields', _.keys(linked)[0]);
    },

    /**
     * Returns object with linked fields.
     *
     * @param {String} moduleName Name of module to find linked fields with.
     * @return {Object} Hash with linked fields labels.
     */
    getLinkedFields: function(moduleName) {
        var fieldDefs  = app.metadata.getModule(this.layout.module).fields;
        var relates =  _.filter(fieldDefs, function(field) {
                if (!_.isUndefined(field.type) && (field.type === 'link')) {
                    if (app.data.getRelatedModule(this.layout.module, field.name) === moduleName) {
                        return true;
                    }
                }
                return false;
            }, this),
            result = {};
        _.each(relates, function(field) {
            result[field.name] = app.lang.get(field.vname || field.name, [this.layout.module, moduleName]);
        }, this);
        return result;
    },

    /**
     * Perform any necessary setup before the user can configure the dashlet.
     *
     * Modifies the dashlet configuration panel metadata to allow it to be
     * dynamically primed prior to rendering.
     *
     * @private
     */
    _configureDashlet: function() {
        var availableModules = this._getAvailableModules(),
            availableColumns = this._getAvailableColumns(),
            relates = this.getLinkedFields(this.module);
        _.each(this.getFieldMetaForView(this.meta), function(field) {
            switch(field.name) {
                case 'module':
                    // load the list of available modules into the metadata
                    field.options = availableModules;
                    break;
                case 'display_columns':
                    // load the list of available columns into the metadata
                    field.options = availableColumns;
                    break;
                case 'linked_fields':
                    field.options = relates;
                    break;
            }
        });
    },

    /**
     * This function adds the `dashablelist-filter` component to the layout
     * (dashletconfiguration), if the component doesn't already exist.
     */
    _addFilterComponent: function() {
        var filterComponent = this.layout.getComponent('dashablelist-filter');
        if (filterComponent) {
            return;
        }

        this.layout.initComponents([{
            layout: 'dashablelist-filter'
        }]);
    },

    /**
     * Gets all of the modules the current user can see.
     *
     * This is used for populating the module select and list view columns
     * fields. Filters any modules that are blacklisted.
     *
     * @return {Object} {@link BaseDashablelistView#_availableModules}
     * @private
     */
    _getAvailableModules: function() {
        if (_.isEmpty(this._availableModules) || !_.isObject(this._availableModules)) {
            this._availableModules = {};
            var visibleModules = app.metadata.getModuleNames({filter: 'visible', access: 'read'}),
                allowedModules = _.difference(visibleModules, this.moduleBlacklist);

            _.each(this.additionalModules, function(extraModules, module) {
                if (_.contains(allowedModules, module)) {
                    allowedModules = _.sortBy(_.union(allowedModules, extraModules), function(name) {return name});
                }
            });
            _.each(allowedModules, function(module) {
                var hasListView = !_.isEmpty(this.getFieldMetaForView(app.metadata.getView(module, 'list')));
                if (hasListView) {
                    this._availableModules[module] = app.lang.getModuleName(module, {plural: true});
                }
            }, this);
        }
        return this._availableModules;
    },

    /**
     * Gets the correct list view metadata.
     *
     * Returns the correct module list metadata
     *
     * @param  {String} module
     * @return {Object}
     */
    _getListMeta: function(module) {
        return app.metadata.getView(module, 'list');
    },

    /**
     * Gets all of the fields from the list view metadata for the currently
     * chosen module.
     *
     * This is used for the populating the list view columns field and
     * displaying the list.
     *
     * @return {Object} {@link BaseDashablelistView#_availableColumns}
     * @private
     */
    _getAvailableColumns: function() {
        var columns = {},
            module = this.settings.get('module');
        if (!module) {
            return columns;
        }

        _.each(this.getFieldMetaForView(this._getListMeta(module)), function(field) {
            columns[field.name] = app.lang.get(field.label || field.name, module);
        });

        return columns;
    },

    /**
     * Perform any necessary setup before displaying the dashlet.
     *
     * @param {Array} [filterDef] The filter definition array.
     * @private
     */
    _displayDashlet: function(filterDef) {
        // Get the columns that are to be displayed and update the panel metadata.
        var columns = this._getColumnsForDisplay();
        this.meta.panels = [{fields: columns}];

        this.context.set('skipFetch', false);
        this.context.set('limit', this.settings.get('limit'));
        this.context.set('fields', this.getFieldNames());

        if (filterDef) {
            this._applyFilterDef(filterDef);
            this.context.reloadData({'recursive': false});
        }
        this._startAutoRefresh();
    },

    /**
     * Sets the filter definition on the context collection to retrieve records
     * for the list view.
     *
     * @param {Array} filterDef The filter definition array.
     * @private
     */
    _applyFilterDef: function(filterDef) {
        if (filterDef) {

            filterDef = _.isArray(filterDef) ? filterDef : [filterDef];
            /**
             * Filter fields that don't exist either on vardefs or search definition.
             *
             * Special fields (fields that start with `$`) like `$favorite` aren't
             * cleared.
             *
             * TODO move this to a plugin method when refactoring the code (see SC-2555)
             * TODO we should support cleanup on all levels (currently made on 1st
             * level only).
             */
            var specialField = /^\$/,
                meta = app.metadata.getModule(this.module);
            filterDef = _.filter(filterDef, function(def) {
                var fieldName = _.keys(def).pop();
                return specialField.test(fieldName) || meta.fields[fieldName];
            }, this);

            this.context.get('collection').filterDef = filterDef;
        }
    },

    /**
     * Gets the columns chosen for display for this dashlet list.
     *
     * The display_columns setting might not have been defined when the dashlet
     * is being displayed from a metadata definition, like is the case for
     * preview and the default dashablelist's that are defined. All columns for
     * the selected module are shown in these cases.
     *
     * @return {Object[]} Array of objects defining the field metadata for
     *   each column.
     * @private
     */
    _getColumnsForDisplay: function() {
        var columns = [];
        var fields = this.getFieldMetaForView(this._getListMeta(this.settings.get('module')));
        var moduleMeta = app.metadata.getModule(this.module);
        if (!this.settings.get('display_columns')) {
            this._updateDisplayColumns();
        }
        if (!this.settings.get('linked_fields')) {
            this.updateLinkedFields(this.model.module);
        }
        _.each(this.settings.get('display_columns'), function(name) {
            var field = _.find(fields, function(field) {
                return field.name === name;
            }, this);
            // It's possible that a column is on the dashlet and not on the
            // main list view (thus was never patched by metadata-manager).
            // We need to fix up the columns in that case.
            // FIXME: This method should not be used as a public method (though
            // it's being used everywhere in the app) this should be reviewed
            // when SC-3607 gets in.
            field = field || app.metadata._patchFields(this.module, moduleMeta, [name]);

            // Handle setting of the sortable flag on the list. This will not
            // always be true
            var sortableFlag,
                column,
                fieldDef = app.metadata.getModule(this.module).fields[field.name];

            // If the module's field def says nothing about the sortability, then
            // assume it's ok to sort
            if (_.isUndefined(fieldDef) || _.isUndefined(fieldDef.sortable)) {
                sortableFlag = true;
            } else {
                // Get what the field def says it is supposed to do
                sortableFlag = !!fieldDef.sortable;
            }

            column = _.extend({sortable: sortableFlag}, field);

            columns.push(column);
        }, this);
        return columns;
    },

    /**
     * Starts the automatic refresh of the dashlet.
     *
     * @private
     */
    _startAutoRefresh: function() {
        var refreshRate = parseInt(this.settings.get('auto_refresh'), 10);
        if (refreshRate) {
            this._stopAutoRefresh();
            this._timerId = setInterval(_.bind(function() {
                this.context.resetLoadFlag();
                this.layout.loadData();
            }, this), refreshRate * 1000 * 60);
        }
    },

    /**
     * Cancels the automatic refresh of the dashlet.
     *
     * @private
     */
    _stopAutoRefresh: function() {
        if (this._timerId) {
            clearInterval(this._timerId);
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (!this.meta || !this.meta.config) {
            return this._super('_render');
        }

        this.action = 'list';
        return this._super('_render');
    },

    /**
     * @inheritdoc
     *
     * Calls {@link BaseDashablelistView#_stopAutoRefresh} so that the refresh will
     * not continue after the view is disposed.
     *
     * @private
     */
    _dispose: function() {
        this._stopAutoRefresh();
        this._super('_dispose');
    },

    /**
     * Gets the fields metadata from a particular view's metadata.
     *
     * @param {Object} meta The view's metadata.
     * @return {Object[]} The fields metadata or an empty array.
     */
    getFieldMetaForView: function(meta) {
        meta = _.isObject(meta) ? meta : {};
        return !_.isUndefined(meta.panels) ? _.flatten(_.pluck(meta.panels, 'fields')) : [];
    },

    /**
     * ListView sort will close previews, but this is not needed for dashablelists
     * In fact, closing preview causes problem when previewing this list dashlet
     * from dashlet-select
     */
    sort: $.noop
}) },
"quicksearch-bar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchBarView
 * @alias SUGAR.App.view.views.BaseQuicksearchBarView
 * @extends View.View
*/
({
	// Quicksearch-bar View (base) 


    className: 'table-cell quicksearch-bar-wrapper',
    /**
     * The minimum number of characters before the search bar attempts to
     * retrieve results.
     *
     * @property {number}
     */
    minChars: 1,

    searchModules: [],
    events: {
        'focus input[data-action=search_bar]': 'requestFocus',
        'click input[data-action=search_bar]': 'searchBarClickHandler'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The collection for executing searches and passing results.
         * This could be shared and used by other components.
         */
        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        this.selectedTags = this.layout.selectedTags || [];

        /**
         * The default number of maximum results to display.
         *
         * You can override this value by providing a `limit` property in the
         * metadata.
         *
         * @type {number}
         * @property
         */
        this.limit = 5;
        if (this.meta && this.meta.limit) {
            this.limit = this.meta.limit;
        }

        /**
         * Used for keyboard up/down arrow navigation between components of `globalsearch` layout
         *
         * @property {boolean}
         */
        this.isFocusable = true;


        /**
         * The current search term.
         * When a search term is typed, the term is immediately stored to this variable. After the 500ms debounce, the
         * term is used to execute a search.
         * @type {string}
         * @private
         */
        this._searchTerm = '';

        /**
         * The previous search term.
         * This is stored to check against `this._searchTerm`. If `this._searchTerm === this._oldSearchTerm`, we do
         * not need to retrieve new results. This protects us against keystrokes that do not change the search term.
         * @type {string}
         * @private
         */
        this._oldSearchTerm = '';

        /**
         * The previous query term.
         * This is the last search term used to get results, and as such, is the term that produced the currently
         * displayed results. If `this._searchTerm === this._currentQueryTerm` when the search is executed (after
         * the 500ms debounce), we do not need to execute a new search.
         * @type {string}
         * @private
         */
        this._currentQueryTerm = '';

        app.events.on('app:sync:complete', this.populateModules, this);

        // Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function() {
            // if the input doesn't have focus, give it focus.
            var inputBox = this.$input[0];
            if (inputBox !== $(document.activeElement)[0]) {
                inputBox.focus();
            } else {
                this.attachKeyEvents();
            }
        }, this);

        // Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.disposeKeyEvents();
        }, this);

        // Listener for `quicksearch:close`. This aborts in progress
        // searches
        this.layout.on('quicksearch:close', function() {
            this._searchTerm = '';
            this._currentQueryTerm = '';
            this._oldSearchTerm = '';
            this.collection.abortFetchRequest();
            this.$input.blur();
        }, this);

        this.layout.on('quicksearch:bar:clear', this.clearSearch, this);

        this.layout.on('quicksearch:bar:clear:term', this.clearSearchTerm, this);

        this.layout.on('quicksearch:bar:search', this.goToSearchPage, this);

        this.layout.on('route:search', this.populateSearchTerm, this);

        this.layout.on('quicksearch:fire:search', function() {
            // In case we are already in the middle of a search
            this.collection.abortFetchRequest();
            this._oldSearchTerm = null;
            this._currentQueryTerm = null;
            this._validateAndSearch();
        }, this);
    },

    /**
     * Renders a view onto the page.
     *
     * @protected
     */
    _renderHtml: function() {
        this._super('_renderHtml');
        this.$input = this.$('input[data-action=search_bar]');
    },

    /**
     * Checks to see if we're in the search context. If we are, populate the search
     * bar with the search term.
     */
    populateSearchTerm: function() {
        var inputBar = this.$input;
        var searchTerm = this.context.get('searchTerm');
        if (inputBar.val() !== searchTerm) {
            inputBar.val(searchTerm);
        }
    },

    /**
     * Request focus from the layout. This is used primarily for mouse clicks.
     */
    requestFocus: function() {
        this.layout.trigger('navigate:to:component', this.name);
    },

    /**
     * Function to attach the keydown and keyup events.
     */
    attachKeyEvents: function() {
        var searchBarEl = this.$input;
        // for arrow key navigation
        searchBarEl.on('keydown', _.bind(this.keydownHandler, this));

        // for searchbar typeahead
        searchBarEl.on('keyup', _.bind(this.keyupHandler, this));
    },

    /**
     * Function to dispose the keydown and keyup events.
     */
    disposeKeyEvents: function() {
        this.$input.off('keydown keyup');
    },

    /**
     * Handles the keydown event for up, down, and ignores tab.
     *
     * @param {Event} e The `keydown` event
     * @private
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                this.moveForward();
                e.preventDefault();
                e.stopPropagation();
                break;
            case 38: // up arrow
                e.preventDefault();
                e.stopPropagation();
                break;
            case 37: // left arrow
            case 8:  //backspace
                // If there's text in the input bar, don't add any special handling
                var term = this.$input.val();
                if (term === '') {
                    this.moveBackward();
                    // Prevent double event calling when element to the left attaches its keydown handler
                    e.stopPropagation();
                    e.preventDefault();
                }
                break;
        }
    },

    /**
     * Handles the keyup event for typing, and ignores tab
     *
     * @param {Event} e The `keyup event
     */
    keyupHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                break;
            case 38: // up arrow
                break;
            case 9: // tab
                break;
            case 16: // shift
                break;
            case 13: // enter
                this.goToSearchPage();
                break;
            case 27: // esc
                this.layout.trigger('quicksearch:close');
                break;
            default:
                this._validateAndSearch();
        }
    },

    /**
     * Goes to the search page and displays results.
     */
    goToSearchPage: function() {
        // navigate to the search results page
        var term = this.$input.val();
        var route = '';
        this._searchTerm === this._currentQueryTerm;
        this._currentQueryTerm = term;
        if (this.layout.v2) {
            route = app.utils.GlobalSearch.buildSearchRoute(term, {
                modules: this.collection.selectedModules,
                tags: _.pluck(this.selectedTags, 'name')
            });
        } else {
            var moduleString = this.collection.selectedModules.join(',');
            route = 'bwc/index.php?module=Home&append_wildcard=true&action=spot&full=true' +
                '&q=' + term +
                '&m=' + moduleString;
        }
        this.collection.abortFetchRequest();
        app.router.navigate(route, {trigger: true});
    },
    /**
     * Handler for clicks on the search bar.
     *
     * Expands the bar and toggles the search icon.
     */
    searchBarClickHandler: function() {
        this.requestFocus();
        _.defer(_.bind(this.layout.expand, this.layout));
    },

    /**
     * Navigate to the next component
     */
    moveForward: function() {
        if (this.layout.triggerBefore('navigate:next:component')) {
            this.disposeKeyEvents();
            this.layout.trigger('navigate:next:component');
        }
    },

    /**
     * Navigate to the previous component
     */
    moveBackward: function() {
        if (this.layout.triggerBefore('navigate:previous:component')) {
            this.disposeKeyEvents();
            this.layout.trigger('navigate:previous:component');
        }
    },

    /**
     * Waits & debounces for 0.5 seconds before firing a search. This is primarily used on the
     * keydown event for the typeahead functionality.
     *
     * @param {string} term The search term.
     * @private
     * @method
     */
    _debounceSearch: _.debounce(function() {
        // Check if the search term is falsy (empty string)
        // or the search term is the same as the previously searched term
        // If either of those conditions are met, we do not need to execute a new search.
        if ((!this._searchTerm && this.selectedTags.length === 0)
            || this._searchTerm === this._currentQueryTerm) {
            return;
        }
        this._currentQueryTerm = this._searchTerm;
        this.fireSearchRequest();
    }, 500),


    /**
     * Collects the search term, validates that a search is appropriate, and executes a debounced search.
     * First, it checks the search term length, to ensure it meets the minimum length requirements.
     * Second, it checks the search term against the previously typed search term. If the search term hasn't changed
     * (for example, for keyboard shortcuts) then there is no need to rerun the search.
     * If the above conditions are met, `_validateAndSearch` runs a debounced search.
     *
     * @private
     */
    _validateAndSearch: function() {
        var term = this.$input.val();
        this._searchTerm = term;

        // if the term is too short, don't search
        if (term.length < this.minChars && this.selectedTags.length === 0) {
            this._searchTerm = '';
            this._currentQueryTerm = '';
            this._oldSearchTerm = '';
            // We trigger `quicksearch:results:close` instead of
            // `quicksearch:close` because we only want to close the dropdown
            // and keep the bar expanded. That means we only want the listener
            // in `quicksearch-results.js` to be called, not the other ones.
            this.collection.abortFetchRequest();
            this.layout.trigger('quicksearch:results:close');
            this.collection.abortFetchRequest();
            return;
        }

        // shortcuts might trigger multiple `keydown` events, to do some actions like blurring the input, but since the
        // input value didn't change we don't want to trigger a new search.
        var hasInputChanged = (this._searchTerm !== this._oldSearchTerm);
        if (hasInputChanged) {
            this.collection.dataFetched = false;
            this.layout.trigger('quicksearch:search:underway');
            this.layout.expand();
            this._oldSearchTerm = term;
            this._debounceSearch();
        }
    },

    /**
     * Executes a search using `this._searchTerm`.
     * TODO: Move this function into the layout so that we can sandbox out tags from the bar
     */
    fireSearchRequest: function() {
        var term = this._searchTerm;
        // FIXME: SC-4254 Remove this.layout.v2
        var limit = this.layout.v2 ? this.limit : 5;
        limit = app.config && app.config.maxSearchQueryResult || limit;
        var options = {
            query: term,
            module_list: this.collection.selectedModules,
            limit: limit,
            params: {
                tags: true
            },
            apiOptions: {
                useNewApi: true
            }
        };

        if (this.selectedTags.length > 0) {
            _.extend(options.apiOptions, {
                    data: {
                        tag_filters: _.pluck(this.selectedTags, 'id')
                    },
                    fetchWithPost: true
            });
        }

        // FIXME: SC-4254 Remove this.layout.v2
        if (!this.layout.v2) {
            options.fields = ['name', 'id'];
        }
        this.collection.query = term;
        this.collection.fetch(options);
    },

    /**
     * Clears out search upon user following search result link in menu
     */
    clearSearch: function() {
        this.$input.val('');
        this._searchTerm = '';
        this._oldSearchTerm = '';
        this._currentQueryTerm = '';
        this.layout.trigger('quicksearch:tags:remove');
        this.disposeKeyEvents();
    },

    clearSearchTerm: function() {
        this.$input.val('');
        this._searchTerm = '';
        this._oldSearchTerm = '';
        this._currentQueryTerm = '';
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeyEvents();
        this._super('unbind');
    }
}) },
"alert": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.AlertView
 * @alias SUGAR.App.view.views.BaseAlertView
 * @extends View.View
 */
({
	// Alert View (base) 

    className: 'alert-wrapper', //override default class

    events: {
        'click [data-action=cancel]': 'cancelClicked',
        'click [data-action=confirm]': 'confirmClicked',
        'click [data-action=close]': 'closeClicked',
        'click a': 'linkClick'
    },

    LEVEL: {
        PROCESS: 'process',
        SUCCESS: 'success',
        WARNING: 'warning',
        INFO: 'info',
        ERROR: 'error',
        CONFIRMATION: 'confirmation'
    },

    /**
     * Initialize alert view.
     *
     * @param {Object} options Options to be passed to the alert view.
     * @param {boolean} options.closeable: boolean flag indicating if the alert
     *   can be closed by the user. Note that non-"info" alerts are closeable by
     *   default if this setting is not specified.
     * @param {Function} options.onConfirm: Handler of action Confirm for
     *   confirmation alerts.
     * @param {Function} options.onCancel: Handler of action Cancel for
     *   confirmation alerts.
     * @param {Function} options.onLinkClicked: Handler for click actions on a
     *   link inside the alert.
     * @param {Function} options.onClose: Handler for the close event on the (x).
     * @param {Object} options.templateOptions: Augment template context with
     *   custom object.
     *
     * @override
     */
    initialize: function(options) {
        app.plugins.attach(this, 'view');

        this.options = options || {};
        this.options.confirm || (this.options.confirm = {});
        this.options.cancel || (this.options.cancel = {});

        this.onConfirm = this.options.onConfirm || this.options.confirm.callback;
        this.confirmLabel = this.options.confirm.label || 'LBL_CONFIRM_BUTTON_LABEL';
        this.onCancel = this.options.onCancel || this.options.cancel.callback;
        this.cancelLabel = this.options.cancel.label || 'LBL_CANCEL_BUTTON_LABEL';
        this.onLinkClick = this.options.onLinkClick;
        this.onClose = this.options.onClose;
        this.templateOptions = this.options.templateOptions;
        this.name = 'alert';
    },

    /**
     * Gets selector for DOM elements that need to be clicked in order to close an alert.
     * @return {Object} jQuery/Zepto selector of the close button.
     */
    getCloseSelector: function() {
        return this.$('.close');
    },

    /**
     * Renders the custom alert view template. Binds `Esc` and `Return` keys for
     * confirmation alerts.
     *
     * @override
     */
    render: function() {
       var options = this.options;

        if (!this.triggerBefore('render')) {
            return false;
        }
        if (_.isUndefined(options)) {
            return this;
        }

        if (options.messages) {
            var messageSize = _.reduce(options.messages, function(memo, message) {
                return memo + message.length;
            }, 0);
            this.templateOptions = this.templateOptions || {};
            this.templateOptions.hasBigMessage = (messageSize > 80);
        }

        var template = this._getAlertTemplate(options, this.templateOptions);

        this.$el.html(template);

        if (options.level === 'confirmation') {
            this.bindCancelAndReturn();
        }

        this.trigger('render');
    },

    /**
     * Dismiss the alert when user clicks `cancel`
     */
    cancel: function() {
        this.trigger('dismiss');
        app.alert.dismiss(this.key);
    },

    /**
     * Executes assigned handlers when user clicks `cancel`.
     *
     * @param {Event} [event]
     */
    cancelClicked: function(event) {
        this.cancel();
        app.events.trigger('alert:cancel:clicked');
        if (_.isFunction(this.onCancel)) {
            this.onCancel(event);
        }
    },

    /**
     * Executes assigned handlers when user clicks `confirm`.
     *
     * @param {Event} [event]
     */
    confirmClicked: function(event) {
        this.cancel();
        app.events.trigger('alert:confirm:clicked');
        if (_.isFunction(this.onConfirm)) {
            this.onConfirm(event);
        }
    },

    /**
     * Fired when a link is clicked
     *
     * @param {Event} event
     */
    linkClick: function(event) {
        if (_.isFunction(this.onLinkClick)) {
            this.onLinkClick(event);
        }
    },

    /**
     * Fired when the close (x) is clicked
     * @param {Event} event
     */
    closeClicked: function(event) {
        if (_.isFunction(this.onClose)) {
            this.onClose(event);
        }
        app.alert.dismiss(this.key);
    },
    /**
     * Gets the HTML string for alert given options.
     *
     * @param {Object} [options] The options object passed to the alert object
     *   when it was created. See {@link #initialize} documentation to know the
     *   available options.
     * @param {string|string[]} [options.messages] The message(s) to be
     *   displayed in the alert dialog.
     * @param {Object} [templateOptions] Optional template options to be passed
     *   to the template.
     * @return {string} The generated template.
     * @private
     */
    _getAlertTemplate: function(options, templateOptions) {
        options = options || {};
        var alert = this._getAlertProps(options);
        var template = alert.templateName ? app.template.getView(alert.templateName) : app.template.empty;
        var seed = _.extend({}, {
            alertClass: alert.cssClass,
            alertIcon: alert.icon,
            title: this.getTranslatedLabels(alert.title),
            messages: this.getTranslatedLabels(options.messages),
            closeable: _.isUndefined(options.closeable) || options.closeable,
            alert: this
        }, templateOptions);

        return template(seed);
    },

    /**
     * From the given `options`, this method returns an object with
     * corresponding alert properties.
     *
     * @private
     * @param {Object} [options] Alert options like `title`, `level`, etc.
     * @param {string} [options.level] Alert level e.g. 'success', 'error' etc.
     * @param {string} [options.title] Custom alert title to be used.
     * @return {Object} Alert properties to be used when rendering the alert
     *   template.
     */
    _getAlertProps: function(options) {
        var title = options.title || '';
        var defaultTemplateName = this.name + '.error';

        switch (options.level) {
            case this.LEVEL.PROCESS:
                // Remove ellipsis from the end of the string.
                title = title.substr(-3) === '...' ? title.substr(0, title.length - 3) : title;

                return {
                    title: title || 'LBL_ALERT_TITLE_LOADING',
                    templateName: this.name + '.process',
                    cssClass: 'alert-process',
                    icon: ''
                };
            case this.LEVEL.SUCCESS:
                return {
                    title: title || 'LBL_ALERT_TITLE_SUCCESS',
                    templateName: defaultTemplateName,
                    cssClass: 'alert-success',
                    icon: 'fa-check-circle'
                };
            case this.LEVEL.WARNING:
                return {
                    title: title || 'LBL_ALERT_TITLE_WARNING',
                    templateName: defaultTemplateName,
                    cssClass: 'alert-warning',
                    icon: 'fa-exclamation-triangle'
                };
            case this.LEVEL.INFO:
                return {
                    title: title || 'LBL_ALERT_TITLE_NOTICE',
                    templateName: defaultTemplateName,
                    cssClass: 'alert-info',
                    icon: 'fa-info-circle'
                };
            case this.LEVEL.ERROR:
                return {
                    title: title || 'LBL_ALERT_TITLE_ERROR',
                    templateName: defaultTemplateName,
                    cssClass: 'alert-danger',
                    icon: 'fa-exclamation-circle'
                };
            case this.LEVEL.CONFIRMATION:
                return {
                    title: title || 'LBL_ALERT_TITLE_WARNING',
                    templateName: this.name + '.confirmation',
                    cssClass: 'alert-warning',
                    icon: 'fa-exclamation-triangle'
                };
            default:
                return {
                    title: title,
                    cssClass: '',
                    icon: 'fa-info-circle'
                };
        }
    },

    /**
     * Get CSS classes given alert level
     *
     * @deprecated Deprecated since 7.8. Will be removed in 7.9.
     * @param {string} level
     * @return {string}
     */
    getAlertClasses: function(level) {
        app.logger.warn('The View.Views.Base.AlertView#getAlertClasses has been deprecated since 7.8.0 and will be ' +
            'removed in 7.9.');

        this._getAlertProps({level: level}).cssClass;
    },

    /**
     * Get the default title given alert level
     *
     * @deprecated Deprecated since 7.8. Will be removed in 7.9.
     * @param {string} level
     * @return {string}
     */
    getDefaultTitle: function(level) {
        app.logger.warn('The View.Views.Base.AlertView#getDefaultTitle has been deprecated since 7.8.0 and will be ' +
            'removed in 7.9.');

        this._getAlertProps({level: level}).title;
    },

    /**
     * Return translated text, given a string or an array of strings.
     * @param {String/Array} stringOrArray
     * @return {String/Array}
     */
    getTranslatedLabels: function(stringOrArray) {
        var result;

        if (_.isArray(stringOrArray)) {
            result = _.map(stringOrArray, function(text) {
                return new Handlebars.SafeString(app.lang.get(text));
            });
        } else {
            result = new Handlebars.SafeString(app.lang.get(stringOrArray));
        }

        return result;
    },

    /**
     * Remove br tags after alerts which are needed to stack alerts vertically.
     */
    close: function() {
        this.unbindCancelAndReturn();
        this.$el.next('br').remove();
        this.dispose();
    },

    /**
     * Used by confirmation alerts so pressing `Esc` will Cancel, pressing
     * `Return` will Confirm
     */
    bindCancelAndReturn: function() {
        app.shortcuts.saveSession();
        app.shortcuts.createSession([
            'Alert:Confirm',
            'Alert:Cancel'
        ], this);

        app.shortcuts.register({
            id: 'Alert:Confirm',
            keys: 'enter',
            component: this,
            description: 'LBL_SHORTCUT_ALERT_CONFIRM',
            handler: function() {
                this.$('[data-action=confirm]').click();
            }
        });

        app.shortcuts.register({
            id: 'Alert:Cancel',
            keys: 'esc',
            component: this,
            description: 'LBL_SHORTCUT_ALERT_CANCEL',
            handler: function() {
                this.$('[data-action=cancel]').click();
            }
        });
    },

    /**
     * Unbind keydown event
     */
    unbindCancelAndReturn: function() {
        if (this.level === 'confirmation') {
            app.shortcuts.restoreSession();
        }
    },

    /**
     * @override
     */
    bindDataChange: function() {
    }
}) },
"marketing-extras": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MarketingExtrasView
 * @alias SUGAR.App.view.views.BaseMarketingExtrasView
 * @extends View.View
 */
({
	// Marketing-extras View (base) 

    marketingContentUrl: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.receiveMessage = this.receiveMessage.bind(this);
        window.addEventListener('message', this.receiveMessage, false);
        this._super('initialize', [options]);
        this.fetchMarketingExtras();
    },

    /**
     * Listen for the marketing frame to post a navigation event on click
     * Expected format for the event data is a JSON encoded object.
     * {"marketing_content_navigate":"https://url.navto.com"}
     *
     * @param {MessageEvent} event Message event with the location to navigate to.
     */
    receiveMessage: function(event) {
        //First verify the message came from the page we expected
        if (this.marketingContentUrl.substr(0, event.origin.length) === event.origin) {
            var data = JSON.parse(event.data);
            if (data && data.marketing_content_navigate) {
                window.open(data.marketing_content_navigate, '_blank');
            }
        }
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        window.removeEventListener('message', this.receiveMessage, false);
        this._super('unbind', arguments);
    },

    /**
     * Retrieve marketing extras URL from login content endpoint
     */
    fetchMarketingExtras: function() {
        var config = app.metadata.getConfig();
        this.showMarketingContent = config.marketingExtrasEnabled;
        if (this.showMarketingContent) {
            var language = app.user.getLanguage();
            var url = app.api.buildURL('login/content', null, null, {selected_language: language});
            app.api.call('read', url, null, {
                success: _.bind(function(contents) {
                    if (contents && !_.isEmpty(contents.content_url)) {
                        this.marketingContentUrl = contents.content_url;
                        this.render();
                    }
                }, this)
            });
        }
    },
}) },
"baseeditmodal": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.BaseeditmodalView
 * @alias SUGAR.App.view.views.BaseBaseeditmodalView
 * @extends View.View
 */
({
	// Baseeditmodal View (base) 

    events: {
        'click [name=save_button]': 'saveButton',
        'click [name=cancel_button]': 'cancelButton'
    },
    // Delegate events
    saveButton: function() {
        var createModel = this.context.get('createModel');

        this.$('[name=save_button]').attr('data-loading-text', app.lang.get('LBL_LOADING'));
        this.$('[name=save_button]').button('loading');

        // Disable the buttons during save.
        this.disableButtons(true);
        this.processModel(createModel);

        // saves the related bean
        createModel.save(null, {
            relate: true,
            fieldsToValidate: this.getFields(this.module),
            success: _.bind(function() {
                this.saveComplete();
            }, this),
            error: _.bind(function() {
                this.disableButtons(false);
            }, this)

        });
    },
    /**
     * Preprocess the model before saving. This function is here so that children may override it as necessary.
     * @param {object} model
     */
    processModel: function(model) {

    },
    cancelButton: function() {
        if (Modernizr.touch) {
            app.$contentEl.removeClass('content-overflow-visible');
        }
        this.$('.modal').modal('hide').find('form').get(0).reset();
        if (this.context.has('createModel')) {
            this.context.get('createModel').clear();
        }
    },
    saveComplete: function() {
        //reset the form
        this.$('.modal').modal('hide').find('form').get(0).reset();
        //reset the `Save` button
        this.disableButtons(false);
        //add the new model to the collection
        this.collection.fetch({relate: true});
    },

    /**
     * Enables or disables the buttons from the metadata. Disables them by
     * default.
     *
     * @param {boolean} [disable=true] Whether to enable or disable the buttons.
     *   Defaults to `true`.
     */
    disableButtons: function(disable) {
        var state = _.isUndefined(disable) ? true : disable;

        _.each(this.meta.buttons, function(button) {
            var btn = this.getField(button.name);
            btn.setDisabled(state);
        }, this);
    }
}) },
"dupecheck-filter-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckFilterDropdownView
 * @alias SUGAR.App.view.views.BaseDupecheckFilterDropdownView
 * @extends View.Views.Base.FilterFilterDropdownView
 */
({
	// Dupecheck-filter-dropdown View (base) 

    extendsFrom: 'FilterFilterDropdownView',

    /**
     * Display `LBL_DUPECHECK_FILTER_DEFAULT` for all record set label.
     */
    labelAllRecordsFormatted: 'LBL_DUPECHECK_FILTER_DEFAULT'
}) },
"modal-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ModalHeaderView
 * @alias SUGAR.App.view.views.BaseModalHeaderView
 * @extends View.View
 */
({
	// Modal-header View (base) 

    events: {
        'click .close' : 'close'
    },
    close: function() {
        this.layout.hide();
    },
    setTitle: function(title) {
        this.title = title;
    },
    setButton: function(buttons) {
        this.buttons = buttons;
    }
}) },
"forecastdetails": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastdetailsView
 * @alias SUGAR.App.view.views.BaseForecastdetailsView
 * @extends View.View
 */
({
	// Forecastdetails View (base) 

    plugins: ['Dashlet'],

    /**
     * Manager totals for likely_adjusted
     */
    likelyTotal: 0,

    /**
     * Manager totals for best_adjusted
     */
    bestTotal: 0,

    /**
     * Manager totals for worst_adjusted
     */
    worstTotal: 0,

    /**
     * If we need to get the rollup or direct forecast data
     */
    shouldRollup: false,

    /**
     * Necessary for Forecast module as the selectedUser can change and be different from currently-loggged-in user
     */
    selectedUser: {},

    /**
     * Has Forecast module been set up
     */
    isForecastSetup: false,

    /**
     * Is the user a Forecast admin
     */
    isForecastAdmin: false,

    /**
     * Track if current user is manager.
     */
    isManager: false,

    /**
     * Holds the subDetails template so the timeperiod field doesn't re-fetch every re-render
     */
    subDetailsTpl: {},

    /**
     * Holds the detailsMsg template
     */
    detailsMsgTpl: {},

    /**
     * Holds the dom values for best/likely/worst show/hide dropdown
     */
    detailsDataSet: {},

    /**
     * Config metadata from Forecasts module
     */
    forecastConfig: {},

    /**
     * If timeperiod dropdown should be shown (not in Forecasts)
     */
    showTimeperiod: true,

    /**
     * Holds if the forecasts config has proper closed won/lost keys
     */
    forecastsConfigOK: false,

    /**
     * Contains the latest saved data from the server
     */
    serverData: {},

    /**
     * The parent module for the dashlet
     */
    currentModule: '',

    /**
     * The span class number to use span12, span4, etc
     */
    spanCSS: '',

    /**
     * Flag for if we've run getInitData yet or not
     */
    initDataLoaded: false,

    /**
     * events on the view for which to watch
     */
    events : {
        'click #forecastsProgressDisplayOptions div.datasetOptions label.radio' : 'changeDisplayOptions'
    },

    /**
     * Holds previous totals for math
     */
    oldTotals: {},

    /**
     * Holds a collection of quota Objects by the quota's record ID
     */
    quotaCollection: undefined,

    /**
     * What to show when we don't have access to the data
     */
    noDataAccessTemplate: undefined,

    /**
     * Holds likely/best/worst field access boolean values
     * ex: { likely: true, best: false, worst: false }
     */
    fieldDataAccess: {},

    /**
     * Managers that are not top-level managers should also
     * show the target quota (exact quota assigned by their mgr)
     */
    showTargetQuota: false,

    /**
     * Holds the forecast isn't set up message if Forecasts hasn't been set up yet
     */
    forecastsNotSetUpMsg: undefined,

    /**
     * Flag for if loadData is currently running
     */
    loading: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.currentModule = app.controller.context.get("module");

        // check to make sure that forecast is configured
        this.forecastConfig = app.metadata.getModule('Forecasts', 'config');
        this.isForecastSetup = this.forecastConfig.is_setup;
        this.forecastsConfigOK = app.utils.checkForecastConfig();
        this.isForecastAdmin = _.isUndefined(app.user.getAcls()['Forecasts'].admin);
        this.isManager = app.user.get('is_manager');

        if(!this.isForecastSetup) {
            this.forecastsNotSetUpMsg = app.utils.getForecastNotSetUpMessage(this.isForecastAdmin);
        }

        if(this.isForecastSetup && this.forecastsConfigOK) {
            this.serverData = new Backbone.Model();

            // Check field access
            var aclModule = this.forecastConfig.forecast_by,
                likelyFieldName = (aclModule == 'RevenueLineItems') ? 'likely_case' : 'amount';
            this.fieldDataAccess = {
                likely: app.acl.hasAccess('read', aclModule, app.user.get('id'), likelyFieldName),
                best: app.acl.hasAccess('read', aclModule, app.user.get('id'), 'best_case'),
                worst: app.acl.hasAccess('read', aclModule, app.user.get('id'), 'worst_case')
            };
            var hasAccess = (this.fieldDataAccess.likely && this.fieldDataAccess.best && this.fieldDataAccess.worst);
            // if any field has no access, get the noaccess field template
            if(hasAccess === false) {
                this.noDataAccessTemplate = app.template.getField('base', 'noaccess')(this);
            }

            // set up the model data
            this.resetModel();

            // since we need the timeperiods from 'Forecasts' set the models module to 'Forecasts'
            this.context.get('model').module = 'Forecasts';

            // use the object version of user not a Model
            this.selectedUser = app.user.toJSON();

            if (this.currentModule != 'Home') {
                // On Forecasts, this is based on whether user is viewing manager or rep worksheet
                this.shouldRollup = this.isManagerView();
            } else {
                // On Home, the dashlet should default to manager data for managers, and rep for non-manager
                this.shouldRollup = this.selectedUser.is_manager;
            }

            // once selectedUser & shouldRollup is set, check if user is a sub-manager
            this.checkShowTargetQuota();

            // set up the subtemplate
            this.subDetailsTpl = app.template.getView('forecastdetails.sub-details');
            this.detailsMsgTpl = app.template.getView('forecastdetails.details-msg');

            this.detailsDataSet = this.setUpShowDetailsDataSet(this.forecastConfig);

            this.checkSpanCSS();
        }
    },

    /**
     * @inheritdoc
     */
    initDashlet: function() {
        this.settings.module = 'Forecasts';
    },

    /**
     * Checks config show_worksheet_ settings for likely/best/worst and sets the spanCSS
     */
    checkSpanCSS: function() {
        var ct = 0;
        _.each([this.forecastConfig.show_worksheet_likely,
            this.forecastConfig.show_worksheet_best,
            this.forecastConfig.show_worksheet_worst], function(val)
        {
            if(val) {
                ct++;
            }
        });

        switch(ct) {
            case 3:
                this.spanCSS = '4';
                break;
            case 2:
                this.spanCSS = '6';
                break;
            case 1:
                this.spanCSS = '12';
                break;
            case 0:
                this.spanCSS = '';
                break;
        }

        this.model.set({spanCSS: this.spanCSS}, {silent: true});
    },

    /**
     * Returns an object of key: value pairs to be used in the select dropdowns to choose Likely/Best/Worst data to show/hide
     *
     * @param cfg Metadata config object for forecasts
     * @return {Object}
     */
    setUpShowDetailsDataSet: function(cfg) {
        var ds = app.metadata.getStrings('app_list_strings')['forecasts_options_dataset'] || [];

        var returnDs = {};
        _.each(ds, function(value, key) {
            if(cfg['show_worksheet_' + key] == 1) {
                returnDs[key] = value
            }
        }, this);
        return returnDs;
    },

    /**
     * Resets the model to default data
     */
    resetModel: function() {
        var model = {
            opportunities : 0,
            closed_amount : undefined,
            quota_amount : undefined,
            target_quota_amount: undefined,
            deficit_amount: undefined,
            worst_details: undefined,
            likely_details: undefined,
            best_details: undefined,
            show_details_likely: this.forecastConfig.show_worksheet_likely,
            show_details_best: this.forecastConfig.show_worksheet_best,
            show_details_worst: this.forecastConfig.show_worksheet_worst,
            spanCSS: this.spanCSS,
            quota_amount_str: undefined,
            target_quota_amount_str: undefined,
            closed_amount_str: undefined,
            deficit_class: undefined,
            deficit_amount_str: undefined,
            isForecastSetup: this.isForecastSetup,
            isForecastAdmin: this.isForecastAdmin
        };
        if(this.context.get('model')) {
            this.context.get('model').set(model)
        } else {
            this.model.set(model);
        }
    },

    /**
     * Builds dashlet url
     *
     * @return {Mixed} url to call
     */
    getProjectedURL: function() {
        var method = this.shouldRollup ? 'progressManager' : 'progressRep',
            url = 'Forecasts/' + this.model.get('selectedTimePeriod') + '/' + method + '/' + this.selectedUser.id,
            params = {};

        // if this is a manager view, send the target_quota param to the endpoint
        if(this.shouldRollup) {
            params = {
                target_quota: (this.showTargetQuota) ? 1 : 0
            };
        }

        return app.api.buildURL(url, 'create', null, params);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if(this.meta.config) {
            return;
        }

        var ctx = this.model;
        if (this.currentModule == 'Forecasts') {
            ctx = this.context.parent || this.context;
            this.showTimeperiod = false;
        } else if (this.currentModule == 'Home') {
            // listen to the TimePeriod field's model changes to set the dashlet
            this.settings.on('change:selectedTimePeriod', function(model) {
                this.updateDetailsForSelectedTimePeriod(model.get('selectedTimePeriod'));
                // reload dashlet data when the selectedTimePeriod changes
                this.loadData({});
            }, this);
        }

        ctx.on('change:selectedTimePeriod', function(model) {
            if(this.currentModule == 'Forecasts') {
                this.updateDetailsForSelectedTimePeriod(model.get('selectedTimePeriod'));
            }
            // reload dashlet data when the selectedTimePeriod changes
            this.loadData({});
        }, this);

        // Home module doesn't have a changing selectedUser
        if(this.currentModule == 'Forecasts') {

            this.quotaCollection = app.utils.getSubpanelCollection(ctx, 'ForecastManagerWorksheets');

            this.quotaCollection.on('reset', this.processQuotaCollection, this);

            this.quotaCollection.on('change:quota', function(data) {
                var oldQuota = (this.getOldTotalFromCollectionById(data.get('user_id'))) ? this.getOldTotalFromCollectionById(data.get('user_id')).quota : 0,
                    newQuota = data.get('quota'),
                    diff = app.math.sub(data.get('quota'), oldQuota),
                    newQuotaTotal = app.math.add(this.serverData.get('quota_amount'), diff);
                // set the new "oldTotals" value
                this.setOldTotalFromCollectionById(data.get('user_id'), {quota: newQuota});
                // calculate and update the Quota on the frontend
                this.calculateData({quota_amount: newQuotaTotal});
            }, this);

            this.processQuotaCollection();

            ctx.on('change:selectedUser', function(model) {
                this.updateDetailsForSelectedUser(model.get('selectedUser'));
                // reload dashlet data when the selectedUser changes
                this.loadData({});
            }, this);

            ctx.on('forecasts:worksheet:totals', function(data) {
                this.calculateData(this.mapAllTheThings(data, true), true);
            }, this);

            // Using LHS Model to store the initial values of the LHS model so we don't have
            // to ping the server every dashlet load for the true original DB values of the LHS model
            if(!_.has(ctx.attributes, 'lhsData')) {
                ctx.set({
                    lhsData: {
                        quotas: this.oldTotals
                    }
                });
            }
        }
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        var ctx;
        if (this.currentModule) {
            if(this.currentModule == 'Forecasts') {
                ctx = this.context.parent || this.context;
                if(this.quotaCollection) {
                    this.quotaCollection.off(null, null, this);
                }
            } else {
                ctx = this.model;
            }

            if(ctx) {
                ctx.off(null, null, this);
            }

            if (this.currentModule == 'Home') {
                this.settings.off(null, null, this);
            }
        }

        this._super('unbindData');
    },

    /**
     * Overrides loadData to load from a custom URL
     *
     * @override
     */
    loadData: function(options) {
        // if in dashlet config, or if Forecasts is not configured properly,
        // do not load data
        if(this.meta.config || !this.forecastsConfigOK || !this.isForecastSetup || this.loading) {
            return;
        }

        if(!this.initDataLoaded) {
            this.getInitData(options);
        }

        if(!_.isEmpty(this.model.get('selectedTimePeriod'))) {
            this.loading = true;
            var url = this.getProjectedURL(),
                cb = {
                    context: this,
                    success: _.bind(function(options, data) {
                        if(options && options.beforeParseData) {
                            data = options.beforeParseData(data);
                            data.parsedData = true;
                        }
                        this.handleNewDataFromServer(data)
                    }, this, options),
                    complete: _.bind(function(){
                        this.loading = false;
                        if (options && options.complete && _.isFunction(options.complete)) {
                            options.complete();
                        }
                    }, this)
                };

            app.api.call('read', url, null, null, cb);
        }
    },

    /**
     * Extensible function for getting initial data
     *
     * @param options
     */
    getInitData: function(options) {
        // get the current timeperiod
        app.api.call('GET', app.api.buildURL('TimePeriods/current'), null, {
            success: _.bind(function(currentTP) {
                // Make sure the model is here when we get back and this isn't mid-pageload or anything
                if(this.model) {
                    this.initDataLoaded = true;
                    this.model.set({selectedTimePeriod: currentTP.id}, {silent: true});
                    this.settings.set({selectedTimePeriod: currentTP.id}, {silent: true});
                    this.loadData();
                }
            }, this),
            error: _.bind(function() {
                // Needed to catch the 404 in case there isnt a current timeperiod
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * Processes this.quotaCollection.models to determine which models IDs should be
     * saved into the closedWonIds array
     */
    processQuotaCollection: function() {
        var model = this.context.get('model') || this.model,
            newQuota = 0,
            oldQuota = model.get('quota_amount'),
            quota = 0;
        this.oldTotals.models = new Backbone.Model();
        _.each(this.quotaCollection.models, function(model) {
            quota = model.get('quota');
            newQuota = app.math.add(newQuota, quota);
            // save all the initial likely values
            this.setOldTotalFromCollectionById(model.get('user_id'), {
                quota: quota
            });
        }, this);

        if(oldQuota !== newQuota) {
            this.calculateData({quota_amount: newQuota});
        }
    },

    /**
     * Gets an object from the oldTotals Model
     *
     * @param id the model ID for the Object
     * @return {Object}
     */
    getOldTotalFromCollectionById: function(id) {
        return this.oldTotals.models.get(id);
    },

    /**
     * Sets a totals Object on the oldTotals Model by id
     *
     * @param id model id
     * @param totals object to set
     * @return {Mixed}
     */
    setOldTotalFromCollectionById: function(id, totals) {
        this.oldTotals.models.set(id, totals);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.renderSubDetails();
    },

    /**
     * Used to re-render only the projected data inside the dashlet so render doesnt
     * get called and dispose the select2 timeperiod field, which would then go
     * re-fetch its data at least once every render
     */
    renderSubDetails: function() {
        if(this.$el && this.subDetailsTpl) {
            var subEl = this.$el.find('.forecast-details'),
                model = this.context.get('model') || this.model;
            // Check if closed or quota is undefined (during opps/rli loading when those numbers aren't available yet)
            if(!_.isUndefined(model.get('closed_amount')) && !_.isUndefined(model.get('quota_amount'))) {
                subEl.html(this.subDetailsTpl(model.toJSON()));
                this.renderCSSChanges(model);
            } else {
                subEl.html('');
            }
        }
    },

    /**
     * Adds the CSS to elements classes post-render
     *
     * @param {Backbone.Model} [model]          The Model to use
     */
    renderCSSChanges: function(model) {
        model = model || this.context.get('model') || this.model;
        var isDeficit = model.get('is_deficit');

        // using getClassBasedOnAmount and sending 0 or 1 to resolve which class to use so the class names
        // are only in one place
        if(isDeficit) {
            this.$el.find('.deficitRow').addClass(this.getClassBasedOnAmount(0, 1, 'color'));
        } else {
            this.$el.find('.deficitRow').addClass(this.getClassBasedOnAmount(1, 0, 'color'));
        }

        this.checkPropertySetCSS('worst', model);
        this.checkPropertySetCSS('likely', model);
        this.checkPropertySetCSS('best', model);
    },

    /**
     * Checks a property on the config and sets the background color of an element
     * @param {String} prop 'likely', 'best', or 'worst'
     * @param {Backbone.Model} [model]      The model to use
     */
    checkPropertySetCSS: function(prop, model) {
        model = model || this.context.get('model') || this.model;
        // if we're showing the field
        // And this is the mgr view or it's the rep view and the user has access to the field
        if(this.forecastConfig['show_worksheet_' + prop]
            && (this.shouldRollup || (!this.shouldRollup && this.fieldDataAccess[prop]))) {
            var css = this.getClassBasedOnAmount(app.math.add(this.serverData.get(prop), this.serverData.get('closed_amount')), model.get('quota_amount'), 'background-color');
            this.$el.find('#forecast_details_' + prop + '_feedback').addClass(css);
        }
    },

    /**
     * Any variable mapping happens here
     *
     * @param data an Object
     */
    mapAllTheThings: function(data, fromModel) {
        if(this.shouldRollup) {
            // Manager View
            data.likely = data.likely_adjusted || data.likely_case;
            data.best = data.best_adjusted || data.best_case;
            data.worst = data.worst_adjusted || data.worst_case;
        } else {
            // Rep View
            if(fromModel) {
                data.likely = data.likely_case;
            } else {
                data.likely = data.amount;
            }

            data.best = data.best_case;
            data.worst = data.worst_case;
            data.closed_amount = data.won_amount;

            // can happen if data comes fromModel and won_amount isnt there
            if(_.isUndefined(data.closed_amount)) {
                // unset closed_amount so it doesnt impact totals
                delete data.closed_amount;
            }
        }

        if (fromModel) {
            data.worst = app.math.sub(data.worst, (data.closed_amount || 0));
            data.likely = app.math.sub(data.likely, (data.closed_amount || 0));
            data.best = app.math.sub(data.best, (data.closed_amount || 0));
        }

        return data;
    },

    /**
     * Success callback function for loadData to call
     *
     * @param data
     */
    handleNewDataFromServer: function(data) {
        // since the user might add this dashlet after they have changed the quota models, but before they saved it
        // we have to check and make sure that we're accounting for any changes in the dashlet totals that come
        // from the server
        if(this.currentModule == 'Forecasts' && this.context && this.shouldRollup) {
            var lhsData = this.context.get('lhsData');
            if(!lhsData && _.has(this.context, 'parent') && !_.isNull(this.context.parent)) {
                lhsData = this.context.parent.get('lhsData');
            }

            if(lhsData && !_.isEmpty(lhsData.quotas.models.attributes)) {
                var lhsTotal = 0;
                _.each(lhsData.quotas.models.attributes, function(val, key) {
                    lhsTotal = app.math.add(lhsTotal, val.quota);
                }, this);
                if(lhsTotal != parseFloat(data.quota_amount)) {
                    data.quota_amount = app.math.sub(data.quota_amount, app.math.sub(data.quota_amount, lhsTotal));
                }
            }
        }
        this.calculateData(this.mapAllTheThings(data, false));
    },

    /**
     * Handles parsing data objects into model
     *
     * @param data
     * @param fromModel if this request is from the model or the server
     */
    calculateData: function(data, fromModel) {
        fromModel = fromModel || false;
        // update serverData with changes from data
        this.serverData.set(data);

        // update data with any values serverData had but data doesn't
        // we create a new variable here, since we don't want to update the data param back on the worksheet table
        // and maybe break something
        var d = _.extend({}, data, this.serverData.toJSON());

        this.likelyTotal = d.likely;
        this.bestTotal = d.best;
        this.worstTotal = d.worst;

        d.quota_amount_str = app.currency.formatAmountLocale(d.quota_amount);
        d.closed_amount_str = app.currency.formatAmountLocale(d.closed_amount);

        if(this.showTargetQuota) {
            d.target_quota_amount_str = app.currency.formatAmountLocale(d.target_quota_amount);
        } else {
            this.serverData.unset('target_quota_amount_str');
        }
        d.showTargetQuota = this.showTargetQuota;

        // handle deficit
        d.deficit_amount = Math.abs(app.math.sub(d.quota_amount, d.closed_amount));
        d.deficit_amount_str = app.currency.formatAmountLocale(d.deficit_amount);
        d.is_deficit = (parseFloat(d.quota_amount) > parseFloat(d.closed_amount));

        var deficitLabelKey = (d.is_deficit) ? 'LBL_FORECAST_DETAILS_DEFICIT' : 'LBL_FORECAST_DETAILS_SURPLUS';
        d.deficit_label = app.lang.get(deficitLabelKey, 'Forecasts');

        // convert detailsForCase params to html template
        d.worst_details = this.detailsMsgTpl(this.getDetailsForCase('worst', this.worstTotal, d.quota_amount, d.closed_amount, fromModel));
        d.likely_details = this.detailsMsgTpl(this.getDetailsForCase('likely', this.likelyTotal, d.quota_amount, d.closed_amount, fromModel));
        d.best_details = this.detailsMsgTpl(this.getDetailsForCase('best', this.bestTotal, d.quota_amount, d.closed_amount, fromModel));

        if(this.shouldRollup && !_.isEmpty(this.selectedUser.reports_to_id)) {
            d.quota_label = app.lang.get('LBL_QUOTA_ADJUSTED', 'Forecasts');
        } else {
            d.quota_label = app.lang.get('LBL_QUOTA', 'Forecasts');
        }

        if(this.context || this.model) {
            var model = this.context.get('model') || this.model;
            if(model) {
                model.set(d);
                this.renderSubDetails();
            }
        }
    },

    /**
     * Determine if one value is bigger than another then build the language string to be used
     *
     * @param caseStr case string "likely", "best", or "worst"
     * @param caseValue the value of the case
     * @param stageValue the value of the quota or closed amount
     * @param closedAmt the value of closed_amount from the model
     * @param fromServer if this is coming from the model or the server
     * @return {Object} params for details-msg template
     */
    getDetailsForCase: function (caseStr, caseValue, stageValue, closedAmt, fromModel) {
        var params = {},
            // get Number versions of values for comparison
            caseValueN = app.math.add(caseValue, closedAmt),
            stageValueN = parseFloat(stageValue),
            openPipeline = 0,
            calcValue = 0;

        params.label = app.lang.get('LBL_' + caseStr.toUpperCase(), 'Forecasts');
        params.spanCSS = this.spanCSS;
        params.case = caseStr;
        params.shortOrExceed = '&nbsp;';
        params.openPipeline = '&nbsp;';
        params.feedbackLn1 = '';
        params.feedbackLn2 = '';

        var hasAccess = true;
        // if this is the rep view and the user doesnt have access to this field set to false
        if(!this.shouldRollup && !this.fieldDataAccess[caseStr]) {
            hasAccess = false;
        }
        // Check field access, in 2 of 3 cases below this works, otherwise it gets overwritten
        // in caseValueN == 0 && stageValueN == 0
        if(hasAccess)
        {
            if (caseValue) {
                params.amount = app.currency.formatAmountLocale(caseValue);
                params.labelAmount = params.label + ': ' + params.amount.toString();
            }

            if (caseValueN == 0 && stageValueN == 0) {
                // if we have no data
                params.amount = app.lang.get('LBL_FORECAST_DETAILS_NO_DATA', "Forecasts");
            } else if (caseValueN != 0 && stageValueN != 0 && caseValueN == stageValueN) {
                // if the values are equal but we have data
                params.shortOrExceed = app.lang.get('LBL_FORECAST_DETAILS_MEETING_QUOTA', "Forecasts");
            } else {
                /**
                 *  The bottom rectangles are supposed to tell the user if there is sufficient open pipeline in the current quarter to cover the deficit or not.
                 *  If there is surplus (meaning there is no deficit), the open pipeline will actually take the user above quota and that is always represented with green color.
                 */
                //if we are exceeding, we need to subtract to get the amount we exceed by
                if (caseValueN > stageValueN) {
                    params.shortOrExceed = app.lang.get('LBL_FORECAST_DETAILS_EXCEED', "Forecasts");
                    calcValue = app.math.sub(caseValueN, stageValueN);
                } else {
                    params.shortOrExceed = app.lang.get('LBL_FORECAST_DETAILS_SHORT', "Forecasts");
                    calcValue = app.math.sub(stageValueN, caseValueN);
                }

                params.percent = this.getPercent(calcValue, stageValueN);
                params.openPipeline = '(' + app.currency.formatAmountLocale(calcValue) + ')';

            }

            params.feedbackLn1 = params.shortOrExceed;

            if (params.percent) {
                params.feedbackLn1 += ' ' + params.percent;
            }

            params.feedbackLn2 = params.openPipeline;
        } else {
            params.amount = this.noDataAccessTemplate;
            params.labelAmount = params.label + ': ' + app.lang.get('LBL_NO_FIELD_ACCESS');
        }

        return params;
    },

    /**
     * Return the difference of two values and make sure it's a positive value
     *
     * used as a shortcut function for determine best/likely to closed/quota
     * @param caseValue
     * @param stageValue
     * @return {Number}
     */
    getAbsDifference: function (caseValue, stageValue) {
        return app.currency.formatAmountLocale(Math.abs(stageValue - caseValue));
    },

    /**
     * Gets a css class based on the amount relative to stageValue
     *
     * @param {Number} caseValue the value to check
     * @param {Number} stageValue the value to check against
     * @param {String} type the property to get
     * @return {string}
     */
    getClassBasedOnAmount: function (caseValue, stageValue, type) {
        var cssClass = '';
        // convert values to Numbers for comparison
        caseValue = parseFloat(caseValue);
        stageValue = parseFloat(stageValue);
        if(type == 'color') {
            if(caseValue == stageValue) {
                //
            } else if(caseValue > stageValue) {
                cssClass = 'font-green';
            } else {
                cssClass = 'font-red'
            }
        } else if(type == 'background-color') {
            if(caseValue == stageValue) {
                cssClass = 'grayLight';
            } else if(caseValue > stageValue) {
                cssClass = 'green';
            } else {
                cssClass = 'red';
            }
        }

        return cssClass;
    },

    /**
     * Returns a percent string based on the best/likely/worst case number vs. quota/closed amount
     *
     * @param caseValue likely/best/worst case value
     * @param stageValue the closed/quota amount from the model
     * @return {String}
     */
    getPercent: function (caseValue, stageValue) {
        var percent = 0,
            calcValue = caseValue;
        if (stageValue > 0 && caseValue > 0) {


            // divide the numbers and multiply times 100
            percent = (calcValue / stageValue) * 100;

            if (percent > 1) {
                // round to a whole number
                percent = Math.round(percent);
            } else {
                // Round the less-than-one percent to two decimal places
                // eg. percent=0.1234 -- percent*100 = 12.34, Math.round makes that 12
                // then percent/100 makes that back to 0.12
                percent = Math.round(percent*100)/100;
            }
        }
        return Math.abs(percent) + '%';
    },

    /**
     * Checks the selectedUser to see if they are a sub-manager
     */
    checkShowTargetQuota: function() {
        if(this.shouldRollup && this.selectedUser.is_manager && !this.selectedUser.is_top_level_manager) {
            this.showTargetQuota = true;
        } else {
            this.showTargetQuota = false;
        }
    },

    /**
     * checks the selectedUser to make sure it's a manager and if we should show the manager view
     * @return {Boolean}
     */
    isManagerView: function () {
        var isMgrView = false;
        if (this.currentModule == 'Forecasts') {
            // Forecasts has a more dynamic state, so make sure we check which worksheet is showing now
            if (this.context && this.context.parent && this.context.parent.has('model')) {
                isMgrView = this.context.parent.get('model').get('forecastType') == 'Rollup';
            }
        } else if(this.selectedUser.is_manager == true
            && (this.selectedUser.showOpps == undefined || this.selectedUser.showOpps === false))
        {
            isMgrView = true;
        }

        return isMgrView;
    },

    /**
     * Set the new time period
     *
     * @param {String} timePeriod id in string form
     */
    updateDetailsForSelectedTimePeriod: function (timePeriod) {
        // setting the model will trigger loadData()
        this.model.set({selectedTimePeriod: timePeriod});
    },

    /**
     * Set the new selected user
     *
     * @param {Object} selectedUser
     */
    updateDetailsForSelectedUser: function (selectedUser) {
        // don't directly set model selectedUser so we can handle selectedUser param in case it comes in as
        // just an id or something from somewhere else, so we can set it the right way for this dashlet
        this.selectedUser.last_name = selectedUser.last_name;
        this.selectedUser.first_name = selectedUser.first_name;
        this.selectedUser.full_name = selectedUser.full_name;
        this.selectedUser.id = selectedUser.id;
        this.selectedUser.is_manager = selectedUser.is_manager;
        this.selectedUser.reportees = selectedUser.reportees;
        this.selectedUser.showOpps = selectedUser.showOpps;
        this.selectedUser.user_name = selectedUser.user_name;
        this.selectedUser.reports_to_id = selectedUser.reports_to_id;
        this.selectedUser.reports_to_name = selectedUser.reports_to_name;
        this.selectedUser.is_top_level_manager = selectedUser.is_top_level_manager;

        this.shouldRollup = this.isManagerView();

        // update showTargetQuota on every user change
        this.checkShowTargetQuota();

        // setting the model will trigger loadData()
        this.model.set({selectedUser: selectedUser});
    },

    /**
     * Event handler to update which dataset is used.
     *
     * @param {jQuery.Event} evt click event
     */
    changeDisplayOptions : function(evt) {
        evt.preventDefault();
        this.handleOptionChange(evt);
    },

    /**
     * Handle the click event for the options menu
     *
     * @param {jQuery.Event} evt click event
     */
    handleOptionChange: function(evt) {
        var $el = $(evt.currentTarget),
            changedSegment = $el.attr('data-set');

        //check what needs to be done to the target
        if($el.hasClass('checked')) {
            //item was checked, uncheck it
            $el.removeClass('checked');
            $('div .projected_' + changedSegment).hide();
        } else {
            //item was unchecked and needs checked now
            $el.addClass('checked');
            $('div .projected_' + changedSegment).show();
        }
    }
}) },
"multi-selection-list-link": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 *
 * @class View.Views.Base.MultiSelectionListLinkView
 * @alias SUGAR.App.view.views.BaseMultiSelectionListLinkView
 * @extends View.Views.Base.MultiSelectionListView
 */
({
	// Multi-selection-list-link View (base) 

    extendsFrom: 'MultiSelectionListView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.meta.selection = _.extend({}, options.meta.selection, {isLinkAction: true});
    },

    /**
     * @override
     */
    initializeEvents: function() {
        this.context.on('selection-list:link:multi', this._selectMultipleAndClose, this);
        this.context.on('selection-list:select', this._refreshList, this);
    },

    /**
     * After a model is selected, refresh the list view and add the model to
     * selections.
     *
     * @private
     */
    _refreshList: function() {
        this.context.reloadData({
            recursive: false,
            error: function() {
                app.alert.show('server-error', {
                    level: 'error',
                    messages: 'ERR_GENERIC_SERVER_ERROR'
                });
            }
        });
    },

    /**
     * Selects multiple models to link and fire the mass link event.
     *
     * @private
     */
    _selectMultipleAndClose: function() {
        var selections = this.context.get('mass_collection');
        if (selections && selections.length > 0) {
            this.layout.once('list:masslink:complete', this._closeDrawer, this);
            this.layout.trigger('list:masslink:fire');
        }
    },

    /**
     * Closes the drawer and then refreshes record page with new links.
     *
     * @private
     */
    _closeDrawer: function(model, data, response) {
        app.drawer.close();

        var context = this.context.get('recContext');
        var view = this.context.get('recView');

        if (context.has('parentModel')) {
            var parentModel = context.get('parentModel');
            var syncedAttributes = parentModel.getSynced();
            var updatedAttributes = _.reduce(data.record, function(memo, val, key) {
                    if (!_.isEqual(syncedAttributes[key], val)) {
                        memo[key] = val;
                    }
                    return memo;
                }, {});
            parentModel.set(updatedAttributes);
            //Once parent model is reset, reset internal synced attributes as well
            parentModel.setSyncedAttributes(data.record);
        }

        context.set('skipFetch', false);
        context.reloadData();
    }
}) },
"link-moduleselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.LinkModuleselectView
 * @alias SUGAR.App.view.views.BaseLinkModuleselectView
 * @extends View.View
 */
({
	// Link-moduleselect View (base) 

    linkModules: [],
    events: {
        'click label[for=relationship]': 'setFocus'
    },
    initialize: function (options) {
        app.view.View.prototype.initialize.call(this, options);
        this.linkModules = this.context.get("linkModules");
    },
    setFocus: function (e) {
        this.$("#relationship").select2("open");
    },
    _renderHtml: function (ctx, options) {
        var self = this;
        app.view.View.prototype._renderHtml.call(this, ctx, options);
        this.$(".select2").select2({
            width: '100%',
            allowClear: true,
            placeholder: app.lang.get("LBL_SEARCH_SELECT")
        }).on("change", function (e) {
            if (_.isEmpty(e.val)) {
                self.context.trigger("link:module:select", null);
            } else {
                var meta = self.linkModules[e.val];
                self.context.trigger("link:module:select", {link: meta.link, module: meta.module});
            }
        });
    },
    _dispose: function() {
        this.$(".select2").select2('destroy');
        app.view.View.prototype._dispose.call(this);
    }
}) },
"filter-module-dropdown-selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Adds ability switch modules with filter module dropdown.
 *
 * Part of {@link View.Layouts.Base.SelectionListModuleSwitchLayout}.
 *
 * @class View.Views.Base.FilterModuleDropdownSelectionListView
 * @alias SUGAR.App.view.views.BaseFilterModuleDropdownSelectionListView
 * @extends View.Views.Base.FilterModuleDropdownView
 */
({
	// Filter-module-dropdown-selection-list View (base) 

    extendsFrom: 'FilterModuleDropdownView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.template = app.template.get('filter-module-dropdown');
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     * @return {Object}
     */
    getFilterList: function() {
        var filterList = this.context.get('filterList');

        if (this.layout.showingActivities) {
            filterList = this._super('getFilterList');
        }

        return filterList;
    },

    /**
     * @inheritdoc
     * @return {boolean}
     */
    shouldDisableFilter: function() {
        return false;
    },

    /**
     * Set the value of the filter to be the current module.
     * @private
     */
    _renderDropdown: function() {
        this._super('_renderDropdown');
        if (this.filterNode) {
            this.filterNode.select2('val', this.module);
        }
    },

    /**
     * Trigger event to reload the layout when the module changes.
     * @param {String} linkModuleName
     * @param {String} linkName
     * @param {Boolean} silent
     */
    handleChange: function(linkModuleName, linkName, silent) {
        if (!silent) {
            this.context.trigger('selection-list:reload', linkModuleName);
        }
    },

    /**
     * Always returns the module with a downward-facing caret button for
     * selecting other modules.
     *
     * @return {string}
     */
    getSelectionLabel: function() {
        return app.lang.get('LBL_MODULE') + '<i class="fa fa-caret-down"></i>';
    }
}) },
"tutorial": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.TutorialView
 * @alias SUGAR.App.view.views.BaseTutorialView
 * @extends View.TutorialView
 */
({
	// Tutorial View (base) 

    /**
     * extendsFrom: This needs to be app.view.TutorialView since it's extending a Sidecar specific view class.  This is a
     * special case, as the normal method is for it to be a string.
     */
    extendsFrom: app.view.TutorialView,

    className: '', //override default class

    initialize: function(options) {
        this.resizeCallback = _.debounce(_.bind(function(){
            this.highlightItem(this.index);
        }, this), 400);
        $(window).on('resize', this.resizeCallback);
        this.keyupCallback = _.bind(this.processKeyCode, this);
        $(document).on('keyup', this.keyupCallback);
        app.view.TutorialView.prototype.initialize.call(this, options);
        app.events.on("cache:clean", function(callback) {
            callback(["tutorialPrefs"]);
        });
    },
    processKeyCode: function(e) {
        switch(e.which) {
            case 37: // left
                this.back(e);
                break;

            case 39: // right
            case 13: // Enter
                this.next(e);
                break;

            case 27: // exit
                this.hide(e);
                break;

            default: return; // exit this handler for other keys
        }
        e.preventDefault();
    },

    /**
     * removes the tour
     */
    remove: function() {
        $(window).off('resize', this.resizeCallback);
        $(document).off('keyup', this.keyupCallback);
        app.view.TutorialView.prototype.remove.call(this);
        var prefs = app.cache.get('tutorialPrefs') || {};
        if (prefs.showTooltip) {
            this.showTooltip();
            this.removeTooltip(3000);
        }
    },

    /**
     * shows tooltip on tour button
     */
    showTooltip: function() {
        $('[data-action=tour]')
            .tooltip({
                container: 'body',
                trigger: 'manual'
            })
            .tooltip('show');
    },

    /**
     * removes tooltip from tour button
     * @param {int} delayTime milliseconds.
     */
    removeTooltip: function(delayTime) {
        if (!delayTime) {
            $('[data-action=tour]').tooltip('hide');
        } else {
            _.delay(function() { $('[data-action=tour]').tooltip('hide'); }, delayTime);
        }
    }
}) },
"panel-top": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Header section for Subpanel layouts.
 *
 * @class View.Views.Base.PanelTopView
 * @alias SUGAR.App.view.views.BasePanelTopView
 * @extends View.View
 */
({
	// Panel-top View (base) 

    /**
     * @inheritdoc
     */
    className: 'subpanel-header',

    /**
     * @inheritdoc
     */
    attributes: {
        'data-sortable-subpanel': 'true'
    },

    /**
     * @inheritdoc
     */
    events: {
        'click': 'togglePanel',
        'click a[name=create_button]:not(".disabled")': 'createRelatedClicked',
        'keydown [data-a11y=toggle]': '_handleKeyClick'
    },

    plugins: ['LinkedModel'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // FIXME: SC-3594 will address having child views extending metadata
        // from its parent.
        options.meta = _.extend(
            {},
            app.metadata.getView(null, 'panel-top'),
            app.metadata.getView(options.module, 'panel-top'),
            options.meta
        );

        this._super('initialize', [options]);

        // This is in place to get the lang strings from the right module. See
        // if there is a better way to do this later.
        this.parentModule = this.context.parent.get('module');

        // Listen to the context for collapsed attribute to change
        // and toggle the aria-expanded attribute on the button element
        this.listenTo(this.context, 'change:collapsed', this._toggleAria);

        // FIXME: Revisit with SC-4775.
        this.on('linked-model:create', function() {
            this.context.set('skipFetch', false);
            this.context.reloadData();
        }, this);
    },

    /**
     * Event handler for the create button.
     *
     * @param {Event} event The click event.
     */
    createRelatedClicked: function(event) {
        this.createRelatedRecord(this.module);
    },

    /**
    * Event handler that toggles the subpanel layout when the SubpanelHeader is
    * clicked.
    *
    * Triggers the `panel:toggle` event to toggle the subpanel.
    *
    * @param {Event} The `click` event.
    */
    togglePanel: function(evt) {
        if (_.isNull(this.$el)) {
            return;
        }

        var $target = this.$(evt.target),
            isLink = $target.closest('a, button').length;

        if (isLink) {
            return;
        }

        this.context.set('collapsed', !this.context.get('collapsed'));
    },

    /**
     * Sets the subpanel header accessibility class 'aria-expanded' to true or false
     * depending on if the subpanel is open or closed.
     *
     * @private
     */
    _toggleAria: function(context, collapsed) {
        this.$('[data-a11y=toggle]')
            .attr('aria-expanded', !collapsed);
    },

    /**
     * Triggers the click event when the data-a11y toggle element has focus
     * and the spacebar or enter keydown event occurs
     *
     * @private
     */
    _handleKeyClick: function(evt) {
        app.accessibility.handleKeyClick(evt, this.$el);
    }
}) },
"config-panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConfigPanelView
 * @alias SUGAR.App.view.views.BaseConfigPanelView
 * @extends View.View
 */
({
	// Config-panel View (base) 

    /**
     * Holds the changing date value for the title
     */
    titleSelectedValues: '',

    /**
     * Holds the view's title name
     */
    titleViewNameTitle: '',

    /**
     * Holds the collapsible toggle title template
     */
    toggleTitleTpl: {},

    /**
     * Holds the vars for the title template
     * <pre><code>
     * {
     *  title: this.titleViewNameTitle,
     *  selectedValues: this.titleSelectedValues,
     *  viewName: this.name
     * }
     * <pre><code>
     */
    titleTemplateVars: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.toggleTitleTpl = app.template.getView('config-panel.title');

        if (this.meta.label) {
            this.titleViewNameTitle = app.lang.get(this.meta.label, this.module);
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        this.on('config:panel:hide', this.onConfigPanelHide, this);
        this.on('config:panel:show', this.onConfigPanelShow, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // add accordion-group class to wrapper $el div
        this.$el.addClass(this.name + '-group accordion-group');

        // update the title every render
        this.updateTitle();
    },

    /**
     * Updates the accordion toggle title
     */
    updateTitle: function() {
        // update the title values
        this._updateTitleValues();
        // update the title template vars
        this._updateTitleTemplateVars();

        // then inject them into the template
        this.$('#' + this.name + 'Title').html(this.toggleTitleTpl(this.titleTemplateVars));
    },

    /**
     * Updates `this.titleSelectedValues` before updating title so child classes
     * can set up how the title should be displayed
     * @private
     */
    _updateTitleValues: function() {
        this.titleSelectedValues = this.model.get(this.name);
    },

    /**
     * Updates `this.titleTemplateVars` before updating title so child classes
     * can set up how the title should be displayed
     * @private
     */
    _updateTitleTemplateVars: function() {
        this.titleTemplateVars = {
            title: this.titleViewNameTitle,
            selectedValues: this.titleSelectedValues,
            viewName: this.name
        };
    },

    /**
     * Handles when the config panel is hidden
     */
    onConfigPanelHide: function() {
    },

    /**
     * Handles when the config panel is shown
     */
    onConfigPanelShow: function() {
    }
}) },
"activitystream-omnibar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivitystreamOmnibarView
 * @alias SUGAR.App.view.views.BaseActivitystreamOmnibarView
 * @extends View.View
 */
({
	// Activitystream-omnibar View (base) 

    events: {
        'click .addPost': 'addPost',
        'keyup .sayit': '_handleContentChange', //type text
        'change .sayit': '_handleContentChange', //drag text in
        'paste .sayit': '_handleContentPaste' //for IE - right click, paste
    },

    className: 'omnibar',

    plugins: ['DragdropAttachments', 'Taggable', 'Pagination'],

    initialize: function(options) {
        // regular expression to find all non-breaking spaces
        this.nbspRegExp = new RegExp(String.fromCharCode(160), 'g');

        app.view.View.prototype.initialize.call(this, options);

        // Assets for the activity stream post avatar
        this.user_id = app.user.get('id');
        this.full_name = app.user.get('full_name');
        this.picture_url = app.user.get('picture') ? app.api.buildFileURL({
            module: 'Users',
            id: this.user_id,
            field: 'picture'
        }) : '';

        this.toggleSubmitButton = _.debounce(this.toggleSubmitButton, 200);
        this.on('attachments:add attachments:remove attachments:end', this.toggleSubmitButton, this);
        this.on('attachments:start', this.disableSubmitButton, this);
    },

    /**
     * Initialize Taggable plugin so that it knows which record the tags are
     * associated with.
     */
    bindDataChange: function() {
        if (this.context.parent) {
            this.context.parent.on('change', function(context) {
                var moduleName = context.get('module'),
                    modelId = context.get('model').get('id');

                this.setTaggableRecord(moduleName, modelId);
            }, this);
        }
        app.view.View.prototype.bindDataChange.call(this);
    },

    /**
     * Remove events added in bindDataChange().
     */
    unbindData: function() {
        if (this.context.parent) {
            this.context.parent.off(null, null, this);
        }
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (!app.config.activityStreamsEnabled) {
            this.$el.addClass('hide');
        }

        return this;
    },

    /**
     * Creates a new post.
     */
    addPost: function() {
        var self = this,
            parentId = this.context.parent.get('model').id,
            parentType = this.context.parent.get('model').module,
            attachments = this.$('.activitystream-pending-attachment'),
            bean;

        // Process "Home" and "Activity" layouts as global activity stream types
        if (parentType == 'Home' || parentType == 'Activities') {
            parentType = null;
            parentId = null;
        }

        var payload = {
            activity_type: 'post',
            parent_id: parentId || null,
            parent_type: parentType,
            data: {}
        };

        if (!this.isSubmitDisabled()) {
            payload.data = this.getPost();

            if (payload.data.value && (payload.data.value.length > 0)) {
                this.disableSubmitButton();
                bean = app.data.createBean('Activities');
                bean.save(payload, {
                    success: function(model) {
                        self.$('div.sayit')
                            .empty()
                            .trigger('change')
                            .focus();

                        model.set('picture', app.user.get('picture'));
                        self.collection.add(model);
                        self.context.trigger('activitystream:post:prepend', model);
                    },
                    complete: function() {
                        self.enableSubmitButton();
                    },
                    showAlerts: true
                });
            }

            this.trigger("attachments:process");
        }
    },

    /**
     * Retrieve the post entered inside content editable and translate any tags into text format
     * so that it can be saved in the database as JSON string.
     *
     * @return {string}
     */
    getPost: function() {
        var post = this.unformatTags(this.$('div.sayit'));

        // Need to replace all non-breaking spaces with a regular space because the EmbedLinkService.php
        // treats spaces and non-breaking spaces differently. Having non-breaking spaces causes to parse
        // URLs incorrectly.
        post.value = post.value.replace(this.nbspRegExp, ' ');

        return post;
    },

    /**
     * Check to see if the Submit button should be disabled/enabled.
     */
    isSubmitDisabled: function() {
        var post = this.getPost(),
            attachments = this.getAttachments();

        return post.value.length === 0 && _.size(attachments) === 0;
    },

    /**
     * Toggle the Submit button disabled/enabled state.
     */
    toggleSubmitButton: function() {
        if (this.isSubmitDisabled()) {
            this.disableSubmitButton();
        } else {
            this.enableSubmitButton();
        }
    },

    /**
     * Enable Submit button
     */
    enableSubmitButton: function() {
        this.$('.addPost')
            .removeClass('disabled')
            .attr('aria-disabled', false)
            .attr('tabindex', 0);
    },

    /**
     * Disable Submit button
     */
    disableSubmitButton: function() {
        this.$('.addPost')
            .addClass('disabled')
            .attr('aria-disabled', true)
            .attr('tabindex', -1);
    },

    /**
     * Show or hide the placeholder and toggle the submit button in response to
     * a content change in the input field.
     *
     * @param e
     * @private
     */
    _handleContentChange: function(e) {
        // We can't use any of the jQuery methods or use the dataset property to
        // set this attribute because they don't seem to work in IE 10. Dataset
        // isn't supported in IE 10 at all.
        var el = e.currentTarget;
        if (el.textContent) {
            el.setAttribute('data-hide-placeholder', 'true');
        } else {
            el.removeAttribute('data-hide-placeholder');
        }
        this.toggleSubmitButton();
    },

    /**
     * Wrapper around _handleContentChange to defer until paste event completes
     * Paste event needed for IE (right click, paste)
     *
     * @param e
     * @private
     */
    _handleContentPaste: function(e) {
        _.defer(_.bind(this._handleContentChange, this), e);
    }
}) },
"shortcuts-help-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Headerpane for keyboard shortcuts help
 *
 * @class View.Views.Base.ShortcutsHelpHeaderpaneView
 * @alias SUGAR.App.view.views.BaseShortcutsHelpHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Shortcuts-help-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    configureButtonName: 'configure_button',

    /**
     * Handle cancel and configure buttons.
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.on('button:cancel_button:click', function() {
            app.drawer.close();
        }, this);

        this.context.on('button:configure_button:click', this.configure, this);
    },

    /**
     * Load template for headerpane.
     * @inheritdoc
     */
    _loadTemplate: function(options) {
        var name = this.name;
        this.name = 'headerpane';
        this._super('_loadTemplate', [options]);
        this.name = name;
    },

    /**
     * Disable configure button if there are no contextual shortcuts to configure.
     * @inheritdoc
     */
    _renderHtml: function() {
        var shouldEnableConfigButton = this._shouldEnableConfigureButton();

        if (shouldEnableConfigButton) {
            this._setTooltipForConfigureButton('LBL_DASHLET_CONFIGURE');
        } else {
            this._setTooltipForConfigureButton('LBL_SHORTCUT_CONFIG_DISABLED');
        }

        this._super('_renderHtml');

        if (!shouldEnableConfigButton) {
            this._disableConfigureButton();
        }
    },

    /**
     * Should configure button be enabled?
     * @return {boolean}
     * @private
     */
    _shouldEnableConfigureButton: function() {
        var lastShortcutSession = app.shortcuts.getLastSavedSession();
        return lastShortcutSession && !_.isEmpty(lastShortcutSession.getRegisteredShortcuts());
    },

    /**
     * Set tooltip label for the configure button.
     * @param {string} tooltip tooltip label to be displayed
     * @private
     */
    _setTooltipForConfigureButton: function(tooltip) {
        var configureButtonViewDef = _.find(this.meta.buttons, function(button) {
            return (button.name === this.configureButtonName);
        }, this);

        if (configureButtonViewDef) {
            configureButtonViewDef.tooltip = tooltip;
        }
    },

    /**
     * Disable configure button.
     * @private
     */
    _disableConfigureButton: function() {
        var configureButton = this.getField(this.configureButtonName);
        if (configureButton) {
            configureButton.setDisabled(true);
        }
    },

    /**
     * Open the drawer to configure shortcut keys.
     */
    configure: function() {
        var self = this;

        app.drawer.open({
            layout: 'shortcuts-config',
            context: {
                shortcutSession: app.shortcuts.getLastSavedSession()
            }
        }, function(shouldRefresh) {
            if (shouldRefresh) {
                self.context.trigger('shortcuts:help:render');
            }
        });
    }
}) },
"subpanel-list-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Custom RecordlistView used for SubpanelCreate layouts.
 *
 * @class View.Views.Base.SubpanelListCreateView
 * @alias SUGAR.App.view.views.BaseSubpanelListCreateView
 * @extends View.Views.Base.SubpanelListView
 */
({
	// Subpanel-list-create View (base) 

    extendsFrom: 'SubpanelListView',

    /**
     * @inheritdoc
     */
    dataView: 'subpanel-list-create',

    contextEvents: {
        'list:deleterow:fire': 'onDeleteRow',
        'list:addrow:fire': 'onAddRow'
    },

    /**
     * Flag if the view has all valid models
     */
    hasValidModels: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // undo flex-list's hardcoding and re-hardcode to use the subpanel-list-create.hbs
        this.template = app.template.getView('subpanel-list-create');

        this.context.set({
            isCreateSubpanel: true
        });
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        var link;
        var oppsConfig;
        var userACLs;

        this._super('bindDataChange');

        link = this.context.get('link');
        oppsConfig = app.metadata.getModule('Opportunities', 'config');
        userACLs = app.user.getAcls();

        if (oppsConfig.opps_view_by === 'RevenueLineItems') {
            if (!(_.has(userACLs.Opportunities, 'edit') ||
                _.has(userACLs.RevenueLineItems, 'access') ||
                _.has(userACLs.RevenueLineItems, 'edit'))) {
                // only listen for PCDashlet if this is Opps in Opps/RLI mode and user has access
                // to both Opportunities and RLIs
                // need to trigger on app.controller.context because of contexts changing between
                // the PCDashlet, and Opps create being in a Drawer, or as its own standalone page
                // app.controller.context is the only consistent context to use
                var viewDetails = this.closestComponent('create') ?
                    this.closestComponent('create') :
                    this.closestComponent('record');

                if (!_.isUndefined(viewDetails)) {
                    app.controller.context.on(viewDetails.cid + ':productCatalogDashlet:add',
                        this.onAddFromProductCatalog,
                        this);
                }
            }
        }

        // listen to revalidate the collection
        this.context.parent.on('subpanel:validateCollection:' + link, this.validateModels, this);

        // listen to reset the collection
        this.context.parent.on('subpanel:resetCollection:' + link, this.resetSubpanel, this);

        this.collection.on('add remove', this.render, this);

        this.resetSubpanel();
    },

    /**
     * Handles when users click to add items from the Product Catalog dashlet to the Opportunity
     *
     * @param {Object} data The ProductCatalog Data
     */
    onAddFromProductCatalog: function(data) {
        var existingModel = this.collection.length === 1 && this.collection.at(0);
        var isEmpty = existingModel &&
            _.isEmpty(existingModel.changedAttributes()) &&
            _.isEmpty(existingModel.get('product_template_id'));

        data.likely_case = data.discount_price;
        data.best_case = data.discount_price;
        data.worst_case = data.discount_price;
        data.assigned_user_id = app.user.get('id');
        data.assigned_user_name = app.user.get('name');

        if (isEmpty) {
            this.collection.remove(existingModel);
        }

        this._addBeanToList(true, data);
    },

    /**
     * Resets the subpanel's collection and adds a new bean to the list
     */
    resetSubpanel: function() {
        this.collection.reset();
        this._addBeanToList(true);
    },

    /**
     * @inheritdoc
     *
     * Toggles all fields in the SubpanelList to Edit view
     */
    render: function() {
        this._super('render');

        // toggle fields to edit view
        this._toggleFields(true);

        _.defer(_.bind(function() {
            this.checkButtons();
        }, this));
    },

    /**
     * Handles toggling collection fields to edit or detail
     *
     * @param {Boolean} isEdit If we're toggling fields TO Edit view or not
     * @private
     */
    _toggleFields: function(isEdit) {
        isEdit = isEdit || false;

        // toggle the fields in the list to be in edit mode
        _.each(this.collection.models, function(model) {
            this.toggleFields(this.rowFields[model.get('id')], isEdit);
            if (isEdit) {
                // this is a subpanel specific logic: when the subpanel is back to edit mode,
                // manually fire the dependency trigger on all its models
                this.context.trigger("list:editrow:fire", model, {def: {}});
            }
        }, this);
    },

    /**
     * Checks the -/+ buttons to enable/disable
     */
    checkButtons: function() {
        if (this.disposed) {
            return;
        }
        var delBtns = this.$('.deleteBtn');
        var addBtns = this.$('.addBtn');
        if (delBtns && delBtns.length === 1 && !delBtns.hasClass('disabled')) {
            // if we have only one button, disable it, otherwise leave them all open
            delBtns.addClass('disabled');
        }

        if (addBtns && addBtns.length > 1) {
            // disable all add buttons except the last row
            _.each(addBtns, function(btn, index) {
                if (index < addBtns.length - 1) {
                    $(btn).addClass('disabled');
                }
            });
        }
    },

    /**
     * @inheritdoc
     *
     * Overriding RecordList/FlexList addActions to use actionmenu-create for the left column
     *
     * @override
     */
    addActions: function() {
        if (this.actionsAdded) {
            return;
        }

        // just need the right-side actions
        if (this.meta && _.isObject(this.meta.rowactions)) {
            // add the fieldset and init rightColumns
            this.addRowActions();
        }

        this.actionsAdded = true;
    },

    /**
     * @inheritdoc
     *
     * Overriding flex-list addRowActions to make the rowactions-create type
     *
     * @override
     */
    addRowActions: function() {
        var _generateMeta = function(label, css_class, buttons) {
            return {
                'type': 'fieldset',
                'fields': [
                    {
                        'type': 'rowactions-create',
                        'label': label || '',
                        'css_class': css_class,
                        'buttons': buttons || [],
                        'no_default_action': true
                    }
                ],
                'value': false,
                'sortable': false
            };
        };
        var def = this.meta.rowactions;
        this.rightColumns.push(_generateMeta(def.label, def.css_class, def.actions));
    },

    /**
     * Validates the models in the subpanel
     *
     * @param {Function} callback The callback function to call after validation
     * @param {undefined|Boolean} [fromCreateView] If this function is being called from Create view or not
     */
    validateModels: function(callback, fromCreateView) {
        fromCreateView = fromCreateView || false;

        var returnCt = 0;
        this.hasValidModels = true;

        _.each(this.collection.models, function(model) {
            // loop through all models and call doValidate on each model
            model.doValidate(this.getFields(this.module), _.bind(function(isValid) {
                returnCt++;

                if (this.hasValidModels && !isValid) {
                    // hasValidModels was true, but a model returned false from validation
                    this.hasValidModels = isValid;
                }

                // check if all model validations have occurred
                if (returnCt === this.collection.length) {
                    if (fromCreateView) {
                        // the create waterfall wants the opposite of if this is validated
                        callback(!this.hasValidModels);
                    } else {
                        // this view wants if the models are valid or not
                        callback(this.hasValidModels);
                    }
                }
            }, this));
        }, this);
    },

    /**
     * Click handler for the Add (+) button.
     * Validates each model on the collection and if they all validate, calls
     */
    onAddRow: function() {
        this.validateModels(_.bind(this._addBeanToList, this));
    },

    /**
     * Handler for when the delete button is clicked
     *
     * @param model
     */
    onDeleteRow: function(model) {
        this.context.get('collection').remove(model);
        this.checkButtons();
    },

    /**
     * Adds a bean for this.module to the collection
     *
     * @param {Boolean} hasValidModels If this collection has validated models
     * @param {Object} prepopulateData The ProductCatalog data to add prepopulate an RLI
     * @private
     */
    _addBeanToList: function(hasValidModels, prepopulateData) {
        var beanId;
        var bean;
        var addAtZeroIndex;
        prepopulateData = prepopulateData || {};

        if (hasValidModels) {
            beanId = app.utils.generateUUID();
            addAtZeroIndex = !_.isEmpty(prepopulateData);

            prepopulateData.id = beanId;
            bean = app.data.createBean(this.module);
            bean.set(prepopulateData);
            bean._module = this.module;

            // check the parent record to see if an assigned user ID/name has been set
            if (this.context.parent && this.context.parent.has('model')) {
                var parentModel = this.context.parent.get('model'),
                    userId = parentModel.get('assigned_user_id'),
                    userName = parentModel.get('assigned_user_name');

                if (userId) {
                    bean.setDefault('assigned_user_id', userId);
                }

                if (userName) {
                    bean.setDefault('assigned_user_name', userName);
                }
            }

            bean = this._addCustomFieldsToBean(bean, addAtZeroIndex);

            // must add to this.collection so the bean shows up in the subpanel list
            if (addAtZeroIndex) {
                this.collection.unshift(bean);
            } else {
                this.collection.add(bean);
            }
        }

        this.checkButtons();
    },

    /**
     * Allows child functions to override and add module-specific properties to the bean
     * before it gets added to the collection
     *
     * @param {Data.Bean} bean The bean to add new properties to
     * @param {boolean} skipCurrency Skip or set currency properties
     * @return {Data.Bean}
     * @private
     */
    _addCustomFieldsToBean: function(bean, skipCurrency) {
        return bean;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (app.controller && app.controller.context) {
            var viewDetails = this.closestComponent('create') ?
                this.closestComponent('create') :
                this.closestComponent('record');

            if (!_.isUndefined(viewDetails)) {
                app.controller.context.off(viewDetails.cid + ':productCatalogDashlet:add', null, this);
            }
        }
        if (this.context && this.context.parent) {
            this.context.parent.off(null, null, this);
        }
        this._super('_dispose');
    }
}) },
"orgchart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View that displays a list of models pulled from the context's collection.
 *
 * @class View.Views.Base.OrgchartView
 * @alias SUGAR.App.view.views.BaseOrgchartView
 * @extends View.View
 */
({
	// Orgchart View (base) 

    events: {
        'click .zoom-control': 'zoomChart',
        'click .toggle-control': 'toggleChart'
    },
    plugins: ['Dashlet', 'Chart'],

    // user configurable
    nodetemplate: null,
    reporteesEndpoint: '',
    zoomExtents: null,
    nodeSize: null,

    // private
    jsTree: null,
    slider: null,
    sliderZoomIn: null,
    sliderZoomOut: null,
    container: null,

    /**
     * Initialize the View
     *
     * @constructor
     * @param {Object} options
     */
    initialize: function(options) {
        var self = this;
        this._super('initialize', [options]);

        //TODO: change api to accept id as param or attrib as object to produce
        this.reporteesEndpoint = app.api.buildURL('Forecasts', 'orgtree/' + app.user.get('id'), null, {'level': 2});
        this.zoomExtents = {'min': 0.25, 'max': 1.75};
        this.nodeSize = {'width': 124, 'height': 56};

        this.chart = sucrose.charts.treeChart()
                .duration(0)
                .horizontal(false)
                .getId(function(d) {
                    var metadata = d.metadata || d.data.metadata;
                    return metadata ? metadata.id : 0;
                })
                .nodeSize(this.nodeSize)
                .nodeRenderer(_.bind(this.nodeRenderer, this))
                .nodeClick(function(d) {
                    var nodeData = d.data.metadata;
                    app.router.navigate(nodeData.url, {trigger: true});
                })
                .zoomExtents(this.zoomExtents)
                .zoomCallback(_.bind(this.moveSlider, this));
    },

    /**
     * Returns a url to a user record
     * @param {String} id the User record id.
     * @protected
     */
    _buildUserUrl: function(id) {
        return '#' + app.bwc.buildRoute('Employees', id);
    },

    /**
     * Appends the node content to the tree
     * This should be extended by each implementation
     * @param {String} content tree content container.
     * @param {Object} d tree node metadata.
     * @param {Int} w tree node width.
     * @param {Int} h tree node height.
     */
    nodeRenderer: function(content, d, w, h) {
        var nodeData = d.data.metadata;
        var node = content.append('g').attr('class', 'sc-org-node');
        var container = d3sugar.select('svg#' + this.cid);
        if (!nodeData.img || nodeData.img === '') {
            nodeData.img = 'include/images/user.svg';
        }

        node.append('rect').attr('class', 'sc-org-bkgd')
            .attr('x', 0)
            .attr('y', 0)
            .attr('rx', 2)
            .attr('ry', 2)
            .attr('width', w)
            .attr('height', h);
        node.append('image').attr('class', 'sc-org-avatar')
            .attr('xlink:href', nodeData.img)
            .attr('width', '32px')
            .attr('height', '32px')
            .attr('transform', 'translate(3, 3)')
            .on('error', function() {
                d3.select(this)
                    .style('width', 'auto')
                    .attr('x', '4')
                    .attr('xlink:href', 'include/images/user.svg');
            });
        node.append('text').attr('class', 'sc-org-name')
            .attr('data-url', d.data.url)
            .attr('transform', 'translate(38, 11)')
            .text(function() {
                return sucrose.utility.stringEllipsify(nodeData.full_name, container, 96);
            });
        node.append('text').attr('class', 'sc-org-title')
            .attr('data-url', d.data.url)
            .attr('transform', 'translate(38, 21)')
            .text(function() {
                return sucrose.utility.stringEllipsify(nodeData.title, container, 96);
            });

        node
            .on('mouseenter', function(d) {
                d3.select(this)
                    .select('.sc-org-name')
                        .style('text-decoration', 'underline');
            })
            .on('mouseleave', function(d) {
                d3.select(this)
                    .select('.sc-org-name')
                        .style('text-decoration', 'none');
            });

        return node;
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        if (!this.slider) {
            // chart controls
            this.slider = this.$('.btn-slider .noUiSlider');
            this.sliderZoomOut = this.$('.zoom-control[data-control="zoom-out"]');
            this.sliderZoomIn = this.$('.zoom-control[data-control="zoom-in"]');

            //zoom slider
            this.slider.noUiSlider('init', {
                start: 100,
                knobs: 1,
                scale: [this.zoomExtents.min * 100, this.zoomExtents.max * 100],
                connect: false,
                step: 5,
                change: _.bind(function(moveType) {
                    var values, scale;
                    if (!this.chart_loaded) {
                        return;
                    }
                    if (moveType === 'slide') {
                        values = this.slider.noUiSlider('value');
                        scale = this.chart.zoomLevel(values[0] / 100);
                    } else {
                        scale = this.chart.zoomScale();
                    }
                    this.sliderZoomOut.toggleClass('disabled', (scale <= this.zoomExtents.min));
                    this.sliderZoomIn.toggleClass('disabled', (scale >= this.zoomExtents.max));
                }, this)
            });
        }
        this.moveSlider();

        if (this.jsTree) {
            this.jsTree.jstree('destroy');
        }

        //jsTree control for selecting root node
        this.jsTree = this.$('div[data-control="org-jstree"]')
                .jstree({
                    // generating tree from json data
                    'json_data': {
                        'data': this.chartCollection
                    },
                    // plugins used for this tree
                    'plugins': ['json_data', 'ui', 'types'],
                    'core': {
                        'animation': 0
                    },
                    'ui': {
                        // when the tree re-renders, initially select the root node
                        'initially_select': ['jstree_node_' + app.user.get('user_name')]
                    }
                }).on('loaded.jstree', _.bind(function() {
                    // do stuff when tree is loaded
                    this.$('div[data-control="org-jstree"]').addClass('jstree-sugar');
                    this.$('div[data-control="org-jstree"] > ul').addClass('list');
                    this.$('div[data-control="org-jstree"] > ul > li > a').addClass('jstree-clicked');
                }, this))
                .on('click.jstree', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                })
                .on('select_node.jstree', _.bind(function(event, data) {
                    var jsData = data.inst.get_json();

                    this.chart.filter(jQuery.data(data.rslt.obj[0], 'id'));
                    this.forceRepaint();
                    this.moveSlider();

                    this.$('div[data-control="org-jstree-dropdown"] .jstree-label').text(data.inst.get_text());
                    data.inst.toggle_node(data.rslt.obj);
                }, this));
        app.accessibility.run(this.jsTree, 'click');

        this.container = d3sugar.select('svg#' + this.cid);

        this.container
            .datum(this.chartCollection[0])
            .call(this.chart);

        this.chart.resetZoom();

        this.forceRepaint();

        this.$('.sc-expcoll').on('click', _.bind(function() {
            this.forceRepaint();
            this.moveSlider();
        }, this));

        this.chart_loaded = _.isFunction(this.chart.resize);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * Forces repaint of images using opacity animation to fix
     * issue with rendering foreignObject in SVG
     */
    forceRepaint: function() {
        this.$('.rep-avatar').on('load', function() {
            $(this).removeClass('loaded').addClass('loaded');
        });

        // this.$('img').on('error', function() {
        //     $(this).attr('src', 'include/images/user.svg');
        // });
    },

    /**
     * Move the slider position
     * Use whenever the tree changes size
     */
    moveSlider: function(scale) {
        var s = scale || 1;
        if (this.slider) {
            this.slider.noUiSlider('move', {to: s * 100});
        }
    },

    /**
     * Override the hasChartData method in Chart plugin because
     * this view does not have a total value.
     */
    hasChartData: function() {
        return !_.isEmpty(this.chartCollection);
    },

    /**
     * Override the chartResize method in Chart plugin because
     * orgchart sucrose model uses resize instead of update.
     */
    chartResize: function() {
        this.moveSlider();
        this.chart.resize();
    },

    /**
     * Recursively step through the tree and for each node representing a tree node, run the data attribute through
     * the _postProcessTree function.  This function supports n-levels of the tree hierarchy.
     *
     * @param data The data structure returned from the REST API Forecasts/reportees endpoint
     * @return The modified data structure after all the parent and children nodes have been stepped through
     * @private
     */
    _postProcessTree: function(data) {
        var root = [];

        if (_.isArray(data) && data.length == 2) {
            root.push(data[0]);
            root[0].children.push(data[1]);
        } else {
            root.push(data);
        }

        //protect against admin and other valid Employees
        if (_.isEmpty(root[0].metadata.id)) {
            return null;
        }

        _.each(root, function(entry) {
            var adopt = [];

            //Scan for the nodes with the data attribute.  These are the nodes we are interested in
            if (!entry.data) {
                return;
            }

            entry.metadata.url = this._buildUserUrl(entry.metadata.id);

            if (!entry.metadata.picture || entry.metadata.picture === '') {
                entry.metadata.img = 'include/images/user.svg';
            } else {
                entry.metadata.img = app.api.buildFileURL({
                    module: 'Employees',
                    id: entry.metadata.id,
                    field: 'picture'
                });
            }

            if (!entry.children) {
                return;
            }

            //For each children found (if any) then call _postProcessTree again.
            _.each(entry.children, function(childEntry) {
                var newChild;
                if (entry.metadata.id !== childEntry.metadata.id) {
                    newChild = this._postProcessTree(childEntry);
                    if (!_.isEmpty(newChild)) {
                        adopt.push(newChild[0]);
                    }
                }
            }, this);

            entry.children = adopt;

        }, this);

        return root;
    },

    /**
     * Slider control for zooming chart viewport.
     * @param {e} event The event object that is triggered.
     */
    zoomChart: function(e) {
        var button, step, scale;
        if (!this.chart_loaded) {
            return;
        }

        button = $(e.target).data('control');
        step = 0.25 * (button === 'zoom-in' ? 1 : -1);
        scale = this.chart.zoomStep(step);

        this.moveSlider(scale);
    },

    /**
     * Handle all chart manipulation toggles.
     * @param {e} event The event object that is triggered.
     */
    toggleChart: function(e) {
        var button;
        if (!this.chart_loaded) {
            return;
        }

        //if icon clicked get parent button
        button = $(e.currentTarget).hasClass('btn') ? $(e.currentTarget) : $(e.currentTarget).parent('.btn');

        switch (button.data('control')) {
            case 'orientation':
                this.chart.orientation();
                button.find('i').toggleClass('fa-arrow-right fa-arrow-down');
                break;

            case 'show-all-nodes':
                this.chart.showall();
                this.forceRepaint();
                break;

            case 'zoom-to-fit':
                this.chart.resize();
                break;

            default:
        }

        this.moveSlider();
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        app.api.call('get', this.reporteesEndpoint, null, {
            success: _.bind(function(data) {
                this.chartCollection = this._postProcessTree(data);
                if (!this.disposed) {
                    this.renderChart();
                }
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * overriding _dispose to make sure custom added event listeners are removed
     * @private
     */
    _dispose: function() {
        if (this.jsTree) {
            this.jsTree.jstree('destroy');
        }
        if (this.slider) {
            this.slider.off('move');
        }
        this._super('_dispose');
    }
}) },
"activitystream-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Activitystream-dashlet View (base) 

    /**
     * The plugins used by this view.
     */
    plugins: ['Dashlet'],

    events: {
        'click .addComment' : 'addComment'
    },

    className: 'block filtered activitystream-layout',

    /**
     * The default settings for activity stream.
     *
     * @property {Object}
     */
    _defaultSettings: {
        limit: 5,
        auto_refresh: 0
    },

    /**
     * Omnibar ActivityStream view
     */
    omnibarView: null,

    initialize: function(opts) {
        this.renderedActivities = {};

        var moduleMeta = app.metadata.getModule(opts.context.parent.get('module'));
        this.activityStreamEnabled = moduleMeta.activityStreamEnabled;
        if (this.activityStreamEnabled && this.activityStreamEnabled === true) {
            this.plugins.push('Pagination');
        }

        this._super('initialize', [opts]);

        this.setCollectionOptions();
        this.context.on('activitystream:post:prepend', this.prependPost, this);

        this.omnibarView = app.view.createView({
            context: this.context,
            type: 'activitystream-omnibar',
            module: this.module,
            layout: this
        });

        if (this.meta.config) {
            this.listenTo(this.layout, 'init', this._addFilterComponent);
            this.layout.before('dashletconfig:save', this.saveDashletFilter, this);
        }
    },

    /**
     * Init dashlet settings
     */
    initDashlet: function()
    {
        var options = {};
        var self = this;
        var refreshRate;

        options.limit = this.settings.get('limit') || this._defaultSettings.limit;
        this.settings.set('limit', options.limit);

        options.auto_refresh = this.settings.get('auto_refresh') || this._defaultSettings.auto_refresh;
        this.settings.set('auto_refresh', options.auto_refresh);

        options = _.extend({}, this.context.get('collectionOptions'), options);
        this.context.set('collectionOptions', options);

        // Set the refresh rate for setInterval so it can be checked ahead of
        // time.  60000 is 1000 miliseconds times 60 seconds in a minute.
        refreshRate = options.auto_refresh * 60000;

        // Only set up the interval handler if there is a refreshRate higher than 0
        if (refreshRate > 0) {
            if (this.timerId) {
                clearInterval(this.timerId);
            }
            this.timerId = setInterval(_.bind(function() {
                if (self.context) {
                    self.context.resetLoadFlag();
                    self.loadData();
                }
            }, this), refreshRate);
        }
    },

    /**
     * This function adds the `dashablelist-filter` component to the layout
     * (dashletconfiguration), if the component doesn't already exist.
     */
    _addFilterComponent: function() {
        var filterComponent = this.layout.getComponent('asdashlet-filter');
        if (filterComponent) {
            return;
        }

        this.layout.initComponents([{
            layout: 'asdashlet-filter'
        }]);
    },

    /**
     * Gets Filter Definition from metadata given a filter id
     */
    _getFilterDefFromMeta: function(id) {
        if (!id) {
            return;
        }

        var moduleMeta = app.utils.deepCopy(app.metadata.getModule('Activities'));
        if (_.isObject(moduleMeta)) {
            var filters = _.compact(_.flatten(_.pluck(_.compact(_.pluck(moduleMeta.filters, 'meta')), 'filters')));
            var filter = _.find(filters, function(filter) {
                return filter.id === id;
            }, this);

            if (filter) {
                return filter;
            }
        }
    },

    /**
     * Set endpoint and the success callback for retrieving activities.
     */
    setCollectionOptions: function() {
        var self = this;

        var endpoint = function(method, model, options, callbacks) {
            var real_module = self.context.parent.get('module'),
                layoutType = self.context.parent.get('layout'),
                modelId = self.context.parent.get('modelId'),
                action = model.module, // equal to 'Activities'
                url;

            // For :Home/:record case we should call for global ActivityStream
            if (real_module == 'Home' && layoutType == 'record') {
                real_module = self.module;
                layoutType = 'activities';
            }

            switch (layoutType) {
                case 'activities':
                    url = app.api.buildURL(real_module, null, {}, options.params);
                    break;
                case 'records':
                    url = app.api.buildURL(real_module, action, {}, options.params);
                    break;
                case 'record':
                    url = app.api.buildURL(real_module, null, {id: modelId, link: 'activities'}, options.params);
                    break;
            }

            return app.api.call('read', url, null, callbacks);
        };

        this.context.set('collectionOptions', {
            endpoint: endpoint,
            success: function(collection) {
                // Toogle no-data visibility
                self.$el.find('.block-footer').toggleClass('hide', (collection.length > 0));
                collection.each(function(model) {
                    self.renderPost(model);
                });
            },
            limit: this._defaultSettings.limit
        });
    },

    /**
     * This function is invoked by the `dashletconfig:save` event. It takes the
     * `currentFilterId` stored on the context, and saves it on the dashlet.
     *
     * @param {Bean} model The dashlet mo`del.
     */
    saveDashletFilter: function() {
        this.layout.trigger('asdashlet:config:save');
    },

    /**
     * Show\hide activity stream omnibar
     */
    addComment: function()
    {
        this.$el.find('.omnibar-dashlet').toggleClass('hide');
    },

    /**
     * Bind data changes and comments\post adding
     */
    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('add', function(model) {
                this.renderPost(model);
            }, this);
            this.collection.on('reset', function() {
                this.disposeAllActivities();

                // Clean up post container
                this.$el.find('.activitystream-list').html('');
                this.collection.each(function(post) {
                    this.renderPost(post);
                }, this);
            }, this);
        }

        if (this.context.parent) {
            var model = this.context.parent.get('model');
            this.listenTo(model, 'sync', _.once(function() {
                // Only attach to the sync event after the inital sync is done.
                this.listenTo(model, 'sync', function() {
                    var options = this.context.get('collectionOptions');
                    var filterDef = this._getFilterDefFromMeta(this.meta.currentFilterId);
                    if (filterDef) {
                        options.filter = filterDef.filter_definition;
                    }
                    this.collection.fetch(options);
                });
            }));
        }
    },

    /**
     * Add posts to activity stream on data change
     *
     * @param model
     */
    prependPost: function(model) {
        var view = this.renderPost(model);
        view.$el.parent().prepend(view.$el);
    },

    loadData: function(options) {
        if (_.isUndefined(this.context.parent.get('layout'))) {
            return;
        }

        // If activity streams are disabled for the current module on which the dashlet sits
        // then display a warning saying as much
        if (!this.activityStreamEnabled) {
            this.template = app.template.get(this.name + '.disabled');
            this._super('_render', [options]);
            return;
        }

        options = _.extend({}, options, this.context.get('collectionOptions'));

        if (this.collection) {
            var filterDef = this._getFilterDefFromMeta(this.meta.currentFilterId);
            if (filterDef) {
                options.filter = filterDef.filter_definition;
            }

            this.collection.fetch(options);
        }
    },

    /**
     * Render each ActivityStream model
     *
     * @param model
     * @return {Mixed}
     */
    renderPost: function(model) {
        var view;

        if (_.has(this.renderedActivities, model.id)) {
            view = this.renderedActivities[model.id];
        } else {
            view = app.view.createView({
                context: this.context,
                type: 'activitystream',
                module: this.module,
                layout: this,
                model: model,
                nopreview: true  // hide preview button
            });

            // Place view to dashlet layout container
            this.$el.find('.activitystream-list').append(view.el);
            this.renderedActivities[model.id] = view;
            view.render();
        }

        return view;
    },

    /**
     * Skip rendering on pagination update
     * This is a hack to prevent dashlet re-render
     *
     * @param options
     */
    render: function(options)
    {
        if (!this.rendered) {
            this.rendered = true;
            this._super('render', [options]);

            // Append sub view - aka add component
            this.$el.find('.omnibar-dashlet').append(this.omnibarView.el);
            this.omnibarView.render();
        }
    },

    unbindData: function() {
        var model, collection;

        if (this.context.parent) {
            model = this.context.parent.get('model');
            collection = this.context.parent.get('collection');

            if (model) {
                model.off('change sync', null, this);
            }
            if (collection) {
                collection.off('sync', null, this);
            }
        }

        this._super('unbindData');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.omnibarView.dispose();
        this.disposeAllActivities();
        this._super('_dispose');
    },

    /**
     * Dispose all previously rendered activities
     */
    disposeAllActivities: function() {
        _.each(this.renderedActivities, function(component) {
            component.dispose();
        });
        this.renderedActivities = {};
    }
}) },
"mobile-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MobileActionView
 * @alias SUGAR.App.view.views.BaseMobileActionView
 * @extends View.View
 */
({
	// Mobile-action View (base) 

    tagName: 'span',
    events: {
        'click [data-action=mobile]': 'navigateToMobile'
    },
    navigateToMobile: function () {
        if (document.cookie.indexOf('sugar_mobile=') !== -1) {
            // kill sugar_mobile=0 cookie
            document.cookie = 'sugar_mobile=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
        }
        // navigate to the same route of mobile site
        window.location = app.utils.buildUrl('mobile/') + window.location.hash;
    }
}) },
"attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Attachment dashlet displays Notes and Attachments records that is related to the LHS record.
 * The following items are configurable.
 *
 * - {Integer} limit Limit imposed to the number of records pulled.
 * - {Integer} auto_refresh How often (minutes) should refresh the data collection.
 *
 * @class View.Views.Base.AttachmentsView
 * @alias SUGAR.App.view.views.BaseAttachmentsView
 * @extends View.View
 */
({
	// Attachments View (base) 

    plugins: ['LinkedModel', 'Dashlet', 'Pagination'],
    events: {
        'click [data-event=create_button]': 'createRelatedNote',
        'click [data-event=select_button]': 'openSelectDrawer'
    },

    /**
     * Default options used when none are supplied through metadata.
     *
     * Supported options:
     * - timer: How often (minutes) should refresh the data collection.
     * - limit: Limit imposed to the number of records pulled.
     *
     * @property {Object}
     * @protected
     */
    _defaultOptions: {
        limit: 5,
        timer: 0
    },

    /**
     * @inheritdoc
     *
     * @param {String} viewName view name.
     */
    initDashlet: function(viewName) {
        this._initOptions();
        if (!this.meta.config && this.context.get('collection')) {
            this.context.set('skipFetch', false);
            this.context.set('limit', this.limit);
        }
        if (!this.meta.config && !this.meta.preview) {
            this.context.on('attachment:view:fire', this.previewRecord, this);
            this.on('attachment:unlinkrow:fire', this.unlinkClicked, this);
            if (this.timer > 0) {
                //disabled previous interval
                this._disableAutoRefresh();
                this._enableAutoRefresh(this.timer);
            }
        }
    },

    /**
     * Initialize options, default options are used when none are supplied
     * through metadata.
     *
     * @return {Backbone.View} Instance of this view.
     * @protected
     */
    _initOptions: function() {
        this.tbodyTag = 'ul[data-action="pagination-body"]';
        var options = _.extend(this._defaultOptions, this.settings.attributes || {});
        this.timer = parseInt(options['auto_refresh'], 10) * 60 * 1000;
        this.limit = options.limit;
        return this;
    },

    /**
     * Get the list of field names to render the dashlet correctly
     * @return {string[]} The list of fields we need to fetch
     * @override
     */
    getFieldNames: function() {
        // FIXME TY-920: we shouldn't have to override this per-dashlet
        return this.dashletConfig && this.dashletConfig.dashlets[0].fields || [];
    },

    /**
     * Disable activated refresh interval
     * @protected
     */
    _disableAutoRefresh: function() {
        if (this.timerId) {
            clearInterval(this.timerId);
            this.timerId = null;
        }
        return this;
    },

    /**
     * Activate auto refresh data fetch.
     *
     * @param {Integer} msec Interval time in milli seconds(msec > 0).
     * @protected
     */
    _enableAutoRefresh: function(msec) {
        if (msec <= 0) {
            app.logger.error('Invalid interval timer: ' + msec);
            return this;
        }

        if (!_.isEmpty(this.timerId)) {
            app.logger.error('Trying to enable an already enabled auto-refresh dashlet.');
            return this;
        }

        this.timerId = setInterval(_.bind(function() {
            this.context.resetLoadFlag();
            this.layout.loadData();
        }, this), msec);
        return this;
    },

    /**
     * Apply svg icon plugin.
     */
    applySvgIcon: function() {
        var self = this,
            svgIconTemplate = app.template.get('attachments.svg-icon', this.module) ||
                app.template.get('attachments.svg-icon');
        this.$('[data-mime]').each(function() {
            var mimeType = $(this).data('mime'),
                filetype = self.dashletConfig.supportedImageExtensions[mimeType] || self._getFileType(mimeType);
            $(this).attr('data-filetype', filetype).html(svgIconTemplate());
        });
    },

    /**
     * Convert file mime type to file format
     *
     * @param {String} mimeType file mime type.
     * @return {String} file type.
     * @private
     */
    _getFileType: function(mimeType) {
        var filetype = mimeType.substr(mimeType.lastIndexOf('/') + 1).toUpperCase();
        return filetype ? filetype : this.dashletConfig.defaultType.toUpperCase();
    },

    /**
     * @inheritdoc
     *
     * Once collection is reset, the view should be refreshed.
     */
    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('reset', this.render, this);
        }
        this.on('render', this.applySvgIcon, this);
        this.on('linked-model:create', this._reloadData, this);
    },

    /**
     * Re-fetches the data for the context's collection.
     *
     * FIXME: This will be removed when SC-4775 is implemented.
     *
     * @private
     */
    _reloadData: function() {
        this._prepContextForLoad();
        this.context.reloadData();
    },

    /**
     * Choose the attachment from the existing module list
     */
    openSelectDrawer: function() {
        var parentModel = this.context.get('parentModel'),
            linkModule = this.context.get('module'),
            link = this.context.get('link'),
            self = this;

        app.drawer.open({
            layout: 'selection-list',
            context: {
                module: linkModule
            }
        }, function(model) {
            if (!model) {
                return;
            }
            var relatedModel = app.data.createRelatedBean(parentModel, model.id, link),
                options = {
                    // Show alerts for this request
                    showAlerts: true,
                    relate: true,
                    success: function() {
                        self.context.resetLoadFlag();
                        self._prepContextForLoad();
                        self.context.loadData();
                    },
                    error: function() {
                        app.alert.show('server-error', {
                            level: 'error',
                            messages: 'ERR_GENERIC_SERVER_ERROR'
                        });
                    }
                };
            relatedModel.save(null, options);
        });
    },

    /**
     * Create new attachment record
     */
    createRelatedNote: function() {
        var link =  this.context.get('link'),
            parentModel = this.context.get('parentModel');
        this.createRelatedRecord(app.data.getRelatedModule(parentModel.module, link), link);
    },

    /**
     * Fix the fields on the context to prevent conflict with list-bottom
     * Also set `skipFetch` on the context since it is needed before most loads
     * @private
     */
    _prepContextForLoad: function() {
        this.context.set('fields', this.getFieldNames());
        this.context.set('skipFetch', false);
    },

    /**
     * Unlinks (removes) the selected model from the list view's collection.
     *
     * We trigger reset after removing the model in order to update html as well.
     *
     * @param {Data.Bean} model Selected model.
     */
    unlinkClicked: function(model) {
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show(model.get('id') + ':unlink_confirmation', {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('NTC_UNLINK_CONFIRMATION_FORMATTED'), [context]),
            onConfirm: function() {
                model.destroy({
                    //Show alerts for this request
                    showAlerts: true,
                    relate: true,
                    success: function() {
                        if (self.disposed) {
                            return;
                        }
                        self.collection.remove(model);
                        self.render();
                    }
                });
            }
        });
    },

    /**
     * @inheritdoc
     *
     * Dispose the interval timer as well.
     */
    _dispose: function() {
        this._disableAutoRefresh();
        app.view.View.prototype._dispose.call(this);
    }
}) },
"search-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Headerpane view for the {@link View.Layouts.Base.SearchLayout
 * Search layout}.
 *
 * @class View.Views.Base.SearchHeaderpaneView
 * @alias SUGAR.App.view.views.BaseSearchHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Search-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.on('change:searchTerm change:tagParams', function(model, value) {
            var tagParams = this.context.get('tagParams') || [];
            this.searchTerm = {term: this.context.get('searchTerm'), tags: tagParams.join(', ')};
            this.render();
        }, this);

        // Let this.searchTerm hold searchTerm and tag data for headerpane title
        var tagParams = this.context.get('tagParams') || [];
        this.searchTerm = {term: this.context.get('searchTerm'), tags: tagParams.join(', ')};
    },

    /**
     * Formats the title passing the search term.
     *
     * @override
     */
    _formatTitle: function(title) {
        if (!title) {
            return '';
        }
        return app.lang.get(title, this.module, {
            searchTerm: new Handlebars.SafeString(this.searchTerm)
        });
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this._super('unbind');
        $(window).off('resize.searchheader');
        this.layout.off('headerpane:adjust_fields', this.adjustTitle);
    }
}) },
"dashboard-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashboardHeaderpaneView
 * @alias SUGAR.App.view.views.BaseDashboardHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 * @deprecated 7.9 It will be removed in 7.11.
 *   Please use {@link View.Views.Dashboards.DashboardHeaderpaneView} instead.
 */
({
	// Dashboard-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',
    buttons: null,
    editableFields: null,
    className: 'preview-headerbar',
    events: {
        'click [name=edit_button]': 'editClicked',
        'click [name=cancel_button]': 'cancelClicked',
        'click [name=create_cancel_button]': 'createCancelClicked',
        'click [name=delete_button]': 'deleteClicked',
        'click [name=add_button]': 'addClicked',
        'click [name=collapse_button]': 'collapseClicked',
        'click [name=expand_button]': 'expandClicked'
    },
    initialize: function(options) {
        app.logger.warn('The class `View.Views.Base.DashboardHeaderpaneView`' +
            'has been deprecated since 7.9.0.0 and will be removed in 7.11.0.0. ' +
            'Please use `View.Views.Dashboards.DashboardHeaderpaneView` instead.');
        if(options.context.parent) {
            options.meta = app.metadata.getView(options.context.parent.get("module"), options.name);
            options.template = app.template.getView(options.name);
        }
        this._super("initialize", [options]);
        this.model.on("change change:layout change:metadata", function() {
            if (this.inlineEditMode) {
                this.changed = true;
            }
        }, this);
        this.model.on("error:validation", this.handleValidationError, this);

        if(this.context.get("create")) {
            this.changed = true;
            this.action = 'edit';
            this.inlineEditMode = true;
        } else {
            this.action = 'detail';
        }
        this.buttons = {};

        this._bindEvents();
    },

    /**
     * Binds the events that are necessary for this view.
     *
     * @protected
     */
    _bindEvents: function() {
        this.context.on('record:set:state', this.setRecordState, this);
    },

    /**
     * Handles the logic done when the state changes in the record.
     * This is the callback for the `record:set:state` event.
     *
     * @param {string} state The state that the record is set to.
     */
    setRecordState: function(state) {
        this.model.trigger('setMode', state);
        this.setButtonStates(state);
        this.inlineEditMode = state === 'edit';
        this.toggleEdit(this.inlineEditMode);
    },

    editClicked: function(evt) {
        this.previousModelState = app.utils.deepCopy(this.model.attributes);
        this.inlineEditMode = true;
        this.setButtonStates('edit');
        this.toggleEdit(true);
        this.model.trigger("setMode", "edit");
    },
    cancelClicked: function(evt) {
        this.changed = false;
        this.model.unset('updated');
        this.clearValidationErrors();
        this.setButtonStates('view');
        this.handleCancel();
        this.model.trigger("setMode", "view");
    },

    /**
     * Compare with last fetched data and return true if model contains changes
     *
     * See {@link app.plugins.view.editable}.
     *
     * @return true if current model contains unsaved changes
     */
    hasUnsavedChanges: function() {
        if (this.model.get('updated')) {
            return true;
        }
        if (this.model.isNew()) {
            return this.model.hasChanged();
        }
        return !_.isEmpty(this.model.changedAttributes(this.model.getSynced()));
    },

    /**
     * The save function is handled by {@link View.Layouts.Base.DashboardLayout#handleSave}.
     *
     * @override
     */
    saveClicked: $.noop,

    createCancelClicked: function(evt) {
        if(this.context.parent) {
            this.layout.navigateLayout('list');
        } else {
            app.navigate(this.context);
        }
    },
    deleteClicked: function(evt) {
        this.handleDelete();
    },
    addClicked: function(evt) {
        if(this.context.parent) {
            this.layout.navigateLayout('create');
        } else {
            var route = app.router.buildRoute(this.module, null, 'create');
            app.router.navigate(route, {trigger: true});
        }
    },
    collapseClicked: function(evt) {
        this.context.trigger("dashboard:collapse:fire", true);
    },
    expandClicked: function(evt) {
        this.context.trigger("dashboard:collapse:fire", false);
    },
    _render: function() {
        app.view.View.prototype._render.call(this);

        this._setButtons();
        this.setButtonStates(this.context.get("create") ? 'create' : 'view');
        this.setEditableFields();
    },
    handleCancel: function() {
        this.inlineEditMode = false;
        if (!_.isEmpty(this.previousModelState)) {
            this.model.set(this.previousModelState);
        }
        this.toggleEdit(false);
    },
    handleDelete: function() {
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_DELETE_DASHBOARD_CONFIRM', this.module),
            onConfirm: _.bind(function() {
                var message = app.lang.get('LBL_DELETE_DASHBOARD_SUCCESS', this.module, {
                    name: app.lang.get(this.model.get('name'), this.module)
                });
                this.model.destroy({
                    success: _.bind(function() {
                        //dispose safe
                        if (this.disposed) {
                            return;
                        }
                        if (this.context.parent) {
                            var contextBro = this.context.parent.getChildContext({module: 'Home'});
                            contextBro.get('collection').remove(this.model);
                            this.layout.navigateLayout('list');
                        } else {
                            var route = app.router.buildRoute(this.module);
                            app.router.navigate(route, {trigger: true});
                        }
                    }, this),
                    error: function() {
                        app.alert.show('error_while_save', {
                            level: 'error',
                            title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                            messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                        });
                    },
                    //Show alerts for this request
                    showAlerts: {
                        'process': true,
                        'success': {
                            messages: message
                        }
                    }
                });
            }, this)
        });
    },

    bindDataChange: function() {
        //empty out because dashboard header does not need to switch the button sets while model is changed
    },
    toggleEdit: function(isEdit) {
        this.toggleFields(this.editableFields, isEdit);
    }
}) },
"forecastdetails-record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastdetailsRecordView
 * @alias SUGAR.App.view.views.BaseForecastdetailsRecordView
 * @extends View.Views.Base.ForecastdetailsView
 */
({
	// Forecastdetails-record View (base) 

    extendsFrom: 'ForecastdetailsView',

    /**
     * Holds the logged-in user's ID
     */
    selectedUserId: '',

    /**
     * Holds the current timeperiod object
     */
    currentTP: undefined,

    /**
     * Holds the business card's model's timeperiod object (original Opps TP)
     */
    modelTP: undefined,

    /**
     * Holds a reference to the RevenueLineItems subpanel collection
     */
    rliCollection: undefined,

    /**
     * An array of the RLI ids that go into Closed Won
     */
    closedWonIds: [],

    /**
     * An array of the RLI ids that are included in likely/best/worst values
     */
    includedIds: [],

    /**
     * An array of the RLI ids that are included in likely/best/worst values in this timeperiod
     */
    includedIdsInTP: [],

    /**
     * Holds Sales Stage values that get added to Closed Won amounts
     */
    salesStageWon: [],

    /**
     * Array of commit_stages that are included in totals
     */
    commitStagesInIncludedTotal: [],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.selectedUserId = app.user.get('id');
        this._super('initialize', [options]);

        var config = app.metadata.getModule('Forecasts', 'config') || {};

        this.salesStageWon = config.sales_stage_won || ['Closed Won'];
        var forecastRanges = config.forecast_ranges || [];

        this.modelTP = new Backbone.Model();

        if (forecastRanges == 'show_custom_buckets') {
            var ranges = config[forecastRanges + '_ranges'] || [];
            _.each(ranges, function(value, key) {
                if (!_.isUndefined(value.in_included_total) && value.in_included_total) {
                    this.commitStagesInIncludedTotal.push(key);
                }
            });
        } else {
            this.commitStagesInIncludedTotal.push('include');
        }
    },

    /**
     * Builds dashlet url
     * @override
     * @return {String} url to call
     */
    getProjectedURL: function() {
        var method = this.shouldRollup ? "progressManager" : "progressRep",
            url = 'Forecasts/' + this.model.get('selectedTimePeriod') + '/' + method + '/' + this.selectedUserId,
            params = {};

        // if this is a manager view, send the target_quota param to the endpoint
        if(this.shouldRollup) {
            params = {
                target_quota: (this.showTargetQuota) ? 1 : 0
            };
        }

        return app.api.buildURL(url, 'create', null, params);
    },

    /**
     * @inheritdoc
     */
    renderSubDetails: function() {
        // clear the footer class
        var subEl = this.$el.find('.forecast-details');
        if(subEl && subEl.hasClass('block-footer')) {
            subEl.removeClass('block-footer');
        }

        if(this.currentModule != 'Opportunities'
            || (this.currentModule == 'Opportunities' && this.model.get('selectedTimePeriod'))) {
            this._super('renderSubDetails');
        } else {
            subEl.addClass('block-footer');
            subEl.html(app.lang.get('LBL_NO_DATA_AVAILABLE'));
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.meta.config || !this.isForecastSetup) {
            return;
        }

        // reset closedWonIds
        this.closedWonIds = [];
        this.includedIds = [];
        this.includedIdsInTP = [];

        var ctx = this.context.parent || this.context,
            ctxMdl = ctx.get('model');

        ctxMdl.on('sync', function(model) {
            this.fetchNewTPByDate(model.get('date_closed'), undefined, true);
        }, this);

        if(this.currentModule == 'Opportunities') {

            this.rliCollection = app.utils.getSubpanelCollection(ctx, 'RevenueLineItems');

            if(this.rliCollection) {
                // because the user may be loading this dashlet by switching
                // between the Help dashboard and a user's dashboard,
                // process the collection now to init the dashlet properly
                this.processRLICollection(this.rliCollection);
                
                this.rliCollection.on('reset', this.processRLICollection, this);

                this.rliCollection.on('change:likely_case change:best_case change:worst_case change:amount', this.processCases, this);

                this.rliCollection.on('change:sales_stage', this.processSalesStage, this);

                this.rliCollection.on('change:commit_stage', this.processCommitStage, this);

                this.rliCollection.on('change:date_closed', this.checkFetchNewTPByDate, this);

                ctx.on('editablelist:cancel', function(a,b,c) {
                    // no way to really tell what all manual math we've done, so when the row
                    // gets cancelled, just completely reload the data
                    this.loadData();
                }, this);

                /**
                 * Init the Opp record TimePeriod model to receive new TP data and set a change listener
                 * so we can update which model IDs are included and in the actual timeperiod
                 */
                this.modelTP.on('change', function(model) {
                    var rliModel;

                    // empty array
                    this.includedIdsInTP = [];

                    _.each(this.includedIds, function(id) {
                        rliModel = this.rliCollection.get(id);
                        // check to see if this RLI's date is inside the current Opp timeperiod
                        if(this.isDateInTimePeriod(rliModel.get('date_closed'), this.modelTP.toJSON())) {
                            this.includedIdsInTP.push(rliModel.get('id'));
                        }
                    }, this);
                }, this);
            }
        } else if(this.currentModule == 'RevenueLineItems') {
            // RLI only listeners

            // set up closedWonIds when we change dashboards
            this.initClosedWonIds(ctxMdl);

            ctxMdl.on('change:likely_case change:best_case change:worst_case change:amount', this.processCases, this);

            ctxMdl.on('change:sales_stage', this.processSalesStage, this);

            ctxMdl.on('change:commit_stage', this.processCommitStage, this);

            this.context.parent.on('button:cancel_button:click', function(model, date) {
                var ctx = this.context.parent || this.context,
                    ctxModel = ctx.get('model'),
                    options = {
                        beforeParseData: _.bind(this.addModelTotalsToServerData, this, ctxModel)
                    };
                // no way to really tell what all manual math we've done, so when the row
                // gets cancelled, just completely reload the data
                this.loadData(options);
            }, this);

            ctxMdl.on('change:date_closed', this.checkFetchNewTPByDate, this);

            ctxMdl.on('sync', function(model) {
                // updates our lhsData when the user saves the model
                if(_.has(ctxMdl.attributes, 'lhsData')) {
                    ctxMdl.set({
                        lhsData: {
                            best: model.get('best_case'),
                            likely: model.get('likely_case'),
                            worst: model.get('worst_case')
                        }
                    });
                }
            }, this);

            // Using LHS Model to store the initial values of the LHS model so we don't have
            // to ping the server every dashlet load for the true original DB values of the LHS model
            if(!_.has(ctxMdl.attributes, 'lhsData')) {
                ctxMdl.set({
                    lhsData: {
                        best: ctxMdl.get('best_case'),
                        likely: ctxMdl.get('likely_case'),
                        worst: ctxMdl.get('worst_case')
                    }
                });
            }

            if(_.contains(this.closedWonIds, ctxMdl.get('id'))) {
                this.processSalesStage(ctxMdl);
            }
        }
    },

    /**
     * @inheritdoc
     *
     * @override just calls calculateData on it's own instead of going back to the parent
     */
    handleNewDataFromServer: function(data) {
        // since the user might add this dashlet after they have changed the RLI model, but before they saved it
        // we have to check and make sure that we're accounting for any changes in the dashlet totals that come
        // from the server, but only if this has not already been parsed by a beforeParseData function
        if(this.currentModule == 'RevenueLineItems' && this.context && _.isUndefined(data.parsedData)) {
            var mdl = this.context.parent.get('model') || this.context.get('model'),
                lhsData = mdl.get('lhsData');

            if(lhsData.likely != mdl.get('likely_case')) {
                data.amount = data.amount - (lhsData.likely - mdl.get('likely_case'));
            }
            if(lhsData.best != mdl.get('best_case')) {
                data.best_case = data.best_case - (lhsData.best - mdl.get('best_case'));
            }
            if(lhsData.worst != mdl.get('worst_case')) {
                data.worst_case = data.worst_case - (lhsData.worst - mdl.get('worst_case'));
            }
        }

        this.calculateData(this.mapAllTheThings(data, false));
    },

    /**
     * Processes this.rliCollection.models to determine which models IDs should be
     * saved into the closedWonIds array
     */
    processRLICollection: function(collection) {
        this.oldTotals.models = new Backbone.Model();
        _.each(this.rliCollection.models, function(model) {
            // save all the initial likely values
            this.oldTotals.models.set(model.get('id'), {
                likely: model.get('likely_case'),
                best: model.get('best_case'),
                worst: model.get('worst_case')
            });
            this.initClosedWonIds(model);
        }, this);

        if(collection) {
            // if this is coming from the rliCollection reset, fetch server data
            this.loadData();
        }
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        if(this.context.parent) {
            this.context.parent.off(null, null, this);
            if(this.context.parent.get('model')) {
                this.context.parent.get('model').off(null, null, this);
            }
        }
        if(this.context) {
            this.context.off(null, null, this);
            if(this.context.get('model')) {
                this.context.get('model').off(null, null, this);
            }
        }

        if(this.currentModule == 'Opportunities' && this.rliCollection) {
            this.rliCollection.off(null, null, this);
            this.rliCollection = undefined;
        }

        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Handles when likely/best/worst case changes, processes numbers and does math before sending
     * to calculateTotals
     *
     * @param {Backbone.Model} model the RLI/Opp model
     */
    processCases: function(model) {
        // model is undefined when users change currency symbols,
        // it throws a change:best_case but there's no model
        if(!_.isUndefined(model) && (app.user.get('id') == model.get('assigned_user_id'))
            && _.contains(this.includedIds, model.get('id'))) {
            var data = _.clone(model.toJSON()),
                diff = 0,
                old = 0,
                totals = {};

            if(this.currentModule == 'Opportunities') {
                // if amount is not undefined, push amount into likely_case
                data.likely_case = (!_.isUndefined(data.amount)) ? data.amount : data.likely_case;
                totals = this.getOldTotalFromCollectionById(model.get('id'));
            } else {
                totals = this.oldTotals;
            }

            // process numbers before parent calculateData
            if(_.has(model.changed, 'likely_case') || _.has(model.changed, 'amount')) {
                data.likely_case = (_.isNaN(Number(data.likely_case)) || _.isEqual(data.likely_case, '')) ? 0 : data.likely_case;
                old = data.likely_case;
                diff = app.math.sub(data.likely_case, totals.likely);
                data.likely_case = app.math.add(this.likelyTotal, diff);
                totals.likely = old;
            } else {
                data.likely_case = this.likelyTotal;
            }

            if(_.has(model.changed, 'best_case')) {
                data.best_case = (_.isNaN(Number(data.best_case)) || _.isEqual(data.best_case, '')) ? 0 : data.best_case;
                old = data.best_case;
                diff = app.math.sub(data.best_case, totals.best);
                data.best_case = app.math.add(this.bestTotal, diff);
                totals.best = old;
            } else {
                data.best_case = this.bestTotal;
            }

            if(_.has(model.changed, 'worst_case')) {
                data.worst_case = (_.isNaN(Number(data.worst_case)) || _.isEqual(data.worst_case, '')) ? 0 : data.worst_case;
                old = data.worst_case;
                diff = app.math.sub(data.worst_case, totals.worst);
                data.worst_case = app.math.add(this.worstTotal, diff);
                totals.worst = old;
            } else {
                data.worst_case = this.worstTotal;
            }

            // set oldTotals back
            if(this.currentModule == 'Opportunities') {
                this.setOldTotalFromCollectionById(model.get('id'), totals);
            } else {
                this.oldTotals = totals;
            }

            return this.calculateData(this.mapAllTheThings(data, true));
        }
    },

    /**
     * Checks a model to see if it should be added to closedWonIds
     *
     * @param {Backbone.Model} model
     */
    initClosedWonIds: function(model) {
        var ss = model.get('sales_stage'),
            cs = model.get('commit_stage'),
            id = model.get('id');

        // If this model's sales_stage and commit_stage both are included in Closed Won totals
        // and the id isnt already in closedWonIds
        if(_.contains(this.salesStageWon, ss)
            && _.contains(this.commitStagesInIncludedTotal, cs)
            && !_.contains(this.closedWonIds, id)) {
            this.closedWonIds.push(id);
        }

        // If this model's commit_stage is included in included totals
        // and the id isnt already in includedIds
        if(_.contains(this.commitStagesInIncludedTotal, cs) && !_.contains(this.includedIds, id)) {
            this.includedIds.push(id);
        }
    },

    /**
     * Process model changes when sales_stage is changed
     * @param model
     */
    processSalesStage: function(model) {
        var shouldBeIncluded = false,
            updatedData = false,
            ss = model.get('sales_stage'),
            cs = model.get('commit_stage'),
            id = model.get('id');

        if(_.contains(this.salesStageWon, ss) && _.contains(this.commitStagesInIncludedTotal, cs)) {
            shouldBeIncluded = true;
        }

        // If the ID was already included in the totals, and now should not be
        if(_.contains(this.closedWonIds, id) && !shouldBeIncluded) {
            // remove the model's ID from the array
            this.closedWonIds = _.without(this.closedWonIds, id);

            // remove this model's likely from the closed won amount
            this.serverData.set({closed_amount: app.math.sub(this.serverData.get('closed_amount'), model.get('likely_case'))});

            updatedData = true;
        } else if(!_.contains(this.closedWonIds, id) && shouldBeIncluded) {
            // model needs to be included in closed_amount
            this.closedWonIds.push(id);

            // add likely amount to closed won
            this.serverData.set({closed_amount: app.math.add(this.serverData.get('closed_amount'), model.get('likely_case'))});

            updatedData = true;
        }

        if(updatedData) {
            // update the calculations
            this.calculateData(this.serverData.toJSON());
        }
    },

    /**
     * Processes a model to see if it should be add/subtracted from likely/best/worst totals
     * based on it's commit_stage
     *
     * @param model
     */
    processCommitStage: function(model) {
        var shouldBeIncluded = false,
            updatedData = false,
            cs = model.get('commit_stage'),
            id = model.get('id');

        if(_.contains(this.commitStagesInIncludedTotal, cs)) {
            shouldBeIncluded = true;
        }

        // If the ID was already included in the totals, and now should not be
        if(_.contains(this.includedIds, id) && !shouldBeIncluded) {
            // remove the model's ID from the array
            this.includedIds = _.without(this.includedIds, id);

            // remove amounts from best/likely/worst
            this.serverData.set({
                likely: app.math.sub(this.serverData.get('likely'), model.get('likely_case')),
                best: app.math.sub(this.serverData.get('best'), model.get('best_case')),
                worst: app.math.sub(this.serverData.get('worst'), model.get('worst_case'))
            });

            updatedData = true;
        } else if(!_.contains(this.includedIds, id) && shouldBeIncluded) {
            // model needs to be included in closed_amount
            this.includedIds.push(id);

            // add amounts to best/likely/worst
            this.serverData.set({
                likely: app.math.add(this.serverData.get('likely'), model.get('likely_case')),
                best: app.math.add(this.serverData.get('best'), model.get('best_case')),
                worst: app.math.add(this.serverData.get('worst'), model.get('worst_case'))
            });
            updatedData = true;
        }

        if(updatedData) {
            // update the calculations
            this.calculateData(this.serverData.toJSON());
        }
    },

    /**
     * Given a model that had its closed_date field changed, check to see if we need to
     * fetch a new timeperiod or not by the date changed and which module we're in
     *
     * @param {Backbone.Model} model the changed model
     */
    checkFetchNewTPByDate: function(model) {
        var newDate = model.get('date_closed'),
            shouldFetch = false,
            inTimePeriod = this.isDateInTimePeriod(newDate, this.modelTP.toJSON()),
            options = {},
            inOpps = (this.currentModule == 'Opportunities'),
            modelId = model.get('id');

        if(!inOpps) {
            // RevenueLineItems

            // always fetch for RLIs
            shouldFetch = true;

            if(!inTimePeriod) {
                // since we don't have parent/Opp data available here, whatever TP the new closed date
                // falls in should be fetched and this new total added to it if it isn't already included
                // after fetching, add this model to the server data that comes back
                options.beforeParseData = _.bind(this.addModelTotalsToServerData, this, model);
            }
        } else {
            // Opportunities
            var alreadyInTP = _.contains(this.includedIdsInTP, modelId),
                newTotals;

            // check if date falls outside current timeperiod, if outside of current timeperiod
            // we need to fetch new timeperiod & projected data
            if(inTimePeriod) {
                // check if RLI is being moved into the TP,
                // if it has already been in the TP, dont do anything
                if(!alreadyInTP) {
                    // item has been moved into the TP

                    // add model ID to included ids in timeperiod
                    this.includedIdsInTP.push(modelId);

                    // fetch new TP based on the new date if user changed item's date
                    // to be outside & after the current timeperiod
                    shouldFetch = true;

                    // after fetching, add this model to the server data that comes back
                    options.beforeParseData = _.bind(this.addModelTotalsToServerData, this, model);
                }
            } else {
                // date is not inside the current timeperiod

                // check if the newDate is before or after the current TP
                if (app.date(newDate).isAfter(this.modelTP.get('end_date'))) {
                    // handle if date is after model (Opportunity) timeperiod

                    // fetch new TP based on the new date if user changed item's date
                    // to be outside & after the current timeperiod
                    shouldFetch = true;

                    // after fetching, add this model to the server data that comes back
                    options.beforeParseData = _.bind(this.addModelTotalsToServerData, this, model);
                } else if (app.date(newDate).isBefore(this.modelTP.get('start_date'))) {
                    // handle if date is before model (Opportunity) timeperiod

                    // check if this RLI has already been inside the TP
                    if(alreadyInTP) {
                        // RLI was in the TP, but is being moved out to before the TP

                        // check to see if this is the last RLI in the TP
                        var isLastRLIInTP = (this.includedIdsInTP.length === 1 && this.includedIdsInTP[0] === modelId);

                        if(isLastRLIInTP) {
                            // since this is the last RLI in the timeperiod, when we move this to an
                            // older timeperiod, fetch new TP based on the new date
                            shouldFetch = true;

                            // after fetching, add this model to the server data that comes back
                            options.beforeParseData = _.bind(this.addModelTotalsToServerData, this, model);
                        } else {
                            // item has been moved out of the TP, but other RLIs in the TP are keeping
                            // the dashlet from updating, so subtract the model totals from the current TP totals
                            newTotals = this.removeModelTotalsFromServerData(model, this.serverData.toJSON());
                            this.calculateData(this.mapAllTheThings(newTotals));
                        }
                    } else {
                        // if trying to move the RLI to a timeperiod before the Opportunity timeperiod start date
                        // set the date to the same start date as the Opp so we don't pull an older timeperiod
                        newDate = this.modelTP.get('start_date');

                        // fetch new TP
                        shouldFetch = true;
                    }
                }

                // if this model is already in the timeperiod, remove it
                if(alreadyInTP) {
                    this.includedIdsInTP = _.without(this.includedIdsInTP, modelId);
                }
            }
        }

        // if we should fetch a new timeperiod, make the call
        if(shouldFetch) {
            this.fetchNewTPByDate(newDate, options);
        }
    },

    /**
     * Given a date, this function makes a call to TimePeriods/<date> to get the whole timeperiod bean
     *
     * @param {string} date the date to use to search for the new timeperiod
     * @param {Backbone.Model} [model] param isn't used but is passed when the model changes
     * @param {boolean} [updateModelTP] if we need to update the modelTP or not
     */
    fetchNewTPByDate: function(date, options, updateModelTP) {
        app.api.call('GET', app.api.buildURL('TimePeriods/' + date), null, {
            success: _.bind(function(data) {
                // Make sure the model is here when we get back and this isn't mid-pageload or anything
                if(this.model) {
                    // if we're updating the model timeperiod
                    if(updateModelTP) {
                        // if the Opp model changed, update the model's TP
                        this.modelTP.set(_.clone(data));
                    }

                    this.currentTP = data;
                    this.model.set({selectedTimePeriod: data.id}, {silent: true});
                    this.loadData(options);
                }
            }, this)
        });
    },

    /**
     * Adds the model's likely/best/worst totals to the data totals
     *
     * @param {Backbone.Model} model the model with values to add to server data
     * @param {Object} data values being returned from the server endpoint with totals
     * @return {Object} returns the data Object back with updated totals
     */
    addModelTotalsToServerData: function(model, data) {
        // if these totals haven't already been added into the data from the server
        // occurs when an RLI was previously saved outside of a timeperiod and is being
        // brought back into this timeperiod. If the RLI *did* start in the current TP
        // and has been moved around and is being brought back in, then don't re-add the totals
        if(!_.contains(data.includedIdsInLikelyTotal, model.get('id'))) {
            data.amount = app.math.add(data.amount, model.get('likely_case'));
            data.best_case = app.math.add(data.best_case, model.get('best_case'));
            data.worst_case = app.math.add(data.worst_case, model.get('worst_case'));
        }

        return data;
    },

    /**
     * Removes the model's likely/best/worst totals from the data totals
     *
     * @param {Backbone.Model} model the model with values to remove from server data
     * @param {Object} data values being returned from the server endpoint with totals
     * @return {Object} returns the data Object back with updated totals
     */
    removeModelTotalsFromServerData: function(model, data) {
        data.amount = app.math.sub(data.amount, model.get('likely_case'));
        data.best_case = app.math.sub(data.best_case, model.get('best_case'));
        data.worst_case = app.math.sub(data.worst_case, model.get('worst_case'));

        return data;
    },

    /**
     * Called during initialize to fetch any relevant data
     *
     * @override
     * @param options
     */
    getInitData: function(options) {
        // This needs to be set going into the function. loadData() checks to see if the init data is loaded and
        // makes an async call to load it, causing this function to be called multiple times until something
        // returns and sets initDataLoaded to be false.  Since everything is async, we are safe to set this on function
        // call to indicate that it HAS been called, eliminating extra api calls.
        this.initDataLoaded = true;

        var ctx = this.context.parent || this.context,
            ctxModel = ctx.get('model'),
            date = ctxModel.get('date_closed');

        // set selectedUser id for progress endpoint param
        this.selectedUser.id = ctxModel.get('assigned_user_id');

        // set old totals in case they change
        this.oldTotals = _.extend(this.oldTotals, {
            best: ctxModel.get('best_case'),
            likely: ctxModel.get('likely_case') || ctxModel.get('amount'),
            worst: ctxModel.get('worst_case')
        });

        if(!_.isEmpty(date)) {
            // get the current timeperiod
            app.api.call('GET', app.api.buildURL('TimePeriods/' + date), null, {
                success: _.bind(function(data) {
                    if(this.model) {
                        // update the initial timeperiod
                        this.modelTP.set(_.clone(data));

                        this.currentTP = data;
                        this.model.set({selectedTimePeriod: data.id}, {silent: true});
                        this.loadData();
                    }
                }, this),
                complete: options ? options.complete : null
            });
        } else {
            // this model doesn't have a selectedTimePeriod yet, so use the current date
            var d = new Date(),
                month = (d.getUTCMonth().toString().length == 1) ? '0' + d.getUTCMonth() : d.getUTCMonth(),
                day = (d.getUTCDate().toString().length == 1) ? '0' + d.getUTCDate() : d.getUTCDate()
            date = d.getFullYear() + '-' + month + '-' + day;
            this.fetchNewTPByDate(date);
        }
    },

    /**
     * Checks a given date from the datepicker against the start/end timestamps of the current
     * timeperiod to see if the user selected a date that needs new data
     *
     * @param {string} date the date we're checking to see if it falls inside the timePeriod
     * @param {Object} timePeriod this is the timeperiod Object to check against
     * @return {boolean} true if a new timeperiod should be fetched from server
     */
    isDateInTimePeriod: function(date, timePeriod) {
        var inTimePeriod = false;

        // check if date is between the timePeriod
        if (app.date(date).isBetween(timePeriod.start_date, timePeriod.end_date)) {
            inTimePeriod = true;
        }

        return inTimePeriod;
    }
}) },
"audit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AuditView
 * @alias SUGAR.App.view.views.BaseAuditView
 * @extends View.Views.Base.FilteredListView
 */
({
	// Audit View (base) 

    extendsFrom: 'FilteredListView',

    fallbackFieldTemplate: 'list',

    /**
     * @inheritdoc
     * Assign base module and record id.
     * Override the new Audit collection
     * in order to fetch correct audit end-point.
     */
    initialize: function(options) {
        // in order to render the 'list' template on each field
        this.action = 'list';
        // populating metadata for audit module
        if (options.context.parent) {
            this.baseModule = options.context.parent.get('module');
            this.baseRecord = options.context.parent.get('modelId');
        }
        this._super('initialize', [options]);

       if (!this.collection) {
           this._initCollection();
       }
    },

    /**
     * Override the collection set up by new audit REST end-point.
     * @private
     */
    _initCollection: function() {
        var self = this;
        var AuditCollection = app.BeanCollection.extend({
            module: 'audit',
            baseModule: this.baseModule,
            baseRecordId: this.baseRecord,

            // FIXME PX-46: remove this function
            buildURL: function(params) {
                params = params || {};

                var parts = [],
                    url;
                parts.push(app.api.serverUrl);
                parts.push(this.baseModule);
                parts.push(this.baseRecordId);
                parts.push(this.module);
                url = parts.join('/');
                params = $.param(params);
                if (params.length > 0) {
                    url += '?' + params;
                }
                return url;
            },
            sync: function(method, model, options) {
                var auditedModel = self.context.get('model');
                var url = this.buildURL(options.params);
                var callbacks = app.data.getSyncCallbacks(method, model, options);
                var defaultSuccessCallback = app.data.getSyncSuccessCallback(method, model, options);
                callbacks.success = function(data, request) {
                    self._applyModelDataOnRecords(auditedModel, data.records);
                    return defaultSuccessCallback(data, request);
                };
                app.api.call(method, url, options.attributes, callbacks);
            }
        });
        this.collection = new AuditCollection();
    },

    /**
     * Filter the metadata in order to initiate the searchable fields.
     * @protected
     */
    _initFilter: function() {
        var filter = this._filter || _.chain(this.getFields())
            .filter(function(field) {
                return field.filter;
            })
            .map(function(field) {
                return {
                    name: field.name,
                    label: app.lang.get(field.label, this.module),
                    filter: field.filter,
                    type: field.type
                };
            }, this)
            .value();
        this.context.trigger('filteredlist:filter:set', _.pluck(filter, 'label'));

        if (_.isEmpty(filter)) {
            return;
        }
        this._filter = filter;
    },

    /**
     * Filtering collection that matches with search term.
     * In order to activate filtering on the field,
     * the filter term should be defined in the metadata.
     * There are three types of filter type (startsWith, contains, endsWith).
     */
    filterCollection: function() {
        var term = this.escapeRegExp(this.searchTerm);
        var filter = this._filter;
        var baseFields = this.model.fields;

        if (!_.isEmpty(term) && _.isString(term)) {
            this.filteredCollection = this.collection.filter(function(model) {
                return _.some(filter, function(params) {
                    var pattern = this._patternToReg[params.filter].replace('term', term);
                    var tester = new RegExp(pattern, 'i');
                    var fieldValue = '';
                    if (params.type === 'fieldtype') {
                        fieldValue = app.lang.get(baseFields[model.get(params.name)].vname, this.baseModule);
                    } else {
                        fieldValue = model.get(params.name);
                    }
                    if (_.isArray(fieldValue)) {
                        fieldValue = _.pluck(fieldValue, 'name').join(', ');
                    }
                    return tester.test(fieldValue);
                }, this);
            }, this);
        }
    },

    /**
     * Escape reserved chars of regular expression.
     *
     * @param {string} string Search term.
     */
    escapeRegExp: function(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
    },

    /**
     * Apply erased field information from the model to records.
     *
     * @private
     */
    _applyModelDataOnRecords: function(model, records) {
        var erasedFields = model.get('_erased_fields');
        _.each(erasedFields, function(erasedField) {
            // Apply erased fields only for records that are marked
            var erasedFieldName = erasedField.field_name || erasedField;

            var properties;
            var recordsRequiringErasedFields;
            if (erasedField.field_name) {
                // email and other non-scalar erased fields
                // check both the before and after fields
                // of each record to see if it matches up with
                // an erased email's ID, and if so mark that field as erased
                var fieldsToCheck = ['before', 'after'];
                _.each(fieldsToCheck, function(fieldToCheck) {
                    properties = {field_name: erasedFieldName};
                    properties[fieldToCheck] = erasedField.id;
                    recordsRequiringErasedFields = _.where(records, properties);
                    _.each(recordsRequiringErasedFields, function(record) {
                        record._erased_fields = record._erased_fields || [];
                        record._erased_fields.push(fieldToCheck);
                    });
                });
            } else {
                properties = {field_name: erasedFieldName};
                recordsRequiringErasedFields = _.where(records, properties);
                _.each(recordsRequiringErasedFields, function(record) {
                    record._erased_fields = ['before', 'after'];
                });
            }
        });
    },

    /**
     * @inheritdoc
     * Instead of fetching context, it fetches the collection directly.
     */
    loadData: function() {
        if (this.collection.dataFetched) {
            return;
        }
        this.collection.fetch();
    },

    /**
     * @inheritdoc
     *
     * Patch audit models `before` and `after` fields with information of
     * original field available within parent model, in order to render
     * properly.
     */
    _renderData: function() {
        var parentModule = this.context.parent.get('module');
        var fields = app.metadata.getModule(parentModule).fields;

        _.each(this.collection.models, function(model) {
            model.fields = app.utils.deepCopy(this.metaFields);

            var before = _.findWhere(model.fields, {name: 'before'});
            _.extend(before, fields[model.get('field_name')], {name: 'before'});

            var after = _.findWhere(model.fields, {name: 'after'});
            _.extend(after, fields[model.get('field_name')], {name: 'after'});

            // FIXME: Temporary fix due to time constraints, proper fix will be addressed in TY-359
            // We can check just `before` since `before` and `after` refer to same field
            if (_.contains(['multienum', 'enum'], before['type']) && before['function']) {
                before['type'] = 'base';
                after['type'] = 'base';
            }

            // FIXME: This method should not be used as a public method (though
            // it's being used everywhere in the app) this should be reviewed
            // when SC-3607 gets in
            model.fields = app.metadata._patchFields(
                this.module,
                app.metadata.getModule(this.module),
                model.fields
            );
        }, this);

        this._super('_renderData');
    }
}) },
"quicksearch-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchResultsView
 * @alias SUGAR.App.view.views.BaseQuicksearchResultsView
 * @extends View.View
 */
({
	// Quicksearch-results View (base) 

    events: {
        'click .view-all-results': 'viewAllResultsClicked'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The fields metadata for this view per module.
         *
         * @property
         * @private
         */
        this._fieldsMeta = {};

        /**
         * The collection for executing searches and passing results.
         * This could be shared and used by other components.
         */
        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        this.selectedTags = this.layout.selectedTags || [];

        /**
         * Stores the index of the currently highlighted list element.
         * This is used for keyboard navigation.
         * @{number} {null}
         */
        this.activeIndex = null;

        // Listener for when a search is triggered. Show "Searching..."
        this.layout.on('quicksearch:search:underway', function() {
            this.close();
            this.render();
            this.open();
        }, this);

        // If the layout has `quicksearch:results:close` called on it, we
        // need to hide just the quicksearch results
        this.layout.on('quicksearch:close quicksearch:results:close', function() {
            this.close();
        }, this);

        //Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function(next) {
            if (next) {
                this.activeIndex = 0;
            } else {
                this.activeIndex = this.countRecordElements() - 1;
            }
            this._highlightActive();
            this.attachKeydownEvent();
        }, this);

        //Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.activeIndex = null;
            this.$('.active').removeClass('active');
            this.disposeKeydownEvent();
        }, this);

        app.events.on('app:sync:complete', this._clearFieldsMeta, this);
    },

    /**
     * Clear the cached fields metadata
     * @private
     */
    _clearFieldsMeta: function() {
        this._fieldsMeta = {};
    },

    /**
     * Parses models when collection resets and renders the view.
     *
     * @override
     */
    bindDataChange: function() {
        // On a collection sync, format the search results and display
        this.collection.on('sync', function(collection) {
            if (this.disposed) {
                return;
            }
            var gsUtils = app.utils.GlobalSearch;

            gsUtils.formatRecords(collection, false);

            _.each(this.collection.models, function(model) {
                model.viewAccess = app.acl.hasAccessToModel('view', model);

                // FIXME: SC-4254 Remove this.layout.v2
                if (this.layout.v2) {
                    var moduleMeta = this._fieldsMeta[model.module] || gsUtils.getFieldsMeta(model.module, {linkablePrimary: false});
                    this._fieldsMeta[model.module] = moduleMeta;
                    model.primaryFields = gsUtils.highlightFields(model, moduleMeta.primaryFields);
                    model.secondaryFields = gsUtils.highlightFields(model, {}, true);

                    model.primaryFields = _.values(model.primaryFields);
                    model.secondaryFields = _.values(model.secondaryFields).slice(0, 3);
                } else {
                    if (model.searchInfo.highlighted) {
                        // Get the highlighted fields. If one is the name, highlight the name. Also, highlight the first
                        // non-name field. If there are multiple non-name highlighted fields, we only use the first.
                        _.find(model.searchInfo.highlighted, function(val, key) {
                            if (key === 'name') {
                                model.name = new Handlebars.SafeString(val.text);
                            } else { // found in a related field
                                model.field_name = app.lang.get(val.label, val.module);
                                model.field_value = new Handlebars.SafeString(val.text);
                                return true;
                            }
                        });
                    }
                }
            }, this);

            // build the link for View all results
            this.searchLink = app.utils.GlobalSearch.buildSearchRoute(collection.query, {
                modules: this.collection.selectedModules,
                tags: _.pluck(this.selectedTags, 'name')
            });
            this.activeIndex = null;
            this.render();
            this.open();

            // If the tags view is shown, move this one down
            var shownTags = _.pluck(collection.tags, 'name');
            var selectedTags = _.pluck(this.selectedTags, 'name');
            shownTags = _.difference(shownTags, selectedTags);
            this.$('.typeahead').toggleClass('tagsShown', shownTags.length > 0);
            this.layout.trigger('quicksearch:tag:' + shownTags.length > 0 ? 'open' : 'close');
        }, this);
    },

    /**
     * Show the quickresults dropdown
     */
    open: function() {
        this.$('.typeahead').show();
    },

    /**
     * Hide the quickresults dropdown
     */
    close: function() {
        this.clearActive();
        this.collection.reset();
        this.$('.typeahead').hide();
    },

    /**
     * Clear the active element and dispose key events
     */
    clearActive: function() {
        this.activeIndex = null;
        this.$('.active').removeClass('active');
        this.disposeKeydownEvent();
    },

    /**
     * If we have search results, the view is focusable.
     */
    isFocusable: function() {
        return this.collection.models.length > 0;
    },

    /**
     * Move to the next the active element.
     */
    moveForward: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex < this.countRecordElements() - 1) {
            // We're in bounds, just go to the next element in this view.
            this.activeIndex++;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the next view
            this._handleBoundary(true);

        }
    },

    /**
     * Move to the previous the active element.
     */
    moveBackward: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex > 0) {
            // We're in bounds, just go to the previous element in this view
            this.activeIndex--;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the previous view
            this._handleBoundary(false);
        }
    },

    /**
     * Highlight the active element and unhighlight the rest of the elements.
     */
    _highlightActive: function() {
        this.$('.active').removeClass('active');
        var nthChild = this.activeIndex + 1;
        this.$('li:nth-child(' + nthChild + ')')
            .addClass('active')
            .find('a').focus();
    },

    /**
     * Retrieve the count of record elements. This can be either the number of records or the number of records plus
     * a 'view all results' element.
     * @return {number}
     * @private
     */
    countRecordElements: function() {
        // If there is no next_offset, it means there are no "see more" option that we need to include.
        var hasMore = (this.collection.next_offset > -1) ? 1 : 0;
        return this.collection.models.length + hasMore;
    },

    /**
     * Handle when the user uses their keyboard to try to navigate outside of the view. This handles both the top and
     * bottom boundaries.
     * @param {boolean} next - If true, we are checking the next element. If false, we are checking the previous.
     * @private
     */
    _handleBoundary: function(next) {
        var event = 'navigate:next:component';
        if (!next) {
            event = 'navigate:previous:component';
        }
        if (this.layout.triggerBefore(event)) {
            this.clearActive();
            this.layout.trigger(event);
        }
    },

    /**
     * Attach the keydown events for the view.
     */
    attachKeydownEvent: function() {
        this.$el.on('keydown', _.bind(this.keydownHandler, this));
    },

    /**
     * Dispose the keydown events for the view.
     */
    disposeKeydownEvent: function() {
        this.$el.off();
    },

    /**
     * Handle the keydown events.
     * @param {event} e
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                this.moveForward();
                break;
            case 38: // up arrow
                this.moveBackward();
                break;
            case 9: // tab
                this.close();
                this.trigger('navigate:focus:lost');
        }
    },

    /**
     * click event handler for the view all results link
     * @param e
     */
    viewAllResultsClicked: function(e) {
        this.close();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeydownEvent();
        this._super('unbind');
    }
}) },
"setup-complete-wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Setup Complete wizard page for the FirstLoginWizard.
 *
 * @class View.Views.Base.SetupCompleteWizardPageView
 * @alias SUGAR.App.view.views.BaseSetupCompleteWizardPageView
 * @extends View.Views.Base.WizardPageView
 */
({
	// Setup-complete-wizard-page View (base) 

    extendsFrom: "WizardPageView",
    /**
     * Name of wizard being displayed
     */
    wizardName : "",
    /**
     * Set flag for admin or user wizard so we can render the correct template
     * @override
     * @param options
     */
    initialize: function(options){
        //Extend default events to add listener for click events on links
        //FIXME: events should be data action driven instead of tied to css
        //TY-573 will address this problem
        this.events = _.extend({}, this.events, {
            "click a.thumbnail": "linkClicked",
            "click [name=start_sugar_button]:not(.disabled)": "next"
        });
        this._super("initialize", [options]);
        this.wizardName = this.context.get("wizardName") || "user";
    },
    /**
     * @override
     * @return {boolean}
     */
    isPageComplete: function(){
        return true;
    },
    /**
     * Event handler whenever a link is clicked that makes sure wizard is finished
     * We need to use app router for Sugar app links on complete page.
     * External links should always open onto new pages.
     *
     * @param ev
     */
    //FIXME: Each link should have its own handler. Will be addressed in TY-573
    linkClicked: function(ev){
        var href, redirectUrl,
            target = this.$(ev.currentTarget);
        if(this.$(target).attr("target") !== "_blank") {
            app.user.unset('show_wizard');
            ev.preventDefault();
            //Show the header bar since it is likely hidden
            $("#header").show();
            href = this.$(target).attr("href");
            // Check if bwc link; if so, we need to do bwc.login first
            if (href.indexOf('#bwc/') === 0) {
                redirectUrl = href.split('#bwc/')[1];
                app.bwc.login(redirectUrl);
            } else {
                // Not bwc, so use router navigate instead
                app.router.navigate($(ev.currentTarget).attr("href"), {trigger: true});
            }
        }
    },

    /**
     * @inheritdoc
     *
     * When the setup complete page is disposed, we can update user object since
     * the user setup is complete, to prevent routing to the setup wizard.
     */
    _dispose: function() {
        this._super('_dispose');
        app.user.unset('show_wizard');
    }
}) },
"planned-activities": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @inheritdoc
 *
 * Planned Activities dashlet takes advantage of the tabbed dashlet abstraction
 * by using its metadata driven capabilities to configure its tabs in order to
 * display planned activities of specific modules.
 *
 * Besides the metadata properties inherited from Tabbed dashlet, Planned Activities
 * dashlet also supports other properties:
 *
 * - {Array} invitation_actions field def for the invitation actions buttonset
 *           triggers showing invitation actions buttons and corresponding collection
 *
 * - {Array} overdue_badge field def to support overdue calculation, and showing
 *   an overdue badge when appropriate.
 *
 * @class View.Views.Base.PlannedActivitiesView
 * @alias SUGAR.App.view.views.BasePlannedActivitiesView
 * @extends View.Views.Base.HistoryView
 */
({
	// Planned-activities View (base) 

    extendsFrom: 'HistoryView',

    /**
     * Besides defining new DOM events that will be later bound to methods
     * through {@link #delegateEvents, the events method also makes sure parent
     * classes events are explicitly inherited.
     *
     * @property {Function}
     */
    events: function() {
        var prototype = Object.getPrototypeOf(this);
        var parentEvents = _.result(prototype, 'events');

        return _.extend({}, parentEvents, {
            'click [data-action=date-switcher]': 'dateSwitcher'
        });
    },

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {String} _defaultSettings.date Date against which retrieved
     *   records will be filtered, supported values are 'today' and 'future',
     *   defaults to 'today'.
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        date: 'today',
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     *
     * Store current date state in settings.
     */
    initDashlet: function() {
        this._super('initDashlet');
        if (!this.meta.last_state) {
            this.meta.last_state = {
                id: this.dashModel.get('id') + ':' + this.name,
                defaults: {}
            };
        }
        if (this.meta.config) {
            this.layout.before('dashletconfig:save', function() {
                this._saveSetting('date', this.settings.get('date'));
            }, this);
        } else {
            this.settings.on('change:date', function(model, value) {
                this._saveSetting('date', value);
            }, this);
        }

        this.settings.set('date', this.getDate());
        this.tbodyTag = 'ul[data-action="pagination-body"]';
    },

    /**
     * @inheritdoc
     *
     * Once new records are received, prevent rendering new rows until we fetch
     * the invitation collection by calling {@link #updateInvitation}.
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('planned-activities:close-record:fire', this.heldActivity, this);
        this.on('linked-model:create', this.loadData, this);

        this.before('render:rows', function(data) {
            this.updateInvitation(this.collection, data);
            return false;
        }, this);

        return this;
    },

    /**
     * Update the invitation collection.
     *
     * @param {BeanCollection} collection Active tab's collection.
     * @param {Array} data Added recordset's data.
     */
    updateInvitation: function(collection, data) {
        var tab = this.tabs[this.settings.get('activeTab')];
        if (!data.length || !tab.invitations) {
            return;
        }
        this._fetchInvitationActions(tab, _.pluck(data, 'id'));
    },

    /**
     * Completes the selected activity.
     *
     * Shows a confirmation alert and sets the activity as `Held` on confirm.
     * Also updates the collection and re-renders the dashlet to remove it from
     * the view.
     *
     * @param {Data.Bean} model Call/Meeting model to be marked as `Held`.
     */
    heldActivity: function(model) {
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show('close_activity_confirmation:' + model.get('id'), {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('LBL_PLANNED_ACTIVITIES_DASHLET_CONFIRM_CLOSE'), [context]),
            onConfirm: function() {
                model.save({status: 'Held'}, {
                    showAlerts: true,
                    success: self._getRemoveModelCompleteCallback()
                });
            }
        });
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {Object} params
     * @param {string} params.module Module name.
     * @param {string} params.link Relationship link.
     */
    createRecord: function(event, params) {
        // FIXME: At the moment there are modules marked as bwc enabled though
        // they have sidecar support already, so they're treated as exceptions
        // and drawers are used instead.
        var self = this,
            bwcExceptions = ['Emails'],
            meta = app.metadata.getModule(params.module) || {};

        if (meta.isBwcEnabled && !_.contains(bwcExceptions, params.module)) {
            this._createBwcRecord(params.module, params.link);
            return;
        }

        if (this.module !== 'Home') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }
    },

    /**
     * Create new record.
     *
     * If we're on Homepage an orphan record is created, otherwise, the link
     * parameter is used and the new record is associated with the record
     * currently being viewed.
     *
     * @param {string} module Module name.
     * @param {string} link Relationship link.
     * @protected
     */
    _createBwcRecord: function(module, link) {
        if (this.module !== 'Home') {
            app.bwc.createRelatedRecord(module, this.model, link);
            return;
        }

        var params = {
            return_module: this.module,
            return_id: this.model.id
        };

        var route = app.bwc.buildRoute(module, null, 'EditView', params);

        app.router.navigate(route, {trigger: true});
    },

    /**
     * @inheritdoc
     * @protected
     */
    _initTabs: function() {
        this._super('_initTabs');

        _.each(this.tabs, function(tab) {
            if (!tab.invitation_actions) {
                return;
            }
            tab.invitations = this._createInvitationsCollection(tab);
        }, this);

        return this;
    },

    /**
     * Create invites collection to set the accept status on the given link.
     *
     * @param {Object} tab Tab properties.
     * @return {Data.BeanCollection} A new instance of bean collection.
     * @protected
     */
    _createInvitationsCollection: function(tab) {
        return app.data.createBeanCollection(tab.module, null, {
            link: {
                name: tab.module.toLowerCase(),
                bean: app.data.createBean('Users', {
                    id: app.user.get('id')
                })
            }
        });
    },

    /**
     * @inheritdoc
     */
    _getRecordsTemplate: function(module) {
        this._recordsTpl = this._recordsTpl || {};

        if (!this._recordsTpl[module]) {
            this._recordsTpl[module] = app.template.getView(this.name + '.records', module) ||
                app.template.getView(this.name + '.records', this.module) ||
                app.template.getView(this.name + '.records') ||
                app.template.getView('history.records', this.module) ||
                app.template.getView('history.records') ||
                app.template.getView('tabbed-dashlet.records', this.module) ||
                app.template.getView('tabbed-dashlet.records');
        }

        return this._recordsTpl[module];
    },

    /**
     * @inheritdoc
     */
    _getFilters: function(index) {

        var today = app.date().formatServer(true);
        var tab = this.tabs[index];
        var filter = {};
        var filters = [];
        var defaultFilters = {
                today: {$lte: today},
                future: {$gt: today}
            };

        filter[tab.filter_applied_to] = defaultFilters[this.getDate()];

        filters.push(filter);

        return filters;
    },

    /**
     * @inheritdoc
     */
    tabSwitcher: function(event) {
        var tab = this.tabs[this.settings.get('activeTab')];
        if (tab.invitations) {
            tab.invitations.dataFetched = false;
        }

        this._super('tabSwitcher', [event]);
    },

    /**
     * @inheritdoc
     *
     * Additional logic on switch visibility event.
     */
    visibilitySwitcher: function() {
        var activeVisibility;
        if (!this.isManager) {
            return;
        }
        activeVisibility = this.getVisibility();
        this.$el.find('[data-action=visibility-switcher]')
            .attr('aria-pressed', function() {
                return $(this).val() === activeVisibility;
            });
    },

    /**
     * Event handler for date switcher.
     *
     * @param {Event} event Click event.
     */
    dateSwitcher: function(event) {
        var date = this.$(event.currentTarget).val();
        if (date === this.getDate()) {
            return;
        }

        this.settings.set('date', date);
        this.loadData();
    },

    /**
     * Saves a setting to local storage.
     *
     * @param {string} setting The setting name.
     * @param {string} value The value to save.
     * @private
     */
    _saveSetting: function(setting, value) {
        var key = app.user.lastState.key(setting, this);
        app.user.lastState.set(key, value);
    },

    /**
     * Get current date state.
     * Returns default value if can't find in last state or settings.
     *
     * @return {string} Date state.
     */
    getDate: function() {
        var date = app.user.lastState.get(
            app.user.lastState.key('date', this),
            this
        );
        return date || this.settings.get('date') || this._defaultSettings.date;
    },

    /**
     * @inheritdoc
     *
     * On load of new data, make sure we reload invitations related data, if
     * it is defined for the current tab.
     */
    loadDataForTabs: function(tabs, options) {
        _.each(tabs, function(tab) {
            if (tab.invitations) {
                tab.invitations.dataFetched = false;
            }
        }, this);

        this._super('loadDataForTabs', [tabs, options]);
    },

    /**
     * Fetch the invitation actions collection for
     * showing the invitation actions buttons
     * @param {Object} tab Tab properties.
     * @param {Array|*} addedIds New added record ids.
     * @private
     */
    _fetchInvitationActions: function(tab, addedIds) {
        this.invitationActions = tab.invitation_actions;
        tab.invitations.filterDef = {
            'id': {'$in': addedIds || this.collection.pluck('id')}
        };

        tab.invitations.fetch({
            relate: true,
            success: _.bind(function(collection) {
                if (this.disposed) {
                    return;
                }

                _.each(collection.models, function(invitation) {
                    var model = this.collection.get(invitation.get('id'));
                    model.set('invitation', invitation);
                }, this);

                if (!_.isEmpty(addedIds)) {
                    _.each(addedIds, function(id) {
                        var model = this.collection.get(id);
                        this._renderRow(model);
                        this._renderAvatars();
                    }, this);
                    return;
                }
                this.render();
                this._renderAvatars();
            }, this),
            complete: function() {
                tab.invitations.dataFetched = true;
            }
        });
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     * - {Bean} invitation The invitation bean that relates the data with the
     *   Users' invitation statuses. This is the model supplied to the
     *   `invitation-actions` field.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        if (tab.overdue_badge) {
            this.overdueBadge = tab.overdue_badge;
        }

        if (!this.collection.length || !tab.invitations ||
            tab.invitations.dataFetched) {
            this._super('_renderHtml');
            return;
        }

        this._fetchInvitationActions(tab);
    }
}) },
"vcard-import-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.VcardImportHeaderpaneView
 * @alias SUGAR.App.view.views.BaseVcardImportHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Vcard-import-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click [name=vcard_cancel_button]': 'initiateCancel'
    },

    /**
     * Add listener for toggling the disabled state of the finish button
     *
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.on('vcard:import-finish-button:toggle', this._toggleFinishButton, this);
    },

    /**
     * Toggle the state of the finish button (enabled/disabled)
     *
     * @param {boolean} enabled Whether the button should be enabled
     * @private
     */
    _toggleFinishButton: function(enabled) {
        this.getField('vcard_finish_button').setDisabled(!enabled);
    },

    /**
     * Handle cancel action - closing the drawer
     */
    initiateCancel: function() {
        app.drawer.close();
    }
}) },
"notifications": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Notifications will pull information from the server based on a given delay.
 *
 * Supported properties:
 *
 * - {Number} delay How often (minutes) should the pulling mechanism run.
 * - {Number} limit Limit imposed to the number of records pulled.
 *
 * Example:
 * <pre><code>
 * // ...
 *     array(
 *         'delay' => 5,
 *         'limit' => 4,
 *     ),
 * //...
 * </code></pre>
 *
 * @class View.Views.Base.NotificationsView
 * @alias SUGAR.App.view.views.BaseNotificationsView
 * @extends View.View
 */
({
	// Notifications View (base) 

    plugins: ['Dropdown', 'RelativeTime'],

    /**
     * Notifications bean collection.
     *
     * @property {Data.BeanCollection}
     */
    collection: null,

    /**
     * Collections for additional modules.
     */
    _alertsCollections: {},

    /**
     * @property {number} Interval ID for checking reminders.
     */
    _remindersIntervalId: null,

    /**
     * @property {number} Timestamp of last time when we checked reminders.
     */
    _remindersIntervalStamp: 0,

    /**
     * Interval ID defined when the pulling mechanism is running.
     *
     * @property {Number}
     * @protected
     */
    _intervalId: null,

    /**
     * Default options used when none are supplied through metadata.
     *
     * Supported options:
     * - delay: How often (minutes) should the pulling mechanism run.
     * - limit: Limit imposed to the number of records pulled.
     * - enable_favicon: Enables/disables notifications in favicon, enabled by default.
     *
     * @property {Object}
     * @protected
     */
    _defaultOptions: {
        delay: 5,
        limit: 4,
        enable_favicon: true
    },

    /**
     * The Maximum delay in minutes
     * Max 32bit Integer size is 2147483647 so this delayMax value prevents any
     * user-added custom delay values from overflowing the max size of the variable.
     */
    delayMax: 35791,

    /**
     * The Minimum delay in minutes.
     * Setting to <= 0 results in infinite polling.
     */
    delayMin: 1,

    events: {
        'click [data-action=is-read-handler]': 'isReadHandler'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.module = 'Notifications';

        this._super('initialize', [options]);
        app.events.on('app:sync:complete', this._bootstrap, this);
        app.events.on('app:logout', this.stopPulling, this);
    },

    /**
     * Bootstrap feature requirements.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @protected
     */
    _bootstrap: function() {
        this._initOptions();
        this._initCollection();
        this._initReminders();
        this._initFavicon();

        //Start pulling data after 1 second so that other more important calls to
        //the server can be processed first.
        window.setTimeout(_.bind(this.startPulling, this), 1000);

        this.collection.on('change:is_read', this.render, this);
        return this;
    },

    /**
     * Initialize options, default options are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @protected
     */
    _initOptions: function() {
        var options = _.extend({}, this._defaultOptions, this.meta || {});

        // doing some simple bounds checking to make sure
        // delay is within the values that we're expecting.
        // Delay must be between 1 and 35791 minutes
        if (options.delay > this.delayMax) {
            options.delay = this.delayMax;
        } else if (options.delay < this.delayMin) {
            options.delay = this.delayMin;
        }

        this.delay = options.delay * 60 * 1000;
        this.limit = options.limit;
        this.enableFavicon = options.enable_favicon;

        return this;
    },

    /**
     * Initialize feature collection.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @protected
     */
    _initCollection: function() {
        this.collection = app.data.createBeanCollection(this.module);
        this.collection.options = {
            params: {
                order_by: 'date_entered:desc'
            },
            limit: this.limit,
            myItems: true,
            fields: [
                'date_entered',
                'id',
                'is_read',
                'name',
                'severity'
            ],
            apiOptions: {
                skipMetadataHash: true
            }
        };

        this.collection.filterDef = [{
            is_read: {$equals: false}
        }];

        return this;
    },

    /**
     * Initialize reminders for Calls and Meetings.
     *
     * Setup the reminderMaxTime that is based on maximum reminder time option
     * added to the pulls delay to get a big interval to grab for possible
     * reminders.
     * Setup collections for each module that we support with reminders.
     *
     * FIXME this will be removed when we integrate reminders with
     * Notifications on server side. This is why we have modules hardcoded.
     * We also don't check for meta as optional because it is required.
     * We will keep all this code private because we don't want to support it
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     * @private
     */
    _initReminders: function() {

        var timeOptions = _.keys(app.lang.getAppListStrings('reminder_time_options'));
        var max = _.max(timeOptions, function(key) {
            return parseInt(key, 10);
        });

        this.reminderMaxTime = parseInt(max, 10) + this.delay / 1000;
        this.reminderDelay = 30 * 1000;

        _.each(['Calls', 'Meetings'], function(module) {
            this._alertsCollections[module] = app.data.createBeanCollection(module);
            this._alertsCollections[module].options = {
                limit: this.meta && parseInt(this.meta.remindersLimit, 10) || 100,
                fields: ['date_start', 'id', 'name', 'reminder_time', 'location', 'parent_name']
            };
        }, this);

        return this;
    },

    /**
     * Initializes the favicon using the Favico library.
     *
     * This will listen to the collection reset and update the favicon badge to
     * match the value of the notification element.
     *
     * @private
     */
    _initFavicon: function() {

        if (!this.enableFavicon) {
            return;
        }

        this.favicon = new Favico({animation: 'none'});
        this.collection.on('reset', function() {
            var badge = this.collection.length;
            if (this.collection.next_offset > 0) {
                badge = badge + '+';
            }
            this.favicon.badge(badge);
        }, this);

        this.on('render', function(){
            if (!app.api.isAuthenticated() || app.config.appStatus === 'offline') {
                this.favicon.reset();
            }
        });
    },

    /**
     * Start pulling mechanism, executes an immediate pull request and defines
     * an interval which is responsible for executing pull requests on time
     * based interval.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    startPulling: function() {
        if (!_.isNull(this._intervalId)) {
            return this;
        }
        this._remindersIntervalStamp = new Date().getTime();

        this.pull();
        this._intervalId = window.setTimeout(_.bind(this._pullAction, this), this.delay);
        this._remindersIntervalId = window.setTimeout(_.bind(this.checkReminders, this), this.reminderDelay);
        return this;
    },

    /**
     * Pulling functionality.
     *
     * @protected
     */
    _pullAction: function() {
        if (!app.api.isAuthenticated()) {
            this.stopPulling();
            return;
        }

        this._intervalId = window.setTimeout(_.bind(this._pullAction, this), this.delay);

        this.pull();
    },

    /**
     * Stop pulling mechanism.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    stopPulling: function() {
        if (!_.isNull(this._intervalId)) {
            window.clearTimeout(this._intervalId);
            this._intervalId = null;
        }
        if (!_.isNull(this._remindersIntervalId)) {
            window.clearTimeout(this._remindersIntervalId);
            this._remindersIntervalId = null;
        }
        return this;
    },

    /**
     * Pull notifications and reminders via bulk API. Render notifications
     * if view isn't disposed or dropdown isn't open.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    pull: function() {
        if (this.disposed || this.isOpen()) {
            return this;
        }

        var self = this;
        var bulkApiId = _.uniqueId();

        this.collection.fetch({
            success: function() {
                if (self.disposed || self.isOpen()) {
                    return this;
                }

                self.render();
            },
            apiOptions: {
                bulk: bulkApiId
            }
        });

        this._pullReminders(bulkApiId);

        app.api.triggerBulkCall(bulkApiId);

        return this;
    },

    /**
     * Pull next reminders from now to the next remindersMaxTime.
     *
     * This will give us all the reminders that should be triggered during the
     * next maximum reminders time (with pull delay).
     *
     * @param {string} bulkApiId Bulk ID that the reminders should be a part of
     */
    _pullReminders: function(bulkApiId) {

        if (this.disposed || !_.isFinite(this.reminderMaxTime)) {
            return this;
        }

        var date = new Date();
        var startDate = date.toISOString();
        var endDate;

        date.setTime(date.getTime() + this.reminderMaxTime * 1000);
        endDate = date.toISOString();

        _.each(['Calls', 'Meetings'], function(module) {

            this._alertsCollections[module].filterDef = _.extend({},
                this.meta.remindersFilterDef || {},
                {
                    'date_start': {'$dateBetween': [startDate, endDate]},
                    'users.id': {'$equals': app.user.get('id')}
                }
            );
            this._alertsCollections[module].fetch({
                silent: true,
                merge: true,
                //Notifications should never trigger a metadata refresh
                apiOptions: {
                    skipMetadataHash: true,
                    bulk: bulkApiId
                }
            });
        }, this);

        return this;
    },

    /**
     * Check if there is a reminder we should show in the near future.
     *
     * If the reminder exists we immediately show it.
     *
     * @return {View.Views.BaseNotificationsView} Instance of this view.
     */
    checkReminders: function() {
        if (!app.api.isAuthenticated()) {
            this.stopPulling();
            return this;
        }
        var date = (new Date()).getTime();
        var diff = this.reminderDelay - (date - this._remindersIntervalStamp) % this.reminderDelay;
        this._remindersIntervalId = window.setTimeout(_.bind(this.checkReminders, this), diff);
        _.each(this._alertsCollections, function(collection) {
            _.chain(collection.models)
                .filter(function(model) {
                    var needDate = (new Date(model.get('date_start'))).getTime() -
                        parseInt(model.get('reminder_time'), 10) * 1000;
                    return needDate > this._remindersIntervalStamp && needDate - this._remindersIntervalStamp <= diff;
                }, this)
                .each(this._showReminderAlert, this);
        }, this);
        this._remindersIntervalStamp = date + diff;
        return this;
    },

    /**
     * Show reminder alert based on given model.
     *
     * @param {Backbone.Model} model Model that is triggering a reminder.
     *
     * @private
     */
    _showReminderAlert: function(model) {
        var url = app.router.buildRoute(model.module, model.id);
        var dateFormat = app.user.getPreference('datepref') + ' ' + app.user.getPreference('timepref');
        var dateValue = app.date.format(new Date(model.get('date_start')), dateFormat);
        var template = app.template.getView('notifications.notifications-alert');
        var message = template({
                title: new Handlebars.SafeString(app.lang.get('LBL_REMINDER_TITLE', model.module)),
                module: model.module,
                name: new Handlebars.SafeString(model.get('name')),
                location: new Handlebars.SafeString(model.get('location')),
                description: model.get('description'),
                dateStart: dateValue,
                parentName: new Handlebars.SafeString(model.get('parent_name'))
            });
        _.defer(function() {
            if (confirm(message)) {
                app.router.navigate(url, {trigger: true});
            }
        });
    },

    /**
     * Check if dropdown is open.
     *
     * @return {Boolean} `True` if dropdown is open, `false` otherwise.
     */
    isOpen: function() {
        return this.$('[data-name=notifications-list-button]').hasClass('open');
    },

    /**
     * Event handler for notifications.
     *
     * Whenever the user clicks a notification, its `is_read` property is
     * defined as read.
     *
     * We're doing this instead of a plain save in order to
     * prevent the case where an error could occur before the notification get
     * rendered, thus making it as read when the user didn't actually see it.
     *
     * @param {Event} event Click event.
     */
    isReadHandler: function(event) {
        var element = $(event.currentTarget),
            id = element.data('id'),
            notification = this.collection.get(id),
            isRead = notification.get('is_read');

        if (!isRead) {
            notification.set({is_read: true});
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        if (!app.api.isAuthenticated() ||
            app.config.appStatus === 'offline' ||
            !app.acl.hasAccess('view', this.module)) {
            return;
        }

        this._super('_renderHtml');
    },

    /**
     * @inheritdoc
     *
     * Stops pulling for new notifications and disposes all reminders.
     */
    _dispose: function() {
        this.stopPulling();
        this._alertsCollections = {};

        this._super('_dispose');
    }
}) },
"dashlet-toolbar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletToolbarView
 * @alias SUGAR.App.view.views.BaseDashletToolbarView
 * @extends View.View
 */
({
	// Dashlet-toolbar View (base) 

    className: 'dashlet-header',
    cssIconDefault: 'fa-cog',
    cssIconRefresh: 'fa-refresh fa-spin',
    defaultActions: {
        'dashlet:edit:clicked' : 'editClicked',
        'dashlet:viewReport:clicked': 'viewReportClicked',
        'dashlet:refresh:clicked' : 'refreshClicked',
        'dashlet:delete:clicked' : 'removeClicked',
        'dashlet:toggle:clicked' : 'toggleMinify'
    },
    events: {
        'shown.bs.dropdown': '_toggleAria',
        'hidden.bs.dropdown': '_toggleAria'
    },

    initialize: function(options) {
        _.extend(options.meta, app.metadata.getView(null, 'dashlet-toolbar'), options.meta.toolbar);
        app.view.View.prototype.initialize.call(this, options);
        var model = this.closestComponent('dashboard') ?
            this.closestComponent('dashboard').model : this.model;

        /**
         * A flag to indicate if the dashlet is editable.
         *
         * @type {boolean}
         */
        this.canEdit = app.acl.hasAccessToModel('edit', model) || false;
    },

    /**
     * Change to the spinning icon to indicate that loading process is triggered
     */
    refreshClicked: function() {
        var $el = this.$('[data-action=loading]');
        var self = this;
        var options = {};
        if ($el.length > 0) {
            $el.removeClass(this.cssIconDefault).addClass(this.cssIconRefresh);
            options.complete = function() {
                if (self.disposed) {
                    return;
                }
                $el.removeClass(self.cssIconRefresh).addClass(self.cssIconDefault);
            };
        }
        this.layout.reloadDashlet(options);
    },

    /**
     * Remove a dashlet.
     *
     * @param {Event} evt Mouse event.
     */
    removeClicked: function(evt) {
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_REMOVE_DASHLET_CONFIRM', this.module),
            onConfirm: _.bind(function() {
                this.layout.removeDashlet();
            }, this)
        });
    },

    /**
     * View report.
     *
     * @param {Event} evt Mouse event.
     */
    viewReportClicked: function(evt) {
        this.layout.viewReport();
    },

    editClicked: function(evt) {
        this.layout.editDashlet();
    },
    /**
     * Toggle current dashlet frame when user clicks the toolbar action
     *
     * @param {Event} mouse event.
     */
    toggleClicked: function(evt) {
        var $btn = $(evt.currentTarget);
        var expanded = _.isUndefined($btn.data('expanded')) ? true : $btn.data('expanded');
        var label = expanded ? 'LBL_DASHLET_MAXIMIZE' : 'LBL_DASHLET_MINIMIZE';

        $btn.html(app.lang.get(label, this.module));
        this.layout.collapse(expanded);
        $btn.data('expanded', !expanded);
    },

    /**
     * Toggle current dashlet frame when user clicks chevron icon
     *
     * @param {Window.Event} mouse event.
     */
    toggleMinify: function(evt) {
        var $el = this.$('.dashlet-toggle > i');
        var collapsed = $el.is('.fa-chevron-up');
        this.layout.collapse(collapsed);
        //firing an event to notify dashlet expand / collapse
        this.layout.trigger('dashlet:collapse', collapsed);
    },

    /**
     * Sets a button accessibility class 'aria-expanded' to true or false
     * depending on if the dropdown menu is open or closed.
     *
     * @private
     */
    _toggleAria: function() {
        var $button = this.$('[data-toggle=dropdown]');
        var $group = $button.parent();
        $button.attr('aria-expanded', $group.hasClass('open'));
    }

}) },
"bubblechart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.BubblechartView
 * @alias SUGAR.App.view.views.BaseBubblechartView
 * @extends View.View
 */
({
	// Bubblechart View (base) 

    plugins: ['Dashlet', 'Chart'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // Track if current user is manager
        this.isManager = app.user.get('is_manager');
        this._initPlugins();

        var config = app.metadata.getModule('Forecasts', 'config');
        // What module are we forecasting by?
        this.forecastBy = config && config.forecast_by || 'Opportunities';

        // set the title label in meta the same way the dashlet title is set on render
        options.meta.label = app.lang.get(options.meta.label, this.forecastBy);

        this._super('initialize', [options]);

        var fields = [
            'id',
            'name',
            'account_name',
            'base_rate',
            'currency_id',
            'assigned_user_name',
            'date_closed',
            'probability',
            'account_id',
            'sales_stage',
            'commit_stage'
        ];

        var orderBy = '';
        // Which field holds the likely case value?
        if (this.forecastBy === 'Opportunities') {
            fields.push('amount');
            orderBy = 'amount:desc';
            this.likelyField = 'amount';
        } else {
            fields.push('likely_case');
            orderBy = 'likely_case:desc';
            this.likelyField = 'likely_case';
        }

        this.params = {
            'fields': fields.join(','),
            'max_num': 10,
            'order_by': orderBy
        };

        // get the locale settings for the active user
        // this.locale is stored by reference in the chart model
        this.locale = SUGAR.charts.getUserLocale();
        // create deep copy for tooltip temp use, etc.
        // it will be set to chart.locality() after instantiation
        this.locality = {};

        this.tooltipTemplate = app.template.getView(this.name + '.tooltiptemplate');
    },

    /**
     * @inheritdoc
     */
    initDashlet: function(view) {
        var self = this;

        if (this.settings.get('filter_duration') == 0) {
            this.settings.set({'filter_duration': 'current'}, {'silent': true});
        }

        this.setDateRange();

        if (!this.isManager && this.meta.config) {
            // FIXME: Dashlet's config page is loaded from meta.panels directly.
            // See the "dashletconfiguration-edit.hbs" file.
            this.meta.panels = _.chain(this.meta.panels).filter(function(panel) {
                panel.fields = _.without(panel.fields, _.findWhere(panel.fields, {name: 'visibility'}));
                return panel;
            }).value();
        }

        this.chart = sucrose.charts.bubbleChart()
            .x(function(d) {
                return d3sugar.timeParse('%Y-%m-%d')(d.x);
            })
            .y(function(d) {
                return d.y;
            })
            .margin({top: 0})
            .tooltipContent(_.bind(function(eo, properties) {
                var point = eo.point;
                var value = this.chart.x()(point);
                point.close_date = sucrose.utility.dateFormat(value, this.locality.date, this.locality);
                point.likely = app.currency.formatAmountLocale(point.base_amount, point.currency_id);
                return self.tooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .showTitle(false)
            .tooltips(true)
            .showLegend(true)
            .direction(app.lang.direction)
            .seriesClick(function(data, eo, chart) {
                self.chart.dispatch.call('tooltipHide', this);
                app.router.navigate(app.router.buildRoute(self.forecastBy, eo.point.id), {trigger: true});
            })
            .colorData('class', {step: 2})
            .groupBy(function(d) {
                return (self.isManager && self.getVisibility() === 'user') ?
                    d.sales_stage_short :
                    d.assigned_user_name;
            })
            .filterBy(function(d) {
                return d.probability;
            })
            .strings({
                legend: {
                    close: app.lang.get('LBL_CHART_LEGEND_CLOSE'),
                    open: app.lang.get('LBL_CHART_LEGEND_OPEN')
                },
                noData: app.lang.get('LBL_CHART_NO_DATA'),
                noLabel: app.lang.get('LBL_CHART_NO_LABEL')
            })
            .locality(this.locale);

        // create deep copy for tooltip temp use
        this.locality = sucrose.utility.buildLocality(this.chart.locality(), true);

        this.on('data-changed', function() {
            this.renderChart();
        }, this);
        this.settings.on('change:filter_duration', this.changeFilter, this);

        this.layout.on('render', function() {
            if (!this.disposed && !this.settings.get('config')) {
                this.layout.setTitle(app.lang.get(this.meta.label, this.forecastBy));
            }
        }, this);
    },

    /**
     * Initialize plugins.
     * Only manager can toggle visibility.
     *
     * @return {View.Views.BaseBubbleChart} Instance of this view.
     * @protected
     */
    _initPlugins: function() {
        if (this.isManager) {
            this.plugins = _.union(this.plugins, [
                'ToggleVisibility'
            ]);
        }
        return this;
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        // Clear out the current chart before a re-render
        this.$('svg#' + this.cid).children().remove();

        // Load data into chart model and set reference to chart
        d3sugar.select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.render);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * Override the chartResize method in Chart plugin because
     * bubblechart sucrose model uses render instead of update.
     */
    chartResize: function() {
        this.chart.render();
    },

    /**
     * Filter out records that don't meet date criteria
     * and convert into format convenient for d3
     */
    evaluateResult: function(data) {
        this.total = data.records.length;

        var statusOptions = 'sales_stage_dom',
            fieldMeta = app.metadata.getModule(this.forecastBy, 'fields');

        if (fieldMeta) {
            statusOptions = fieldMeta.sales_stage.options || statusOptions;
        }

        this.chartCollection = {
            data: data.records.map(function(d) {
                var sales_stage = app.lang.getAppListStrings(statusOptions)[d.sales_stage] || d.sales_stage;

                // if probability is null or empty set to 0
                if(_.isNull(d.probability) || d.probability === '') {
                    d.probability = 0;
                }

                // if likely is null or empty set to 0, for customers that do not require likely
                if(_.isNull(d[this.likelyField]) || d[this.likelyField] === '') {
                    d[this.likelyField] = 0;
                }

                return {
                    id: d.id,
                    x: d.date_closed,
                    y: Math.round(parseInt(d[this.likelyField], 10) / parseFloat(d.base_rate)),
                    shape: 'circle',
                    account_name: d.account_name,
                    assigned_user_name: d.assigned_user_name,
                    sales_stage: sales_stage,
                    sales_stage_short: sales_stage,
                    probability: parseInt(d.probability, 10),
                    base_amount: d[this.likelyField],
                    currency_symbol: app.currency.getCurrencySymbol(d.currency_id),
                    currency_id: d.currency_id
                };
            }, this),
            properties: {
                title: app.lang.get('LBL_DASHLET_TOP10_SALES_OPPORTUNITIES_NAME'),
                value: data.records.length,
                xDataType: 'datetime',
                yDataType: 'numeric'
            }
        };
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            _filter = [
                {
                    'date_closed': {
                        '$gte': self.dateRange.begin
                    }
                },
                {
                    'date_closed': {
                        '$lte': self.dateRange.end
                    }
                }
            ];

        if (!this.isManager || this.getVisibility() === 'user') {
            _filter.push({'$owner': ''});
        }

        var _local = _.extend({'filter': _filter}, this.params);
        var url = app.api.buildURL(this.forecastBy, null, null, _local, this.params);

        // Request data from REST endpoint, evaluate result and trigger data change event
        app.api.call('read', url, null, {
            success: function(data) {
                self.evaluateResult(data);
                if (!self.disposed) {
                    self.trigger('data-changed');
                }
            },
            error: _.bind(function() {
                this.displayNoData(true);
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * Calculate date range based on date range dropdown control
     */
    setDateRange: function() {
        var now = new Date(),
            mapping = {
                'current' : 0,
                'next' : 3,
                'year' : 12
            },
            duration = mapping[this.settings.get('filter_duration')],
            startMonth = Math.floor(now.getMonth() / 3) * 3,
            startDate = new Date(now.getFullYear(), (duration === 12 ? 0 : startMonth + duration), 1),
            addYear = 0,
            addMonth = duration === 12 ? 12 : 3,
            endDate;

        // if "Next Quarter" is selected and the current month is Oct/Nov/Dec, add 1 to the year
        if(duration === 3 && now.getMonth() >= 9) {
            addYear = 1;
        }
        endDate = new Date(now.getFullYear() + addYear, startDate.getMonth() + addMonth, 0);

        this.dateRange = {
            'begin': app.date.format(startDate, 'Y-m-d'),
            'end': app.date.format(endDate, 'Y-m-d')
        };
    },

    /**
     * Trigger data load event based when date range dropdown changes
     */
    changeFilter: function() {
        this.setDateRange();
        this.loadData();
    },

    /**
     * @inheritdoc
     *
     * Additional logic on switch visibility event.
     */
    visibilitySwitcher: function() {
        var activeVisibility;
        if (!this.isManager) {
            return;
        }
        activeVisibility = this.getVisibility();
        this.$el.find('[data-action=visibility-switcher]')
            .attr('aria-pressed', function() {
                return $(this).val() === activeVisibility;
            });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.off('data-changed');
        this.settings.off('change:filter_duration');
        this._super('_dispose');
    }
}) },
"list-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ListHeaderpaneView
 * @alias SUGAR.App.view.views.BaseListHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// List-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // FIXME: SC-3594 will address having child views extending metadata
        // from its parent.
        options.meta = _.extend(
            {},
            app.metadata.getView(null, 'list-headerpane'),
            app.metadata.getView(options.module, 'list-headerpane'),
            options.meta
        );

        this._super('initialize', [options]);

        //shortcut keys
        app.shortcuts.register({
            id: 'List:Headerpane:Create',
            keys: 'a',
            component: this,
            description: 'LBL_SHORTCUT_CREATE_RECORD',
            handler: function() {
                var $createButton = this.$('a[name=create_button]');
                if ($createButton.is(':visible') && !$createButton.hasClass('disabled')) {
                    $createButton.get(0).click();
                }
            }
        });
    }
}) },
"sweetspot-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotResultsView
 * @alias SUGAR.App.view.views.BaseSweetspotResultsView
 * @extends View.View
 */
({
	// Sweetspot-results View (base) 

    className: 'sweetspot-results',
    tagName: 'ul',

    events: {
        'click li[data-sweetaction] > a': 'triggerAction',
    },

    /**
     * @inheritdoc
     *
     * - Listens to `sweetspot:results` on the layout to update the results.
     * - Listens to `keydown` on `window` to highlight an item.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * It serves as a helper for the navigation within the results.
         * Includes:
         *
         *  - {@link #actions}
         *  - {@link #keywords}
         *  - {@link #records}
         *
         * @property {Array}
         */
        this.results = [];

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * @property {Array}
         */
        this.records = [];

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * @property {Array}
         */
        this.actions = [];

        /**
         * The list of results returned by Sweet Spot, split by category.
         *
         * @property {Array}
         */
        this.keywords = [];

        /**
         * Partial template for rendering a result row.
         *
         * @property {Function}
         */
        this._resultPartial = app.template.get(this.name + '.result');

        /**
         * Template for rendering the show more link.
         *
         * @property {Function}
         */
        this._showMoreTpl = app.template.get(this.name + '.showmore');

        /**
         * Stores the index of the currently highlighted list element.
         * This is used for keyboard navigation.
         *
         * @property {number}
         */
        this.activeIndex = null;

        // Listens to new set of results and updates the different sections.
        this.layout.on('sweetspot:results', function(results) {
            // We want to highlight the same item that was highlighted before,
            // so first we get the result that was highlighted.
            var oldHighlighted = this.results[this.activeIndex];
            var options = _.pick(results, 'showMore', 'term');

            // Rendering different sections
            this.renderSection('actions', this._formatResults(results.actions));
            this.renderSection('records', this._formatResults(results.records), options);
            this.renderSection('keywords', this._formatResults(results.keywords));

            if (options.showMore) {
                // This is so we get the moveForward/moveBackward working
                // properly.
                this.records.push(options);
            }

            // Update with the new list of records.
            this.results = this.keywords.concat(this.actions).concat(this.records);

            var newActiveIndex;
            if (oldHighlighted) {
                // Try to find the old highlighted result in the new data set.
                _.find(this.results, function(result, index) {
                    var test;
                    if (oldHighlighted.id) {
                        test = oldHighlighted.id === result.id;
                    }
                    if (oldHighlighted.route) {
                        test = oldHighlighted.route === result.route;
                    }
                    if (test) {
                        // Once we found it, we actually want its new index.
                        newActiveIndex = index;
                        return true;
                    }
                });
            }
            // Sets the item that will be highlighted.
            this.activeIndex = newActiveIndex || 0;
            if (this.results.length) {
                this._highlightActive();
                this.layout.trigger('sweetspot:calc:resultsHeight');
            }
        }, this);

        // Listens to when sweet spot is opened to bind keydown event
        this.layout.on('show', function() {
            this.results = this.actions = this.records = this.keywords = [];
            $(window).on('keydown.' + this.cid, _.bind(this.keydownHandler, this));
            this.render();
        }, this);

        // Listens to when sweet spot is opened to unbind keydown event
        this.layout.on('hide', function() {
            $(window).off('keydown.' + this.cid);
        }, this);

        this.layout.on('sweetspot:results:adjustMaxHeight', this.setMaxHeight, this);
    },

    /**
     * Sets the max-height of the element.
     *
     * @param {number} maxHeight The max-height value.
     */
    setMaxHeight: function(maxHeight) {
        if (this.results.length) {
            this.$el.css('maxHeight', maxHeight);
        }
    },

    /**
     * Renders a specific section.
     *
     * - Only if the list of records for that section has changed.
     * - Shows the section if there is at least a record
     * - Hides the section if there are no records.
     *
     * @param {string} section The section name (can be `actions`, `keywords`
     *   or `records`).
     * @param {Array} results The list of results for that section.
     * @param {Object} [options] Custom rendering options per section.
     */
    renderSection: function(section, results, options) {
        options = options || {};
        var allowed = ['actions', 'keywords', 'records'];
        if (!_.contains(allowed, section)) {
            return;
        }
        if (_.isEqual(this[section], results)) {
            return;
        }
        var $section = this.$('[data-section="' + section + '"]');
        var $list = $section.find('ul');
        $list.empty();
        this[section] = results;
        if (results.length === 0) {
            $section.addClass('hide');
            $list.empty();
        } else {
            $section.removeClass('hide');
            _.each(results, function(result) {
                $list.append(this._resultPartial(result));
            }, this);
            if (options.showMore) {
                options.searchRoute = '#search/' + options.term + '?';
                $list.append(this._showMoreTpl(options));
            }
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.activeIndex = 0;
        if (this.results.length) {
            this._highlightActive();
        }
    },

    /**
     * Formatter function for the list of results.
     *
     * @param {Array} results The list of actions/commands.
     * @return {Array} The formatted list of actions/commands.
     */
    _formatResults: function(results) {
        if (_.isEmpty(results)) {
            return [];
        }

        return results;
    },

    /**
     * Handle the keydown events.
     * @param {event} e The `keydown` event.
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 13: // enter
                this.triggerAction();
                break;
            case 40: // down arrow
                this.moveForward();
                e.preventDefault();
                break;
            case 38: // up arrow
                this.moveBackward();
                e.preventDefault();
                break;
        }
    },

    /**
     * Hides the {@link View.Layouts.Base.SweetspotLayout sweet spot layout}.
     */
    triggerHide: function() {
        this.layout.hide();
    },

    /**
     * Triggers the action linked to the active element.
     *
     * Navigates to the view or calls the callback method.
     *
     * @param {Event} [evt] The `click` event.
     */
    triggerAction: function(evt) {
        if (_.isEmpty(this.results)) {
            return;
        }

        this.triggerHide();

        var $action;
        if (evt) {
            evt.preventDefault();
            // When the user clicks on an action, we need to select that action
            // instead of the active one.
            $action = this.$(evt.currentTarget);
        } else {
            $action = this.$('.active > a');
        }

        var route = $action.data('route');
        if (route) {
            var openwindow = $action.data('openwindow');
            if (openwindow) {
                // If the there is an `openwindow` property configured on the action
                // metadata, open this action in a new browser window.
                window.open(route, '_blank');
                return;
            }

            app.router.navigate(route, {trigger: true});
        }

        var callback = $action.data('callback');
        if (callback) {
            this.layout.triggerSystemAction(callback);
        }
    },

    /**
     * Highlight the active element and unhighlight the rest of the elements.
     */
    _highlightActive: function() {
        this.$('.active').removeClass('active');
        var nth = this.activeIndex;
        var $active = this.$('[data-sweetaction=true]:nth(' + nth + ')');
        $active.addClass('active');
        $active.find('a').focus();
        this.$el.prev().find('input').focus();
    },

    /**
     * Moves to the next the active element.
     */
    moveForward: function() {
        // check to make sure we will be in bounds.
        this.activeIndex++;
        if (this.activeIndex < this.results.length) {
            // We're in bounds, just go to the next element in this view.
            this._highlightActive();
        } else {
            this.activeIndex = 0;
            this._highlightActive();
        }
    },

    /**
     * Moves to the previous the active element.
     */
    moveBackward: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex > 0) {
            // We're in bounds, just go to the previous element in this view
            this.activeIndex--;
            this._highlightActive();
        } else {
            this.activeIndex = this.results.length - 1;
            this._highlightActive();
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        $(window).off('keydown.' + this.cid);
        this._super('_dispose');
    }
}) },
"password-expired": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PasswordExpiredView
 * @alias SUGAR.App.view.views.BasePasswordExpiredView
 * @extends View.View
 */
({
	// Password-expired View (base) 

    plugins: ['ErrorDecoration'],
    events: {
        'click [name=save_button]': 'savePassword'
    },
    /**
     * @override
     * @param options
     */
    initialize: function(options){
        var meta = options.meta || {},
            fields = {};
        _.each(_.flatten(_.pluck(meta.panels, "fields")), function(field) {
            fields[field.name] = field;
        });
        this.fieldsToValidate = fields;
        app.view.View.prototype.initialize.call(this, options);
        // Field name in defs doesn't match rendered field name
        // So remove this validation task
        this.model.removeValidationTask('sidecar');
        // This flag allows change-password field to show alerts
        this.model.showPopupAlerts = true;
    },
    /**
     * @override
     * @private
     */
    _render: function() {
        var self = this;
        var message = app.lang.get('LBL_PASSWORD_EXPIRATION_LOGIN');

        //Hack: Gets rid of leftover loading...
        app.alert.dismissAll();
        this.logoUrl = app.metadata.getLogoUrl();

        // Check if we have any password requirements messages and if so
        // push in to our passwordRequirements so hbs displays 'em
        this._showPasswordRequirements = false;
        this.passwordRequirements = [];
        if (app.user && app.user.has('password_requirements')) {
            this._showPasswordRequirements = true;
            var preqs = app.user.get('password_requirements');
            _.each(preqs, function(val, key) {
                self.passwordRequirements.push(val);
            });
        }
        app.view.View.prototype._render.call(this);

        //Render password expired message (after view rendered)
        if (app.user && app.user.has('password_expired_message')) {
            message = app.user.get('password_expired_message');
        }
        this.$('.password-reqs-status').text(message);
        return this;
    },
    savePassword: function() {
        var self = this, callbacks, newPass, oldPass = self.$('[name=current_password]').val();
        app.alert.dismiss('passwords_mismatch');
        self.model.doValidate(this.fieldsToValidate, function(isValid) {
            if (isValid) {
                // A robot has reached into the honey pot. Do not submit (name_field not real)
                if (app.config.honeypot_on && app.config.honeypot_on === true &&
                    (self.$('input[name="name_field"]').val() || self.model.get('name_field'))) return;
                newPass = self.model.get('expired_password_update');//see change-my-password field

                if (newPass) {
                    app.alert.dismiss('changePassword');
                    app.alert.show('passreset', {level: 'process', title: app.lang.get('LBL_CHANGE_PASSWORD'), messages: app.lang.get('LBL_PROCESSING'), autoClose: false});
                    app.api.updatePassword(oldPass, newPass, {
                        success: function(data) {
                            app.alert.dismiss('passreset');
                            app.$contentEl.show();

                            //Password was valid and update successful
                            if (data && data.valid) {
                                callbacks = self.context.get("callbacks");
                                if (callbacks && callbacks.complete) {
                                    callbacks.complete();
                                }
                            } else if (data.message) {
                                //Password was deemed invalid by server. Display provided message
                                app.alert.show('password-invalid', {
                                    level: 'error',
                                    title: data.message
                                });
                            } else {
                                //Server should have provided data.message; use a generic message as fallback
                                app.alert.show('password-invalid', {
                                    level: 'error',
                                    title: app.lang.get('ERR_GENERIC_TITLE') + ': ' +
                                        app.lang.get('ERR_CONTACT_TECH_SUPPORT')
                                });
                            }
                        },
                        error: function(error) {
                            app.alert.dismiss('passreset');
                            app.error.handleHttpError(error, self);
                        }
                    });
                }
            }
        }, self);
    }
}) },
"config-drawer-howto": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConfigDrawerHowtoView
 * @alias SUGAR.App.view.views.BaseConfigDrawerHowtoView
 * @extends View.View
 */
({
	// Config-drawer-howto View (base) 

    howtoData: {},

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.context.on('config:howtoData:change', this.onHowtoDataChange, this);
    },

    /**
     * Handles updating the howto data when it changes
     *
     * @param howtoData
     */
    onHowtoDataChange: function(howtoData) {
        this.howtoData = howtoData;
        this.render();
    }
}) },
"search-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * List view for the {@link View.Layouts.Base.SearchLayout
 * Search layout}.
 *
 * @class View.Views.Base.SearchListView
 * @alias SUGAR.App.view.views.BaseSearchListView
 * @extends View.View
 */
({
	// Search-list View (base) 

    plugins: ['Pagination'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        /**
         * The fields metadata for this view per module.
         *
         * @property
         * @private
         */
        this._fieldsMeta = {};
        this.addPreviewEvents();
    },

    /**
     * Parses models when collection resets and renders the view.
     *
     * @override
     */
    bindDataChange: function() {
        this.collection.on('sync', function(collection) {
            if (this.disposed) {
                return;
            }
            var isCollection = (collection instanceof App.BeanCollection);
            if (!isCollection) {
                return;
            }
            this.parseModels(this.collection.models);
            if (this._previewed) {
                app.events.trigger('preview:close');
            }
            this.render();
        }, this);
    },

    /**
     * Parses models to generate primary fields and secondary fields based on
     * the metadata and data sent by the globalsearch API. This is used to
     * render them properly in the template.
     *
     * @param {Data.Bean[]} models The models to parse.
     */
    parseModels: function(models) {
        var gsUtils = app.utils.GlobalSearch;
        _.each(models, function(model) {
            var moduleMeta = this._fieldsMeta[model.module] || gsUtils.getFieldsMeta(model.module);
            this._fieldsMeta[model.module] = moduleMeta;

            model.primaryFields = gsUtils.highlightFields(model, moduleMeta.primaryFields);
            model.secondaryFields = gsUtils.highlightFields(model, moduleMeta.secondaryFields, true);
            model.viewAccess = app.acl.hasAccessToModel('view', model);

            this._rejectEmptyFields(model, model.secondaryFields);

            model.primaryFields = this._sortHighlights(model.primaryFields);
            model.secondaryFields = this._sortHighlights(model.secondaryFields);

            model.rowactions = moduleMeta.rowactions;
        }, this);
    },

    /**
     * Converts a hash of field names and their definitions into an array of
     * field definitions sorted such as:
     *
     *  - avatar field(s) is(are) first (in theory there should be only one),
     *  - highlighted fields are second,
     *  - non highlighted fields are third.
     *
     * @param {Object} fieldsObject The object to transform.
     * @return {Array} fieldsArray The sorted array of objects.
     * @private
     */
    _sortHighlights: function(fieldsObject) {
        var fieldsArray = _.values(fieldsObject);
        fieldsArray = _.sortBy(fieldsArray, function(field) {
            if (field.type === 'avatar') {
                return 0;
            }
            return field.highlighted ? 1 : 2;
        });
        return fieldsArray;
    },

    /**
     * Removes fields that have an empty value.
     *
     * @param {Data.Bean} model The model.
     * @param {Object} viewDefs The viewDefs of the fields.
     * @private
     */
    _rejectEmptyFields: function(model, viewDefs) {
        _.each(viewDefs, function(field) {
            var fieldValue = model.get(field.name);
            // _.isEmpty() returns true for any number, so checking for _.isNumber() as well
            if (_.isEmpty(fieldValue) && !_.isNumber(fieldValue)) {
                delete viewDefs[field.name];
            }
        });
    },

    /**
     * Adds event listeners related to preview.
     */
    addPreviewEvents: function() {
        this.context.on('list:preview:fire', function(model) {
            app.events.trigger('preview:render', model, this.collection, true);
        }, this);

        //When switching to next/previous record from the preview panel, we need
        //to update the highlighted row.
        app.events.on('list:preview:decorate', this.decorateRow, this);
        if (this.layout) {
            this.layout.on('list:paginate:success', function() {
                //When fetching more records, we need to update the preview
                //collection.
                app.events.trigger('preview:collection:change', this.collection);
                // If we have a model in preview, redecorate the row as previewed
                if (this._previewed) {
                    this.decorateRow(this._previewed);
                }
            }, this);
        }
    },

    /**
     * Decorates the row in the list that is being shown in Preview.
     *
     * @param {Data.Bean} model The model corresponding to the row to be
     *   decorated. Pass a falsy value to clear decoration.
     */
    decorateRow: function(model) {
        this._previewed = model;
        this.$('li.highlighted').removeClass('highlighted current');
        if (model) {
            var curr = this.$('[data-id="' + model.id + '"]');
            curr.addClass('current highlighted');
        }
    },

    /**
     * Add the tags and facets options to the paginate query.
     * Please see the {@link Pagination#getNextPagination} for detail.
     *
     * @return {Object} Pagination fetch options.
     */
    getPaginationOptions: function() {
        var selectedFacets = this.context.get('selectedFacets');
        var tagFilters = _.pluck(this.context.get('tags'), 'id');
        var options = null;
        if (selectedFacets || tagFilters) {
            options = {
                apiOptions: {
                    data: {},
                    fetchWithPost: true,
                    useNewApi: true
                }
            };
        }
        if (selectedFacets) {
            options.apiOptions.data.agg_filters = selectedFacets;
        }
        if (tagFilters) {
            options.apiOptions.data.tag_filters = tagFilters;
        }

        return options;
    }
}) },
"baseedit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View that displays edit view on a model
 * @class View.Views.Base.BaseeditView
 * @alias SUGAR.App.view.views.BaseBaseeditView
 * @extends View.View
 */
({
	// Baseedit View (base) 

    /**
     * Resets the error messages for all fields that have been changed and sent on the models change event.
     * @param {object} model that was changed.
     * @param {object} object that holds the changed fields.
     */
    clearValidationError: function(model, fields) {
        var self = this;
        if(!_.isEmpty(fields.changes)){
            _.each(fields.changes, function (num, key) {
                var field = self.getField(key);

                if (field) {
                    var controlGroup = field.$el.parents('.control-group:first');

                    if (controlGroup) {
                        controlGroup.removeClass("error");
                        controlGroup.find('.add-on').remove();
                        controlGroup.find('.help-block').html("");
                    }
                }
            });
        }
    },

    /**
     * Highlights all fields that fails field validation during save.
     * @param {object} Object containing the fields that failed validation.
     */
    handleValidationError:function (errors) {
        var self = this;

        _.each(errors, function (fieldErrors, fieldName) {
            //retrieve the field by name
            var field = self.getField(fieldName);
            var ftag = this.fieldTag || '';

            if (field) {
                var controlGroup = field.$el.parents('.control-group:first');

                if (controlGroup) {
                    controlGroup.addClass("error");
                    controlGroup.find('.add-on').remove();
                    controlGroup.find('.help-block').html("");

                    if (field.$el.parent().parent().find('.input-append').length > 0) {
                        field.$el.unwrap()
                    }
                    // Add error styling
                    field.$el.wrap('<div class="input-append  '+ftag+'">');

                    _.each(fieldErrors, function (errorContext, errorName) {
                        controlGroup.find('.help-block').append(app.error.getErrorString(errorName, errorContext));
                    });

                    $('<span class="add-on"><i class="fa fa-exclamation-circle"></i></span>').insertBefore(controlGroup.find('.help-block'));
                }
            }
        });
    }
}) },
"user-wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * User Profile wizard page for the FirstLoginWizard.
 *
 * @class View.Views.Base.UserWizardPageView
 * @alias SUGAR.App.view.views.BaseUserWizardPageView
 * @extends View.Views.Base.WizardPageView
 */
({
	// User-wizard-page View (base) 

    extendsFrom: "WizardPageView",

    /**
     * Always show the page at start.
     *
     * @inheritdoc
     */
    showPage: true,

    /**
     * is IDM mode enabled?
     * @var boolean
     */
    isIDMModeEnabled: false,

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        //Load the default wizard page template, if you want to.
        options.template = app.template.getView('wizard-page');
        this._super('initialize', [options]);
        this.fieldsToValidate = this._fieldsToValidate(options.meta);
        this.action = 'edit';
        this.isIDMModeEnabled = App.metadata.getConfig().idmModeEnabled || false;
    },
    /**
     * @override
     * @return {boolean}
     */
    isPageComplete: function(){
        return this.areAllRequiredFieldsNonEmpty;
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.listenTo(this.model, 'sync', this.render);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (!this.model.dataFetched) {
            return this;
        }
        this._super('_render');
    },

    /**
     * @inheritdoc
     */
    _renderField: function(field, $fieldEl) {
        this._super('_renderField', [field, $fieldEl]);
        if (this.isIDMModeEnabled && field.def.idm_mode_disabled) {
            field.setDisabled(true);
        }
    },

    /**
     * Prepares HTTP payload
     * @return {Object} Payload with fields we want to update
     * @protected
     */
    _prepareRequestPayload: function() {
        var payload = {},
            self = this,
            fields = _.keys(this.fieldsToValidate);
        _.each(fields, function(key) {
            payload[key] = self.model.get(key);
        });
        return payload;
    },
    /**
     * Called before we allow user to proceed to next wizard page. Does the validation and profile update.
     * @param {Function} callback The callback to call once HTTP request is completed.
     * @override
     */
    beforeNext: function(callback) {
        var self = this;
        this.getField("next_button").setDisabled(true); // temporarily disable
        this.model.doValidate(this.fieldsToValidate,
            _.bind(function(isValid) {
                var self = this;
                if (isValid) {
                    var payload = self._prepareRequestPayload();
                    app.alert.show('wizardprofile', {level: 'process', title: app.lang.get('LBL_LOADING'), autoClose: false});
                    app.user.updateProfile(payload, function(err) {
                        app.alert.dismiss('wizardprofile');
                        self.updateButtons(); //re-enable buttons
                        if (err) {
                            app.logger.debug("Wizard profile update failed: " + err);
                            callback(false);
                        } else {
                            callback(true);
                        }
                    });
                } else {
                    callback(false);
                }
            }, self)
        );
    }

}) },
"base": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The Base View that all Views should extend from before extending
 * {@link #View.View}.
 *
 * Use this controller to specify your customizations for the Base platform.
 * This should contain any special override that only applies to Base platform
 * and not to Sidecar's library.
 *
 * Any View in a module can skip the default fallback and extend this one
 * directly. In your `BaseModuleMyView` component that lives in the file
 * `modules/<module>/clients/base/views/my-view/my-view.js`, you can
 * directly extend the `BaseView` skipping the normal extend flow which will
 * extend automatically from `BaseMyView` that might live in
 * `clients/base/views/my-view/my-view.js`. Simply define your controller
 * with:
 *
 * ```
 * ({
	// Base View (base) 

 *     extendsFrom: 'BaseView',
 *     // ...
 * })
 * ```
 *
 * This controller exists to force the component to be created and not fallback
 * to the default flow (which happens when the component isn't found).
 *
 * @class View.Views.Base.BaseView
 * @alias SUGAR.App.view.views.BaseBaseView
 * @extends View.View
 */
({
    /**
     * The Base View will always clear any tooltips after `render`.
     */
    initialize: function() {
        this._super('initialize', arguments);
        if (app.tooltip) {
            this.on('render', app.tooltip.clear);
        }
    }
}) },
"masslink-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MasslinkProgressView
 * @alias SUGAR.App.view.views.BaseMasslinkProgressView
 * @extends View.Views.Base.MassupdateProgressView
 */
({
	// Masslink-progress View (base) 

    extendsFrom: 'MassupdateProgressView',

    /**
     * Set of labels.
     */
    _labelSet: {
        'update': {
            PROGRESS_STATUS: 'TPL_MASSLINK_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSLINK_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSLINK_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSLINK_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSLINK_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSLINK_SUCCESS',
            TITLE: 'TPL_MASSLINK_TITLE'
        }
    }

}) },
"resolve-conflicts-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ResolveConflictsHeaderpaneView
 * @alias SUGAR.App.view.views.BaseResolveConflictsHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Resolve-conflicts-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * Register event handlers for the buttons and set the title.
     * @param options
     */
    initialize: function(options) {
        this.events = _.extend({}, this.events, {
            'click [name=select_button]': 'selectClicked',
            'click [name=cancel_button]': 'cancelClicked'
        });

        this._super('initialize', [options]);

        this.context.on("change:selection_model", this.enableSelectButton, this);
    },

    /**
     * @inheritdoc
     */
    _formatTitle: function(title) {
        var modelToSave = this.context.get('modelToSave'),
            name = modelToSave.get('name') || modelToSave.get('full_name');

        return app.lang.get(title, this.module, {name: name});
    },

    /**
     * Perform action according to whether the client's or database's data was selected.
     * @param event
     */
    selectClicked: function(event) {
        var selected = this.context.get('selection_model'),
            modelToSave = this.context.get('modelToSave'),
            dataInDb = this.context.get('dataInDb'),
            origin;

        if (selected instanceof Backbone.Model) {
            origin = selected.get('_dataOrigin');
            if (origin === 'client') {
                modelToSave.set('date_modified', dataInDb.date_modified);
                app.drawer.close(modelToSave, false);
            } else if (origin === 'database') {
                modelToSave.set(dataInDb);
                // trigger sync so that synced attributes are reset
                modelToSave.trigger('sync');
                app.drawer.close(modelToSave, true);
            }
        }
    },

    /**
     * Enable select button when a row has been selected.
     * @param context
     * @param selected
     */
    enableSelectButton: function(context, selected) {
        if (selected) {
            this.$('[name=select_button]').removeClass('disabled');
        }
    },

    /**
     * Close the drawer when cancel is clicked.
     * @param event
     */
    cancelClicked: function(event) {
        app.drawer.close();
    }
}) },
"shortcuts-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Configure keyboard shortcuts.
 *
 * @class View.Views.Base.ShortcutsConfigView
 * @alias SUGAR.App.view.views.BaseShortcutsConfigView
 * @extends View.View
 */
({
	// Shortcuts-config View (base) 

    /**
     * Handle button actions from the headerpane.
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.on('button:cancel_button:click', function() {
            app.drawer.close();
        }, this);
        this.context.on('button:save_button:click', this.saveShortcuts, this);
        this.context.on('button:restore_button:click', this.removeCustomizations, this);
    },

    /**
     * Render global and contextual shortcut keys.
     * @inheritdoc
     */
    _renderHtml: function(ctx, options) {
        var shortcutSession = this.context.get('shortcutSession');

        if (shortcutSession) {
            this.shortcuts = shortcutSession.getRegisteredShortcuts();
        }

        this.global = app.shortcuts.getRegisteredGlobalShortcuts();

        this._super('_renderHtml', [ctx, options]);
    },

    /**
     * Save custom shortcut keys to user preferences.
     */
    saveShortcuts: function() {
        var self = this,
            shortcutsToSave = [],
            findShortcut = function(shortcuts, id) {
                return _.find(shortcuts, function(shortcut) {
                    return (shortcut.id === id);
                });
            };

        this.$('[data-id]').each(function() {
            var $row = $(this),
                id = $row.data('id'),
                keys = $row.find('input').val().trim().split(','),
                shortcut = findShortcut(self.shortcuts, id);

            _.each(keys, function (key, index){
                keys[index] = $.trim(key);
            });

            if (shortcut && !_.isEqual(shortcut.keys, keys)) {
                shortcutsToSave.push({
                    id: id,
                    keys: keys
                });
            }
        });

        app.shortcuts.saveCustomShortcutKey(shortcutsToSave, this._savePreferencesCallback);
    },

    /**
     * Clear custom shortcut keys in user preferences.
     */
    removeCustomizations: function() {
        var customShortcutsToDelete = [];

        this.$('[data-id]').each(function() {
            customShortcutsToDelete.push($(this).data('id'));
        });

        app.shortcuts.removeCustomShortcutKeys(customShortcutsToDelete, this._savePreferencesCallback);
    },

    /**
     * Close drawer once custom shortcut keys are saved.
     * @param {Object} error Error data from the server.
     * @private
     */
    _savePreferencesCallback: function(error) {
        var refreshHelp;

        if (error) {
            app.alert.show('preference-save-error', {
                level: 'error',
                messages: 'LBL_SHORTCUT_CONFIG_ERROR'
            });
        } else {
            refreshHelp = true;
        }

        app.drawer.close(refreshHelp);
    }
}) },
"inactive-tasks": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Inactive tasks dashlet takes advantage of the tabbed dashlet abstraction by
 * using its metadata driven capabilities to configure its tabs in order to
 * display information about tasks module.
 *
 * @class View.Views.Base.InactiveTasksView
 * @alias SUGAR.App.view.views.BaseInactiveTasksView
 * @extends View.Views.BaseTabbedDashletView
 */
({
	// Inactive-tasks View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);
        this.tbodyTag = 'ul[data-action="pagination-body"]';

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('linked-model:create', this.loadData, this);
        return this;
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {Object} params
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    createRecord: function(event, params) {
        if (this.module !== 'Home') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            var self = this;
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }
    },

    /**
     * New model related properties are injected into each model.
     * Update the picture url's property for model's assigned user.
     *
     * @param {Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var pictureUrl = app.api.buildFileURL({
            module: 'Users',
            id: model.get('assigned_user_id'),
            field: 'picture'
        });
        model.set('picture_url', pictureUrl);
        this._super('bindCollectionAdd', [model]);
    }
}) },
"user-locale-wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * User Locale wizard page for the FirstLoginWizard.
 *
 * @class View.Views.Base.UserLocaleWizardPageView
 * @alias SUGAR.App.view.views.BaseUserLocaleWizardPageView
 * @extends View.Views.Base.UserWizardPageView
 */
({
	// User-locale-wizard-page View (base) 

    extendsFrom: "UserWizardPageView",
    TIME_ZONE_KEY: 'timezone',
    TIME_PREF_KEY: 'timepref',
    DATE_PREF_KEY: 'datepref',
    NAME_FORMAT_KEY: 'default_locale_name_format',

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        var self = this;
        options.template = app.template.getView('wizard-page');
        this._super('initialize', [options]);
        // Preset the user prefs for formats
        if (this.model) {
            this.model.set(this.TIME_ZONE_KEY, (app.user.getPreference(this.TIME_ZONE_KEY) || ''));
            this.model.set(this.TIME_PREF_KEY, (app.user.getPreference(this.TIME_PREF_KEY) || ''));
            this.model.set(this.DATE_PREF_KEY, (app.user.getPreference(this.DATE_PREF_KEY) || ''));
            this.model.set(this.NAME_FORMAT_KEY, (app.user.getPreference(this.NAME_FORMAT_KEY) || ''));
        }
        this.action = 'edit';
    },

    _render: function(){
        var self = this;
        // Prepare the metadata so we can prefetch select2 locale options
        this._prepareFields(function() {
            if (!self.disposed) {
                self.fieldsToValidate = self._fieldsToValidate(self.meta);
                self._super("_render");
            }
        });
    },
    _prepareFields: function(callback) {
        var self = this;
        // Fixme this doesn't belong in user. See TY-526.
        app.user.loadLocale(function(localeOptions) {
            // Populate each field def of type enum with returned locale options and use user's pref as displayed
            _.each(self.meta.panels[0].fields, function(fieldDef) {
                var opts = localeOptions[fieldDef.name];
                if (opts) {
                    fieldDef.options = opts;
                }
            });
            callback();
        });
    },
    /**
     * Called before we allow user to proceed to next wizard page. Does the validation and locale update.
     * @param {Function} callback The callback to call once HTTP request is completed.
     * @override
     */
    beforeNext: function(callback) {
        this.getField("next_button").setDisabled(true);  //temporarily disable
        this.model.doValidate(this.fieldsToValidate,
            _.bind(function(isValid) {
                var self = this;
                if (isValid) {
                    var payload = this._prepareRequestPayload();
                    app.alert.show('wizardlocale', {
                        level: 'process',
                        title: app.lang.get('LBL_LOADING'),
                        autoClose: false
                    });
                    // 'ut' is, historically, a special flag in user's preferences that is
                    // generally marked truthy upon timezone getting saved. It's also used
                    // to semantically represent "is the user's instance configured"
                    payload['ut'] = true;
                    app.user.updatePreferences(payload, function(err) {
                        app.alert.dismiss('wizardlocale');
                        self.updateButtons();  //re-enable buttons
                        if (err) {
                            app.logger.debug("Wizard locale update failed: " + err);
                            callback(false);
                        } else {
                            callback(true);
                        }
                    });
                } else {
                    callback(false);
                }
            }, this)
        );
    }

}) },
"preview-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PreviewHeaderView
 * @alias SUGAR.App.view.views.BasePreviewHeaderView
 * @extends View.View
 */
({
	// Preview-header View (base) 

    className: 'preview-headerbar',

    events: {
        'click [data-direction]': 'triggerPagination',
        'click .closeSubdetail': 'triggerClose'
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        this.checkACL(this.model);

        this._delegateEvents();
    },

    /**
     * Set up event listeners
     *
     * @private
     */
    _delegateEvents: function() {
        if (this.layout) {
            this.layout.on('preview:pagination:update', this.render, this);
        }

        if (this.layout.previewEdit) {
            _.extend(this.events, {'click [data-action=edit]': 'triggerEdit'});
            this.layout.on('preview:edit:complete', this.toggleSaveAndCancel, this);
        }
    },

    triggerPagination: function(e) {
        var direction = this.$(e.currentTarget).data();
        this.layout.trigger('preview:pagination:fire', direction);
    },

    triggerClose: function() {
        app.events.trigger('list:preview:decorate', null, this);
        app.events.trigger('preview:close');
    },

    /**
     * Call preview view to turn on editing
     */
    triggerEdit: function() {
        this.toggleSaveAndCancel(true);
        this.layout.trigger('preview:edit');
    },

    /**
     * Toggle save, cancel, left, right and x buttons
     *
     * @param {boolean} edit `true` to show save and cancel and hide
     * left, right and X icons
     */
    toggleSaveAndCancel: function(edit) {
        if (edit) {
            this.getField('save_button').show();
            this.getField('cancel_button').show();
            this.$('[data-direction], [data-action=close]').hide();
        } else {
            this.getField('save_button').hide();
            this.getField('cancel_button').hide();
            this.$('[data-direction], [data-action=close]').show();
        }
    },

    /**
     * @inheritdoc
     *
     * @override Overriding to hide preview save/cancel buttons initially
     * @private
     */
    _renderFields: function() {
        this._super('_renderFields');

        if (this.layout.previewEdit) {
            this.getField('save_button').hide();
            this.getField('cancel_button').hide();
        }
    },

    /**
     *  @inheritdoc
     *
     *  @override Overiding render
     */
    _render: function() {
        this.layout.on('previewheader:ACLCheck', this.checkACL, this)
        this._super('_render');
    },

    /**
     * Check if the user has permission to edit the current record
     *
     * @param model Model for preview
     */
    checkACL: function(model) {
        if (app.config.previewEdit && this.layout.meta.editable === true &&
            app.acl.hasAccessToModel('edit', model)) {
            this.layout.previewEdit = true;
        } else {
            this.layout.previewEdit = false;
        }
    }
}) },
"profileactions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ProfileactionsView
 * @alias SUGAR.App.view.views.BaseProfileactionsView
 * @extends View.View
 */
({
	// Profileactions View (base) 

    plugins: ['Dropdown'],

    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        app.events.on("app:sync:complete", this.render, this);
        app.events.on("bwc:avatar:removed", this.bwcAvatarRemoved, this);
        app.user.on("change:picture", this.setCurrentUserData, this);
    },

    /**
     * Render profile actions dropdown menu
     * @private
     */
    _renderHtml: function() {
        // FIXME check why the router is not loaded before all the other components are rendered
        if (!app.router || !app.api.isAuthenticated() || app.config.appStatus === 'offline') {
            return;
        }

        if (!_.isEmpty(this.meta)) {
            this.menulist = this.filterAvailableMenu(app.utils.deepCopy(this.meta));
        }
        this._super('_renderHtml');
    },

    /**
     * Filters menu metadata
     * @param Array menuMeta
     * @return {Array}
     */
    filterAvailableMenu: function(menuMeta){
        var result = [];
        _.each(menuMeta,function(item) {
            item = this.filterMenuProperties(item);
            if (!_.isEmpty(item.acl_module) &&
                !app.acl.hasAccess(item.acl_action, item.acl_module)) {
                return;
            }

            // if current user is neither a developer nor allowed to access admin actions,
            // but the action is reserved for admin, skip this action
            if (!app.acl.hasAccessToAny('developer') &&
                !app.acl.hasAccess('admin', 'Administration') &&
                item.acl_action === 'admin') {
                return;
            }

            result.push(item);
        },this);
        return result;
    },

    /**
     * Filters single menu data
     * @param Array menu data
     * @return {Array}
     */
    filterMenuProperties:function(singleItem){
        if(singleItem['label'] === 'LBL_PROFILE'){
            singleItem['img_url'] = this.pictureUrl;
        }
        return singleItem;
    },
    //TODO: Remove once bwc is completely pruned out of the product
    bwcProfileEntered: function() {
        //Refetch latest user data (since bwc updated avatar); reset
        var self = this;
        app.user.load(function() {
            self.setCurrentUserData();
        });
    },
    //This will get called when avatar is removed from bwc User profile edit (SP-1949)
    //TODO: Remove once bwc is completely pruned out of the product
    bwcAvatarRemoved: function() {
        app.user.set("picture", '');//so `this.pictureUrl` is falsy and default avatar kicks in on .hbs template
        this.setCurrentUserData();
    },
    /**
     * Sets the current user's information like full name, user name, avatar, etc.
     * @protected
     */
    setCurrentUserData: function() {
        this.fullName = app.user.get("full_name");
        this.userName = app.user.get("user_name");
        this.userId = app.user.get('id');
        var picture = app.user.get("picture");

        this.pictureUrl = picture ? app.api.buildFileURL({
            module: "Users",
            id: this.userId,
            field: "picture"
        }, {
            cleanCache: true
        }) : '';

        this.render();
    },
    _dispose: function() {
        if (app.user) app.user.off(null, null, this);
        app.view.View.prototype._dispose.call(this);
    }
}) },
"history": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * History dashlet takes advantage of the tabbed dashlet abstraction by using
 * its metadata driven capabilities to configure its tabs in order to display
 * historic information about specific modules.
 *
 * @class View.Views.Base.HistoryView
 * @alias SUGAR.App.view.views.BaseHistoryView
 * @extends View.Views.Base.TabbedDashletView
 */
({
	// History View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {Number} _defaultSettings.filter Number of past days against
     *   which retrieved records will be filtered, supported values are '7',
     *   '30' and '90' days, defaults to '7'.
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        filter: 7,
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this._super('initialize', [options]);
        this.tbodyTag = 'ul[data-action="pagination-body"]';
    },

    /**
     * Retrieves custom filters.
     *
     * @param {number} index Tab index.
     * @return {Array} Custom filters.
     * @protected
     */
    _getFilters: function(index) {
        var filterStr = app.date().subtract(this.settings.get('filter'), 'days').formatServer(true);

        var tab = this.tabs[index],
            filter = {},
            filters = [];

        filter[tab.filter_applied_to] = {$gte: filterStr};

        filters.push(filter);

        return filters;
    },

    /**
     * New model related properties are injected into each model.
     * Update the picture url's property for model's assigned user.
     *
     * @param {Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var pictureUrl = app.api.buildFileURL({
            module: 'Users',
            id: model.get('assigned_user_id'),
            field: 'picture'
        });
        model.set('picture_url', pictureUrl);
        this._super('bindCollectionAdd', [model]);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.$('.select2').select2('destroy');

        this._super("_dispose");
    },

    /**
     * Open up a drawer to archive email.
     * @param event
     * @param params
     */
    archiveEmail: function(event, params) {
        var metadata = app.metadata.getModule(this.model.module) || {};
        var fields = metadata.fields || {};
        var modelCanBeRecipient = _.some(fields, function(field) {
            return field.type === 'email';
        });
        var data = {
            related: this.model
        };

        if (modelCanBeRecipient) {
            // Don't set email_address_id. It will be set when the email is
            // archived.
            data.to = app.data.createBean('EmailParticipants', {
                _link: 'to',
                parent: _.extend({type: this.model.module}, app.utils.deepCopy(this.model)),
                parent_type: this.model.module,
                parent_id: this.model.get('id'),
                parent_name: app.utils.getRecordName(this.model)
            });
        }

        app.utils.openEmailCreateDrawer('create', data, _.bind(function(model) {
            var links;

            if (model) {
                this.layout.reloadDashlet();
                links = app.utils.getLinksBetweenModules(this.context.parent.get('module'), 'Emails');

                _.each(links, function(link) {
                    this.context.parent.trigger('panel-top:refresh', link.name);
                }, this);
            }
        }, this));
    }
}) },
"dashlet-cell-empty": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletCellEmptyView
 * @alias SUGAR.App.view.views.BaseDashletCellEmptyView
 * @extends View.View
 */
({
	// Dashlet-cell-empty View (base) 

    events: {
        'click .dashlet.empty' : 'addClicked'
    },
    originalTemplate: null,
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        //use the dashboard model rather than the current page's
        this.model = this.layout.context.get("model");

        this.model.on("setMode", this.setMode, this);
        this.originalTemplate = this.template;
        this.setMode(this.model.mode);
    },
    addClicked: function(evt) {
        var self = this;
        app.drawer.open({
            layout: 'dashletselect',
            context: this.layout.context
        }, function(model) {
            if(!model) return;
            var conf = model.toJSON(),
                dash = {
                    context: {
                        module: model.get("module"),
                        link: model.get("link")
                    }
                },
                type = conf.componentType;
            delete conf.config;
            delete conf.componentType;
            if(_.isEmpty(dash.context.module) && _.isEmpty(dash.context.link)) {
                delete dash.context;
            }
            dash[type] = conf;
            self.layout.addDashlet(dash);
        });
    },
    setMode: function(type) {
        if(type === 'edit') {
            this.template = this.originalTemplate;
        } else if(type === 'drag') {
            this.template = app.template.getView(this.name + '.drop') || this.originalTemplate;
        } else {
            this.template = app.template.getView(this.name + '.empty') || app.template.empty;
        }
        this.render();
    },
    _dispose: function() {
        this.model.off("setMode", null, this);
        app.view.View.prototype._dispose.call(this);
    }
}) },
"shortcuts-help": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Render help page for keyboard shortcuts.
 *
 * @class View.Views.Base.ShortcutsHelpView
 * @alias SUGAR.App.view.views.BaseShortcutsHelpView
 * @extends View.View
 */
({
	// Shortcuts-help View (base) 

    shortcutsHelpTableTemplate: '',
    modRegExp: new RegExp('mod'),
    macRegExp: new RegExp('Mac|iPod|iPhone|iPad'),
    hasCommandKey: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // refresh shortcuts help page
        this.context.on('shortcuts:help:render', function() {
            this.render();
        }, this);

        // get templates
        this.shortcutsHelpTableTemplate = app.template.getView(this.name + '.shortcuts-help-table');

        // test to see if user uses MacOS.
        this.hasCommandKey = this.macRegExp.test(this.getCurrentPlatform());
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function(ctx, options) {
        this._super('_renderHtml', [ctx, options]);

        // populate help tables
        this.$('[data-render=global]').append(this.buildGlobalHelpTable().children());
        this.$('[data-render=contextual]').append(this.buildContextualHelpTable().children());
    },

    /**
     * Build the help table for global shortcuts.
     * @returns {jQuery}
     */
    buildGlobalHelpTable: function() {
        var $html = $('<div/>'),
            globalShortcuts = app.shortcuts.getRegisteredGlobalShortcuts(),
            help = this.prepareShorcutsHelpDataForDisplay(globalShortcuts);

        $html.append(this.shortcutsHelpTableTemplate(help));

        return $html;
    },

    /**
     * Build the help table for contextual shortcuts.
     * @returns {jQuery}
     */
    buildContextualHelpTable: function() {
        var $html = $('<div/>'),
            lastShortcutSession = app.shortcuts.getLastSavedSession(),
            contextualShortcuts,
            help;

        if (lastShortcutSession) {
            contextualShortcuts = lastShortcutSession.getRegisteredShortcuts();
            if (contextualShortcuts) {
                help = this.prepareShorcutsHelpDataForDisplay(contextualShortcuts);
                $html.append(this.shortcutsHelpTableTemplate(help));
            }
        }

        return $html;
    },

    /**
     * Take the available shortcuts data and transform it for displaying the data
     * in a help table.
     * @param {Array} shortcuts
     * @returns {Array}
     */
    prepareShorcutsHelpDataForDisplay: function(shortcuts) {
        var help = [];

        _.each(shortcuts, function(shortcut) {
            help.push({
                keys: this.getKeyString(shortcut.keys),
                help: app.lang.get(shortcut.description, this.module)
            });
        }, this);

        return help;
    },

    /**
     * Build text for keys needed to perform shortcut action.
     * @param {Array} keys
     * @return {string}
     */
    getKeyString: function(keys) {
        var formattedKeys = _.map(keys, function(key) {
            return key.replace(this.modRegExp, this.hasCommandKey ? 'command' : 'ctrl');
        }, this);

        return formattedKeys.join(', ');
    },

    /**
     * Get the user's current platform.
     * @return {string}
     */
    getCurrentPlatform: function() {
        return navigator.platform;
    }
}) },
"dashletconfiguration-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletconfigurationHeaderpaneView
 * @alias SUGAR.App.view.views.BaseDashletconfigurationHeaderpaneView
 * @extends View.View
 */
({
	// Dashletconfiguration-headerpane View (base) 

    plugins: ['Editable', 'ErrorDecoration'],

    events: {
        "click a[name=cancel_button]": "close",
        "click a[name=save_button]":   "save"
    },

    /**
     * Store the translated i18n label.
     * @type {String} Translated dashlet's title label.
     * @private
     */
    _translatedLabel: null,

    /**
     * @inheritdoc
     * Binds the listener for the before `save` event.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.before('save', function(model) {
            return this.layout.triggerBefore('dashletconfig:save', model);
        }, this);

        //shortcut keys
        app.shortcuts.register({
            id: 'Dashlet:Config:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.click();
                }
            }
        });
        app.shortcuts.register({
            id: 'Dashlet:Config:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=save_button]');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.click();
                }
            }
        });
    },

    /**
     * @inheritdoc
     * Compare with the previous attributes and translated dashlet's label
     * in order to warn unsaved changes.
     *
     * @return {Boolean} true if the dashlet setting contains changes.
     */
    hasUnsavedChanges: function() {
        var previousAttributes = _.extend(this.model.previousAttributes(), {
            label: this._translatedLabel
        });
        return !_.isEmpty(this.model.changedAttributes(previousAttributes));
    },

    /**
     * Triggers a `save` event before `app.drawer.close()` is called, in case
     * any processing needs to be done on the model before it is saved.
     *
     * @return {Boolean} `false` if the `dashletconfig:save` event returns false.
     */
    save: function() {
        if (this.triggerBefore('save', this.model) === false) {
            return false;
        }

        var fields = {};
        _.each(this.meta.panels[0].fields, function(field) {
            fields[field.name] = field;
        });

        this.model.doValidate(fields, _.bind(function(isValid) {
            if (isValid) {
                app.drawer.close(this.model);
            }
        }, this));
    },

    close: function() {
        app.drawer.close();
    },

    /**
     * @inheritdoc
     *
     * Translate model label before render using model attributes.
     */
    _renderHtml: function() {
        var label;
        this.model = this.context.get('model');
        label = app.lang.get(
            this.model.get('label'),
            this.model.get('module') || this.module,
            this.model.attributes
        );
        this._translatedLabel = label;
        this.model.set('label', label, {silent: true});
        app.view.View.prototype._renderHtml.call(this);
    }
}) },
"massaddtolist-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassaddtolistProgressiew
 * @alias SUGAR.App.view.views.BaseMassaddtolistProgressView
 * @extends View.Views.Base.MassupdateProgressView
 */
({
	// Massaddtolist-progress View (base) 

    extendsFrom: 'MassupdateProgressView',

    /**
     * Set of labels.
     *
     * @property
     */
    _labelSet: {
        'update': {
            PROGRESS_STATUS: 'TPL_MASSADDTOLIST_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSADDTOLIST_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSADDTOLIST_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSADDTOLIST_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSADDTOLIST_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSADDTOLIST_SUCCESS',
            TITLE: 'TPL_MASSADDTOLIST_TITLE'
        }
    }

}) },
"resolve-conflicts-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ResolveConflictsListView
 * @alias SUGAR.App.view.views.BaseResolveConflictsListView
 * @extends View.Views.Base.FlexListView
 */
({
	// Resolve-conflicts-list View (base) 

    extendsFrom: 'FlexListView',
    plugins: ['ListColumnEllipsis', 'ListRemoveLinks'],

    initialize: function (options) {
        // set as single select list
        options.meta = options.meta || {};
        options.meta.selection = {type: 'single', label: 'LBL_LINK_SELECT'};

        //FIXME: This will be moved out as part of SC-5449.
        options.meta.template = 'flex-list';

        this._super('initialize', [options]);

        // do not fetch on initial load
        this.context._fetchCalled = true;

        this._buildList();
    },

    /**
     * Do not build default list columns.
     */
    parseFields: function () {},

    /**
     * Populate the list with data from the client and the server.
     * @private
     */
    _buildList: function() {
        var dataInDb = this.context.get('dataInDb'),
            modelToSave = this.context.get('modelToSave'),
            modelInDb, copyOfModelToSave, originalId;

        if (!_.isEmpty(dataInDb) && !_.isEmpty(modelToSave)) {
            modelInDb = app.data.createBean(modelToSave.module, dataInDb);
            copyOfModelToSave = app.data.createBean(modelToSave.module);
            originalId = modelToSave.get('id');

            //cannot use bean.copy() because we need date_modified
            copyOfModelToSave.set(app.utils.deepCopy(modelToSave.attributes));

            this._buildFieldDefinitions(copyOfModelToSave, modelInDb);

            // set IDs to be different so that backbone collection can recognize that they're not the same
            copyOfModelToSave.set('id', originalId + '-client');
            modelInDb.set('id', originalId + '-database');

            // indicate which model is from the client and the server
            copyOfModelToSave.set('_dataOrigin', 'client');
            modelInDb.set('_dataOrigin', 'database');

            // set the person who modified the data
            copyOfModelToSave.set('_modified_by', app.lang.get('LBL_YOU'));
            modelInDb.set('_modified_by', modelInDb.get('modified_by_name'));

            this._populateMissingDataFromDatabase(copyOfModelToSave, modelInDb);
            this.collection.add([copyOfModelToSave, modelInDb]);
        }
    },

    /**
     * Build columns to be displayed to the user.
     * @param {Bean} modelToSave
     * @param {Bean} modelInDb
     * @private
     */
    _buildFieldDefinitions: function(modelToSave, modelInDb) {
        var fieldsThatDiffer,
            fieldDefinition,
            modifiedByColumnDef = {
                name: '_modified_by',
                type: 'base',
                label: 'LBL_MODIFIED',
                sortable: false
            };

        // determine which fields have different values
        fieldsThatDiffer = app.utils.compareBeans(modelToSave, modelInDb);

        // remove modified_by_name if exists
        fieldsThatDiffer = _.filter(fieldsThatDiffer, function(name) {
            return name !== 'modified_by_name';
        });

        // get field view definitions
        fieldDefinition = this._getFieldViewDefinition(fieldsThatDiffer);

        // insert modified by column
        fieldDefinition = _.union([modifiedByColumnDef], fieldDefinition);

        this._fields = this._createCatalog(fieldDefinition);
    },

    /**
     * @inheritdoc
     */
    _patchField: function(fieldMeta, i) {
        var isVisible = (fieldMeta.name !== 'date_modified');
        return _.extend({
            sortable: false,
            selected: isVisible,
            position: ++i
        }, fieldMeta, {
            sortable: false
        });
    },

    /**
     * Get field view definition from the record view, given field names.
     * @param fieldNames
     * @return {Array}
     * @private
     */
    _getFieldViewDefinition: function(fieldNames) {
        var fieldDefs = [],
            moduleViewDefs = app.metadata.getView(this.module, 'record'),
            addFieldDefinition = function(definition) {
                if (definition.name && (_.indexOf(fieldNames, definition.name) !== -1)) {
                    fieldDefs.push(app.utils.deepCopy(definition));
                }
            };

        _.each(moduleViewDefs.panels, function(panel) {
            _.each(panel.fields, function(field) {
                if (field.fields && _.isArray(field.fields)) {
                    // iterate through fieldsets to get the field view definition
                    _.each(field.fields, function(field) {
                        addFieldDefinition(field);
                    });
                } else {
                    addFieldDefinition(field);
                }
            });
        });

        return fieldDefs;
    },

    /**
     * Populate missing values on the client's bean from the database data.
     * @param {Bean} modelToSave
     * @param {Bean} modelInDb
     * @private
     */
    _populateMissingDataFromDatabase: function(modelToSave, modelInDb) {
        _.each(modelInDb.attributes, function(value, attribute) {
            if (!modelToSave.has(attribute) || !app.utils.hasDefaultValueChanged(attribute, modelToSave)) {
                modelToSave.set(attribute, value);
            }
        })
    },

    /**
     * Trigger preview event when the preview is clicked. Preview needs to render without activity
     * stream and pagination.
     */
    addPreviewEvents: function () {
        this._super("addPreviewEvents");

        this.context.off('list:preview:fire', null, this);
        this.context.on('list:preview:fire', function (model) {
            app.events.trigger('preview:render', model, this.collection, false, model.id, false);
            app.events.trigger('preview:pagination:hide');
        }, this);
    },

    /**
     * Add Preview button on the actions column on the right.
     */
    addActions: function() {
        this._super("addActions");

        this.rightColumns.push({
            type: 'rowaction',
            css_class: 'btn',
            tooltip: 'LBL_PREVIEW',
            event: 'list:preview:fire',
            icon: 'fa-eye'
        });
    }
}) },
"active-tasks": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Active tasks dashlet takes advantage of the tabbed dashlet abstraction by
 * using its metadata driven capabilities to configure its tabs in order to
 * display information about tasks module.
 *
 * Besides the metadata properties inherited from Tabbed dashlet, Active tasks
 * dashlet also supports other properties:
 *
 * - {Array} overdue_badge field def to support overdue calculation, and showing
 *   an overdue badge when appropriate.
 *
 * @class View.Views.Base.ActiveTasksView
 * @alias SUGAR.App.view.views.BaseActiveTasksView
 * @extends View.Views.Base.TabbedDashletView
 */
({
	// Active-tasks View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);

        this.tbodyTag = 'ul[data-action="pagination-body"]';

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('active-tasks:close-task:fire', this.closeTask, this);
        this.on('linked-model:create', this.loadData, this);
        this.on('render:rows', this._renderAvatars, this);
        return this;
    },

    /**
     * Completes the selected task.
     *
     * Shows a confirmation alert and sets the task as `Completed` on confirm.
     *
     * @param {Data.Bean} model The task to be marked as completed.
     */
    closeTask: function(model){
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show('complete_task_confirmation:' + model.get('id'), {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('LBL_ACTIVE_TASKS_DASHLET_CONFIRM_CLOSE'), [context]),
            onConfirm: function() {
                model.save({status: 'Completed'}, {
                    showAlerts: true,
                    success: self._getRemoveModelCompleteCallback()
                });
            }
        });
    },

    /**
     * @inheritdoc
     *
     * FIXME: This should be removed when metadata supports date operators to
     * allow one to define relative dates for date filters.
     */
    _initTabs: function() {
        this._super("_initTabs");

        // FIXME: since there's no way to do this metadata driven (at the
        // moment) and for the sake of simplicity only filters with 'date_due'
        // value 'today' are replaced by today's date
        var today = new Date();
        today.setHours(23, 59, 59);
        today.toISOString();

        _.each(_.pluck(_.pluck(this.tabs, 'filters'), 'date_due'), function(filter) {
            _.each(filter, function(value, operator) {
                if (value === 'today') {
                    filter[operator] = today;
                }
            });
        });
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {Object} params
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    createRecord: function(event, params) {
        if (this.module !== 'Home') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            var self = this;
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }

    },

    /**
     * New model related properties are injected into each model.
     * Update the picture url's property for model's assigned user.
     *
     * @param {Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var pictureUrl = app.api.buildFileURL({
            module: 'Users',
            id: model.get('assigned_user_id'),
            field: 'picture'
        });
        model.set('picture_url', pictureUrl);
        this._super('bindCollectionAdd', [model]);
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        if (tab.overdue_badge) {
            this.overdueBadge = tab.overdue_badge;
        }

        this._super('_renderHtml');

        this._renderAvatars();
    }
}) },
"panel-top-readonly": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Header section for Subpanel layouts.
 *
 * @class View.Views.Base.PanelTopReadonlyView
 * @alias SUGAR.App.view.views.BasePanelTopReadonlyView
 * @extends View.PanelTopView
 */
({
	// Panel-top-readonly View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'PanelTopView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
    }
}) },
"selection-list-context": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 *
 * This view displays the selected records at the top of a selection list. It
 * also allows to unselect them.
 *
 * @class View.Views.Base.SelectionListContextView
 * @alias SUGAR.App.view.views.BaseSelectionListContextView
 * @extends View.View
 */

({
	// Selection-list-context View (base) 

    className: 'selection-context',
    events: {
        'click [data-close-pill]': 'handleClosePillEvent',
        'click .reset_button': 'removeAllPills'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.pills = [];
        /**
         * The maximum number of pills that can be displayed.
         *
         * @property {number}
         */
        this.maxPillsDisplayed = 50;
        this._super('initialize', [options]);
     },

    /**
     * Adds a pill in the template.
     *
     * @param {Data.Bean|Object|Array} models The model, set of model attributes
     * or array of those corresponding to the pills to add.
     */
    addPill: function(models) {

        models = _.isArray(models) ? models : [models];

        if (_.isEmpty(models)) {
            return;
        }

        var pillsAttrs = [];
        var pillsIds = _.pluck(this.pills, 'id');

        _.each(models, function(model) {
            //FIXME : SC-4196 will remove this.
            var modelName = model.get('name') || model.get('full_name') ||
                app.utils.formatNameLocale(model.attributes) ||
                model.get('document_name');

            if (modelName && !_.contains(pillsIds, model.id)) {
                pillsAttrs.push({id: model.id, name: modelName});
            }
        });

        this.pills.push.apply(this.pills, pillsAttrs);

        this._debounceRender();
    },

    /**
     * Removes a pill from the template.
     *
     * @param {Data.Bean|Object|Array} models The model or array of models
     * corresponding to the pills to remove. It can also be an object or array
     * of objects containing the 'id' of the pills to remove.
     *
     */
    removePill: function(models) {
        models = _.isArray(models) ? models : [models];
        var ids = _.pluck(models, 'id');
        this.pills = _.reject(this.pills, function(pill) {
            return _.contains(ids, pill.id);
        });
        this._debounceRender();
    },

    /**
     * Removes all the pills and sends an event to clear the mass collection.
     *
     * @param {Event} The click event.
     */
    removeAllPills: function(event) {
        if (event) {
            if (this.$(event.target).hasClass('disabled')) {
                return;
            }
        }
        this.pills = [];
        this.render();
        this.context.trigger('mass_collection:clear');
    },

    /**
     * Resets the pills to match the mass collection. Useful to update pills
     * on mass collection reset.
     *
     * @param {Data.BeanCollection} collection The collection that has been reset.
     */
    resetPills: function(collection) {
        if (!collection.length) {
            this.pills = [];
        }
        this.render();
    },

    /**
     * Click handler for the `close` button on a pill.
     *
     * @param {Event} event The click event.
     */
    handleClosePillEvent: function(event) {
        var id = this.$(event.target).closest('.select2-search-choice').data('id').toString();
        this.closePill(id);
    },

    /**
     * Removes the pill and triggers an event to remove it the model from the
     * mass collection.
     *
     * @param {string} modelId The id of the model to remove.
     */
    closePill: function(modelId) {
        this.removePill({id: modelId});
        var model = this.massCollection.get(modelId);
        this.context.trigger('mass_collection:remove', model);
    },

    /**
     * Debounced version of render.
     *
     * @private
     */
    _debounceRender: _.debounce(function() {
        this.render();
    }, 50),

    /**
     * @inheritdoc
     */
    _render: function() {
        this.massCollection = this.context.get('mass_collection');
        if (!this.massCollection) {
            return;
        }

        if (this.pills.length > this.maxPillsDisplayed) {
            this.displayedPills = this.pills.slice(0, this.maxPillsDisplayed);
            this.tooManySelectedRecords = true;
            this.msgMaxPillsDisplayed = app.lang.get('TPL_MAX_PILLS_DISPLAYED', this.module, {
                maxPillsDisplayed: this.maxPillsDisplayed
            });
        } else {
            this.tooManySelectedRecords = false;
            this.displayedPills = this.pills;
        }

        var recordsLeft = this.massCollection.length - this.displayedPills.length;
        if (recordsLeft) {
            this.moreRecords = true;
            var label = this.displayedPills.length ? 'TPL_MORE_RECORDS' : 'TPL_RECORDS_SELECTED';
            this.msgMoreRecords = app.lang.get(label, this.module, {
                recordsLeft: recordsLeft
            });
        } else {
            this.moreRecords = false;
        }

        this._super('_render');
        this.stopListening(this.massCollection);

        this.listenTo(this.massCollection, 'add', this.addPill);
        this.listenTo(this.massCollection, 'remove', this.removePill);
        this.listenTo(this.massCollection, 'reset', this.resetPills);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('sync', function() {

            var recordsToAdd = this.collection.filter(_.bind(function(model) {
                return this.massCollection.get(model.id);
            }, this));

            this.addPill(recordsToAdd);

        }, this);
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.stopListening(this.massCollection);
        this._super('unbind');
    }
}) },
"rssfeed": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * RSS Feed dashlet consumes an RSS Feed URL and displays it's content as a list
 * of entries.
 * 
 * The following items are configurable.
 *
 * - {number} limit Limit imposed to the number of records pulled.
 * - {number} refresh How often (minutes) should refresh the data collection.
 *
 * @class View.Views.Base.RssfeedView
 * @alias SUGAR.App.view.views.BaseRssfeedView
 * @extends View.View
 */
({
	// Rssfeed View (base) 

    plugins: ['Dashlet'],

    /**
     * Default options used when none are supplied through metadata.
     *
     * Supported options:
     * - timer: How often (minutes) should refresh the data collection.
     * - limit: Limit imposed to the number of records pulled.
     *
     * @property {Object}
     * @protected
     */
    _defaultOptions: {
        limit: 5,
        auto_refresh: 0
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        this._super('initialize', [options]);
        this.loadData(options.meta);
    },

    /**
     * Init dashlet settings
     */
    initDashlet: function() {
        // We only need to handle this if we are NOT in the configure screen
        if (!this.meta.config) {
            var options = {};
            var self = this;
            var refreshRate;

            // Get and set values for limits and refresh
            options.limit = this.settings.get('limit') || this._defaultOptions.limit;
            this.settings.set('limit', options.limit);

            options.auto_refresh = this.settings.get('auto_refresh') || this._defaultOptions.auto_refresh;
            this.settings.set('auto_refresh', options.auto_refresh);

            // There is no default for this so there's no pointing in setting from it
            options.feed_url = this.settings.get('feed_url');

            // Set the refresh rate for setInterval so it can be checked ahead
            // of time. 60000 is 1000 miliseconds times 60 seconds in a minute.
            refreshRate = options.auto_refresh * 60000;

            // Only set up the interval handler if there is a refreshRate higher
            // than 0
            if (refreshRate > 0) {
                if (this.timerId) {
                    clearInterval(this.timerId);
                }
                this.timerId = setInterval(_.bind(function() {
                    if (self.context) {
                        self.context.resetLoadFlag();
                        self.loadData(options);
                    }
                }, this), refreshRate);
            }
        }

        // Validation handling for individual fields on the config
        this.layout.before('dashletconfig:save', function() {
            // Fields on the metadata
            var fields = _.flatten(_.pluck(this.meta.panels, 'fields'));

            // Grab all non-valid fields from the model
            var notValid = _.filter(fields, function(field) {
                return field.required && !this.dashModel.get(field.name);
            }, this);

            // If there no invalid fields we are good to go
            if (notValid.length === 0) {
                return true;
            }

            // Otherwise handle notification of invalidation
            _.each(notValid, function(field) {
                 var fieldOnView = _.find(this.fields, function(comp, cid) { 
                    return comp.name === field.name;
                 });

                 fieldOnView.model.trigger('error:validation:' + field.name, {required: true});
            }, this);

            // False return tells the drawer that it shouldn't close
            return false;
        }, this);
    },

    /**
     * Handles the response of the feed consumption request and sets data from 
     * the result
     * 
     * @param {Object} data Response from the rssfeed API call
     */
    handleFeed: function (data) {
        if (this.disposed) {
            return;
        }

        // Load up the template
        _.extend(this, data);
        this.render();
    },

    /**
     * Loads an RSS feed from the RSS Feed endpoint.
     * 
     * @param {Object} options The metadata that drives this request
     */
    loadData: function(options) {
        if (options && options.feed_url) {
            var callbacks = {success: _.bind(this.handleFeed, this), error: _.bind(this.handleFeed, this)},
                limit = options.limit || this._defaultOptions.limit,
                params = {feed_url: options.feed_url, limit: limit},
                apiUrl = app.api.buildURL('rssfeed', 'read', '', params);

            app.api.call('read', apiUrl, {}, callbacks);
        }
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        this._super('_renderHtml');
    }
}) },
"access-denied": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AccessDeniedView
 * @alias SUGAR.App.view.views.BaseAccessDeniedView
 * @extends View.View
 */
({
	// Access-denied View (base) 

    className: 'error-page',

    cubeOptions: {spin: false},

    events: {
        'click .sugar-cube': 'spinCube'
    },

    spinCube: function() {
        this.cubeOptions.spin = !this.cubeOptions.spin;
        this.render();
    }
}) },
"dupecheck-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListView
 * @alias SUGAR.App.view.views.BaseDupecheckListMenuView
 * @extends View.Views.Base.FlexListView
 */
({
	// Dupecheck-list View (base) 

    extendsFrom: 'FlexListView',
    plugins: ['ListColumnEllipsis', 'ListDisableSort', 'ListRemoveLinks', 'Pagination'],
    collectionSync: null,
    additionalTableClasses: null,

    /**
     * @inheritdoc
     *
     * The metadata used is the default `dupecheck-list` metadata, extended by
     * the module specific `dupecheck-list` metadata, extended by subviews
     * metadata.
     */
    initialize: function(options) {
        var dupeListMeta = app.metadata.getView(null, 'dupecheck-list') || {},
            moduleMeta = app.metadata.getView(options.module, 'dupecheck-list') || {};

        options.meta = _.extend({}, dupeListMeta, moduleMeta, options.meta || {});

        this._super('initialize', [options]);
        this.context.on('dupecheck:fetch:fire', this.fetchDuplicates, this);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('reset', function() {
            this.context.trigger('dupecheck:collection:reset');
        }, this);
        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        var classesToAdd = 'duplicates highlight';
        this._super('_renderHtml');
        if (this.additionalTableClasses) {
            classesToAdd = classesToAdd + ' ' + this.additionalTableClasses;
        }
        this.$('table.table-striped').addClass(classesToAdd);
    },

    /**
     * Fetch the duplicate collection.
     *
     * @param {Backbone.Model} model Duplicate check model.
     * @param {Object} options Fetch options.
     */
    fetchDuplicates: function(model, options) {
        this.collection.dupeCheckModel = model;
        this.collection.fetch(options);
    }
}) },
"history-summary": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryView
 * @alias SUGAR.App.view.views.BaseHistorySummaryView
 * @extends View.Views.Base.FlexListView
 */
({
	// History-summary View (base) 

    extendsFrom: 'FlexListView',

    /**
     * Array of module names to fetch history
     */
    activityModules: [],

    /**
     * An array of default activity modules to fetch
     */
    allActivityModules: [
        'Calls',
        'Emails',
        'Meetings',
        'Notes',
        'Tasks'
    ],

    /**
     * Module name of the record we're coming from
     */
    baseModule: '',

    /**
     * Record ID of the record we're coming from
     */
    baseRecord: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['ReorderableColumns', 'ResizableColumns', 'ListColumnEllipsis']);

        if (options.context.parent) {
            this.baseModule = options.context.parent.get('module');
            this.baseRecord = options.context.parent.get('modelId');
        }

        this.setActivityModulesToFetch();

        var HistoryCollection = app.MixedBeanCollection.extend({
            module: 'history',
            activityModules: this.activityModules,
            buildURL: _.bind(function(params) {
                params = params || {};

                var url = app.api.serverUrl + '/'
                    + this.baseModule + '/'
                    + this.baseRecord + '/'
                    + 'link/history';

                params.module_list = this.activityModules.join(',');
                params = $.param(params);
                if (params.length > 0) {
                    url += '?' + params;
                }
                return url;
            }, this),
            sync: function(method, model, options) {
                options = app.data.parseOptionsForSync(method, model, options);
                if (options.params.fields) {
                    delete options.params.fields;
                }
                var url = this.buildURL(options.params),
                    callbacks = app.data.getSyncCallbacks(method, model, options);

                app.api.call(method, url, options.attributes, callbacks);
            }
        });

        options.collection = new HistoryCollection();

        this._super('initialize', [options]);

        //override the flex-list template
        this.template = app.template.getView(this.meta.template);

        this.context.set({
            collection: this.collection
        });

        $('html').addClass('print-drawer');
    },

    /**
     * @override
     *
     * This view doesn't use the regular {@link Utils.Utils#isSortable} to check
     * whether the field is sortable.
     */
    _initOrderBy: function() {
        var lastStateOrderBy = app.user.lastState.get(this.orderByLastStateKey) || {},
            lastOrderedFieldMeta = this.getFieldMeta(lastStateOrderBy.field);

        if (_.isEmpty(lastOrderedFieldMeta) || !lastOrderedFieldMeta.isSortable) {
            lastStateOrderBy = {};
        }

        return _.extend({
                field: '',
                direction: 'desc'
            },
            this.meta.orderBy,
            lastStateOrderBy
        );
    },

    /**
     * Sets the activityModules array which the collection sends to the endpoint
     * Override this function in child views to set a custom list of modules to fetch
     */
    setActivityModulesToFetch: function() {
        this.activityModules = this.allActivityModules;
    },

    /***
     * @inheritdoc
     *
     * Sets the field properly depending on the field name
     */
    _renderField: function(field) {
        var fieldName = field.name,
            fieldModule = field.model.get('_module'),
            fieldType = field.def.type || 'default';

        // check the fieldName and set the proper values
        if (fieldName === 'name') {
            // set the model's module to be the field's model's module
            // for the name link to be the proper ID
            field.model.module = fieldModule;
        } else if (fieldName === 'module') {
            field.model.set({
                module: field.model.get('moduleNameSingular')
            });
        } else if (fieldName === 'related_contact') {
            var contact,
                contactId;
            field.model.module = 'Contacts';
            switch (fieldModule) {
                case 'Emails':
                    // Emails does not have a related Contact/ID
                    contact = '';
                    contactId = '';
                    break;

                case 'Notes':
                case 'Calls':
                case 'Meetings':
                case 'Tasks':
                    contact = field.model.get('contact_name');
                    contactId = field.model.get('contact_id');
                    break;
            }
            field.model.set({
                related_contact: contact,
                related_contact_id: contactId
            });
        } else if (fieldName === 'status' && fieldModule === 'Emails') {
            // if this is the Status field and an Emails row,
            // translate the email status
            var fieldStatus = field.model.get('status'),
                emailStatusDom = app.lang.getAppListStrings('dom_email_status');

            // If this field is rendering again (like after "More history..." has been clicked)
            // it's 'status' will have already been run through the dom object
            if(!_.contains(emailStatusDom, fieldStatus)) {
                // if it hasn't already been translated, do it, do it now!
                fieldStatus = emailStatusDom[fieldStatus]
            }
            field.model.set({
                status: fieldStatus
            });
        }

        this._super('_renderField', [field]);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this._sanitizeModels();
    },

    /**
     * Sets `model.module` to be in accordance with
     * model's `_module` attribute for each model.
     *
     * @private
     */
    _sanitizeModels: function() {
        this.collection.each(function(model) {
            model.module = model.get('_module');
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        $('html').removeClass('print-drawer');
        this._super('_dispose');
    }
}) },
"filter-quicksearch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for doing a quick search.
 *
 * Part of {@link View.Layouts.Base.FilterLayout}.
 *
 * @class View.Views.Base.FilterQuicksearchView
 * @alias SUGAR.App.view.views.BaseFilterQuicksearchView
 * @extends View.View
 */
({
	// Filter-quicksearch View (base) 

    events: {
        'keyup': 'throttledSearch',
        'paste': 'throttledSearch'
    },

    className: 'table-cell full-width',

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        app.view.View.prototype.initialize.call(this, opts);
        this.listenTo(this.layout, 'filter:clear:quicksearch', this.clearInput);
        this.listenTo(this.layout, 'filter:change:module', this.updatePlaceholder);

        /**
         * The previous search string. This is used to prevent searches from
         * being triggered on keyup if the search string is not changed.
         *
         * @type {string}
         */
        this.currentSearch = '';

        //shortcut keys
        app.shortcuts.register({
            id: 'Filter:Search',
            keys: ['f i','mod+alt+9'],
            component: this,
            description: 'LBL_SHORTCUT_FILTER_SEARCH',
            handler: function() {
                if (this.$el.is(':visible')) {
                    this.$el.focus();
                }
            }
        });
    },

    /**
     * @inheritdoc
     *
     * Changes `this.$el` to point to the `<input>` element.
     */
    _renderHtml: function() {
        this._super('_renderHtml');
        this.setElement(this.$('input'));
    },

    /**
     * For customers with large datasets, allow customization to disable
     * the automatic filtering in the omnibar.
     *
     * @inheritdoc
     */
    delegateEvents: function(events) {
        if (app.config.disableOmnibarTypeahead) {
            // Remove the keyup and paste events from this.events.
            // This is before the call to this._super('delegateEvents'),
            // so they have not been registered.
            delete this.events.keyup;
            delete this.events.paste;

            // On enter key press, apply the quicksearch.
            this.events.keydown = _.bind(function(evt) {
                // Enter key code is 13
                if (evt.keyCode === 13) {
                    this.applyQuickSearch();
                }
            }, this);
        }
        this._super('delegateEvents', [events]);
    },

    /**
     * Fires the quick search.
     * @param {Event} [event] A keyup event.
     */
    throttledSearch: _.debounce(function(event) {
        this.applyQuickSearch();
    }, 400),

    /**
     * Retrieves the labels for the fields that are searchable in the
     * quicksearch.
     *
     * @param {string} moduleName The module name the fields belong to.
     * @param {string[]} fields The list of searchable fields.
     * @return {string[]} The list of labels.
     */
    getFieldLabels: function(moduleName, fields) {
        var moduleMeta = app.metadata.getModule(moduleName);
        var labels = [];

        _.each(_.flatten(fields), function(fieldName) {
            var fieldMeta = moduleMeta.fields[fieldName];
            if (fieldMeta) {
                labels.push(app.lang.get(fieldMeta.vname, moduleName).toLowerCase());
            }
        });

        return labels;
    },

    /**
     * Update quick search placeholder to Search by Field1, Field2, Field3 when the module changes
     * @param string linkModuleName
     * @param string linkModule
     */
    updatePlaceholder: function(linkModuleName, linkModule) {
        var label;
        this.toggleInput();
        if (!this.$el.hasClass('hide') && linkModule !== 'all_modules') {
            var filtersBeanPrototype = app.data.getBeanClass('Filters').prototype,
                fields = filtersBeanPrototype.getModuleQuickSearchMeta(linkModuleName).fieldNames,
                fieldLabels = this.getFieldLabels(linkModuleName, fields);
            label = app.lang.get('LBL_SEARCH_BY') + ' ' + fieldLabels.join(', ') + '...';
        } else {
            label = app.lang.get('LBL_BASIC_QUICK_SEARCH');
        }
        var input = this.$el.attr('placeholder', label);
        this.$el.attr('aria-label', label);
    },

    /**
     * Hide input if on Activities
     */
    toggleInput: function() {
        this.$el.toggleClass('hide', !!this.layout.showingActivities);
    },

    /**
     * Clear input
     */
    clearInput: function() {
        this.toggleInput();
        var input = this.$el.val('');
        this.applyQuickSearch(true);
    },

    /**
     * Invokes the `filter:apply` event with the current value on the
     * quicksearch field.
     *
     * @param {boolean} [force] `true` to always trigger the `filter:apply`
     *   event, `false` otherwise. Defaults to `false`.
     */
    applyQuickSearch: function(force) {
        force = !_.isUndefined(force) ? force : false;
        var newSearch = this.$el.val();
        if (force || this.currentSearch !== newSearch) {
            this.currentSearch = newSearch;
            this.layout.trigger('filter:apply', newSearch);
        }
    }
}) },
"tabbed-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Tabbed dashlet is an abstraction that allows new tabbed dashlets to be
 * easily created based on a metadata driven configurable set of tabs, where
 * each new tab is created under a tabs array, where a specific set of
 * properties can be defined.
 *
 * Supported properties:
 *
 * - {Boolean} active If specific tab should be active by default.
 * - {String} filter_applied_to Date field to be used on date switcher, defaults
 *   to date_entered.
 * - {Array} filters Array of filters to be applied.
 * - {String} label Tab label.
 * - {Array} labels Array of labels (singular/plural) to be applied when
 *   LBL_MODULE_NAME_SINGULAR and LBL_MODULE_NAME aren't available or there's a
 *   need to use custom labels depending on the number of records available.
 * - {String} link Relationship link to be used if we're on a record view
 *   context, leading to only associated records being shown.
 * - {String} module Module from which the records are retrieved.
 * - {String} order_by Sort records by field.
 * - {String} record_date Date field to be used to print record date, defaults
 *   to 'date_entered' if none supplied.
 * - {Array} row_actions Row actions to be applied to each record.
 *
 * Example:
 * <pre><code>
 * // ...
 * 'tabs' => array(
 *     array(
 *         'filter_applied_to' => 'date_entered',
 *         'filters' => array(
 *             'type' => array('$equals' => 'out'),
 *         ),
 *         'labels' => array(
 *             'singular' => 'LBL_DASHLET_EMAIL_OUTBOUND_SINGULAR',
 *             'plural' => 'LBL_DASHLET_EMAIL_OUTBOUND_PLURAL',
 *         ),
 *         'link' => 'emails',
 *         'module' => 'Emails',
 *     ),
 *     //...
 * ),
 * //...
 * </code></pre>
 *
 * @class View.Views.Base.TabbedDashletView
 * @alias SUGAR.App.view.views.BaseTabbedDashletView
 * @extends View.View
 */
({
	// Tabbed-dashlet View (base) 

    plugins: ['Dashlet', 'RelativeTime', 'ToggleVisibility', 'Pagination'],

    events: {
        'click [data-action=show-more]': 'showMore',
        'click [data-action=tab-switcher]': 'tabSwitcher'
    },

    /**
     * Default settings used when none are provided via metadata.
     *
     * @template
     * @protected
     */
    _defaultSettings: {},

    /**
     * Bind the separate context to avoid sharing context's handlers
     * between its extension dashlets.
     */
    initDashlet: function() {
        this._initSettings();
        if (this.meta.config) {
            return;
        }

        this.collection = app.data.createBeanCollection(this.module);
        this.context = this.context.getChildContext({
            forceNew: true,
            model: this.context.parent && this.context.parent.get('model'),
            collection: this.collection,
            //FIXME: name is temporary - special case for LinkedModel - SC-2550
            name: 'tabbed-dashlet',
            skipFetch: true
        });

        this.context.set('parentModule', this.module);

        this._initMaxHeightTarget();
        this._initEvents();
        this._initTabs();
        this._initTemplates();
    },

    /**
     * Initialize max height target element by overriding its value and
     * setting it to a specific tab inner element.
     *
     * @chainable
     * @template
     * @protected
     */
    _initMaxHeightTarget: function() {
        this.maxHeightTarget = this.meta.max_height_target || 'div.tab-content';

        return this;
    },

    /**
     * Initialize events.
     *
     * @chainable
     * @template
     * @protected
     */
    _initEvents: function() {
        this.settings.on('change:filter', this.loadData, this);
        this.on('tabbed-dashlet:unlink-record:fire', this.unlinkRecord, this);
        this.context.on('tabbed-dashlet:refresh', this.refreshTabsForModule, this);
        this.context.on('change:collection', this.onCollectionChange, this);

        return this;
    },

    /**
     * Initialize tabs.
     *
     * @chainable
     * @protected
     */
    _initTabs: function() {
        this.tabs = [];
        _.each(this.dashletConfig.tabs, function(tab, index) {
            if (tab.active) {
                this.settings.set('activeTab', index);
            }

            var collection = this._createCollection(tab);
            if (_.isNull(collection)) {
                return;
            }

            collection.on('add', this.bindCollectionAdd, this);
            collection.on('reset', this.bindCollectionReset, this);

            this.tabs[index] = tab;
            this.tabs[index].collection = collection;
            this.tabs[index].relate = _.isObject(collection.link);
            this.tabs[index].record_date = tab.record_date || 'date_entered';
            this.tabs[index].include_child_items = tab.include_child_items || false;
        }, this);

        return this;
    },

    /**
     * Initialize templates.
     *
     * This will get the templates from either the current module (since we
     * might want to customize it per module) or from core templates.
     *
     * Please define your templates on:
     *
     * - `custom/clients/{platform}/view/tabbed-dashlet/tabs.hbs`
     * - `custom/clients/{platform}/view/tabbed-dashlet/toolbar.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/tabbed-dashlet/tabs.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/tabbed-dashlet/toolbar.hbs`
     *
     * @chainable
     * @template
     * @protected
     */
    _initTemplates: function() {
        this._tabsTpl = app.template.getView(this.name + '.tabs', this.module) ||
            app.template.getView(this.name + '.tabs') ||
            app.template.getView('tabbed-dashlet.tabs', this.module) ||
            app.template.getView('tabbed-dashlet.tabs');

        this._toolbarTpl = app.template.getView(this.name + '.toolbar', this.module) ||
            app.template.getView(this.name + '.toolbar') ||
            app.template.getView('tabbed-dashlet.toolbar', this.module) ||
            app.template.getView('tabbed-dashlet.toolbar');

        return this;
    },

    /**
     * Sets up settings, starting with defaults.

     * @chainable
     * @protected
     */
    _initSettings: function() {
        var settings = _.extend({},
            this._defaultSettings,
            this.settings.attributes);

        this.settings.set(settings);

        return this;
    },

    /**
     * New model related properties are injected into each model.
     * Update the record date associating by tab's record date value.
     *
     * @param {Data.Bean} model Appended new model.
     */
    bindCollectionAdd: function(model) {
        var tab = this._getTab(model.collection);
        model.set('record_date', model.get(tab.record_date));
    },

    /**
     * Bind event triggers for each updated models on collection reset.
     *
     * @param {Data.BeanCollection} collection Activated tab's collection.
     */
    bindCollectionReset: function(collection) {
        _.each(collection.models, this.bindCollectionAdd, this);
    },

    /**
     * Bind event listener for the updating collection count on the tab.
     */
    onCollectionChange: function() {
        var prevCollection = this.context.previous('collection');
        if (prevCollection) {
            prevCollection.off(null, this.updateCollectionCount, this);
        }
        this.collection = this.context.get('collection');
        this.collection.on('add remove reset', _.debounce(this.updateCollectionCount, 100), this);
    },

    /**
     * Update the collection's count on the active tab.
     */
    updateCollectionCount: function() {
        var tabIndex = this.settings.get('activeTab');
        var count = this.collection.length;

        if (this.collection.next_offset >= 0) {
            count += '+';
        }
        this.$('[data-action=tab-switcher][data-index=' + tabIndex + ']')
            .children('[data-action=count]')
            .text(count);
    },

    /**
     * Retrieve records template.
     *
     * This will get the template from either the active tab associated module,
     * from the current module (since we might want to customize it per module)
     * or from core templates.
     *
     * Please define your template on:
     *
     * - `custom/clients/{platform}/view/tabbed-dashlet/records.hbs`
     * - `{custom/,}modules/{module}/clients/{platform}/view/tabbed-dashlet/records.hbs`
     *
     * @param {String} module Module name.
     * @return {Function} Template function.
     * @protected
     */
    _getRecordsTemplate: function(module) {
        this._recordsTpl = this._recordsTpl || {};

        if (!this._recordsTpl[module]) {
            this._recordsTpl[module] = app.template.getView(this.name + '.records', module) ||
                app.template.getView(this.name + '.records', this.module) ||
                app.template.getView(this.name + '.records') ||
                app.template.getView('tabbed-dashlet.records', this.module) ||
                app.template.getView('tabbed-dashlet.records');
        }

        return this._recordsTpl[module];
    },

    /**
     * Create collection based on tab properties and current context,
     * furthermore if supplied tab has a valid 'link' property a related
     * collection will be created instead.
     *
     * @param {Object} tab Tab properties.
     * @return {Data.BeanCollection|null} A new instance of bean collection or `null`
     *   if we cannot access module metadata.
     * @protected
     */
    _createCollection: function(tab) {
        if (this.context.parent) {
            var module = this.context.parent.get('module');
        } else {
            var module = this.module;
        }

        var meta = app.metadata.getModule(module);
        if (_.isUndefined(meta)) {
            return null;
        }

        var options = {};
        if (meta.fields[tab.link] && meta.fields[tab.link].type === 'link') {
            options = {
                link: {
                    name: tab.link,
                    bean: this.model
                }
            };
        }

        var collection = app.data.createBeanCollection(tab.module, null, options);

        return collection;
    },

    /**
     * Retrieves collection options for a specific tab.
     *
     * @param {number} index Tab index.
     * @return {Object} Collection options.
     * @return {number} return.limit The number of records to retrieve.
     * @return {number} return.offset The offset for pagination.
     * @return {Object} return.params Additional parameters to the API call.
     * @return {Object|null} return.fields Specifies the fields on each
     * requested model.
     * @return {boolean|undefined} return.myItems Whether or not there is user
     * visibility when the module is not Meetings or Calls.
     * @protected
     */
    _getCollectionOptions: function(index) {
        var tab = this.tabs[index];
        var options = {
            limit: this.settings.get('limit'),
            offset: 0,
            params: {
                order_by: tab.order_by || null,
                include_child_items: tab.include_child_items || null
            },
            fields: tab.fields || null
        };

        if (tab.module != 'Meetings' && tab.module != 'Calls') {
            options.myItems = this.getVisibility() === 'user';
        }

        return options;
    },

    /**
     * Retrieves collection filters for a specific tab.
     *
     * @param {number} index Tab index.
     * @return {Array} Collection filters.
     * @protected
     */
    _getCollectionFilters: function(index) {
        var tab = this.tabs[index];
        var filters = [];

        _.each(tab.filters, function(condition, field) {
            var filter = {};
            filter[field] = condition;

            filters.push(filter);
        });

        if ((tab.module === 'Meetings' || tab.module === 'Calls')
            && this.getVisibility() === 'user') {
            filters.push({
                "$or":[{"assigned_user_id":app.user.id},
                       {"users.id":app.user.id}]
            });
        }

        return filters;
    },

    /**
     * Retrieves tab based on supplied collection.
     *
     * @param {Object} collection Collection of the desired tab.
     * @return {Object} Tab.
     * @private
     */
    _getTab: function(collection) {
        return _.find(this.tabs, function(tab) {
            return tab.collection === collection;
        }, this);
    },

    /**
     * Override this method to provide custom filters.
     *
     * @param {number} index Tab index.
     * @return {Array} Custom filters.
     * @template
     * @protected
     */
    _getFilters: function(index) {
        return [];
    },

    /**
     * Fetch data for view tabs based on selected options and filters.
     *
     * @param {Object} options Options that are passed to collection/model's
     *   fetch method.
     */
    loadData: function(options) {

        if (this.disposed || this.meta.config) {
            return;
        }
        this.loadDataForTabs(this.tabs, options);

    },

    /**
     * Refresh tabs for the given module
     * @param module {String} name of module needing refresh
     */
    refreshTabsForModule: function(module) {
        var toRefresh = [];
        _.each(this.tabs, function(tab) {
            if (tab.module === module) {
               toRefresh.push(tab);
            }
        });
        this.loadDataForTabs(toRefresh, {});
    },

    /**
     * Load data for passed set of tabs.
     * @param tabs {Array} Set of tabs to update.
     * @param options {Object} load options.
     */
    loadDataForTabs: function(tabs, options) {
        options = options || {};
        var self = this;
        var loadDataRequests = [];
        _.each(tabs, function(tab, index) {
            loadDataRequests.push(function(callback) {
                tab.collection.setOption(self._getCollectionOptions(index));

                tab.collection.filterDef = _.union(
                    self._getCollectionFilters(index),
                    self._getFilters(index)
                );
                tab.collection.fetch({
                    relate: tab.relate,
                    complete: function() {
                        tab.collection.dataFetched = true;
                        callback(null);
                    }
                });
            });
        }, this);
        if (!_.isEmpty(loadDataRequests)) {
            async.parallel(loadDataRequests, function() {
                if (self.disposed) {
                    return;
                }
                self.collection = self.tabs[self.settings.get('activeTab')].collection;
                self.context.set('collection', self.collection);

                self.render();

                if (_.isFunction(options.complete)) {
                    options.complete.call(self);
                }
            });
        }
    },

    /**
     * Convenience callback for updating this
     * and related dashlets once a model has been removed.
     * @return {Function} complete callback.
     * @private
     */
    _getRemoveModelCompleteCallback: function() {
        return _.bind(function(model) {
            if (this.disposed) {
                return;
            }
            this.collection.remove(model);
            this.render();
            this.context.trigger('tabbed-dashlet:refresh', model.module);
        }, this);
    },

    /**
     * Show more records for current collection.
     */
    showMore: function() {
        this.getNextPagination({
            showAlerts: true,
            limit: this.settings.get('limit')
        });
    },

    /**
     * Event handler for tab switcher.
     *
     * @param {Event} event Click event.
     */
    tabSwitcher: function(event) {
        var index = this.$(event.currentTarget).data('index');
        if (index === this.settings.get('activeTab')) {
            return;
        }

        this.settings.set('activeTab', index);
        this.collection = this.tabs[index].collection;
        this.context.set('collection', this.collection);
        this.render();
    },

    /**
     * Additional logic on switch visibility event.
     *
     * See {@link app.plugins.ToggleVisibility}.
     */
    visibilitySwitcher: function() {
        var activeVisibility;
        if (!this.isManager) {
            return;
        }
        activeVisibility = this.getVisibility();
        this.$el.find('[data-action=visibility-switcher]')
            .attr('aria-pressed', function() {
                return $(this).val() === activeVisibility;
            });
    },

    /**
     * Unlinks the selected record.
     *
     * Shows a confirmation alert and removes the model on confirm.
     *
     * @param {Data.Bean} model Selected model.
     */
    unlinkRecord: function(model) {
        var self = this;
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;
        app.alert.show(model.get('id') + ':unlink_confirmation', {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('NTC_UNLINK_CONFIRMATION_FORMATTED'), [context]),
            onConfirm: function() {
                model.destroy({
                    showAlerts: true,
                    relate: true,
                    success: self._getRemoveModelCompleteCallback()
                });
            }
        });
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        var recordsTpl = this._getRecordsTemplate(tab.module);

        this.toolbarHtml = this._toolbarTpl(this);
        this.tabsHtml = this._tabsTpl(this);
        this.recordsHtml = recordsTpl(this);

        this.row_actions = tab.row_actions;

        this._super('_renderHtml');
    },

    /**
     *  Handle Avatar display, in case image doesn't exist.
     *
     *  FIXME: render avatar should happen when rendering each row, after pagination.(SC-2605)
     *  @private
     */
    _renderAvatars: function() {
        this.$('img.avatar')
            .on('load', function() {
                $(this).removeClass('hide');
            })
            .on('error', function() {
                $(this).parent().removeClass('avatar avatar-md')
                                .addClass('label label-module label-module-md label-Users');
                $(this).parent().find('span').removeClass('hide');
            });
        this.$('img.avatar').each(function() {
            var img = $(this);
            img.attr('src', img.data('src'));
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        _.each(this.tabs, function(tab) {
            tab.collection.off(null, null, this);
        });

        this._super('_dispose');
    }
}) },
"modal-confirm": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ModalConfirmView
 * @alias SUGAR.App.view.views.BaseModalConfirmView
 * @extends View.View
 */
({
	// Modal-confirm View (base) 

    events: {
        'click [name=close_button]' : 'close',
        'click [name=ok_button]' : 'ok'
    },
    initialize: function(options) {
        this.message = options.layout.confirmMessage;
        app.view.View.prototype.initialize.call(this, options);
    },
    close: function(evt) {
        this.layout.context.trigger("modal:close");
    },
    ok: function(evt) {
        this.layout.context.trigger("modal:callback");
    }
}) },
"massupdate-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassupdateProgressView
 * @alias SUGAR.App.view.views.BaseMassupdateProgressView
 * @extends View.View
 */
({
	// Massupdate-progress View (base) 

    plugins: ['Editable'],

    events: {
        'click [name=btn-stop]': 'pauseUpdate'
    },

    /**
     * Total number of records.
     *
     * @property
     */
    totalRecord: 0,

    /**
     * Executed datetime in milliseconds.
     *
     * @property
     */
    _startTime: 0,

    /**
     * Speed of last executed job.
     *
     * @property
     */
    _velocity: 0,

    /**
     * HTML Elements that needs to update dynamically.
     *
     * @property
     */
    $holders: {},

    /**
     * Set of labels.
     *
     * @property
     */
    _labelSet: {
        'update': {
            PROGRESS_STATUS: 'TPL_MASSUPDATE_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSUPDATE_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSUPDATE_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSUPDATE_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSUPDATE_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSUPDATE_SUCCESS',
            TITLE: 'TPL_MASSUPDATE_TITLE'
        },
        'delete': {
            PROGRESS_STATUS: 'TPL_MASSDELETE_PROGRESS_STATUS',
            DURATION_FORMAT: 'TPL_MASSDELETE_DURATION_FORMAT',
            FAIL_TO_ATTEMPT: 'TPL_MASSDELETE_FAIL_TO_ATTEMPT',
            WARNING_CLOSE: 'TPL_MASSDELETE_WARNING_CLOSE',
            WARNING_INCOMPLETE: 'TPL_MASSDELETE_WARNING_INCOMPLETE',
            SUCCESS: 'TPL_MASSDELETE_SUCCESS',
            TITLE: 'TPL_MASSDELETE_TITLE'
        }
    },

    /**
     * @inheritdoc
     * Check if current process job is completed.
     *
     * @return {boolean} If this process job is not completed, it returns true.
     */
    hasUnsavedChanges: function() {
        return (this.totalRecord > 0);
    },

    /**
     * Initialize the job collection set.
     *
     * @param {Backbone.Collection} collection Selected set of models.
     */
    initCollection: function(collection) {
        this.unbindData();
        this.collection = collection;
        this.hide();
        this.bindDataChange();
    },

    /**
     * Returns action name.
     *
     * @return {string}
     */
    getCurrentMethod: function() {
        return this.collection.method || this.collection.defaultMethod;
    },

    /**
     * Initialize the labels.
     */
    initLabels: function() {
        this.LABELSET = this._labelSet[this.getCurrentMethod()];
    },

    /**
     * Initialize the dynamic DOM elements into the variable,
     * in order to avoid the multiple jQuery selector.
     */
    initHolders: function() {
        var self = this;
        self.$holders = {};
        this.$('[data-holder]').each(function(holder) {
            var $el = $(this);
            self.$holders[$el.data('holder')] = $el;
        });
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        this.offBefore('start');
        this.off('render', null, this);
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * @inheritdoc
     * Bind the listeners for each massupdate status.
     */
    bindDataChange: function() {
        if (!this.collection) {
            return;
        }
        this.on('render', this.initHolders, this);
        this.collection.on('massupdate:always', this.updateProgress, this);
        this.collection.on('massupdate:start', this.showProgress, this);
        this.collection.on('massupdate:end', this.hideProgress, this);
        this.collection.on('massupdate:fail', this.checkError, this);
        this.collection.on('massupdate:resume', this.resumeProcess, this);
        this.collection.on('massupdate:pause', this.pauseProcess, this);
    },

    /**
     * Check current job occurs error or not.
     *
     * If api retry the attempt,
     * it displays api failure error message in the alert bar.
     */
    checkError: function() {
        if (this.collection.attempt === 0) {
            this.$holders.bar
                .addClass('progress-info')
                .removeClass('progress-danger');
            return;
        } else if (this.collection.attempt > this.collection.maxAllowAttempt) {
            return;
        }
        this.$holders.bar
            .removeClass('progress-info')
            .addClass('progress-danger');
        app.alert.dismiss('stop_confirmation');
        app.alert.show('stop_confirmation', {
            level: 'error',
            messages: app.lang.get(this.LABELSET['FAIL_TO_ATTEMPT'], this.module, {
                num: this.collection.attempt,
                total: this.collection.maxAllowAttempt
            })
        });
    },

    /**
     * Estimate remaining time.
     *
     * @return {Number} Remaining seconds.
     */
    getEstimate: function() {
        if (!this.collection.chunks) {
            return 0;
        }
        var chunkSize = this.collection.chunks.length,
            remainSize = this.collection.length,
            duration = (new Date().getTime() - this._startTime) / 1000;
        this._startTime = new Date().getTime();
        this._velocity = chunkSize / duration; //amount per sec

        return parseInt(remainSize / this._velocity, 10);
    },

    /**
     * Convert numeric time into the relative time.
     * @param {Number} elapsed Numeric time.
     * @return {String} Converted string time.
     *   Returns empty unless condition is satisfied.
     */
    getRelativeTime: function(elapsed) {
        var msPerMinute = 60,
            msPerHour = msPerMinute * 60,
            msPerDay = msPerHour * 24,
            unitString = '',
            relateTime = 0;

        if (elapsed <= 0) {
            return '';
        }

        if (elapsed < msPerMinute) {
            relateTime = elapsed;
            unitString = app.lang.get('LBL_DURATION_SECONDS');
        } else if (elapsed < msPerHour) {
            relateTime = Math.round(elapsed / msPerMinute);
            unitString = app.lang.get('LBL_DURATION_MINUTES');
        } else if (elapsed < msPerDay) {
            relateTime = Math.round(elapsed / msPerHour);
            unitString = app.lang.get('LBL_DURATION_HOUR');
        } else {
            //too huge
            return '';
        }

        return app.lang.get(this.LABELSET['DURATION_FORMAT'], this.collection.baseModule, {
            time: relateTime,
            unit: unitString
        });
    },

    /**
     * Returns number of total elements for progress.
     *
     * @return {Number} Number of total elements.
     */
    getTotalRecords: function() {
        return this.collection.length;
    },

    /**
     * Calculate remaining records.
     *
     * @return {Number} Remaining size.
     */
    getRemainder: function() {
        var chunkSize = _.isEmpty(this.collection.chunks) ? 0 : this.collection.chunks.length,
            size = _.min([this.collection.models.length, this.collection.length + chunkSize]);

        return size;
    },

    /**
     * Calculate current progress size.
     * Include the completed queue size and current executing chunk size.
     *
     * @return {Number} Progress size.
     */
    getProgressSize: function() {
        var chunkSize = _.isEmpty(this.collection.chunks) ? 0 : this.collection.chunks.length,
            size = _.min([this.totalRecord, this.totalRecord - this.collection.length + chunkSize]);

        return size;
    },

    /**
     * Calculate completed size.
     *
     * @return {Number} Completed size.
     */
    getCompleteRecords: function() {
        return this.totalRecord - this.collection.length;
    },

    /**
     * Calculate number of failed updates.
     *
     * @return {Number} Number of failed updates.
     */
    getFailedRecords: function() {
        return this.collection.numFailures;
    },

    /**
     * Resume the mass job once user were requested to resume.
     * Update screen in proper way.
     */
    resumeUpdate: function() {
        this.collection.resumeFetch();
    },

    /**
     * Request pausing the mass job once user were requested to pause.
     * Update screen in proper way.
     */
    pauseUpdate: function() {
        var stopButton = this.getField('btn-stop');
        stopButton.setDisabled(true);
        this.collection.pauseFetch();
    },

    /**
     * Update the progress view when the job is paused.
     */
    pauseProcess: function() {
        this.$holders.bar.removeClass('active');
        app.alert.dismiss('stop_confirmation');
        app.alert.show('stop_confirmation', {
            level: 'confirmation',
            messages: app.lang.get(this.LABELSET['WARNING_CLOSE'], this.module, {
                num: this.getRemainder()
            }),
            onConfirm: _.bind(this.hideProgress, this),
            onCancel: _.bind(this.resumeUpdate, this),
            autoClose: false
        });
    },

    /**
     * Update the progress view when the job is resumed.
     */
    resumeProcess: function() {
        this.$holders.bar.addClass('active');
        var stopButton = this.getField('btn-stop');
        stopButton.setDisabled(false);
    },

    /**
     * Start displaying the progress view.
     */
    showProgress: function() {
        this.initLabels();
        this.totalRecord = this.getTotalRecords();
        this._startTime = new Date().getTime();

        //restore back previous button status.
        var stopButton = this.getField('btn-stop');
        if (stopButton) {
            stopButton.setDisabled(false);
        }

        var title = app.lang.get(this.LABELSET.TITLE, this.module, {
            module: app.lang.getModuleName(this.module, {plural: true})
        });
        this.$holders.title.text(title);

        this.updateProgress();
        this.show();
    },

    /**
     * Finish displaying the pregress view.
     * Reset current mass job.
     */
    hideProgress: function() {
        var size = this.getCompleteRecords(),
            discardSize = this.collection.discards.length,
            failed = this.getFailedRecords();
        // "failed" records may mean field acl restrictions on "update" action
        if (discardSize > 0 || (this.getCurrentMethod() == 'update' && failed > 0)) {
            //permission warning
            var message = app.lang.get(this.LABELSET['SUCCESS'], this.module, {
                num: this.totalRecord - discardSize - failed
            });
            message += ' ' + app.lang.get('TPL_MASSUPDATE_WARNING_PERMISSION', this.module, {
                remain: discardSize + failed
            });
            app.alert.show('massupdate_final_notice', {
                level: 'warning',
                messages: message,
                autoClose: true,
                autoCloseDelay: 8000
            });
        } else if (this.totalRecord !== size || failed > 0) {
            //incomplete
            app.alert.show('massupdate_final_notice', {
                level: 'warning',
                messages: app.lang.get(this.LABELSET['WARNING_INCOMPLETE'], this.module, {
                    num: this.getRemainder() + failed
                }),
                autoClose: true,
                autoCloseDelay: 8000
            });
        } else {
            //successfully complete
            app.alert.show('massupdate_final_notice', {
                level: 'success',
                messages: app.lang.get(this.LABELSET['SUCCESS'], this.module, {
                    num: size
                }),
                autoClose: true,
                autoCloseDelay: 8000
            });
        }
        this.totalRecord = 0;
        this.collection.resetProgress();
        this.hide();
    },

    /**
     * Update current progress status.
     */
    updateProgress: function() {
        if (!this.collection || this.collection.length === 0) {
            return;
        }

        var estimate = this.getEstimate(),
            estimateMessage = this.getRelativeTime(estimate),
            size = this.getProgressSize(),
            percent = (size * 100 / this.totalRecord),
            message = app.lang.get(this.LABELSET['PROGRESS_STATUS'], this.module, {
                num: size,
                percent: Math.round(percent),
                total: this.totalRecord
            });
        if (!_.isEmpty(estimateMessage)) {
            this.$holders.estimate.text(estimateMessage);
        }
        this.checkError();
        this.$holders.message.text(message);
        this.$holders.progressbar.css({'width': percent + '%'});
    }
}) },
"merge-duplicates-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for merge duplicates header pane.
 *
 * @class View.Views.Base.MergeDuplicatesHeaderpaneView
 * @alias SUGAR.App.view.views.BaseMergeDuplicatesHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Merge-duplicates-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=cancel_button]': 'cancel',
        'click a[name=save_button]': 'save'
    },

    /**
     * @inheritdoc
     *
     * Gets the selected duplicates from the context and defines the title based
     * on the number of selected records.
     */
    _formatTitle: function(title) {
        var records = this.context.get('selectedDuplicates');
        return app.lang.get(title, this.module, {mergeCount: records.length});
    },

    /**
     * Cancel and close the drawer.
     */
    cancel: function() {
        app.drawer.close();
    },

    /**
     * Save primary and delete other records.
     */
    save: function() {
        this.layout.trigger('mergeduplicates:save:fire');
    }
}) },
"editmodal": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.EditmodalView
 * @alias SUGAR.App.view.views.BaseEditmodalView
 * @extends View.Views.Base.BaseeditmodalView
 */
({
	// Editmodal View (base) 

    extendsFrom:'BaseeditmodalView',
    fallbackFieldTemplate: 'edit',
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        if (this.layout) {
            this.layout.on('app:view:activity:editmodal', function() {
                this.context.set('createModel',
                    app.data.createRelatedBean(app.controller.context.get('model'), null, 'notes', {})
                );
                this.render();
                this.$('.modal').modal({backdrop: 'static'});
                this.$('.modal').modal('show');
                app.$contentEl.attr('aria-hidden', true);
                $('.modal-backdrop').insertAfter($('.modal'));
                this.context.get('createModel').on('error:validation', function() {
                    this.disableButtons(false);
                }, this);
            }, this);
        }
        this.bindDataChange();
    },
    cancelButton: function() {
        this._super('cancelButton');
        app.$contentEl.removeAttr('aria-hidden');
    },
    saveComplete: function() {
        this._super('saveComplete');
        app.$contentEl.removeAttr('aria-hidden');
    }
  }) },
"filter-module-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for the module dropdown.
 *
 * Part of {@link View.Layouts.Base.FilterLayout}.
 *
 * @class View.Views.Base.FilterModuleDropdownView
 * @alias SUGAR.App.view.views.BaseFilterModuleDropdownView
 * @extends View.View
 */
({
	// Filter-module-dropdown View (base) 

    //Override default Backbone tagName
    tagName: "span",
    className: "table-cell",

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //Load partials
        this._select2formatSelectionTemplate = app.template.get("filter-module-dropdown.selection-partial");
        this._select2formatResultTemplate = app.template.get("filter-module-dropdown.result-partial");

        this.listenTo(this.layout, "filter:change:module", this.handleChange);
        this.listenTo(this.layout, "filter:render:module", this._render);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this._renderDropdown();
    },

    /**
     * Render select2 dropdown
     * @private
     */
    _renderDropdown: function() {
        var self = this;

        this.filterList = this.getFilterList();

        // Hide the dropdown if filterList has not been specified.
        if (!this.filterList) {
            this.$el.hide();
            return;
        }

        this.filterNode = this.$(".related-filter");

        this.filterNode.select2({
            data: this.filterList,
            multiple: false,
            minimumResultsForSearch: 7,
            formatSelection: _.bind(this.formatSelection, this),
            formatResult: _.bind(this.formatResult, this),
            dropdownCss: {width: 'auto'},
            dropdownCssClass: 'search-related-dropdown',
            initSelection: _.bind(this.initSelection, this),
            escapeMarkup: function(m) {
                return m;
            },
            width: 'off'
        });

        // Disable the module filter dropdown.
        if (this.shouldDisableFilter()) {
            this.filterNode.select2("disable");
        }

        this.filterNode.off("change");
        this.filterNode.on("change", function(e) {
            /**
             * Called when the user selects a module in the dropdown
             * Triggers filter:change:module on filter layout
             * @param {Event} e
             */
            var linkModule = e.val;
            if (self.layout.layoutType === "record" && linkModule !== "all_modules") {
                linkModule = app.data.getRelatedModule(self.module, linkModule);
            }
            self.layout.trigger("filter:change:module", linkModule, e.val);
        });
    },

    /**
     * Get the list for filter module dropdown.
     * @return {Object}
     */
    getFilterList: function() {
        var filterList;

        if (this.layout.showingActivities) {
            filterList = this.getModuleListForActivities();
        } else if (this.layout.layoutType === "record") {
            filterList = this.getModuleListForSubpanels();
        }

        return filterList;
    },

    /**
     * Should the filter be disabled?
     * @return {boolean}
     */
    shouldDisableFilter: function() {
        return (this.layout.layoutType !== "record" || this.layout.showingActivities);
    },

    /**
     * Trigger events when a change happens
     * @param {String} linkModuleName
     * @param {String} linkName
     * @param {Boolean} silent
     */
    handleChange: function(linkModuleName, linkName, silent) {
        if (linkName === "all_modules") {
            this.layout.trigger("subpanel:change");
        } else if (linkName) {
            this.layout.trigger("subpanel:change", linkName);
        }

        // It is important to reset the `currentFilterId` in order to retrieve
        // the last filter from cache later.
        this.context.set('currentFilterId', null);

        if (this.filterNode) {
            this.filterNode.select2("val", linkName || linkModuleName);
        }
        if (!silent) {
            this.layout.layout.trigger("filter:change", linkModuleName, linkName);
            this.layout.trigger('filter:get', linkModuleName, linkName);
            //Clear the search input and apply filter
            this.layout.trigger('filter:clear:quicksearch');
        }
    },

    /**
     * For record layout,
     * Populate the module dropdown by reading the subpanel relationships
     */
    getModuleListForSubpanels: function() {
        var filters = [];
        filters.push({id: "all_modules", text: app.lang.get("LBL_MODULE_ALL")});

        var subpanels = this.pullSubpanelRelationships();
        subpanels = this._pruneHiddenModules(subpanels);
        if (subpanels) {
            _.each(subpanels, function(value, key) {
                var module = app.data.getRelatedModule(this.module, value);
                if (app.acl.hasAccess("list", module)) {
                    filters.push({id: value, text: app.lang.get(key, this.module)});
                }
            }, this);
        }
        return filters;
    },

    /**
     * For Activity Stream,
     * Populate the module dropdown with a single item
     */
    getModuleListForActivities: function() {
        var filters = [], label;
        if (this.module == "Activities") {
            label = app.lang.get("LBL_MODULE_ALL");
        } else {
            label = app.lang.getModuleName(this.module, {plural: true});
        }
        filters.push({id: 'Activities', text: label});
        return filters;
    },

    /**
     * Pull the list of related modules from the subpanel metadata
     * @return {Object}
     */
    pullSubpanelRelationships: function() {
        // Subpanels are retrieved from the global module and not the
        // subpanel module, therefore we use this.module instead of
        // this.currentModule.
        return app.utils.getSubpanelList(this.module);
    },

    /**
     * Prunes hidden modules from related dropdown list
     * @param {Object} subpanels List of candidate subpanels to display
     * @return {Object} pruned list of subpanels
     * @private
     */
    _pruneHiddenModules: function(subpanels){
        var hiddenSubpanels = _.map(app.metadata.getHiddenSubpanels(), function(subpanel) {
            return subpanel.toLowerCase();
        });
        var pruned = _.reduce(subpanels, function(obj, value, key) {
            var relatedModule = app.data.getRelatedModule(this.module, value);
            if (relatedModule && !_.contains(hiddenSubpanels, relatedModule.toLowerCase())) {
                obj[key] = value;
            }
            return obj;
        }, {}, this);
        return pruned;
    },

    /**
     * Get the dropdown labels for the module dropdown
     * @param {Object} el
     * @param {Function} callback
     */
    initSelection: function(el, callback) {
        var selection, label;
        if (el.val() === "all_modules") {
            label = (this.layout.layoutType === "record") ? app.lang.get("LBL_MODULE_ALL") : app.lang.getModuleName(this.module, {plural: true});
            selection = {id: "all_modules", text: label};
        } else if (_.findWhere(this.filterList, {id: el.val()})) {
            selection = _.findWhere(this.filterList, {id: el.val()});
        } else if(this.filterList && this.filterList.length > 0)  {
            selection = this.filterList[0];
        }
        callback(selection);
    },

    /**
     * Returns the label for the dropdown.
     *
     * @return {string}
     */
    getSelectionLabel: function() {
        var selectionLabel;

        if (this.layout.layoutType !== "record" || this.layout.showingActivities) {
            selectionLabel = app.lang.get("LBL_MODULE");
        } else {
            selectionLabel = app.lang.get("LBL_RELATED") + '<i class="fa fa-caret-down"></i>';
        }

        return selectionLabel;
    },

    /**
     * Update the text for the selected module and returns template
     *
     * @param {Object} item
     * @return {string}
     */
    formatSelection: function(item) {
        var safeString;

        //Escape string to prevent XSS injection
        safeString = Handlebars.Utils.escapeExpression(item.text);
        // Update the text for the selected module.
        this.$('.choice-filter-label').html(safeString);

        return this._select2formatSelectionTemplate(this.getSelectionLabel());
    },

    /**
     * Returns template
     * @param {Object} option
     * @return {string}
     */
    formatResult: function(option) {
        // TODO: Determine whether active filters should be highlighted in bold in this menu.
        return this._select2formatResultTemplate(option.text);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (!_.isEmpty(this.filterNode)) {
            this.filterNode.select2('destroy');
        }
        this._super('_dispose');
    }
}) },
"create-nodupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CreateNodupecheckView
 * @alias SUGAR.App.view.views.BaseCreateNodupecheckView
 * @extends View.Views.Base.CreateView
 */
({
	// Create-nodupecheck View (base) 

    extendsFrom: 'CreateView',

    initialize: function(options) {
        this._super("initialize", [options]);
        this.enableDuplicateCheck = false;
    }
}) },
"dashlet-row-empty": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashletRowEmptyView
 * @alias SUGAR.App.view.views.BaseDashletRowEmptyView
 * @extends View.View
 */
({
	// Dashlet-row-empty View (base) 

    events: {
        'click .add-dashlet' : 'layoutClicked',
        'click .add-row.empty' : 'addClicked'
    },
    originalTemplate: null,
    columnOptions: [],
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.model = this.layout.context.get("model");

        this.model.on("setMode", this.setMode, this);
        this.originalTemplate = this.template;
        this.setMode(this.model.mode);
        this.columnOptions = [];

        var parentLayoutWidth = 12,
            parentLayout = this;
        while (parentLayout) {
            if (parentLayout.type === 'dashlet-row') {
                parentLayoutWidth = parentLayout.meta.width;
            }
            parentLayout = parentLayout.layout;
        }
        var allowColumnSize = _.max([
            1, //should be at least one
            Math.floor(parentLayoutWidth / this.model.minColumnSpanSize)
        ]);
        _.times(allowColumnSize, function(index) {
            var n = index + 1;
            this.columnOptions.push({
                index: n,
                label: (n > 1) ?
                    app.lang.get('LBL_DASHBOARD_ADD_' + n + '_COLUMNS', this.module) :
                    app.lang.get('LBL_DASHBOARD_ADD_' + n + '_COLUMN', this.module)
            });
        }, this);
    },
    addClicked: function(evt) {
        var self = this;
        this._addRowTimer = setTimeout(function() {
            self.addRow(1);
        }, 100);
    },
    layoutClicked: function(evt) {
        var columns = $(evt.currentTarget).data('value');
        var addRow = _.bind(this.addRow, this);
        _.delay(addRow, 0, columns);
    },
    addRow: function(columns) {
        this.layout.addRow(columns);
        if(this._addRowTimer) {
            clearTimeout(this._addRowTimer);
        }
    },
    setMode: function(model) {
        if(model === 'edit') {
            this.template = this.originalTemplate;
        } else {
            this.template = app.template.empty;
        }
        this.render();
    },
    _dispose: function() {
        this.model.off("setMode", null, this);
        app.view.View.prototype._dispose.call(this);
    }
}) },
"forecast-pareto": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Dashlet that displays a chart.
 *
 * @class View.Views.Base.ForecastParetoView
 * @alias SUGAR.App.view.views.BaseForecastParetoView
 * @extends View.View
 */
({
	// Forecast-pareto View (base) 

    plugins: ['Dashlet'],

    className: 'forecasts-chart-wrapper',

    /**
     * Should we display the timeperiod Pivot options
     */
    displayTimeperiodPivot: true,

    /**
     * Track if they are a manager
     */
    isManager: false,

    /**
     * Track if the user is a top-level manager
     */
    isTopLevelManager: false,

    /**
     * When on a Record view this are fields we should listen to changes in
     */
    validChangedFields: ['amount', 'likely_case', 'best_case', 'worst_case', 'assigned_user_id',
        'date_closed', 'date_closed_timestamp', 'probability', 'commit_stage', 'sales_stage'],

    /**
     * Hold the initOptions if we have to call the Forecast/init end point cause we are not on Forecasts
     */
    initOptions: null,

    /**
     * Holds the forecast isn't set up message if Forecasts hasn't been set up yet
     */
    forecastsNotSetUpMsg: undefined,

    /**
     * Holds the Forecast Module Config
     */
    forecastConfig: undefined,

    /**
     * Are we using Opportunities with RevenueLineItems?
     */
    opportunitiesWithRevenueLineItems: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.isManager = app.user.get('is_manager');
        this._initPlugins();

        // if the user is a manager, check if they're toplevel or not
        if (this.isManager) {
            this.isTopLevelManager = app.user.get('is_top_level_manager');
        }

        // if the parent exists, use it, otherwise use the main context
        this.initOptions = options;
        this.forecastConfig = app.metadata.getModule('Forecasts', 'config');
        this.isForecastSetup = this.forecastConfig.is_setup;
        this.forecastsConfigOK = app.utils.checkForecastConfig();

        var oppConfig = app.metadata.getModule('Opportunities', 'config');
        if (oppConfig && oppConfig['opps_view_by'] === 'RevenueLineItems') {
            this.opportunitiesWithRevenueLineItems = true;
        } else {
            this.opportunitiesWithRevenueLineItems = false;
        }

        if (this.isForecastSetup && this.forecastsConfigOK) {
            this.initOptions.meta.template = undefined;

            if (!options.meta.config) {
                // we only want to call this if forecast is setup and configured
                // and this is not the dashlet config screen
                app.api.call('GET', app.api.buildURL('Forecasts/init'), null, {
                    success: _.bind(this.forecastInitCallback, this),
                    complete: this.initOptions ? this.initOptions.complete : null
                });
            }

            this.displayTimeperiodPivot = (options.context.get('module') === 'Home');
        } else {
            // set the no access template
            this.initOptions.meta.template = 'forecast-pareto.no-access';
            var isAdmin = _.isUndefined(app.user.getAcls()['Forecasts'].admin);
            this.forecastsNotSetUpMsg = app.utils.getForecastNotSetUpMessage(isAdmin);
        }

        this._super('initialize', [this.initOptions]);
    },

    /**
     * @inheritdoc
     */
    getLabel: function() {
        return app.lang.get(this.meta.label);
    },

    /**
     * @inheritdoc
     */
    initDashlet: function() {
        if (!this.isManager && this.meta.config) {
            // FIXME: Dashlet's config page is rendered from meta.panels directly.
            // See the "dashletconfiguration-edit.hbs" file.
            this.meta.panels = _.chain(this.meta.panels).filter(function(panel) {
                panel.fields = _.without(panel.fields, _.findWhere(panel.fields, {name: 'visibility'}));
                return panel;
            }).value();
        }
        if (this.isForecastSetup && this.forecastsConfigOK) {
            this.settings.module = 'Forecasts';
        }
        var fieldOptions = app.lang.getAppListStrings(this.dashletConfig.dataset.options),
            cfg = app.metadata.getModule('Forecasts', 'config');
        this.dashletConfig.dataset.options = {};

        if (cfg.show_worksheet_worst &&
            app.acl.hasAccess('view', 'ForecastWorksheets', app.user.get('id'), 'worst_case')) {
            this.dashletConfig.dataset.options['worst'] = fieldOptions['worst'];
        }

        if (cfg.show_worksheet_likely) {
            this.dashletConfig.dataset.options['likely'] = fieldOptions['likely'];
        }

        if (cfg.show_worksheet_best &&
            app.acl.hasAccess('view', 'ForecastWorksheets', app.user.get('id'), 'best_case')) {
            this.dashletConfig.dataset.options['best'] = fieldOptions['best'];
        }

        // Hide dataset drop-down if there is only one option.
        this.dashletConfig.show_dataset = true;
        if (_.size(this.dashletConfig.dataset.options) <= 1) {
            this.dashletConfig.show_dataset = false;
        }
    },

    /**
     * Callback function for Forecasts/init success
     */
    forecastInitCallback: function(initData) {
        if (this.disposed) {
            return;
        }
        var defaultOptions = {
            user_id: app.user.get('id'),
            // Default to 'user' view for reps, and 'group' view for managers.
            display_manager: this.isDisplayManager(),
            show_target_quota: (this.isManager && !this.isTopLevelManager),
            selectedTimePeriod: initData.defaultSelections.timeperiod_id.id,
            timeperiod_id: initData.defaultSelections.timeperiod_id.id,
            timeperiod_label: initData.defaultSelections.timeperiod_id.label,
            dataset: initData.defaultSelections.dataset,
            group_by: initData.defaultSelections.group_by,
            ranges: _.keys(app.lang.getAppListStrings(this.forecastConfig.buckets_dom))
        };

        var model = this._getNonForecastModel();

        if (model && !this.displayTimeperiodPivot && model.has('date_closed_timestamp') &&
            model.get('date_closed_timestamp') != 0) {
            // if we have a timestamp, use it, otherwise just default to the current time period
            defaultOptions.timeperiod_id = model.get('date_closed_timestamp');
        } else {
            this.layout.setTitle(this.getLabel() + ' ' + defaultOptions.timeperiod_label);
        }
        this.settings.set(defaultOptions);
    },

    /**
     * Overwrite loadData so the default behavior doesn't happen
     *
     * @override
     */
    loadData: function(options) {
        if (options && _.isFunction(options.complete)) {
            options.complete();
        }
    },

    _render: function() {
        this.settings.set('display_manager', this.isDisplayManager());
        this.spanSize = this.displayTimeperiodPivot && this.dashletConfig.show_dataset ? 'span4' : 'span6';
        this._super('_render');

        var chartField = this.getField('paretoChart');

        if (!_.isUndefined(chartField)) {
            chartField.renderChart();
            chartField.once('chart:pareto:rendered', function() {
                if (this.opportunitiesWithRevenueLineItems &&
                    this.context.get('module') == 'RevenueLineItems') {
                    this.addRowToChart();
                } else {
                    this.addRowToChart();
                }
            }, this);
        }
    },

    /**
     * Called after _render
     */
    toggleRepOptionsVisibility: function() {
        var mgrToggleOffset;
        if (this.settings.get('display_manager') === true) {
            mgrToggleOffset = 6;
            this.$el.find('div.groupByOptions').addClass('hide');
        } else {
            mgrToggleOffset = 3;
            this.$el.find('div.groupByOptions').removeClass('hide');
        }

        if (this.displayTimeperiodPivot) {
            mgrToggleOffset = mgrToggleOffset - 3;
        }

        if (this.isManager) {
            var el = this.$el.find('#' + this.cid + '-mgr-toggle');
            if (el.length > 0) {
                var classes = el.attr('class').split(' ').filter(function(item) {
                    return item.indexOf('offset') === -1 ? item : '';
                });
                if (mgrToggleOffset != 0) {
                    classes.push('offset' + mgrToggleOffset);
                }
                el.attr('class', classes.join(' '));
            }
        }
    },

    /**
     * @inheritdoc
     *
     * Additional logic on switch visibility event.
     */
    visibilitySwitcher: function(event) {
        var activeVisibility;
        this.settings.set({
            display_manager: this.isDisplayManager(),
            show_target_quota: (this.isDisplayManager() && !this.isTopLevelManager)
        });
        if (!this.isManager) {
            return;
        }
        activeVisibility = this.getVisibility();
        this.$el.find('[data-action=visibility-switcher]')
            .attr('aria-pressed', function() {
                return $(this).val() === activeVisibility;
            });
    },

    /**
     * Calculates "display_manager" option according to visibility.
     *
     * @return {Boolean}
     */
    isDisplayManager: function() {
        return this.isManager ? (this.getVisibility() === 'group') : false;
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        // on the off chance that the init has not run yet.
        var meta = this.meta || this.initOptions.meta;
        if (meta.config) {
            return;
        }

        // if we don't have a context, this shouldn't run yet.
        if (_.isUndefined(this.context)) {
            return;
        }

        if (this.isForecastSetup && this.forecastsConfigOK) {
            this.on('render', function() {
                var chartField = this.getField('paretoChart'),
                    dashletToolbar = this.layout.getComponent('dashlet-toolbar');

                // if we have a dashlet-toolbar, then make it do the refresh icon
                // while the chart is loading from the server
                if (chartField && dashletToolbar) {
                    chartField.before('chart:pareto:render', function() {
                        this.$('[data-action=loading]').removeClass(this.cssIconDefault).addClass(this.cssIconRefresh);
                    }, dashletToolbar);
                    chartField.on('chart:pareto:rendered', function() {
                        this.$('[data-action=loading]').removeClass(this.cssIconRefresh).addClass(this.cssIconDefault);
                    }, dashletToolbar);
                }
            }, this);

            this.settings.on('change:title', function(model, title) {
                this.layout.setTitle(this.getLabel() + title);
            }, this);

            this.settings.on('change:display_manager', this.toggleRepOptionsVisibility, this);

            if (!this.displayTimeperiodPivot) {
                this.findModelToListen();
                this.listenModel.on('change', this.handleDataChange, this);
            } else {
                this.settings.on('change:selectedTimePeriod', function(context, timeperiod) {
                    this.settings.set({timeperiod_id: timeperiod});
                }, this);
            }
        }
    },

    findModelToListen: function() {
        this.listenModel = this._getNonForecastModel();
        if (this.opportunitiesWithRevenueLineItems) {
            // now that this context is set to the forecast module, we should use the parent context if it exists
            // if it doesn't then we use the context on this dashlet
            var context = this.context.parent || this.context;
            if (context.get('module') == 'Opportunities') {
                // we need to watch for when the date changes time periods on the opportunity to re-render the chart
                this._getNonForecastModel().on('change:date_closed_timestamp', function(model, changed) {
                    this.settings.set('timeperiod_id', changed);
                }, this);
                // since we are forecasting by RLI but on the Opp Module, we need to find the subpanel for RLI to watch
                // for the changes there
                var ctx = _.find(context.children, function(child) {
                    return (child.get('module') == 'RevenueLineItems');
                });
                if (ctx && ctx.has('collection')) {
                    this.listenModel = ctx.get('collection');
                }
            }
        }
    },

    /**
     * Utility Method to find the proper model to use, if this.model.module is forecasts, go up to the parent context
     * and use the model that's attached to it otherwise return this.model
     *
     * @return {Backbone.Model|Data.Bean}
     * @private
     */
    _getNonForecastModel: function() {
        if (this.model.module == 'Forecasts') {
            return this.context.parent.get('model');
        }

        return this.model;
    },

    /**
     * Handler for when the model changes
     * @param {Object} [model]      The model that changed, if not provided, it will use this.model
     */
    handleDataChange: function(model) {
        model = model || this._getNonForecastModel();
        var changed = model.changed,
            changedField = _.keys(changed),
            validChangedFields = _.intersection(this.validChangedFields, _.keys(changed)),
            changedCurrencyFields = _.intersection(
                ['amount', 'best_case', 'likely_case', 'worst_case'],
                validChangedFields
            ),
            assigned_user = model.get('assigned_user_id');

        // lets make sure that the values actually changed on the currencies,
        // this is needed because the server will send back the values with out .00 on the end and the model has .00
        // so it looks like it changed, when in fact it didn't so don't worry about this change
        if (!_.isEmpty(changedCurrencyFields)) {
            _.each(changedCurrencyFields, function(field) {
                if (parseFloat(model.get(field)) == parseFloat(model.previous(field))) {
                    validChangedFields = _.without(validChangedFields, field);
                }
            });
        }

        // dump out if it's not a field we are watching
        if (_.isEmpty(validChangedFields)) {
            return;
        }

        if (this.settings.get('display_manager') === false && assigned_user == app.user.get('id')) {
            // we can update this chart
            // get what we are currently filtered by
            // find the item in the serverData
            var field = this.getField('paretoChart'),
                serverData = field.getServerData();

            if (!field.hasServerData()) {
                // if the field does not have server data, that means it's re-rendering the chart already,
                // just bail out
                return;
            }

            // if we only have one changed field and it's the date_closed, lets map it to a timestamp.
            // this happens on the Opp -> RLI Subpanel since we don't have SugarLogic Support in ListViews
            if (changedField.length == 1 && changedField[0] == 'date_closed') {
                // convert this into the timestamp
                changedField.push('date_closed_timestamp');
                changed.date_closed_timestamp = Math.round(+app.date.parse(changed.date_closed).getTime() / 1000);
                model.set('date_closed_timestamp', changed.date_closed_timestamp, {silent: true});
            }

            // before we do anything, lets make sure that if the date_changed, make sure it's still in this range,
            // if it's not force the chart to update to the new timeperiod that is valid for this row, then add this
            // row to the new timeperiod
            if (_.contains(changedField, 'date_closed_timestamp')) {
                if (!(model.get('date_closed_timestamp') >= _.first(serverData['x-axis']).start_timestamp &&
                    model.get('date_closed_timestamp') <= _.last(serverData['x-axis']).end_timestamp)) {

                    // lets check to see, if we have a collection as the listenModel, then just remove the row if there
                    // is more than one record in the collection
                    if (this.listenModel instanceof Backbone.Collection) {
                        if (this.listenModel.length > 1) {
                            this.removeRowFromChart(model);
                            return;
                        }
                    }
                    // we just have a model, so lets just update it
                    field.once('chart:pareto:rendered', function() {
                        this[0].addRowToChart(this[1]);
                    }, [this, model]);
                    this.settings.set('timeperiod_id', model.get('date_closed_timestamp'));
                    return;
                }
            }

            // Amount on Opportunity maps to likely in the data set
            if (_.contains(changedField, 'amount')) {
                changed.likely = this._convertCurrencyValue(changed.amount, model.get('base_rate'));
                delete changed.amount;
            }
            // Likely Case in RLI
            if (_.contains(changedField, 'likely_case')) {
                changed.likely = this._convertCurrencyValue(changed.likely_case, model.get('base_rate'));
                delete changed.likely_case;
            }

            if (_.contains(changedField, 'best_case')) {
                changed.best = this._convertCurrencyValue(changed.best_case, model.get('base_rate'));
                delete changed.best_case;
            }
            if (_.contains(changedField, 'worst_case')) {
                changed.worst = this._convertCurrencyValue(changed.worst_case, model.get('base_rate'));
                delete changed.worst_case;
            }

            if (_.contains(changedField, 'commit_stage')) {
                changed.forecast = changed.commit_stage;
                delete changed.commit_stage;
            }

            var record = _.find(serverData.data, function(record, i, list) {
                if (model.get('id') == record.record_id) {
                    list[i] = _.extend({}, record, changed);
                    return true;
                }
                return false;
            });

            // the row was not found, lets add it
            if (_.isEmpty(record)) {
                this.addRowToChart(model);
            } else {
                field.setServerData(serverData, _.contains(changedField, 'probability'));
            }
        } else if (_.contains(changedField, 'assigned_user_id')) {
            if (assigned_user === app.user.get('id')) {
                this.addRowToChart(model);
            } else {
                this.removeRowFromChart(model);
            }
        }
    },

    /**
     * Add the model to the pareto chart
     * @param {Object} [model]      The Model to add, if not passed in, it will use this.model
     */
    addRowToChart: function(model) {
        model = model || this._getNonForecastModel();
        if (model.get('assigned_user_id') == app.user.get('id') && !this.settings.get('display_manager')) {
            var field = this.getField('paretoChart'),
                serverData = field.getServerData(),
            // make sure it doesn't exist in the serverdata
                found = _.find(serverData.data, function(record) {
                    return (record.record_id == model.get('id'));
                }),
                base_rate = model.get('base_rate'),
                likely_field = model.has('amount') ? model.get('amount') : model.get('likely_case');

            if (_.isEmpty(found)) {
                serverData.data.push({
                    best: this._convertCurrencyValue(model.get('best_case'), base_rate),
                    likely: this._convertCurrencyValue(likely_field, base_rate),
                    worst: this._convertCurrencyValue(model.get('worst_case'), base_rate),
                    record_id: model.get('id'),
                    date_closed_timestamp: model.get('date_closed_timestamp'),
                    probability: model.get('probability'),
                    sales_stage: model.get('sales_stage'),
                    forecast: model.get('commit_stage')
                });
                field.setServerData(serverData, true);
            }
        }
    },

    /**
     * Utility Method to convert to base rate
     * @param {Number} value
     * @param {Number} base_rate
     * @return {Number}
     * @protected
     */
    _convertCurrencyValue: function(value, base_rate) {
        return app.currency.convertWithRate(value, base_rate);
    },

    /**
     * Get the server data from the ParetoField and if the model exists in the data, remove it
     *
     * @param {Object} [model]      The Model to add, if not passed in, it will use this.model
     */
    removeRowFromChart: function(model) {
        model = model || this._getNonForecastModel();
        var field = this.getField('paretoChart'),
            serverData = field.getServerData();

        _.find(serverData.data, function(record, i, list) {
            if (model.get('id') == record.record_id) {
                list.splice(i, 1);
                return true;
            }
            return false;
        });

        field.setServerData(serverData, true);
    },

    /**
     * @inheritdoc
     * Clean up!
     */
    unbindData: function() {
        var ctx = this.context.parent;
        if (ctx) {
            ctx.off(null, null, this);
        }
        if (this.listenModel) this.listenModel.off(null, null, this);
        if (this.context) this.context.off(null, null, this);
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Initialize plugins.
     * Only manager can toggle visibility.
     *
     * @return {BaseForecastParetoView} Instance of this view.
     * @protected
     */
    _initPlugins: function() {
        if (this.isManager) {
            this.plugins = _.union(this.plugins, [
                'ToggleVisibility'
            ]);
        }
        return this;
    }
}) },
"dupecheck-list-select": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListSelectView
 * @alias SUGAR.App.view.views.BaseDupecheckListSelectView
 * @extends View.Views.Base.DupecheckListView
 */
({
	// Dupecheck-list-select View (base) 

    extendsFrom: 'DupecheckListView',
    additionalTableClasses: 'duplicates-singleselect'
}) },
"flex-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FlexListView
 * @alias SUGAR.App.view.views.BaseFlexListView
 * @extends View.Views.Base.ListView
 */
({
	// Flex-list View (base) 

    extendsFrom: 'ListView',
    className: 'flex-list-view',
    // Model being previewed (if any)
    _previewed: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //Store left column fields
        this.leftColumns = [];
        //Store right column fields
        this.rightColumns = [];
        this.addActions();

        this.template = app.template.getView('flex-list');
        this.events = _.clone(this.events);

        /**
         * The last state key that contains the full list of fields displayable
         * in list views of this module.
         *
         * @property {string}
         * @protected
         */
        this._allListViewsFieldListKey = app.user.lastState.buildKey('field-list', 'list-views', this.module);

        /**
         * The last state key that contains the visible state of the fields and
         * their position in the table for this specific view.
         *
         * @property {string}
         * @protected
         */
        this._thisListViewFieldListKey = app.user.lastState.key('visible-fields', this);

        if (this.meta.sticky_resizable_columns) {
            /**
             * The last state key that contains the user defined column widths
             * for this specific view.
             *
             * @property {string}
             * @protected
             */
            this._thisListViewFieldSizesKey = app.user.lastState.key('width-fields', this);
        }

        this._fields = this.parseFields();

        this.addPreviewEvents();

        //add debounce in initialize so that subclasses will not all use the same prototype function
        this.resize = _.bind(_.debounce(this.resize, 200), this);
        this.bindResize();

        var rightColumnsEvents = {};
        //add an event delegate for right action dropdown buttons onclick events
        if (this.rightColumns.length) {
            rightColumnsEvents = {
                'hidden.bs.dropdown .actions': 'resetDropdownDelegate',
                'shown.bs.dropdown .actions': 'delegateDropdown',
                'shown.bs.dropdown .morecol': '_toggleAria',
                'hidden.bs.dropdown .morecol': '_toggleAria'
            };
        }

        this.events = _.extend(rightColumnsEvents, this.events, {
            'click [data-widths=reset]': 'resetColumnWidths',
            'click [data-columns-order=reset]': 'resetColumnOrder'
        });

        this.on('list:reorder:columns', this.reorderCatalog, this);
        this.on('list:toggle:column', this.saveCurrentState, this);
        this.on('list:save:laststate', this.saveCurrentState, this);
        this.on('list:column:resize:save', this.saveCurrentWidths, this);
        this.on('list:scrollLock', this.scrollLock, this);
    },

    // fn to turn off event listeners and reenable tooltips
    resetDropdownDelegate: function(e) {
        this.$el.removeClass('no-touch-scrolling');
        var $b = this.$(e.currentTarget).first();
        $b.parent().closest('.list').removeClass('open');
        $b.off('resetDropdownDelegate.right-actions');
    },

    delegateDropdown: function(e) {
        var $buttonGroup = this.$(e.currentTarget).first(), // the button group
            windowHeight = $(window).height() - 65; // height of window less padding

        // fn to detect menu colliding with window bottom
        var needsDropupClass = function($b) {
                var menuHeight = $b.height() + $b.children('ul').first().height();
                return (
                     windowHeight < $b.offset().top + menuHeight
                );
            };

        this.$el.addClass('no-touch-scrolling');
        // add open class to parent list to elevate absolute z-index for iOS
        $buttonGroup.parent().closest('.list').addClass('open');
        // detect window bottom collision
        $buttonGroup.toggleClass('dropup', needsDropupClass($buttonGroup));
        // listen for delegate reset
        $buttonGroup.on('resetDropdownDelegate.right-actions', this.resetDropdownDelegate);
        // add a listener to scrolling container
        $buttonGroup.parents('.main-pane')
            .on('scroll.right-actions', _.bind(_.debounce(function() {
                // detect window bottom collision on scroll
                $buttonGroup.toggleClass('dropup', needsDropupClass($buttonGroup));
            }, 30), this));
    },

    /**
     * Sets a button accessibility class 'aria-expanded' to true or false
     * depending on if the dropdown menu is open or closed.
     *
     * @param {Event} provides the needed currentTarget
     * @private
     */
    _toggleAria: function(e) {
        var $dropdown = this.$(e.currentTarget).find('.dropdown'),
            $button = $dropdown.find('[data-toggle="dropdown"]');
        $button.attr('aria-expanded', $dropdown.hasClass('open'));
    },

    addPreviewEvents: function () {
        //When clicking on eye icon, we need to trigger preview:render with model&collection
        this.context.on("list:preview:fire", function (model) {
            app.events.trigger("preview:render", model, this.collection, true);
        }, this);

        //When switching to next/previous record from the preview panel, we need to update the highlighted row
        app.events.on("list:preview:decorate", this.decorateRow, this);
        if (this.layout) {
            this.layout.on("list:sort:fire", function () {
                //When sorting the list view, we need to close the preview panel
                app.events.trigger("preview:close");
            }, this);
            this.layout.on("list:paginate:success", function () {
                //When fetching more records, we need to update the preview collection
                app.events.trigger("preview:collection:change", this.collection);
                // If we have a model in preview, redecorate the row as previewed
                if (this._previewed) {
                    this.decorateRow(this._previewed);
                }
            }, this);
        }
    },

    /**
     * Parse fields to identify which fields are visible and which fields are
     * hidden.
     *
     * In practice, it creates a catalog that lists the fields that are
     * visible (user configuration if exists, otherwise default metadata
     * configuration) and all the fields (no matter their visible state) used to
     * populate the ellipsis dropdown.
     *
     * By default the catalog is sorted by the order defined in the metadata. If
     * user configuration is found, the catalog is sorted per user preference.
     *
     * @return {Object} The catalog object.
     */
    parseFields: function() {
        var fields = _.flatten(_.pluck(this.meta.panels, 'fields'));

        /**
         * The default order of the fields.
         *
         * @property {string[]}
         * @private
         */
        this._defaultFieldOrder = _.pluck(fields, 'name');
        var catalog = this._createCatalog(fields);

        /**
         * The custom order of the fields.
         *
         * See {@link #_getFieldsLastState}.
         *
         * @property {string[]}
         * @private
         */
        this._thisListViewFieldList = this._getFieldsLastState();

        if (this._thisListViewFieldList) {
            catalog = this._toggleFields(catalog, this._thisListViewFieldList, false);
            catalog = this.reorderCatalog(catalog, this._thisListViewFieldList.position, false);
        }
        return catalog;
    },

    /**
     * Retrieves the user configuration from the cache.
     *
     * The cached value changed in 7.2. In an entry is found in the local
     * storage and is at the wrong format, the value is converted to the new
     * format. If no entry found, or the entry has an unexpected format, it
     * throws an exception and return undefined.
     *
     * @return {Object/undefined} An object whom keys are field names, and
     * values are an object containing the position and the visible state,
     * or `undefined` in case of failure.
     *
     * @private
     */
    _getFieldsLastState: function() {
        if (!this._thisListViewFieldListKey) {
            return;
        }
        var data = app.user.lastState.get(this._thisListViewFieldListKey);
        if (_.isUndefined(data)) {
            return;
        }
        if (!_.isArray(data) || _.isEmpty(data)) {
            app.logger.error('The format of "' + this._thisListViewFieldListKey + '" is unexpected, skipping.');
            return;
        }
        if (_.isString(data[0])) {
            // Old format detected.
            return this._convertFromOldFormat(data);
        }
        return this._decodeCacheData(data);
    },

    /**
     * Create an object that contains 2 keys. Each key is associated to an array
     * that contains the field metadata.
     * List of keys:
     * - `visible` lists fields user wants to see,
     * - `all` lists all the fields, with a `selected` attribute that indicates
     * their visible state (used to populate the ellipsis dropdown).
     *
     * @param {Array} fields The list of field definition for this view.
     * @return {Object} The catalog object.
     * @private
     */
    _createCatalog: function(fields) {
        var catalog = {};
        catalog._byId = {};
        catalog.visible = [];
        catalog.all = [];

        _.each(fields, function(fieldMeta, i) {
            catalog._byId[fieldMeta.name] = this._patchField(fieldMeta, i);
        }, this);
        catalog.all = _.toArray(catalog._byId);
        catalog.visible = _.where(catalog.all, { selected: true });
        return catalog;
    },

    /**
     * Patch a field metadata for this list view.
     *
     * Note that {@link View.FlexListView requires the attributes `selected` and
     * `position`} in order to work properly.
     *
     * @param {Object} fieldMeta The field metadata.
     * @param {Number} index The index of the field in the field list.
     * @return {Object} The patched metadata.
     * @private
     */
    _patchField: function(fieldMeta, index) {
        var isVisible = (fieldMeta['default'] !== false);
        return _.extend({
            selected: isVisible,
            position: index + 1
        }, fieldMeta);
    },

    /**
     * Take the existing catalog and toggle field visibility based on the last
     * state found in the cache.
     *
     * If for some reason, the field is not found at all in the cached data, it
     * fallbacks to the default visible state of that field (defined in the
     * metadata).
     *
     * @param {Object} catalog The catalog of fields.
     * @param {Object} fields The decoded cached data that contains fields
     * wanted visible and fields wanted hidden.
     * @param {Boolean} saveLastState(optional) `true` to save last state,
     * `false` otherwise. `true` by default.
     * @return {Object} The catalog with visible state of fields based on user
     * preference.
     * @private
     */
    _toggleFields: function(catalog, fields, saveLastState) {
        if (_.isEmpty(fields) || (_.isEmpty(fields.visible) && _.isEmpty(fields.hidden))) {
            return catalog;
        }
        saveLastState = _.isUndefined(saveLastState) ? true : saveLastState;
        _.each(fields.visible, function(fieldName) {
            var f = catalog._byId[fieldName];
            if (f) {
                f.selected = true;
            }
        }, this);
        _.each(fields.hidden, function(fieldName) {
            var f = catalog._byId[fieldName];
            if (f) {
                f.selected = false;
            }
        }, this);
        catalog.all = _.sortBy(_.toArray(catalog._byId), function(f) {
            return f.position;
        });
        catalog.visible = _.where(catalog.all, { selected: true });

        if (saveLastState) {
            this.trigger('list:save:laststate');
        }

        return catalog;
    },

    /**
     * Sort the catalog of fields per the list of field names passed as
     * argument.
     *
     * @param {Object} catalog Field definitions listed in 2 categories:
     * `visible` / `all`.
     * @param {Array} order Array of field names used to sort the catalog.
     * @param {Boolean} saveLastState(optional) `true` to save last state,
     * `false` otherwise. `true` by default.
     * @return {Object} catalog The catalog of fields entirely sorted.
     */
    reorderCatalog: function(catalog, order, saveLastState) {
        saveLastState = _.isUndefined(saveLastState) ? true : saveLastState;

        order = _.union(order, _.pluck(catalog.all, 'name'));

        _.each(order, function(fieldName, i) {
            var f = catalog._byId[fieldName];
            if (f) {
                f.position = ++i;
            }
        });
        catalog.all = _.sortBy(_.toArray(catalog._byId), function(f) {
            return f.position;
        });
        catalog.visible = _.where(catalog.all, { selected: true });

        if (saveLastState) {
            this.trigger('list:save:laststate');
        }

        return catalog;
    },

    /**
     * Takes the minimized value stored into the cache and decode it to make
     * it more readable and more manipulable.
     *
     *     @example
     *     If field storage entry is:
     *     <pre><code>
     *     [
     *         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'
     *     ]
     *     </code></pre>
     *     And encoded data is:
     *     <pre><code>
     *     [
     *         0, [1,5], [1,2], 0, [0,1], [1,3], 0, [1,4]
     *     ]
     *     </code></pre>
     *     The decoded data will be:
     *     <pre><code>
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         hidden: ['E'],
     *         position: ['E', 'C', 'B', 'F', 'H']
     *     }
     *     </code></pre>
     *     `visible` contains the list of visible fields,
     *     `hidden` contains the list of hidden fields,
     *     `position` is the order of fields,
     *     indexes whom value is `0` are skipped (fields not displayable).
     *
     * @param {Array} encodedData The minimized data.
     * @return {Object} The decoded data.
     * @private
     */
    _decodeCacheData: function(encodedData) {
        var decodedData = {
            visible: [],
            hidden: [],
            position: []
        };

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        _.each(encodedData, function(fieldArray, i) {
            if (!_.isArray(fieldArray)) {
                return;
            }
            var name = fieldList[i];
            if (fieldArray[0]) {
                decodedData.visible.push(name);
            } else {
                decodedData.hidden.push(name);
            }
            decodedData.position[fieldArray[1]] = name;
        });
        decodedData.position = _.difference(decodedData.position, [undefined]);
        return decodedData;
    },

    /**
     * Takes the decoded data and minimize it to save cache size.
     *
     *     @example
     *     If field storage entry is:
     *     <pre><code>
     *     [
     *         'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'
     *     ]
     *     </code></pre>
     *     And decoded data is:
     *     <pre><code>
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         hidden: ['E'],
     *         position: ['E', 'C', 'B', 'F', 'H']
     *     }
     *     </code></pre>
     *     The encoded data will be:
     *     <pre><code>
     *     [
     *         0, [1,5], [1,2], 0, [0,1], [1,3], 0, [1,4]
     *     ]
     *     </code></pre>
     *     `0` means the field is not displayable. (i.e: `A`, `D`, `G`),
     *     the first item is the visible state: `1` visible, `0` hidden,
     *     the second item of the array is the position of the field.
     *
     * @param {Object} decodedData The decoded data.
     * @return {Array} The minimized data.
     * @private
     */
    _encodeCacheData: function(decodedData) {
        var encodedData = [];

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        _.each(fieldList, function(fieldName) {
            var value = 0;
            if (_.contains(decodedData.position, fieldName)) {
                value = [
                    _.contains(decodedData.visible, fieldName) ? 1 : 0,
                    _.indexOf(decodedData.position, fieldName) + 1
                ];
            }
            encodedData.push(value);
        });
        return encodedData;
    },

    /**
     * Takes the decoded data and minimize it to save cache size.
     *
     * For example, if the field's storage entry is:
     *
     *     ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
     *
     * And the decoded data is:
     *
     *     {
     *         visible: ['B', 'C', 'E', 'F', 'H'],
     *         widths: [125, 50, 60, 150, 200]
     *     }
     *
     * The encoded data will be:
     *
     *     [0, 125, 50, 0, 60, 150, 0, 200]
     *
     * `0` means the field has no user defined width. (i.e: `A`, `D`, `G`)
     * This is either because the column is hidden, or not displayable in this
     * list view.
     *
     * @param {Object} decodedData The decoded data.
     * @return {Array} The encoded data.
     * @private
     */
    _encodeCacheWidthData: function(decodedData) {
        var encodedData = [];

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        var visibleIndex = 0;
        _.each(fieldList, function(fieldName) {
            var value = 0;
            if (_.contains(decodedData.visible, fieldName)) {
                value = decodedData.widths[visibleIndex++];
            }
            encodedData.push(value);
        });
        return encodedData;
    },

    /**
     * Takes the minimized value stored in the cache and decodes it to make it
     * more readable and easier to manipulate.
     *
     * If the field's storage entry is:
     *
     *     ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
     *
     * And the encoded data is:
     *
     *     [0, 125, 50, 0, 60, 150, 0, 200]
     *
     * The decoded data will be:
     *
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         widths: [125, 50, 60, 150, 200]
     *     }
     *
     * - `visible` contains the list of visible fields,
     * - `widths` is the widths of fields, indexes whose value is `0` are
     * skipped (fields not being displayed).
     *
     * @param {Array} encodedData The minimized data.
     * @return {Object} The decoded data.
     * @private
     */
    _decodeCacheWidthData: function(encodedData) {
        var decodedData = {
            'visible': [],
            'widths': []
        };

        var fieldList = this._appendFieldsToAllListViewsFieldList();
        _.each(_.pluck(this._fields.visible, 'name'), function(fieldName) {
            var index = _.indexOf(fieldList, fieldName);
            var width = encodedData[index] || 0;
            decodedData.visible.push(fieldName);
            decodedData.widths.push(width);
        });
        return decodedData;
    },

    /**
     * Append the list of fields defined in the metadata that are missing in the
     * field storage cache entry.
     *
     * We initially used `_.uniq` to guarantee the unicity of fields. It appears
     * that this `underscore` method is slow, unlike `Lo-Dash` one. Meanwhile a
     * potential migration to Lo-Dash, it is faster to build an object whom keys
     * are field names.
     *
     * @return {Array} The list of all the fields that are displayable in list
     * views of this module.
     * @private
     */
    _appendFieldsToAllListViewsFieldList: function() {
        this._allListViewsFieldList = app.user.lastState.get(this._allListViewsFieldListKey) || [];
        var obj = {};
        _.each(this._allListViewsFieldList, function(fieldName) {
            obj[fieldName] = fieldName;
        });

        _.each(this.meta.panels, function(panel) {
            _.each(panel.fields, function(fieldMeta, i) {
                obj[fieldMeta.name] = fieldMeta.name;
            }, this);
        }, this);
        this._allListViewsFieldList = _.keys(obj);
        app.user.lastState.set(this._allListViewsFieldListKey, this._allListViewsFieldList);
        return this._allListViewsFieldList;
    },

    /**
     * Converts the old localStorage data for fields visibility to the new
     * decoded format.
     *
     * {@link View.FlexListView#_encodeCacheData To see how the new format looks like.}
     *
     *     @example Only visible fields used to be stored. Example of data stored:
     *     <pre><code>
     *     [
     *         'B', 'C', 'F', 'H'
     *     ]
     *     </code></pre>
     *     If the list of fields defined in the metadata was:
     *     <pre><code>
     *     [
     *         'E', 'C', 'B', 'F', 'H'
     *     ]
     *     </code></pre>
     *     The decoded data would be:
     *     <pre><code>
     *     {
     *         visible: ['B', 'C', 'F', 'H'],
     *         hidden: ['E'],
     *         position: ['E', 'C', 'B', 'F', 'H']
     *     }
     *     </code></pre>
     *
     * @return {Array} The data converted to the new decoded format.
     * @private
     */
    _convertFromOldFormat: function(visibleFieldList) {
        var thisViewFieldList = _.reduce(_.map(this.meta.panels, function(panel) {
            return _.pluck(panel.fields, 'name');
        }), function(memo, field) {
            return memo.concat(field);
        }, []);

        var decoded = {
            visible: [],
            hidden: [],
            position: []
        };
        _.each(thisViewFieldList, function(fieldName, i) {
            if (_.contains(visibleFieldList, fieldName)) {
                decoded.visible.push(fieldName);
            } else {
                decoded.hidden.push(fieldName);
            }
            decoded.position.push(fieldName);
        });
        app.user.lastState.set(this._thisListViewFieldListKey, this._encodeCacheData(decoded));
        return decoded;
    },

    /**
     * Save to the cache the current order of fields, and their visible state.
     *
     *     @example Example of value stored in the cache:
     *     <pre><code>
     *     [
     *         ['A', 'B', 'D', 'C'],
     *         [0, 1, 0, 1]
     *     ]
     *     </code></pre>
     * Means the current order is `ABDC`, and only `B` and `C` are visible
     * fields.
     */
    saveCurrentState: function() {
        if (!this._thisListViewFieldListKey) {
            return;
        }
        var allFields = _.pluck(this._fields.all, 'name'),
            visibleFields = _.pluck(this._fields.visible, 'name');
        var decoded = {
            visible: visibleFields,
            hidden: _.difference(allFields, visibleFields),
            position: allFields
        };
        app.user.lastState.set(this._thisListViewFieldListKey, this._encodeCacheData(decoded));
        this._thisListViewFieldList = this._getFieldsLastState();
    },

    /**
     * Add actions to left and right columns
     */
    addActions: function() {
        var meta = this.meta;
        if (_.isObject(meta.selection)) {
            this.isSearchAndSelectAction = meta.selection.isSearchAndSelectAction;
            switch (meta.selection.type) {
                case 'single':
                    this.addSingleSelectionAction();
                    break;
                case 'multi':
                    this.addMultiSelectionAction();
                    break;
                default:
                    break;
            }
        }
        if (meta && _.isObject(meta.rowactions)) {
            this.addRowActions();
        }
    },
    /**
     * Add single selection field to left column
     */
    addSingleSelectionAction: function () {
        var _generateMeta = function (name, label) {
            return {
                'type': 'selection',
                'name': name,
                'sortable': false,
                'label': label || ''
            };
        };
        var def = this.meta.selection;
        this.leftColumns.push(_generateMeta(def.name || this.module + '_select', def.label));
    },
    /**
     * Add multi selection field to left column
     */
    addMultiSelectionAction: function() {
        var _generateMeta = function(buttons, disableSelectAllAlert) {
            return {
                'type': 'fieldset',
                'fields': [
                    {
                        'type': 'actionmenu',
                        'buttons': buttons || [],
                        'disable_select_all_alert': !!disableSelectAllAlert
                    }
                ],
                'value': false,
                'sortable': false
            };
        };
        var buttons = this.meta.selection.actions;
        var disableSelectAllAlert = !!this.meta.selection.disable_select_all_alert;
        this.leftColumns.push(_generateMeta(buttons, disableSelectAllAlert));
    },
    /**
     * Add fieldset of rowactions to the right column
     */
    addRowActions: function() {
        var _generateMeta = function(label, css_class, buttons) {
            return {
                'type': 'fieldset',
                'fields': [
                    {
                        'type': 'rowactions',
                        'label': label || '',
                        'css_class': css_class,
                        'buttons': buttons || []
                    }
                ],
                'value': false,
                'sortable': false
            };
        };
        var def = this.meta.rowactions;
        this.rightColumns.push(_generateMeta(def.label, def.css_class, def.actions));
    },
    /**
     * Decorate a row in the list that is being shown in Preview
     * @param model Model for row to be decorated.  Pass a falsy value to clear decoration.
     */
    decorateRow: function (model) {
        // If there are drawers, make sure we're updating only list views on active drawer.
        if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            this._previewed = model;
            this.$('.btn.rowaction.active').removeClass('active').attr('aria-pressed', false);
            this.$('tr.highlighted').removeClass('highlighted current');
            if (model) {
                var rowName = model.module + "_" + model.id;
                var curr = this.$('tr[name="' + rowName + '"]');
                curr.addClass('current highlighted');
                this.$('tr.current .btn.rowaction[data-event="list:preview:fire"]')
                    .addClass('active')
                    .attr('aria-pressed', true);
            }
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this.colSpan = this._fields.visible.length || 0;
        if (this.leftColumns.length) {
            this.colSpan++;
        }
        if (this.rightColumns.length) {
            this.colSpan++;
        }
        if (this.colSpan < 2) {
            this.colSpan = null;
        }
        this._super('_renderHtml');

        if (this.leftColumns.length) {
            this.$el.addClass('left-actions');
        }
        if (this.rightColumns.length) {
            this.$el.addClass('right-actions');
        }

        var displayWidthSetting = this._thisListViewFieldSizes ||
            !_.isUndefined(app.user.lastState.get(this._thisListViewFieldSizesKey));
        var displayOrderSetting = false;
        if (this._thisListViewFieldList) {
            var customOrder = _.union(this._thisListViewFieldList.position, this._defaultFieldOrder);
            displayOrderSetting = !_.isEqual(customOrder, this._defaultFieldOrder);
        }
        this._toggleSettings('widths', displayWidthSetting);
        this._toggleSettings('order', displayOrderSetting);

        this.resize();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // FIXME SC-3484 Testing `this.closestComponent('sidebar')` is required
        // to make unit tests pass.
        if (this.closestComponent('sidebar') && !(app.drawer.count())) {
                this._setHelperScrollBar();
        }
    },

    /**
     * Sets up the helper scrollbar.
     *
     * It first sets the helper `scrollWidth` and `width`. Then it adds
     * listeners on the spy and helper scrollbars to make them follow each
     * other.
     * Then it adds a listener on the vertical scrolling to watch when the
     * bottom of the table is visible, and when it is, to hide the helper since
     * the scrollbar at the bottom of the table is visible.
     *
     * @private
     */
    _setHelperScrollBar: function() {
        /**
         * The 'helper' scrollbar is the horizontal scrollbar fixed to the
         * bottom of the screen.
         *
         * @property {jQuery}
         */
        this.$helper = this.$('[data-scroll-spy]');

        // if no helper was found, just go about our way and not produce any javascript errors
        if (this.$helper.length === 0) {
            return;
        }

        /**
         * The `spy` is the list container element.
         *
         * @property {jQuery}
         */
        this.$spy = this.$('.' + this.$helper.data('scrollSpy'));

        this.$helper.find('div').width(this.$spy.get(0).scrollWidth);
        this._updateHelperWidth();
        this.listenTo(this.closestComponent('sidebar'), 'sidebar:toggle', _.bind(this._updateHelperWidth, this));

        this.$helper.on('scroll.' + this.cid, _.bind(function() {
            this.$spy.scrollLeft(this.$helper.scrollLeft());
        }, this));
        this.$spy.on('scroll.' + this.cid, _.bind(function() {
            this.$helper.scrollLeft(this.$spy.scrollLeft());
        }, this));

        // `#content` is the scrolling element in responsive view.
        $('#content').on('scroll.' + this.cid, _.bind(function() {
            this._toggleScrollHelper();
        }, this));

        // `.main-pane` is the scrolling element in desktop view.
        $('.main-pane').on('scroll.' + this.cid, _.bind(function() {
            this._toggleScrollHelper();
        }, this));
    },

    /**
     * Toggles the helper scroll bar.
     *
     * If the spy's `width` is greater than its `scrollWidth` (the screen is
     * large enough) OR if the footer is higher than the table (the table is not
     * visible on the screen), we hide the helper scrollbar.
     * Also, we hide it if the bottom of the table is higher than the footer
     * (the natural scroll bar is present).
     *
     * @private
     */
    _toggleScrollHelper: function() {
        if (this.$spy.get(0).scrollWidth <= this.$spy.width() ||
            this.$('tbody').offset().top + this.$helper.height() > $('footer').offset().top
        ) {
            this.$helper.toggle(false);
            return;
        }

        this.$helper.toggle(!(this.$('.scrollbar-landmark').offset().top < $('footer').offset().top));
        if (this.$helper.css('display') !== 'none') {
            this.$helper.scrollLeft(this.$spy.scrollLeft());
        }
    },

    /**
     * Updates the helper scrollbar width depending on whether dashboard is
     * open or not.
     *
     * @private
     */
    _updateHelperWidth: function() {
        if (this.$helper.length === 0) {
            return;
        }
        this.$helper.toggleClass('dash-collapsed', !$('.side.sidebar-content').is(':visible'));
    },

    /**
     * Saves the current field widths in {@link #_thisListViewFieldSizes}.
     *
     * If the stickiness is enabled, it also saves the widths into the cache,
     * so that the next time the view is loaded, the user retrieves his
     * preferred widths.
     *
     * Example of a value stored in the cache:
     *
     *     [125, 0, 52, 115, 0, 0, 51]
     *
     * Represents the current widths of fields `ABCDEF`, but no width has been
     * defined for fields `B`, `E` and `F` (because they were hidden or not
     * displayable).
     *
     * @param {Array} columns The widths of the current visible fields.
     */
    saveCurrentWidths: function(columns) {
        // Needed in order to fix the scroll helper whenever the widths change.
        this.resize();
        if (!this._thisListViewFieldListKey) {
            return;
        }
        var visibleFields = _.pluck(this._fields.visible, 'name');
        var decoded = {
            visible: visibleFields,
            widths: columns
        };
        var encoded = this._encodeCacheWidthData(decoded);
        this._toggleSettings('widths', true);

        /**
         * The list of user defined column widths for this specific view.
         *
         * @property {Array}
         * @protected
         */
        this._thisListViewFieldSizes = encoded;

        if (this._thisListViewFieldSizesKey) {
            app.user.lastState.set(this._thisListViewFieldSizesKey, encoded);
        }
    },

    /**
     * Resets the column widths to the default settings.
     *
     * If the stickiness is enabled, it also removes the entry from the cache.
     */
    resetColumnWidths: function() {
        this._thisListViewFieldSizes = null;
        if (this._thisListViewFieldSizesKey) {
            app.user.lastState.remove(this._thisListViewFieldSizesKey);
        }
        if (!this.disposed) {
            this.render();
            this._toggleSettings('widths', false);
        }
    },

    /**
     * Resets the column order to the default settings.
     */
    resetColumnOrder: function() {
        var fields = _.flatten(_.pluck(this.meta.panels, 'fields'));
        this._fields = this._createCatalog(fields);
        this.saveCurrentState();
        if (this.disposed) {
            return;
        }
        this.render();
    },

    /**
     * Shows, or hides, the reset setting option from the settings dropdown.
     *
     * @param {string} category The setting to show or hide.
     * @param {boolean} show `true` to show it, `false` to hide it.
     * @private
     */
    _toggleSettings: function(category, show) {
        this.$('li[data-settings-li=' + category + ']').toggle(show);
    },

    /**
     * Gets the list of widths for each visible field in the list view.
     *
     * If the stickiness is enabled, it will look for the entry in the cache.
     *
     * @return {Array} The list of widths if found, `undefined` otherwise.
     */
    getCacheWidths: function() {
        var encodedData = this._thisListViewFieldSizes ||
            app.user.lastState.get(this._thisListViewFieldSizesKey);
        if (!encodedData) {
            return;
        }
        return this._decodeCacheWidthData(encodedData).widths;
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        $('#content, .main-pane').off('scroll.' + this.cid);
        $(this).parents('.main-pane').off('scroll.right-actions');
        this.$('.flex-list-view .actions').trigger('resetDropdownDelegate.right-actions');
        $(window).off('resize.flexlist-' + this.cid);

        if (this.$helper) {
            this.$helper.off('scroll.' + this.cid);
        }
        if (this.$spy) {
            this.$spy.off('scroll.' + this.cid);
        }

        this._super('unbind');
    },

    bindResize: function() {
        $(window).on("resize.flexlist-" + this.cid, _.bind(this.resize, this));
    },

    /**
     * Temporarily overwrites the css from the .scroll-width class so that
     * row field dropdown menues aren't clipped by overflow-x property.
     */
    scrollLock: function(lock) {
        var $content = this.$('.flex-list-view-content');
        if (lock) {
            $content.css({'overflow-y': 'visible', 'overflow-x': 'hidden'});
        } else {
            $content.removeAttr('style');
        }
    },

    /**
     * Updates the class of this flex list as scrollable or not, and
     * adjusts/toggles the scroll helper.
     */
    resize: function() {
        if (this.disposed) {
            return;
        }
        var $content = this.$('.flex-list-view-content');
        if (!$content.length) {
            return;
        }
        var toggle = $content.get(0).scrollWidth > $content.width() + 1;
        this.$el.toggleClass('scroll-width', toggle);

        if (this.$helper && this.$helper.length > 0) {
            this.$helper.find('div').width(this.$spy.get(0).scrollWidth);
            this._toggleScrollHelper();
        }
    }
}) },
"pii-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PiiHeaderpaneView
 * @alias SUGAR.App.view.views.BasePiiHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Pii-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=close_button]': 'close'
    },

    /**
     * @inheritdoc
     *
     * Initialize and bind close drawer shortcut keys.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        app.shortcuts.register({
            id: 'PiiHeaderPanel:Close',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $closeButton = this.$('a[name=close_button]');
                if ($closeButton.is(':visible') && !$closeButton.hasClass('disabled')) {
                    $closeButton.click();
                }
            }
        });
    },

    /**
     * Closes the drawer.
     */
    close: function() {
        app.drawer.close();
    },

    /**
     * @override
     *
     * Overriding to show record name on title header if it is available;
     * if not, use the standard title.
     */
    _formatTitle: function(title) {
        var model = this.context.parent.get('model');
        var recordName = app.utils.getRecordName(model);
        if (recordName) {
            return app.lang.get('TPL_DATAPRIVACY_PII_TITLE', model.module, {name: recordName});
        } else if (title) {
            return app.lang.get(title, this.module);
        } else {
            return '';
        }
    }
}) },
"massupdate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassupdateView
 * @alias SUGAR.App.view.views.BaseMassupdateView
 * @extends View.View
 */
({
	// Massupdate View (base) 

    events: {
        'click [data-action="add"]' : 'addItem',
        'click [data-action="remove"]' : 'removeItem',
        'click .btn[name=update_button]' : 'saveClicked',
        'click .btn.cancel_button' : 'cancelClicked'
    },
    visible: false,
    fieldOptions: null,
    fieldValues: null,
    defaultOption: null,
    fieldPlaceHolderTag: '[name=fieldPlaceHolder]',
    massUpdateViewName: 'massupdate-progress',
    className: 'extend',

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} mass_delete_chunk_size Number of records per chunk while
     *   performing mass delete.
     * - {Number} mass_update_chunk_size Number of records per chunk while
     *   performing mass update.
     * - {Number} max_records_to_merge Default number of records we can merge.
     *
     * Example:
     * <pre><code>
     * // ...
     * 'settings' => array(
     *     'mass_delete_chunk_size' => 20,
     *     'mass_update_chunk_size' => 20,
     *     'max_records_to_merge' => 5,
     *     //...
     * ),
     * //...
     * </code></pre>
     *
     * If 'mass_delete_chunk_size' or 'mass_update_chunk_size' aren't supplied
     * default values fallback to 'app.config.massDeleteChunkSize' and
     * 'app.config.massUpdateChunkSize' respectively.
     *
     * @property {Object}
     * @protected
     */
    _defaultSettings: {
        max_records_to_merge: 5,
        mass_delete_chunk_size: 20,
        mass_update_chunk_size: 500
    },

    /**
     * @inheritdoc
     *
     * Try to find the `massupdate` template
     * falls back to `edit` when it does not exist
     */
    fallbackFieldTemplate: 'edit',

    /**
     * @inheritdoc
     * Retrieves metadata from sugarTemplate and then able to override it from
     * the core metadata. `panels` will only be supported on the core metadata.
     *
     * Each module can override the massupdate default metadata definitions.
     * To do this, please use the following path:
     * `{custom/,}modules/{module}/clients/{platform}/view/massupdate/massupdate.php`
     *
     * Core massupdate metadata (non-module based) doesn't support the `panels` and
     * `fields` properties, since we don't support generic default fields to be added.
     * Keep that in mind when defining your metadata on:
     * `{custom/,}clients/{platform}/view/massupdate/massupdate.php`
     */
    initialize: function(options) {
        var genericMeta = _.omit(app.metadata.getView(null, options.name), 'panels');
        options.meta = _.extend(
            {},
            genericMeta,
            options.meta
        );
        this.fieldValues = [{}];
        this.setMetadata(options);

        // FIXME massupdate shouldn't mess with the main context (should have own context)
        // this is a hack to prevent the massupdate fields to be added to the
        // context
        this.dataView = true;

        this._super('initialize', [options]);
        this._initSettings();

        this.setDefault();

        this.delegateListFireEvents();
        this.before('render', this.isVisible);

        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before("route", this.beforeRouteDelete, this);
        $(window).on("beforeunload.delete" + this.cid, _.bind(this.warnDeleteOnRefresh, this));
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseMassupdateView} Instance of this view.
     * @protected
     */
    _initSettings: function() {

        var configSettings = {};
        if (app.config.massActions) {
            if (app.config.massActions.massDeleteChunkSize) {
                configSettings.mass_delete_chunk_size = app.config.massActions.massDeleteChunkSize;
            }
            if (app.config.massActions.massUpdateChunkSize) {
                configSettings.mass_update_chunk_size = app.config.massActions.massUpdateChunkSize;
            }
        }

        this._settings = _.extend(
            {},
            this._defaultSettings,
            configSettings,
            this.meta && this.meta.settings || {}
        );

        return this;
    },

    delegateListFireEvents: function() {
        this.layout.on("list:massupdate:fire", this.show, this);
        this.layout.on("list:massaction:hide", this.hide, this);
        this.layout.on("list:massdelete:fire", this.warnDelete, this);
        this.layout.on("list:massexport:fire", this.massExport, this);
        this.layout.on("list:updatecalcfields:fire", this.updateCalcFields, this);
    },

    /**
     * Filter and patch the mass update fields.
     *
     * If the view definition contains an empty list of fields, it will pull all
     * the fields from the module metadata and add those with `massupdate = true`
     *
     * @param {Object} options The options object passed in 'initialize'.
     * @deprecated This will be removed on future versions.
     * Please see {@link view.fields.BaseBoolField} how you should define
     * your fields to be rendered on with a massupdate template.
     */
    //FIXME: remove this method when SC-2554 is implemented
    setMetadata: function(options) {
        var fieldList,
            massFields = [],
            metadataModule = app.metadata.getModule(options.module);
        if (!metadataModule) {
            app.logger.error('Failed to get module ' + options.module);
            return;
        }
        options.meta.panels = options.meta.panels || [{fields: []}];
        fieldList = metadataModule.fields;

        if (!_.isEmpty(options.meta.panels[0].fields)) {
            fieldList = _.map(options.meta.panels[0].fields, function(fieldDef) {
                var def = _.extend({}, fieldList[fieldDef.name], fieldDef);
                return def;
            });
        }
        _.each(fieldList, function(field) {
            // Only fields that are marked with massupdate set to true AND
            // that are not readonly should be used
            if (!field.massupdate || field.readonly) {
                return;
            }

            //we clone the metadata definition
            //to make sure we don't change the original metadata
            //FIXME we should not be faking metadata - (SC-2554)
            var cloneField = app.utils.deepCopy(field);
            cloneField.label = cloneField.label || cloneField.vname;
            if (cloneField.type === 'multienum') {
                cloneField.type = 'enum';
            }
            massFields.push(cloneField);
        });
        options.meta.panels[0].fields = massFields;
    },

    _render: function() {
        var result = app.view.View.prototype._render.call(this),
            self = this;

        if (this.$(".select2.mu_attribute")) {
            this.$(".select2.mu_attribute")
                .select2({
                    width: '100%',
                    minimumResultsForSearch: 5
                })
                .on("change", function(evt) {
                    var $el = $(this),
                        name = $el.select2('val'),
                        index = $el.data('index');
                    var option = _.find(self.fieldOptions, function(field){
                        return field.name == name;
                    });
                    self.replaceUpdateField(option, index);
                    self.placeField($el);
                });
            this.$(".select2.mu_attribute").each(function(){
                self.placeField($(this));
            });
        }

        if(this.fields.length == 0) {
            this.hide();
        }
        return result;
    },
    isVisible: function() {
        return this.visible;
    },
    placeField: function($el) {
        var name = $el.select2('val'),
            index = $el.data('index'),
            fieldEl = this.getField(name).$el;

        if($el.not(".disabled") && fieldEl) {
            var holder = this.$(this.fieldPlaceHolderTag + "[index=" + index + "]");
            this.$("#fieldPlaceHolders").append(holder.children());
            holder.html(fieldEl);
        }
    },
    addItem: function(evt) {
        if(!$(evt.currentTarget).hasClass("disabled")) {
            this.addUpdateField();
            // this will not be called in an async process so no need to
            // check for the view to be disposed
            this.render();
        }
    },
    removeItem: function(evt) {
        var index = $(evt.currentTarget).data('index');
        this.removeUpdateField(index);
        // this will not be called in an async process so no need to
        // check for the view to be disposed
        this.render();
    },
    addUpdateField: function() {
        this.fieldValues.splice(this.fieldValues.length - 1, 0, this.defaultOption);
        this.defaultOption = null;
        this.setDefault();
    },

    /**
     * Removes the field value at the provided index.
     *
     * @param {integer} index
     */
    removeUpdateField: function(index) {
        var fieldValue = this.fieldValues[index];

        if (_.isUndefined(fieldValue)) {
            return;
        }
        // If the fieldValue has a name, we need to remove it from the model and
        // the fieldValues object.
        if (fieldValue.name) {
            this.model.unset(fieldValue.name);
            // For relate fields, we need to clear fieldValue.id_name.
            // Note that if fieldValue.id_name is undefined, this is still safe.
            this.model.unset(fieldValue.id_name);
            this.fieldValues.splice(index, 1);
        // If the fieldValue does not have a name, reset the default option to
        // the last item, which should be empty
        } else {
            var removed = this.fieldValues.splice(index - 1, 1);
            this.defaultOption = removed[0];
        }

        // If there is a populate_list (i.e. this is a relate field)
        // clear the related data.
        // Fixme: This should be cleaned up on the relate field. See TY-651
        if (!_.isUndefined(fieldValue.populate_list)) {
            _.each(fieldValue.populate_list, function(key) {
                this.model.unset(key);
            }, this);
        }
        this.setDefault();
    },

    replaceUpdateField: function(selectedOption, targetIndex) {
        var fieldValue = this.fieldValues[targetIndex];

        if(fieldValue.name) {
            this.model.unset(fieldValue.name);
            this.fieldOptions.push(fieldValue);
            this.fieldValues[targetIndex] = selectedOption;
        } else {
            this.model.unset(this.defaultOption.name);
            this.fieldOptions.push(this.defaultOption);
            this.defaultOption = selectedOption;
        }
    },
    setDefault: function() {
        var assignedValues = _.pluck(this.fieldValues, 'name');
        if(this.defaultOption) {
            assignedValues = assignedValues.concat(this.defaultOption.name);
        }
        //remove the attribute options that has been already assigned
        this.fieldOptions = (this.meta) ? _.reject(_.flatten(_.pluck(this.meta.panels, 'fields')), function(field){
            return (field) ? _.contains(assignedValues, field.name) : false;
        }) : [];
        //set first item as default
        this.defaultOption = this.defaultOption || this.fieldOptions.splice(0, 1)[0];
    },

    /**
     * Create the Progress view unless it is initialized.
     * Return the progress view component in the same layout.
     *
     * @return {Backbone.View} MassupdateProgress view component.
     */
    getProgressView: function() {
        var progressView = this.layout.getComponent(this.massUpdateViewName);
        if (!progressView) {
            progressView = app.view.createView({
                context: this.context,
                type: this.massUpdateViewName,
                layout: this.layout
            });
            this.layout._components.push(progressView);
            this.layout.$el.append(progressView.$el);
        }
        progressView.render();
        return progressView;
    },

    /**
     * Create massupdate collection against the parent module.
     * Design the model synchronizing progressively.
     *
     * @param {String} baseModule parent module name.
     * @return {Backbone.Collection} Massupdate collection.
     */
    getMassUpdateModel: function(baseModule) {
        var massModel = this.context.get('mass_collection'),
            progressView = this.getProgressView(),
            massCollection = massModel ? _.extend({}, massModel, {
                defaultMethod: 'update',
                module: 'MassUpdate',
                baseModule: baseModule,

                /**
                 * Maximum number of retrial attempt.
                 *
                 * @property
                 */
                maxAllowAttempt: 3,

                /**
                 * Chunk for each execution.
                 *
                 * @property
                 */
                chunks: null,

                /**
                 * Discarded records due to the permission.
                 *
                 * @property
                 */
                discards: [],

                /**
                 * Current trial attempt number.
                 *
                 * @property
                 */
                attempt: 0,

                /**
                 * Pause status.
                 * If current job is on progress,
                 * the next queue will be paused.
                 *
                 * @property
                 */
                paused: false,

                /**
                 * Number of records per chunk, defaults to '20'.
                 *
                 * @property {Number} chunkSize Number of records.
                 * @protected
                 */
                 _chunkSize: 20,

                /**
                 * Number of update failures
                 *
                 * @property {Number} numFailures Number of failures.
                 * @protected
                 */
                 numFailures: 0,

                /**
                 * Set number of records per chunk.
                 *
                 * @param {Number} chunkSize Number of records.
                 */
                setChunkSize: function(chunkSize) {
                    this._chunkSize = parseInt(chunkSize, 10);
                },

                /**
                 * Reset mass job.
                 */
                resetProgress: function() {
                    massModel.reset();
                    this.length = 0;
                },

                /**
                 * Update current progress job.
                 */
                updateProgress: function() {
                    this.remove(this.chunks.splice(0));
                    massModel.length = this.length;
                },

                /**
                 * Update the next chunk queue.
                 */
                updateChunk: function() {
                    if (!this.chunks) {
                        this.chunks = this.slice(0, this._chunkSize);
                        this.trigger('massupdate:start');
                    }
                    if (_.isEmpty(this.chunks)) {
                        this.chunks = this.slice(0, this._chunkSize);
                    }
                },

                /**
                 * Resume the job from the previous paused status.
                 */
                resumeFetch: function() {
                    if (!this._pauseOptions) {
                        return;
                    }
                    this.paused = false;
                    this.trigger('massupdate:resume');
                    this.fetch(this._pauseOptions);
                },

                /**
                 * Request pausing mass job.
                 */
                pauseFetch: function() {
                    this.paused = true;
                },

                /**
                 * @inheritdoc
                 * Instead of fetching entire set,
                 * split entire set into small chunks
                 * and repeat fetching until entire set is completed.
                 */
                sync: function(default_method, model, options) {
                    if (model.paused) {
                        this._pauseOptions = options;
                        this.trigger('massupdate:pause');
                        return;
                    }
                    this.method = options.method;

                    //split set into chunks.
                    this.updateChunk();
                    var callbacks = {
                            success: function(data, response) {
                                model.numFailures += data.failed;
                                model.updateProgress();
                                model.trigger('massupdate:done');
                                if (model.length === 0) {
                                    model.trigger('massupdate:end');
                                    if (_.isFunction(options.success)) {
                                        //setting data to null since backbone reset will add the data object to the collection
                                        //using the respoonse as options for callback
                                        options.status = response.status;
                                        options.success();
                                    }
                                } else {
                                    model.fetch(options);
                                }
                            },
                            error: function(xhr) {
                                model.attempt++;
                                model.trigger('massupdate:fail');
                                if (model.attempt <= model.maxAllowAttempt) {
                                    model.fetch(options);
                                } else if (_.isFunction(options.error)) {
                                    model.trigger('massupdate:end');
                                    options.error(xhr);
                                }
                            },
                            complete: function(xhr) {
                                model.trigger('massupdate:always');
                                if (_.isFunction(options.complete)) {
                                    options.complete(xhr);
                                }
                            }
                    };
                    var method = options.method || this.defaultMethod;
                    var data = this.getAttributes(options.attributes, method);

                    if (_.isEmpty(data.massupdate_params.uid)) {
                        // No records to update, end the mass update.
                        model.trigger('massupdate:end');
                        return;
                    }
                    var url = app.api.buildURL(baseModule, this.module, data, options.params);
                    app.api.call(method, url, data, callbacks);
                },

                /**
                 * Convert collection attributes into MassUpdate API format.
                 * @param {Object} attributes Collection attributes.
                 * @return {Object} MassUpdate data format.
                 */
                getAttributes: function(attributes, action) {
                    return {
                        massupdate_params: _.extend({
                            'uid': this.getAvailableList(action)
                        }, attributes)
                    };
                },

                /**
                 * Check the access role for entire selection.
                 * Return only available model ids and store the discarded ids.
                 *
                 * @param action
                 * @return {Array} List of available model ids.
                 */
                getAvailableList: function(action) {
                    var action2permission = {
                            'update': 'edit',
                            'delete': 'delete'
                        },
                        list = [];
                    _.each(this.chunks, function(model) {
                        if (app.acl.hasAccessToModel(action2permission[action], model) !== false) {
                            list.push(model.id);
                        } else {
                            this.discards.push(model.id);
                        }
                    }, this);
                    return list;
                }
            }) : null;
        progressView.initCollection(massCollection);
        return massCollection;
    },

    /**
     * Popup dialog message to confirm delete action
     */
    warnDelete: function() {
        this._modelsToDelete = this.getMassUpdateModel(this.module);
        this._modelsToDelete.setChunkSize(this._settings.mass_delete_chunk_size);

        this._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (this._targetUrl !== this._currentUrl) {
            app.router.navigate(this._currentUrl, {trigger: false, replace: true});
        }

        this.hideAll();

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('NTC_DELETE_CONFIRMATION_MULTIPLE', this.module),
            onConfirm: _.bind(this.deleteModels, this),
            onCancel: _.bind(function() {
                app.analytics.trackEvent('click', 'mass_delete_cancel');
                this._modelsToDelete = null;
                app.router.navigate(this._targetUrl, {trigger: false, replace: true});
            }, this)
        });
    },

    /**
     * Popup browser dialog message to confirm delete action
     *
     * @return {String} the message to be displayed in the browser dialog
     */
    warnDeleteOnRefresh: function() {
        if (this._modelsToDelete) {
            return app.lang.get('NTC_DELETE_CONFIRMATION_MULTIPLE');
        }
    },

    /**
     * Delete the model once the user confirms the action
     */
    deleteModels: function() {
        var self = this,
            collection = self._modelsToDelete;
        var lastSelectedModels = _.clone(collection.models);

        app.analytics.trackEvent('click', 'mass_delete_confirm');
        if(collection) {
            // massupdate:end could be triggered without triggering success event on collection.
            // For example, when we user has no permissions to perform delete.
            // That's why we need to clear modelsToDelete when massupdate:end triggered too.
            collection.once('massupdate:end', function() {
                self._modelsToDelete = null;
            }, this);

            collection.fetch({
                //Don't show alerts for this request
                showAlerts: false,
                method: 'delete',
                error: function() {
                    app.alert.show('error_while_mass_update', {
                        level:'error',
                        title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                        messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                    });
                },
                success: function(data, response, options) {
                    self.layout.trigger("list:records:deleted", lastSelectedModels);
                    var redirect = self._targetUrl !== self._currentUrl;
                    if (options.status === 'done') {
                        //TODO: Since self.layout.trigger("list:search:fire") is deprecated by filterAPI,
                        //TODO: Need trigger for fetching new record list
                        self.layout.context.reloadData({showAlerts: false});
                    } else if (options.status === 'queued') {
                        app.alert.show('jobqueue_notice', {level: 'success', title: app.lang.get('LBL_MASS_UPDATE_JOB_QUEUED'), autoClose: true});
                    }
                    self._modelsToDelete = null;
                    if (redirect) {
                        self.unbindBeforeRouteDelete();
                        //Replace the url hash back to the current staying page
                        app.router.navigate(self._targetUrl, {trigger: true});
                    }
                }
            });
        }
    },

    /**
     * Pre-event handler before current router is changed
     *
     * @return {Boolean} true to continue routing, false otherwise
     */
    beforeRouteDelete: function () {
        if (this._modelsToDelete) {
            this.warnDelete(this._modelsToDelete);
            return false;
        }
        return true;
    },

    /**
     * Called to allow admins to resave records and update thier calculated fields.
     */
    updateCalcFields: function() {
        this.hideAll();
        this.save(true);
    },

    /**
     * Performs mass export on selected records
     */
    massExport: function() {
        this.hideAll();
        var massExport = this.context.get("mass_collection");

        if (massExport) {
            app.alert.show('massexport_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});

            app.api.exportRecords({
                    module: this.module,
                    uid: massExport.pluck('id')
                },
                this.$el,
                {
                    complete: function(data) {
                        app.alert.dismiss('massexport_loading');
                    }
                });
        }
    },

    /**
     * Called to start the massupdate process. Checks for validation errors
     * before sending down the modified attributes and starting the job queue.
     *
     * @param {Boolean} [forCalcFields=false] Causes the massupdate model to
     *   fetch with empty attributes, prior to saving the records.
     */
    save: function(forCalcFields) {
        forCalcFields = !!forCalcFields;
        var massUpdate = this.getMassUpdateModel(this.module),
            self = this;

        massUpdate.setChunkSize(this._settings.mass_update_chunk_size);

        this.once('massupdate:validation:complete', function(validate) {
            var errors = validate.errors,
                emptyValues = validate.emptyValues,
                confirmMessage = app.lang.get('LBL_MASS_UPDATE_EMPTY_VALUES'),
                attributes = validate.attributes || this.getAttributes();

            this.$(".fieldPlaceHolder .error").removeClass("error");
            this.$(".fieldPlaceHolder .help-block").hide();

            if (_.isEmpty(errors)) {
                confirmMessage += '<br>[' + emptyValues.join(',') + ']<br>' + app.lang.get('LBL_MASS_UPDATE_EMPTY_CONFIRM') + '<br>';
                if (massUpdate) {
                    var fetchMassupdate = _.bind(function() {
                        var successMessages = this.buildSaveSuccessMessages(massUpdate);
                        massUpdate.fetch({
                            //Show alerts for this request
                            showAlerts: true,
                            attributes: attributes,
                            error: function() {
                                app.alert.show('error_while_mass_update', {
                                    level: 'error',
                                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                                });
                            },
                            success: function(data, response, options) {
                                self.hide();
                                if (options.status === 'done') {
                                    //TODO: Since self.layout.trigger("list:search:fire") is deprecated by filterAPI,
                                    //TODO: Need trigger for fetching new record list
                                    self.collection.fetch({
                                        //Don't show alerts for this request
                                        showAlerts: false,
                                        remove: true,
                                        // Boolean coercion.
                                        relate: !!self.layout.collection.link
                                    });
                                } else if (options.status === 'queued') {
                                    app.alert.show('jobqueue_notice', {level: 'success', messages: successMessages[options.status], autoClose: true});
                                }
                            }
                        });
                    }, this);
                    if (emptyValues.length === 0) {
                        fetchMassupdate.call(this);
                    } else {
                        app.alert.show('empty_confirmation', {
                            level: 'confirmation',
                            messages: confirmMessage,
                            onConfirm: fetchMassupdate
                        });
                    }
                }
            } else {
                this.handleValidationError(errors);
            }
        }, this);

        if (forCalcFields) {
            this.trigger('massupdate:validation:complete', {
                errors: [],
                emptyValues: [],
                attributes: {}
            });
        } else {
            this.checkValidationError();
        }
    },

    /**
     * Build dynamic success messages to be displayed if the API call is successful
     * This is overridden by massaddtolist view which requires different success messages
     *
     * @param massUpdateModel - contains the attributes of what records are being updated (used by override in massaddtolist)
     */
    buildSaveSuccessMessages: function(massUpdateModel) {
        return {
            done: app.lang.get('LBL_MASS_UPDATE_SUCCESS'),
            queued: app.lang.get('LBL_MASS_UPDATE_JOB_QUEUED')
        };
    },

    /**
     * By default attributes are retrieved directly off the model, but broken out to allow for manipulation before handing off to the API
     */
    getAttributes: function() {
        var values = [this.defaultOption].concat(this.fieldValues),
            attributes = [],
            fieldFilter = function(field) {
                return field && field.name;
            };
        values = _.chain(values)
            //Grab the field arrays from any fields that have child fields
            //and merge them with the top level field list
            .union(_.chain(values)
                .pluck("fields")
                .compact()
                .flatten()
                .value()
            )
            //Remove any dupes or empties
            .uniq(fieldFilter)
            .filter(fieldFilter)
            .value();

        _.each(values, function(value) {
            attributes = _.union(attributes,
                _.values(_.pick(value, 'name', 'id_name'))
            );
            //FIXME: remove these hard coded conditions (SC-2836)
            if (value.name === 'parent_name') {
                attributes.push('parent_id', 'parent_type');
            } else if (value.name === 'team_name') {
                attributes.push('team_name_type');
            } else if (value.name === 'tag') {
                attributes.push('tag_type');
            } else if (value.isMultiSelect) {
                attributes.push(value.name + '_replace');
            }
        }, this);
        return _.pick(this.model.attributes, attributes);
    },

    /**
     * Get fields to validate.
     * @return {Object}
     * @private
     */
    _getFieldsToValidate: function() {
        var fields = _.initial(this.fieldValues).concat(this.defaultOption);
        return _.filter(fields, function(f) {
            return f.name;
        })
    },

    checkValidationError: function() {
        var self = this,
            emptyValues = [],
            errors = {},
            validator = {},
            i = 0;

        var fieldsToValidate = this._getFieldsToValidate();

        if (_.size(fieldsToValidate)) {
            _.each(fieldsToValidate, function(field) {
                i++;
                validator = {};
                validator[field.name] = field;
                field.required = (_.isBoolean(field.required) && field.required) || (field.required && field.required == 'true') || false;
                var value = this.model.get(field.name);
                // check if value represents emptiness
                if ((!_.isBoolean(value) && !value) || (_.isArray(value) && value.length === 0)) {
                    // If value is empty, but it's being appended, don't add it to empty values
                    // use == because the value may be a string
                    var appendCheck = this.model.get(field.name + '_type');
                    if (!appendCheck || appendCheck == 0) {
                        emptyValues.push(app.lang.get(field.label, this.model.module));
                        //don't set model if field is a relate collection
                        if (!field.relate_collection) {
                            this.model.set(field.name, '', {silent: true});
                            if (field.id_name) {
                                this.model.set(field.id_name, '', {silent: true});
                            }
                        }
                    }
                }
                this.model._doValidate(validator, errors, function(didItFail, fields, errors, callback) {
                    if (i === _.size(fieldsToValidate)) {
                        self.trigger('massupdate:validation:complete', {
                            errors: errors,
                            emptyValues: emptyValues
                        });
                    }
                });
            }, this);
        } else {
            this.trigger('massupdate:validation:complete', {
                errors: errors,
                emptyValues: emptyValues
            });
        }

        return;
    },
    handleValidationError: function(errors) {
        var self = this;
        _.each(errors, function (fieldErrors, fieldName) {
            var field = self.getField(fieldName);
            if (!_.isUndefined(field)) {
                var fieldEl = field.$el,
                    errorEl = fieldEl.find('.help-block');
                fieldEl.addClass('error');
                if(errorEl.length == 0) {
                    errorEl = $('<span>').addClass('help-block');
                    errorEl.appendTo(fieldEl);
                }
                errorEl.show().html('');
                _.each(fieldErrors, function (errorContext, errorName) {
                    errorEl.append(app.error.getErrorString(errorName, errorContext));
                });
            }
        });
    },
    show: function() {
        this.hideAll();
        this.visible = true;
        this.defaultOption = null;
        this.model.clear();
        var defaults = _.extend({}, this.model._defaults, this.model.getDefault());
        this.model.set(defaults);
        this.setDefault();

        var massModel = this.context.get('mass_collection');
        massModel.off(null, null, this);
        massModel.on('add remove reset massupdate:estimate', this.setDisabled, this);
        massModel.on('massupdate:start massupdate:end', this.setDisabledOnUpdate, this);

        // show will be called only on context.trigger("list:massupdate:fire").
        // therefore this should never be called in a situation in which
        // the view is disposed.
        this.$el.show();
        this.render();

        this.createShortcutSession();
        this.registerShortcuts();
    },
    /**
     * Hide all views that make up the list mass action section (ie. massupdate, massaddtolist)
     */
    hideAll: function() {
        this.layout.trigger("list:massaction:hide");
    },
    hide: function() {
        if (this.disposed) {
            return;
        }
        this.visible = false;
        this.$el.hide();

        this.clearAndRestorePreviousShortcuts();
    },
    /**
     * Create new shortcut session.
     */
    createShortcutSession: function() {
        app.shortcuts.saveSession();
        app.shortcuts.createSession([
            'MassUpdate:Add',
            'MassUpdate:Remove',
            'MassUpdate:Cancel',
            'MassUpdate:Update'
        ], this);
    },
    /**
     * Register shortcuts for mass update inline drawer.
     */
    registerShortcuts: function() {
        app.shortcuts.register({
            id: 'MassUpdate:Add',
            keys: '+',
            component: this,
            description: 'LBL_SHORTCUT_MASS_UPDATE_ADD',
            handler: function() {
                this.$('[data-action=add]').last().click();
            }
        });
        app.shortcuts.register({
            id: 'MassUpdate:Remove',
            keys: '-',
            component: this,
            description: 'LBL_SHORTCUT_MASS_UPDATE_REMOVE',
            handler: function() {
                this.$('[data-action=remove]').last().click();
            }
        });
        app.shortcuts.register({
            id: 'MassUpdate:Cancel',
            keys: ['esc', 'mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_MASS_UPDATE_CANCEL',
            callOnFocus: true,
            handler: function() {
                this.$('a.cancel_button').click();
            }
        });
        app.shortcuts.register({
            id: 'MassUpdate:Update',
            keys: ['mod+s', 'mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_MASS_UPDATE_SAVE',
            callOnFocus: true,
            handler: function() {
                this.$('[name=update_button]:not(.disabled)').click();
            }
        });
    },
    /**
     * Clear shortcuts and restore previous shortcut session.
     */
    clearAndRestorePreviousShortcuts: function() {
        var activeShortcutSession = app.shortcuts.getCurrentSession();
        if (activeShortcutSession && (activeShortcutSession.layout === this)) {
            app.shortcuts.restoreSession();
        }
    },
    setDisabledOnUpdate: function() {
        var massUpdate = this.context.get('mass_collection');
        if (massUpdate.length == 0) {
            this.$('.btn[name=update_button]').removeClass('disabled');
        } else {
            this.$('.btn[name=update_button]').addClass('disabled');
        }
    },
    setDisabled: function() {
        var massUpdate = this.context.get('mass_collection');
        if (massUpdate.isEmpty() || massUpdate.fetched === false) {
            this.$('.btn[name=update_button]').addClass('disabled');
        } else {
            this.$('.btn[name=update_button]').removeClass('disabled');
        }
    },
    saveClicked: function(evt) {
        if(this.$(".btn[name=update_button]").hasClass("disabled") === false) {
            this.save();
        }
    },
    cancelClicked: function(evt) {
        this.hide();
    },
    unbindData: function() {
        var massModel = this.context.get("mass_collection");
        if (massModel) {
            massModel.off(null, null, this);
        }
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Detach the event handlers for warning delete
     */
    unbindBeforeRouteDelete: function() {
        app.routing.offBefore("route", this.beforeRouteDelete, this);
        $(window).off("beforeunload.delete" + this.cid);
    },

    _dispose: function() {
        this.unbindBeforeRouteDelete();
        this.$('.select2.mu_attribute').select2('destroy');
        app.view.View.prototype._dispose.call(this);
    }
}) },
"sweetspot-config-theme": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotConfigThemeView
 * @alias SUGAR.App.view.views.BaseSweetspotConfigThemeView
 * @extends View.View
 */
({
	// Sweetspot-config-theme View (base) 

    className: 'columns',

    // FIXME: Change this to 'UnsavedChanges' when SC-4167 gets merged.
    plugins: ['Editable'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = this._getMeta(options);
        this._super('initialize', [options]);
        this._bindEvents();
    },

    /**
     * Merges the base metadata with custom view metadata.
     *
     * @protected
     * @param {Object} options The options hash containing the custom
     *   metadata.
     * @return {Object} The metadata this view should use.
     */
    _getMeta: function(options) {
        return  _.extend({},
            app.metadata.getView(null, 'sweetspot-config-theme'),
            app.metadata.getView(this.module, 'sweetspot-config-theme'),
            options.meta
        );
    },

    /**
     * Binds the events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        this.context.on('sweetspot:ask:configs', this.generateConfig, this);
    },


    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this._super('_renderHtml');
        this._initTheme();
    },

    /**
     * Initializer function that ensures the correct theme is checked when the
     * view is rendered.
     *
     * @protected
     */
    _initTheme: function() {
        var prefs = app.user.getPreference('sweetspot');
        var theme = prefs && prefs.theme;

        this.model.set('theme', theme);
    },

    /**
     * Generates an object that the
     * {@link View.Layouts.Base.SweetspotConfigLayout config layout} uses to
     * save configurations to the user preferences.
     *
     * @return {undefined} Returns `undefined` if the default theme is selected.
     */
    generateConfig: function() {
        var theme = this._getSelectedTheme();

        // The default configuration should not be defined in user prefs.
        if (!theme) {
            return;
        }
        var data = this._formatForUserPrefs(theme);
        this.context.trigger('sweetspot:receive:configs', data);
    },

    /**
     * This method prepares the attributes payload for the call to
     * {@link Core.User#updatePreferences}.
     *
     * @protected
     * @param {string} theme The configured theme name.
     * @return {Object} The prepared configuration data.
     */
    _formatForUserPrefs: function(theme) {
        return {theme: theme};
    },

    /**
     * Returns the currently selected theme from this view.
     *
     * @protected
     * @return {string|undefined} The currently selected theme. Returns
     *   `undefined` if the default theme is selected.
     */
    _getSelectedTheme: function() {
        var theme = this.model.get('theme');

        // The default configuration should be empty in user prefs.
        if (theme === 'default') {
            return;
        }

        return theme;
    },

    /**
     * Compare with the user preferences and return true if the checkbox
     * contains changes.
     *
     * This method is called by {@link app.plugins.Editable}.
     *
     * @return {boolean} `true` if current collection contains unsaved changes,
     *   `false` otherwise.
     */
    hasUnsavedChanges: function() {
        var prefs = app.user.getPreference('sweetspot');
        var oldConfig = prefs && prefs.theme;
        var newConfig = this._getSelectedTheme();
        var isChanged = !_.isEqual(oldConfig, newConfig);

        return isChanged;
    }
}) },
"headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HeaderpaneView
 * @alias SUGAR.App.view.views.BaseHeaderpaneView
 * @extends View.View
 */
({
	// Headerpane View (base) 

    plugins: [
        'ErrorDecoration',
        'Editable'
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.meta = _.extend({}, app.metadata.getView(null, 'headerpane'), this.meta);

        /**
         * The label used for the title. This is the raw label.
         *
         * @deprecated 7.5 and will be removed in 7.7. We recommend to set the
         * title by defining a `fields` array, containing a field named `title`,
         * in the metadata. You should not define the title with `meta.title`.
         * Note that you can extend {@link #formatTitle} if the string used is a
         * template and you wish to pass a context.
         *
         * @type {string}
         * @private
         */
        this._title = this.meta.title;
        this.buttons = {};

        this.context.on('headerpane:title', function(title) {
            this._title = title;
            if (!this.disposed) this.render();
        }, this);

        //shortcut keys
        app.shortcuts.register({
            id: 'Headerpane:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]'),
                    $closeButton = this.$('a[name=close]');

                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.click();
                } else if ($closeButton.is(':visible') && !$closeButton.hasClass('disabled')) {
                    $closeButton.click();
                }
            }
        });
        app.shortcuts.register({
            id: 'Headerpane:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=save_button]');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.click();
                }
            }
        });

        this.adjustHeaderpane = _.debounce(this.adjustHeaderpane, 50);
        _.bindAll(this, 'adjustHeaderpane');
        $(window).on('resize.headerpane.' + this.cid, this.adjustHeaderpane);
        this.layout.on('headerpane:adjust_fields', this.adjustTitle, this);
    },

    /**
     * Adjusts the title's ellipsis max-width to match the ancestor title cell.
     */
    adjustTitle: function() {
        var $titleCell = this.$el.find('[data-name=title]');
        if ($titleCell) {
            var $ellipsisDiv = $titleCell.find('.ellipsis_inline');
            var width = $titleCell.css('max-width');
            $ellipsisDiv.css({'max-width': width});
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        /**
         * The title being rendered in the headerpane. This is the formatted
         * label.
         *
         * @deprecated 7.5 and will be removed in 7.7. We recommend to set the
         * title by defining a `fields` array, containing a field named `title`,
         * in the metadata. You should not define the title with `meta.title`.
         * Note that you can extend {@link #_formatTitle} if the string used is a
         * template and you wish to pass a context.
         *
         * @type {string}
         */
        this.title = !_.isUndefined(this._title) ? this._formatTitle(this._title) : this.title;
        // FIXME TY-1751 Move code that alters the metadata outside of _renderHtml
        this.meta.fields = _.map(this.meta.fields, function(field) {
            if (field.name === 'title') {
                field['formatted_value'] = this.title || this._formatTitle(field['default_value']);
            }
            return field;
        }, this);
        this._super('_renderHtml');
    },

    /**
     * Formats the title before being rendered.
     *
     * @param {string} title The unformatted title.
     * @return {string} The formatted title.
     * @protected
     */
    _formatTitle: function(title) {
        if (!title) {
            return '';
        }
        return app.lang.get(title, this.module);
    },

    /**
     * Adjust headerpane such that certain fields can be shown with ellipsis.
     */
    adjustHeaderpane: function() {
        this.setContainerWidth();
        this.adjustHeaderpaneFields();
    },

    /**
     * Adjust headerpane fields such that the first field is ellipsified and the last field
     * is set to 100% on view.  On edit, the first field is set to 100%.
     */
    adjustHeaderpaneFields: function() {
        var $ellipsisCell,
            ellipsisCellWidth,
            $recordCells;

        if (this.disposed) {
            return;
        }

        $recordCells = this.$('.headerpane h1').children('.record-cell, .btn-toolbar').get().reverse();

        if (($recordCells.length > 0) && (this.getContainerWidth() > 0)) {
            $ellipsisCell = $(this._getCellToEllipsify($recordCells));

            if ($ellipsisCell.length > 0) {
                if ($ellipsisCell.hasClass('edit')) {
                    // make the ellipsis cell widen to 100% on edit
                    $ellipsisCell.css({'width': '100%'});
                } else {
                    ellipsisCellWidth = this._calculateEllipsifiedCellWidth($recordCells, $ellipsisCell);
                    this._setMaxWidthForEllipsifiedCell($ellipsisCell, ellipsisCellWidth);
                }
            }
        }
        if (this.layout) {
            this.layout.trigger('headerpane:adjust_fields');
        }
    },

    /**
     * Adds the button corresponding to `buttonName` to the `buttons` object.
     *
     * @param {string} buttonName The name of the button.
     * @private
     */
    _registerFieldAsButton: function(buttonName) {
        var button = this.getField(buttonName);
        if (button) {
            this.buttons[buttonName] = button;
        }
    },

    /**
     * Returns a list of fields that are not button of the view.
     *
     * @private
     */
    _getNonButtonFields: function() {
        return _.filter(this.fields, _.bind(function(field) {
            if (field.name) {
                return !this.buttons[field.name];
            }

            return true;
        }, this));
    },

    /**
     * Uses {@link app.plugins.Editable} to
     *   set the internal property of {@link #editableFields}.
     */
    setEditableFields: function() {
        this.editableFields = this.getEditableFields(this._getNonButtonFields(), this.noEditFields || []);
    },

    /**
     * Registers fields as buttons as specified in the metadata.
     *
     * @protected
     */
    _setButtons: function() {
        if (this.meta && this.meta.buttons) {
            _.each(this.meta.buttons, function(button) {
                this._registerFieldAsButton(button.name);
            }, this);
        }
    },

    /**
     * Show/hide buttons depending on the state defined for each buttons in the
     * metadata.
     *
     * @param {string} state The {@link #STATE} of the current view.
     */
    setButtonStates: function(state) {
        this.currentState = state;

        _.each(this.buttons, function(field) {
            var showOn = field.def.showOn;
            if (_.isUndefined(showOn) || (showOn === state)) {
                field.show();
            } else {
                field.hide();
            }
        });

        this._toggleButtons(true);
    },

    /**
     * Enables or disables the action buttons that are currently shown on the
     * page. Toggles the `.disabled` class by default.
     *
     * @param {boolean} [enable=false] Whether to enable or disable the action
     *   buttons. Defaults to `false`.
     * @private
     */
    _toggleButtons: function(enable) {
        var state = !_.isUndefined(enable) ? !enable : false;

        _.each(this.buttons, function(button) {
            var showOn = button.def.showOn;
            if (_.isUndefined(showOn) || this.currentState === showOn) {
                button.setDisabled(state);
            }
        }, this);
    },

    /**
     * Get the width of the layout container
     */
    getContainerWidth: function() {
        return this._containerWidth;
    },

    /**
     * Set the width of the layout container
     */
    setContainerWidth: function() {
        this._containerWidth = this._getParentLayoutWidth(this.layout);
    },

    /**
     * Get the width of the parent layout that contains `getPaneWidth()`
     * method.
     *
     * @param {View.Layout} layout The parent layout.
     * @return {number} The parent layout width.
     * @private
     */
    _getParentLayoutWidth: function(layout) {
        if (!layout) {
            return 0;
        } else if (_.isFunction(layout.getPaneWidth)) {
            return layout.getPaneWidth(this);
        }

        return this._getParentLayoutWidth(layout.layout);
    },

    /**
     * Get the first cell for the field that can be ellipsified.
     * @param {jQuery} $cells
     * @return {jQuery}
     * @private
     */
    _getCellToEllipsify: function($cells) {
        var fieldTypesToEllipsify = ['fullname', 'name', 'text', 'base', 'enum', 'url',
            'dashboardtitle', 'label', 'drillthrough-labels'];

        return _.find($cells, function(cell) {
            return (_.indexOf(fieldTypesToEllipsify, $(cell).data('type')) !== -1);
        });
    },

    /**
     * Calculate the width for the cell that needs to be ellipsified.
     * @param {jQuery} $cells
     * @param {jQuery} $ellipsisCell
     * @return {number}
     * @private
     */
    _calculateEllipsifiedCellWidth: function($cells, $ellipsisCell) {
        var width = this.getContainerWidth();

        _.each($cells, function(cell) {
            var $cell = $(cell);

            if ($cell.is($ellipsisCell)) {
                width -= (parseInt($ellipsisCell.css('padding-left'), 10) +
                parseInt($ellipsisCell.css('padding-right'), 10));
            } else if ($cell.is(':visible')) {
                $cell.css({'width': 'auto'});
                width -= $cell.outerWidth();
            }
            $cell.css({'width': ''});
        });

        return width;
    },

    /**
     * Set the max-width for the specified cell.
     * @param {jQuery} $ellipsisCell
     * @param {number} width
     * @private
     */
    _setMaxWidthForEllipsifiedCell: function($ellipsisCell, width) {
        var ellipsifiedCell,
            fieldType = $ellipsisCell.data('type');

        if (fieldType === 'fullname' || fieldType === 'dashboardtitle') {
            ellipsifiedCell = this.getField($ellipsisCell.data('name'));
            width -= ellipsifiedCell.getCellPadding();
            ellipsifiedCell.setMaxWidth(width);
        } else {
            $ellipsisCell.css({'max-width': width});
        }
    },

    /**
     * @inheritdoc
     */
    _renderFields: function() {
        this._super('_renderFields');
        this.adjustHeaderpane();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this._super('unbind');
        $(window).off('resize.headerpane.' + this.cid);
        this.layout.off('headerpane:adjust_fields', this.adjustTitle);
    }
}) },
"themerollerpreview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This view is used in Administration > Studio Portal > Theme Portal
 * in order to show a preview of the custom theme being edited.
 *
 * @class View.Views.Base.ThemerollerpreviewView
 * @alias SUGAR.App.view.views.BaseThemerollerpreviewView
 * @extends View.View
 */
({
	// Themerollerpreview View (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        /**
         * The name of the theme being edited.
         *
         * @property {string}
         */
        this.customTheme = 'default';
        this.context.on('change:colors', this.reloadIframeBootstrap, this);
    },

    /**
     * Makes a request to get new CSS based on the themeable colors, and updates
     * the theme preview on success.
     */
    reloadIframeBootstrap: function() {
        var self = this;
        var params = {
            preview: new Date().getTime(),
            platform: app.config.platform,
            themeName: this.customTheme
        };
        _.extend(params, this.context.get('colors'));
        var cssLink = app.api.buildURL('css/preview', '', {}, params);
        var $iframe = this.$('iframe#previewTheme');
        var $alert = this.$('.ajaxLoading');

        $iframe.hide();
        $alert.show();

        $.get(cssLink)
            .success(function(data) {
                if (self.disposed) {
                    return;
                }
                $iframe.contents().find('style').text(data);
                $alert.hide();
                $iframe.show();
            });
        $iframe.contents().find('body').css('backgroundColor', 'transparent');
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        if (!app.acl.hasAccess('admin', 'Administration')) {
            return;
        }
        this._super('_renderHtml');
    }
}) },
"bwc": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.BwcView
 * @alias SUGAR.App.view.views.BaseBwcView
 * @extends View.View
 */
({
	// Bwc View (base) 

    className: 'bwc-frame',
    // Precompiled regex (note-regex literal causes errors but RegExp doesn't)
    moduleRegex: new RegExp('module=([^&]*)'),
    idRegex: new RegExp('record=([^&]*)'),
    actionRegex: new RegExp('action=([^&]*)'),

    plugins: ['Editable', 'LinkedModel'],

    /**
     * Enabled actions for warning unsaved changes.
     */
    warnEnabledBwcActions: [
        'editview', 'config'
    ],

    /**
     * The URL to a BWC view to be used in the iFrame element (template).
     *
     * See {@link #_renderHtml} on how this is created and then kept in sync
     * with the iFrame.
     *
     * @property {string}
     */
    url: '',

    /**
     * Sets the current URL of this view to point to a bwc link.
     *
     * See {@link #_setCurrentUrl} on how this is kept in sync with the current
     * view url and window hash.
     *
     * @property {string}
     * @private
     */
    _currentUrl: '',

    initialize: function(options) {
        // If (for some reason) we're trying to directly access old Home/Dashboards, for redirect to sidecar #Home
        var url = options.context.get('url');
        if (url && (url.search(/module=Home.*action=index/) > -1 || url.search(/action=index.*module=Home/) > -1)) {
            app.router.navigate('#Home', {trigger: true});
            return;
        }

        app.events.on("api:refreshtoken:success", this._refreshSession, this);

        this._super('initialize', [options]);
        this.bwcModel = app.data.createBean('bwc');

        // because loadView disposes the old layout when the bwc iFrame is no
        // longer in the DOM, it causes a memory leak unless we unbind it
        // before the new layout is loaded.
        app.before('app:view:load', this.unbindDom, this);
    },

    /**
     * @inheritdoc
     *
     * Inspect changes on current HTML input elements with initial values.
     */
    hasUnsavedChanges: function() {
        var bwcWindow = this.$('iframe').get(0).contentWindow;
        //if bwcModel is empty, then it should return false (since it's not in enabled actions)
        // or we couldnt find a edit view to compare or the view doesn't want to be compared
        if (_.isEmpty(this.bwcModel.attributes) || _.isUndefined(bwcWindow.EditView) || $(bwcWindow.EditView).data('disablebwchaschanged')) {
            return false;
        }
        // some forms may still be doing async loading after document ready
        // do not compare if the loading is not done yet
        if (!_.isUndefined(bwcWindow.asyncLoading) && bwcWindow.asyncLoading) {
            return false;
        }
        var newAttributes = this.serializeObject(bwcWindow.EditView);
        return !_.isEmpty(this.bwcModel.changedAttributes(newAttributes));
    },

    /**
     * Retrieves form's input values in object format
     *
     * @param {HTMLElement} theForm form element.
     * @return {Object} key-value paired object.
     */
    serializeObject: function(theForm) {
        var formArray = $(theForm).serializeArray();
        return _.reduce(formArray, function(acc, field) {
            acc[field.name] = field.value;
            return acc;
        }, {});
    },

    /**
     * @inheritdoc
     *
     * Override {@link View.View#_render} method to
     * extend ACL check for Administration module in BWC mode.
     * Allow access to Administration if user has admin access to any
     * module only, if not - show error message and navigate to home.
     */
    _render: function() {
        if (this.module === 'Administration' &&
            !app.acl.hasAccessToAny('admin') &&
            !app.acl.hasAccessToAny('developer')
        ) {
            app.logger.info(
                'Current user does not have access to this module view. name: ' +
                    this.name + ' module:' + this.module
            );
            app.error.handleRenderError(this, 'view_render_denied');
            app.router.navigate('#Home', {trigger: true});
            return;
        }
        app.view.View.prototype._render.call(this);
        return this;
    },

    /**
     * Render the iFrame and listen for content changes on it.
     *
     * Every time there is an update on the iFrame, we:
     * - clear any '.bwc.sugarcrm' event (namespace for any bind in this view);
     * - update the controller context to mach our bwc module (if exists);
     * - update our url to match the current iFrame location in bwc way;
     * - rewrite links for sidecar modules;
     * - rewrite links that go for new windows;
     * - memorize the form input elements in order to warn unsaved changes;
     * - update the context model to mach our current bwc module (if exists);
     *
     * @private
     */
    _renderHtml: function() {
        var self = this;

        this.url = app.utils.addIframeMark(this.context.get('url') || 'index.php?module=' + this.module + '&action=index');
        app.view.View.prototype._renderHtml.call(this);

        this.$('iframe').on('load', function() {
            //In order to update current location once bwc link is clicked.
            self.url = 'index.php' + this.contentWindow.location.search;
            self._setCurrentUrl();

            if (this.contentWindow.$ === undefined) {
                // no jQuery available, graceful fallback
                return;
            }

            $(this.contentWindow).one('beforeunload', _.bind(self.unbindDom, self));

            self._setModule(this.contentWindow);
            self._setBwcModel(this.contentWindow);
            self._setModel(this.contentWindow);
            self._rewriteLinksForSidecar(this.contentWindow);
            self._rewriteNewWindowLinks(this.contentWindow);
            self._cloneBodyClasses(this.contentWindow);

            $('html', this.contentWindow.document).on('click.bwc.sugarcrm', function() {
                app.bwc.trigger('clicked');
            });
        });
    },

    /**
     * Clone classes, added by Modernizr, "top frame" into "bwc frame";
     * necessary for various overrides on iPhone and Android.
     */
    _cloneBodyClasses: function(contentWindow) {
        contentWindow.$('html').addClass($('html').prop('class'));
    },
    /**
     * Update the controller context to mach our bwc module.
     *
     * @param {HTMLElement} contentWindow iframe window.
     * @private
     */
    _setModule: function(contentWindow) {
        var module = this.moduleRegex.exec(contentWindow.location.search);
        module = (_.isArray(module)) ? module[1] : null;

        if (!module) {
            // try and strip module off the page if its not set on location
            if (contentWindow.$ && contentWindow.$('input[name="module"]') && contentWindow.$('input[name="module"]').val()) {
                module = contentWindow.$('input[name="module"]').val();
            } else {
                return;
            }

        }
        // on BWC import we want to try and take the import module as the module
        if (module === 'Import') {
            var importModule = /import_module=([^&]*)/.exec(contentWindow.location.search);
            if (!_.isNull(importModule) && !_.isEmpty(importModule[1])) {
                module = importModule[1];
            } else if (contentWindow.$ &&
                contentWindow.$('input[name="import_module"]') &&
                contentWindow.$('input[name="import_module"]').val()) {

                // try and strip import module off the page if its not set on location
                module = contentWindow.$('input[name="import_module"]').val();
            }
        }
        // update bwc context
        var app = window.parent.SUGAR.App;
        app.controller.context.set('module', module);
        app.events.trigger('app:view:change', this.layout, {module: module});
    },

    /**
     * Memorize the form input elements if current page contains edit form.
     *
     * @param {HTMLElement} contentWindow iframe window.
     * @private
     */
    _setBwcModel: function(contentWindow) {
        var action = this.actionRegex.exec(contentWindow.location.search);
        action = (_.isArray(action)) ? action[1].toLowerCase() : null;

        var EditViewGrid = contentWindow.document.getElementById('EditViewGrid');
        if (EditViewGrid) {
            contentWindow.EditView = EditViewGrid;
        }

        //once edit page is entered, the page is navigated without action query string.
        //Therefore, if current page contains 'EditView' form, bind the action as 'editview'.
        if (contentWindow.EditView) {
            action = 'editview';
        }

        var attributes = {};
        if (_.contains(this.warnEnabledBwcActions, action)) {
            attributes = this.serializeObject(contentWindow.EditView);
        }
        this.resetBwcModel(attributes);
    },

    /**
     * Populates the context model with API data.
     * `this.model` is a link for `this.context.model`.
     *
     * @param {HTMLElement} contentWindow iframe window.
     * @private
     */
    _setModel: function(contentWindow) {
        var action = this.actionRegex.exec(contentWindow.location.search);
        action = (_.isArray(action)) ? action[1].toLowerCase() : null;

        if (action !== 'detailview') {
            return;
        }

        var id = this.idRegex.exec(this._currentUrl);
        if (!_.isArray(id)) {
            return;
        }

        this.model.set('id', id[1]);
        this.model.module = this.context.get('module');
        this.model.fetch();
    },

    /**
     * @inheritdoc
     *
     * Opens the appropriate sidecar create layout in a drawer.
     *
     * @param {String} module Module name.
     * @param {String} link Link name.
     */
    openCreateDrawer: function(module, link) {
        var parentModel = this.context.get('model'),
            model = this.createLinkModel(parentModel, link),
            self = this;
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: model.module,
                model: model
            }
        }, function(context, model) {
            if (!model) {
                return;
            }
            // Reload the BWC to update subpanels.
            self.$('iframe').get(0).contentWindow.location.reload(true);
        });
    },

    /**
     * Opens the Compose Email drawer, passing in the parent model to which the
     * email should be related, as well other prefills, like the subject and
     * body.
     *
     * @param {Object} [options] Data for the email from the compose package.
     * @param {Object} [options.subject] Populate the email with this subject.
     * @param {Object} [options.body] Populate the email with this body.
     * @param {Object} [options.to] Populate the email with these recipients.
     * @param {Object} [options.cc] Populate the email with these recipients.
     * @param {Object} [options.attachments] Populate the email with these
     * attachments.
     */
    openComposeEmailDrawer: function(options) {
        var prepopulate = {
            related: this.context.get('model')
        };

        options = app.utils.deepCopy(options) || {};

        if (!_.isEmpty(options.subject)) {
            prepopulate.name = options.subject;
        }

        if (!_.isEmpty(options.body)) {
            prepopulate.description_html = options.body;
        }

        _.each(['to', 'cc'], function(field) {
            if (!_.isArray(options[field])) {
                return;
            }

            prepopulate[field] = [];

            _.each(options[field], function(data) {
                var bean = app.data.createBean('EmailParticipants', {
                    _link: field,
                    email_address_id: data.email_address_id,
                    email_address: data.email_address
                });

                if (data.parent_type && data.parent_id) {
                    bean.set({
                        parent: {
                            _acl: {},
                            type: data.parent_type,
                            id: data.parent_id,
                            name: data.parent_name || ''
                        },
                        parent_type: data.parent_type,
                        parent_id: data.parent_id,
                        parent_name: data.parent_name || ''
                    });
                }

                prepopulate[field].push(bean);
            });
        });

        if (!_.isEmpty(options.attachments)) {
            prepopulate.attachments = [];

            _.each(options.attachments, function(attachment) {
                var bean = app.data.createBean('Notes', {
                    _link: 'attachments',
                    upload_id: attachment.id,
                    name: attachment.filename,
                    filename: attachment.filename
                });

                prepopulate.attachments.push(bean);
            });
        }

        app.utils.openEmailCreateDrawer(
            'compose-email',
            prepopulate,
            _.bind(function(context, model) {
                // Reload the BWC window to update subpanels.
                if (model) {
                    this.$('iframe').get(0).contentWindow.location.reload(true);
                }
            }, this)
        );
    },

    /**
     * Opens the Archive Email drawer, passing in the parent model to relate to
     * Reloads the BWC page if email created so it appears in the subpanel
     */
    openArchiveEmailDrawer: function() {
        app.utils.openEmailCreateDrawer(
            'create',
            {
                related: this.context.get('model')
            },
            _.bind(function(model) {
                if (model) {
                    // Reload the BWC window to update subpanels.
                    this.$('iframe').get(0).contentWindow.location.reload(true);
                }
            }, this)
        );
    },

    /**
     * Update current window location based on the {@link #url} property.
     *
     * Confirms that the sidecar hash is always matching the url in the iFrame
     * prefixed by`#bwc/` hash (for proper routing handling).
     *
     * @private
     */
    _setCurrentUrl: function() {
        this._currentUrl = app.utils.rmIframeMark('#bwc/' + this.url);
        window.parent.location.hash = this._currentUrl;
    },

    /**
     * Revert model attributes with the current form elements.
     */
    revertBwcModel: function() {
        var bwcWindow = this.$('iframe').get(0).contentWindow;
        var newAttributes = this.serializeObject(bwcWindow.EditView);
        this.resetBwcModel(newAttributes);
    },

    /**
     * Reset model attributes with the initial attributes.
     *
     * @param {Object} key-value pair attributes.
     */
    resetBwcModel: function(attr) {
        this.bwcModel.clear({
            silent: true
        }).set(attr);
    },

    /**
     * Gets the sidecar url based on a given bwc hyperlink.
     * @param {String} href the bwc hyperlink.
     * @return {String} the new sidecar hyperlink (empty string if unable to convert).
     */
    convertToSidecarUrl: function(href) {
        var module = this.moduleRegex.exec(href),
            id = this.idRegex.exec(href),
            action = this.actionRegex.exec(href);

        module = (_.isArray(module)) ? module[1] : null;
        if (!module) {
            return '';
        }
        //Route links for BWC modules through bwc/ route
        if (app.metadata.getModule(module).isBwcEnabled) {
            //Remove any './' nonsense in existing hrefs
            href = href.replace(/^.*\//, '');
            return "bwc/" + href;
        }
        id = (_.isArray(id)) ? id[1] : null;
        action = (_.isArray(action)) ? action[1] : '';
        // fallback to sidecar detail view
        if (action.toLowerCase() === 'detailview') {
            action = '';
        }

        if (!id && action.toLowerCase() === 'editview') {
            action = 'create';
        }
        return app.router.buildRoute(module, id, action);
    },

    /**
     * Rewrites old link element to the new sidecar router.
     *
     * This adds an event to all the links that are converted and don't open in
     * a new tab/window. Therefore it is imperative that you take memory leaks
     * precautions. See {@link #unbindDom} for more information.
     *
     * The reason why we don't use an `onclick="..."` attribute, is simply due
     * to requirements of tracking the event and stop propagation, which would
     * be extremely difficult to support cross browser.
     *
     * @param {HTMLElement} The link `<a>` to rewrite into a sidecar url.
     */
    convertToSidecarLink: function(elem) {
        elem = $(elem);
        //Relative URL works better on all browsers than trying to include origin
        var baseUrl = app.config.siteUrl || window.location.pathname;
        var href = elem.attr('href');
        var module = this.moduleRegex.exec(href);
        var dataSidecarRewrite = elem.attr('data-sidecar-rewrite');
        var action = this.actionRegex.exec(href);

        if (
            !_.isArray(module) ||
            _.isEmpty(module[1]) ||
            _.isUndefined(app.metadata.getModule(module[1])) ||
            module[1] === "Administration" || // Leave Administration module links alone for 7.0
            href.indexOf("javascript:") === 0 || //Leave javascript alone (this is mostly BWC links)
            dataSidecarRewrite === 'false' ||
            (_.isArray(action) && action[1] === 'sugarpdf') //Leave PDF downloads for bwc modules
        ) {
            return;
        }
        var sidecarUrl = this.convertToSidecarUrl(href);
        elem.attr('href', baseUrl + '#' + sidecarUrl);
        elem.data('sidecarProcessed', true);

        if (elem.attr('target') === '_blank') {
            return;
        }

        app.logger.debug('Bind event in BWC view');

        elem.on('click.bwc.sugarcrm', function(e) {
            if (e.button !== 0 || e.ctrlKey || e.metaKey) {
                return;
            }
            e.stopPropagation();
            parent.SUGAR.App.router.navigate(sidecarUrl, {trigger: true});
            return false;
        });
        app.accessibility.run(elem, 'click');
    },

    /**
     * Rewrites old error elements to the new one pop-ups.
     *
     * @param {Object} $errors DOM elements containing errors to rewrite into standard errors.
     */
    convertToSidecarErrors: function($errors) {
        if ($errors.length === 0) {
            return;
        }

        $errors.hide();
        var errorMessages = _.map($errors, function(error) {
            return $(error).text();
        });
        app.alert.show('delete-error', {
            level: 'error',
            messages: errorMessages
        });
    },

    /**
     * Allow BWC modules to rewrite their links when using their own ajax
     * calls.
     *
     * *ATTENTION:* This method might cause memory leaks if not used properly.
     * Make sure that {@link #unbindDom} is being used and cleaning up any
     * events that this view is creating (use {@link Utils.Logger.levels}
     * `debug` level to track all the events being created and check if the
     * ones being cleared by {@link #unbindDom} match.
     */
    rewriteLinks: function() {
        app.logger.warn('Possible memory leak on BWC code');
        var frame = this.$('iframe').get(0).contentWindow;
        this._rewriteLinksForSidecar(frame);
        this._rewriteNewWindowLinks(frame);
    },

    /**
     * Rewrite old links on the frame given to the new sidecar router.
     *
     * This will match all hrefs that contain "module=" on it and if the module
     * isn't blacked listed, then rewrite into sidecar url.
     * Since iFrame needs full URL to sidecar urls (to provide copy paste urls,
     * open in new tab/window, etc.) this will check what is the base url to
     * apply to that path.
     *
     * See `include/modules.php` for the list (`$bwcModules`) of modules not
     * sidecar ready.
     *
     * This method is private because it binds data and might cause memory
     * leaks. Please use this with caution and with {@link #unbindDom}.
     *
     * @param {Window} frame The `contentWindow` of the frame to rewrite links.
     * @private
     */
    _rewriteLinksForSidecar: function(frame) {
        var self = this;

        frame.$('a[href*="module="]').each(function(i, elem) {
            self.convertToSidecarLink(elem);
        });
    },

    /**
     * Rewrite new window links (`target=_blank`) on the frame given to the new
     * sidecar with bwc url.
     *
     * This will match all `"target=_blank"` links that aren't already pointing
     * to sidecar already and make them sidecar bwc compatible. This will
     * assume that all links to sidecar modules are already rewritten.
     *
     * @param {Window} frame The `contentWindow` of the frame to rewrite links.
     * @private
     */
    _rewriteNewWindowLinks: function(frame) {
        var ieOrigin,
            baseUrl,
            $links = frame.$('a[target="_blank"]').not('[href^="http"]').not('[href*="entryPoint=download"]');

        // for IE 10 & below, which does not have window.location.origin
        if (!window.location.origin) {
            ieOrigin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
        }
        baseUrl = app.config.siteUrl || (window.location.origin || ieOrigin) + window.location.pathname;

        $links.each(function(i, elem) {
            var $elem = $(elem);
            if ($elem.data('sidecarProcessed')) {
                return;
            }
            $elem.attr('href', baseUrl + '#bwc/' + $elem.attr('href'));
        });
    },

    /**
     * Unbinds all events that were hooked in this view with the `bwc.sugarcrm`
     * namespace into links (`<a>` anchor tags).
     *
     * Only unbinds if the content window has jQuery and the `iframe` is
     * loaded.
     * To avoid memory leaks, please always confirm that this function is
     * called when any event is added to the `iframe` from this view or
     * sidecar.
     *
     * Example:
     *
     *     // write some `methodWithBind` that binds click events in bwc
     *     // elements in this bwc view.
     *     // call that method from within the bwc view like:
     *     parent.SUGAR.App.view.views.BaseBwcView.prototype.methodWithBind();
     *     // memory leak will happen if `methodWithBind` doesn't use the
     *     // `.bwc.sugarcrm` namespace.
     *
     * If the BWC view is replacing it's current html with a new one, it should
     * also call this method before replacing the contents, so that it won't
     * cause memory leak.
     */
    unbindDom: function() {
        var bwcWindow = this.$('iframe').get(0).contentWindow;
        if (!bwcWindow || bwcWindow.$ === undefined) {
            return;
        }

        this.confirmMemLeak(bwcWindow.document);

        $('a', bwcWindow.document).off('.bwc.sugarcrm');
        $('html', bwcWindow.document).off('.bwc.sugarcrm');
    },

    confirmMemLeak: function(target) {
        app.logger.debug(function() {
            var registered = _.reduce($('a', target), function(memo, el) {
                var events = $._data(el, 'events');
                return memo + _.where(_.flatten(events), {namespace: 'bwc.sugarcrm'}).length;
            }, 0);

            return 'Clear ' + registered + ' event(s) in `bwc.sugarcrm`.';
        });
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        app.events.off("api:refreshtoken:success", this._refreshSession, this);

        this.unbindDom();
        app.offBefore(null, null, this);
        if (this.bwcModel) {
            this.bwcModel.off();
            this.bwcModel = null;
        }
        this._super('_dispose');
    },

    /**
     * Refreshes session on server side
     */
    _refreshSession: function() {
        app.bwc.login();
    }
}) },
"audit-footer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AuditFooterView
 * @alias SUGAR.App.view.views.BaseAuditFooterView
 * @extends View.View
 */
({
	// Audit-footer View (base) 

    /**
     * @inheritdoc
     * Initialize the audited fields on the parent model.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        if (this.context.parent) {
            var baseModule = this.context.parent.get('module');
            this.auditedFields = this._getAuditedFields(baseModule);
            this.hasCurrencyFields = this._hasCurrencyFields(baseModule);
        }
    },

    /**
     * Parse the parent module metadata and determine audited fields.
     *
     * @param {String} baseModule Name of parent module.
     * @return {Array} List of audited field's name.
     * @protected
     */
    _getAuditedFields: function(baseModule) {
        return _.chain(app.metadata.getModule(baseModule, 'fields'))
            .filter(function(o) {return o.audited;})
            .map(function(o) {return app.lang.get(o.vname, baseModule);})
            .value();
    },

    /**
     *  Look to see if the baseModule has any currency fields
     *
     *  @return {boolean}
     *  @protected
     */
    _hasCurrencyFields: function(baseModule) {
        return _.some(app.metadata.getModule(baseModule, 'fields'), function(field) {
           return field.audited && field.type && field.type == 'currency';
        });
    }
}) },
"history-summary-preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryPreviewView
 * @alias SUGAR.App.view.views.BaseHistorySummaryPreviewView
 * @extends View.Views.Base.PreviewView
 */
({
	// History-summary-preview View (base) 

    extendsFrom: 'PreviewView',

    /**
     * @inheritdoc
     * @override
     *
     * Overridden to make custom calls by module to get activities
     */
    _renderPreview: function(model, collection, fetch, previewId) {
        var self = this,
            newModel;

        // If there are drawers there could be multiple previews, make sure we are only rendering preview for active drawer
        if(app.drawer && !app.drawer.isActive(this.$el)){
            return;  //This preview isn't on the active layout
        }

        // Close preview if we are already displaying this model
        if(this.model && model && (this.model.get("id") == model.get("id") && previewId == this.previewId)) {
            // Remove the decoration of the highlighted row
            app.events.trigger("list:preview:decorate", false);
            // Close the preview panel
            app.events.trigger('preview:close');
            return;
        }

        if (app.metadata.getModule(model.module).isBwcEnabled) {
            // if module is in BWC mode, just return
            return;
        }

        if (model) {
            // Use preview view if available, otherwise fallback to record view
            var viewName = 'preview',
                previewMeta = app.metadata.getView(model.module, 'preview'),
                recordMeta = app.metadata.getView(model.module, 'record');
            if (_.isEmpty(previewMeta) || _.isEmpty(previewMeta.panels)) {
                viewName = 'record';
            }
            this.meta = this._previewifyMetadata(_.extend({}, recordMeta, previewMeta));

            newModel = app.data.createBean(model.module);
            newModel.set('id', model.id);

            if (fetch) {
                newModel.fetch({
                    //Show alerts for this request
                    showAlerts: true,
                    success: function(model) {
                        self.renderPreview(model, collection);
                    },
                    //The view parameter is used at the server end to construct field list
                    view: viewName
                });
            } else {
                newModel.copy(model);
                this.renderPreview(newModel, collection);
            }
        }

        this.previewId = previewId;
    }
}) },
"opportunity-metrics": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OpportunityMetricsView
 * @alias SUGAR.App.view.views.BaseOpportunityMetricsView
 * @extends View.View
 */
({
	// Opportunity-metrics View (base) 

    plugins: ['Dashlet', 'Chart'],
    className: 'opportunity-metrics-wrapper',

    metricsCollection: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.tooltipTemplate = app.template.getField('chart', 'singletooltiptemplate', this.module);
        this.locale = SUGAR.charts.getSystemLocale();

        this.chart = sucrose.charts.pieChart()
                .margin({top: 0, right: 0, bottom: 5, left: 0})
                .donut(true)
                .donutLabelsOutside(true)
                .donutRatio(0.447)
                .rotateDegrees(0)
                .arcDegrees(360)
                .maxRadius(110)
                .hole(this.total)
                .showTitle(false)
                .tooltips(true)
                .showLegend(false)
                .colorData('data')
                .direction(app.lang.direction)
                .tooltipContent(_.bind(function(eo, properties) {
                    var point = {};
                    point.key = this.chart.getKey()(eo);
                    point.label = app.lang.get('LBL_CHART_COUNT');
                    point.value = this.chart.getValue()(eo);
                    point.percent = sucrose.utility.numberFormatPercent(point.value, properties.total, this.locality);
                    return this.tooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
                }, this))
                .fmtValue(_.bind(function(d) {
                    return this._valueFormat(d);
                }, this))
                .fmtKey(_.bind(function(d) {
                    return this._labelFormat(d);
                }, this))
                .strings({
                    noData: app.lang.get('LBL_CHART_NO_DATA'),
                    noLabel: app.lang.get('LBL_CHART_NO_LABEL')
                })
                .locality(this.locale);

        this.locality = this.chart.locality();
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        // Set value of label inside donut chart
        this.chart.hole(this.total);

        d3sugar.select(this.el).select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.update);
        this.displayNoData(!this.chart_loaded);
    },

    /* Process data loaded from REST endpoint so that d3 chart can consume
     * and set general chart properties
     */
    evaluateResult: function(data) {
        var total = 0,
            userConversionRate = 1 / app.metadata.getCurrency(app.user.getPreference('currency_id')).conversion_rate,
            userCurrencyPreference = app.user.getPreference('currency_id'),
            stageLabels = app.lang.getAppListStrings('opportunity_metrics_dom'),
            convertedAmount;

        _.each(data, function(value, key) {
            convertedAmount = app.currency.convertWithRate(value.amount_usdollar, userConversionRate);
            // parse currencies, format to user preference and attach the correct delimiters/symbols etc
            data[key].formattedAmount = app.currency.formatAmountLocale(convertedAmount, userCurrencyPreference, 0);
            data[key].icon = key === 'won' ? 'caret-up' : (key === 'lost' ? 'caret-down' : 'minus');
            data[key].cssClass = key === 'won' ? 'won' : (key === 'lost' ? 'lost' : 'active');
            data[key].dealLabel = key;
            data[key].stageLabel = stageLabels[key] || key;
            total += value.count;
        });

        this.total = total;
        this.metricsCollection = data;

        this.chartCollection = {
            data: _.map(this.metricsCollection, function(value, key) {
                return {
                    key: value.stageLabel,
                    value: value.count,
                    classes: key
                };
            }),
            properties: {
                title: app.lang.get('LBL_DASHLET_OPPORTUNITY_NAME'),
                value: 3,
                label: total,
                yDataType: 'numeric',
                xDataType: 'string'
            }
        };
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            url;
        if (this.meta.config) {
            return;
        }
        url = app.api.buildURL(this.model.module, 'opportunity_stats', {
            id: this.model.get('id')
        });
        app.api.call('read', url, null, {
            success: function(data) {
                self.evaluateResult(data);
                if (!self.disposed) {
                    // we have to rerender the entire dashlet, not just the chart,
                    // because the HBS file is dependant on metricsCollection
                    self.render();
                }
            },
            error: _.bind(function() {
                this.displayNoData(true);
            }, this),
            complete: options ? options.complete : null
        });
    },

    /**
     * This method is called by the chart model in initialize
     *
     * @param {number} d  The numeric value to be formatted
     * @return {string}  A number formatted with SI units if needed
     * @private
     */
    _valueFormat: function(d) {
        var val = d.series ? this.chart.getValue()(d.series) : d;
        return sucrose.utility.numberFormatSI(val, 2, false);
    },

    /**
     * This method is called by the chart model in initialize
     *
     * @param {Object|string} d  The data to extract the label from
     * @return {string}  A label formatted as needed
     * @private
     */
    _labelFormat: function(d) {
        var val = d.series ? this.chart.getKey()(d.series) : d;
        return val;
    }
}) },
"activitystream-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivitystreamBottomView
 * @alias SUGAR.App.view.views.BaseActivitystreamBottomView
 * @extends View.View
 */
({
	// Activitystream-bottom View (base) 

    events: {
        'click [data-action=show-more]': 'paginate'
    },

    /**
     * Load list-bottom template.
     * @inheritdoc
     */
    _loadTemplate: function(options) {
        this.tplName = 'list-bottom';
        this.template = app.template.getView(this.tplName);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (!app.config.activityStreamsEnabled) {
            this.$el.addClass('hide');
        }

        return this;
    },

    /**
     * Display appropriate label depending on the state of activity stream collection.
     * @inheritdoc
     */
    _renderHtml: function() {
        if ((this.collection.next_offset === -1) && (this.collection.length > 0)) {
            this.$el.addClass('hide');
        } else {
            this.dataFetched = this.collection.dataFetched;
            this.showMoreLabel = app.lang.get('TPL_SHOW_MORE_MODULE', this.module);
            this.showLoadMsg = true;
            this._super('_renderHtml');
            this.$el.removeClass('hide');
        }
    },

    /**
     * Re-render when activity stream is fetched.
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('reset add', this.render, this);
    },

    /**
     * Call to paginate activity stream.
     */
    paginate: function() {
        this.context.trigger('activitystream:paginate', true);
    }
}) },
"filter-rows": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Form for creating a filter.
 *
 * Part of {@link View.Layouts.Base.FilterpanelLayout}.
 *
 * @class View.Views.Base.FilterRowsView
 * @alias SUGAR.App.view.views.BaseFilterRowsView
 * @extends View.View
 */
({
	// Filter-rows View (base) 

    events: {
        'click [data-action=add]': 'addRow',
        'click [data-action=remove]': 'removeRow',
        'change [data-filter=field] input[type=hidden]': 'handleFieldSelected',
        'change [data-filter=operator] input[type=hidden]': 'handleOperatorSelected'
    },

    className: 'filter-definition-container',

    filterFields: [],

    lastFilterDef: [],

    /**
     * Map of fields types.
     *
     * Specifies correspondence between field types and field operator types.
     */
    fieldTypeMap: {
        'datetime' : 'date',
        'datetimecombo' : 'date'
    },

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        //Load partial
        this.formRowTemplate = app.template.get("filter-rows.filter-row-partial");

        this._super('initialize', [opts]);

        this.loadFilterOperators(this.module);

        /**
         * FIXME: we should consider moving it to metadata instead. (see TY-177).
         * Storage for operators that have no values associated with them
         *
         * @private
         * @property {Array}
         * */
        this._operatorsWithNoValues = ['$empty', '$not_empty'];

        this.listenTo(this.layout, "filterpanel:change:module", this.handleFilterChange);
        this.listenTo(this.layout, "filter:create:open", this.openForm);
        this.listenTo(this.layout, 'filter:create:close', this.closeForm);
        this.listenTo(this.context, "filter:create:save", this.saveFilter);
        this.listenTo(this.layout, "filter:create:delete", this.confirmDelete);
    },

    /**
     * Loads filterable fields and operators for supplied module.
     *
     * @param {string} module Selected module name.
     */
    handleFilterChange: function(module) {
        if (_.isEmpty(app.metadata.getModule(module, 'filters')) || this.moduleName === module) {
            return;
        }

        /**
         * Name of the selected module which triggered the filter change.
         *
         * @property {string}
         */
        this.moduleName = module;

        this.loadFilterFields(module);
        this.loadFilterOperators(module);
    },

    /**
     * Loads the list of filter fields for supplied module.
     *
     * @param {string} module The module to load the filter fields for.
     */
    loadFilterFields: function(module) {
        if (_.isEmpty(app.metadata.getModule(module, 'filters'))) {
            return;
        }

        this.fieldList = app.data.getBeanClass('Filters').prototype.getFilterableFields(module);
        this.filterFields = {};

        _.each(this.fieldList, function(value, key) {
            this.filterFields[key] = app.lang.get(value.vname, module);
        }, this);
    },

    /**
     * Loads the list of filter operators for supplied module.
     *
     * @param {string} [module] The module to load the filters for.
     */
    loadFilterOperators: function(module) {
        this.filterOperatorMap = app.metadata.getFilterOperators(module);
    },

    /**
     * Handler for filter:create:open event
     * @param {Bean} filterModel
     */
    openForm: function(filterModel) {
        var template = filterModel.get('filter_template') || filterModel.get('filter_definition');
        if (_.isEmpty(template)) {
            this.render();
            this.addRow();
        } else {
            this.populateFilter();
        }
        // After populating the form, save the current edit state
        this.saveFilterEditState();

        //shortcut keys
        app.shortcuts.register({
            id: 'Filter:Add',
            keys: '+',
            component: this,
            description: 'LBL_SHORTCUT_FILTER_ADD',
            handler: function() {
                this.$('[data-action=add]').last().click();
            }
        });
        app.shortcuts.register({
            id: 'Filter:Remove',
            keys: '-',
            component: this,
            description: 'LBL_SHORTCUT_FILTER_REMOVE',
            handler: function() {
                this.$('[data-action=remove]').last().click();
            }
        });
    },

    /**
     * Handler for filter:create:close event
     */
    closeForm: function() {
        this.lastFilterDef = [];
        this.lastFilterTemplate = [];

        this.render();
    },

    /**
     * Save the filter.
     *
     * @param {String} [name] The name of the filter.
     */
    saveFilter: function(name) {
        var self = this,
            obj = {
                filter_definition: this.buildFilterDef(true),
                filter_template: this.buildFilterDef(),
                name: name || this.context.editingFilter.get('name'),
                module_name: this.moduleName
            },
            message = app.lang.get('TPL_FILTER_SAVE', this.moduleName, {name: name});

        this.context.editingFilter.save(obj, {
            success: function(model) {
                self.context.trigger('filter:add', model);
                self.layout.trigger('filter:toggle:savestate', false);
            },
            showAlerts: {
                'success': {
                    title: app.lang.get('LBL_SUCCESS'),
                    messages: message
                }
            }
        });
    },


    /**
     * Popup alert to confirm delete action.
     */
    confirmDelete: function() {
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_DELETE_FILTER_CONFIRMATION', this.moduleName),
            onConfirm: _.bind(this.deleteFilter, this)
        });
    },

    /**
     * Delete the filter.
     */
    deleteFilter: function() {
        var self = this,
            name = this.context.editingFilter.get('name'),
            message = app.lang.get('TPL_DELETE_FILTER_SUCCESS', this.moduleName, {name: name});

        this.context.editingFilter.destroy({
            success: function(model) {
                self.layout.trigger('filter:remove', model);
            },
            showAlerts: {
                'success': {
                    title: app.lang.get('LBL_SUCCESS'),
                    messages: message
                }
            }
        });
        this.layout.trigger('filter:create:close');
    },

    /**
     * Get filterable fields from the module metadata
     * @param {String} moduleName
     * @return {Object}
     */
    getFilterableFields: function(moduleName) {
        var moduleMeta = app.metadata.getModule(moduleName),
            fieldMeta = moduleMeta.fields,
            fields = {};
        if (moduleMeta.filters) {
            _.each(moduleMeta.filters, function(templateMeta) {
                if (templateMeta.meta && templateMeta.meta.fields) {
                    fields = _.extend(fields, templateMeta.meta.fields);
                }
            });
        }

        _.each(fields, function(fieldFilterDef, fieldName) {
            var fieldMetaData = app.utils.deepCopy(fieldMeta[fieldName]);
            if (_.isEmpty(fieldFilterDef)) {
                fields[fieldName] = fieldMetaData || {};
            } else {
                fields[fieldName] = _.extend({name: fieldName}, fieldMetaData, fieldFilterDef);
            }
            delete fields[fieldName]['readonly'];
        });

        return fields;
    },

    /**
     * Utility function that instantiates a field for this form.
     *
     * The field action is manually set to `detail` because we want to render
     * the `edit` template but the action remains `detail` (filtering).
     *
     * @param {Data.Bean} model A bean necessary to the field for storing the
     *   value(s).
     * @param {Object} def The field definition.
     * @return {View.Field} The field component.
     */
    createField: function(model, def) {
        var obj = {
            meta: {
                view: "edit"
            },
            def: def,
            model: model,
            context: app.controller.context,
            viewName: "edit",
            view: this
        };
        var field = app.view.createField(obj);
        field.action = 'detail';
        return field;
    },

    /**
     * Add a row to the next element of the event target that triggered it or
     * in the end of the list.
     *
     * @param {Event} [e] The event that triggered the row.
     * @return {Element} The new initialized appended row element.
     */
    addRow: function(e) {
        var $row;

        if (e) {
            // Triggered by clicking the plus sign. Add the row to that point.
            $row = this.$(e.currentTarget).closest('[data-filter=row]');
            $row.after(this.formRowTemplate());
            $row = $row.next();
            this.layout.trigger('filter:toggle:savestate', true);
        }
        return this.initRow($row);
    },

    /**
     * Initializes a row either with the retrieved field values or the
     * default field values.
     *
     * @param {jQuery} [$row] The related filter row.
     * @param {Object} [data] The values to set in the fields.
     * @return {jQuery} $row The initialized row element.
     */
    initRow: function($row, data) {
        $row = $row || $(this.formRowTemplate()).appendTo(this.$el);
        data = data || {};
        var model, field, $fieldValue, $fieldContainer;

        // Init the row with the data available.
        $row.data('name', data.name);
        $row.data('operator', data.operator);
        $row.data('value', data.value);

        // Create a blank model for the enum field, and set the field value if
        // we know it.
        model = app.data.createBean(this.moduleName);
        if (data.name) {
            model.set('filter_row_name', data.name);
        }
        field = this.createField(model, {
            name: 'filter_row_name',
            type: 'enum',
            options: this.filterFields
        });

        // Add the field to the dom.
        $fieldValue = $row.find('[data-filter=field]');
        $fieldContainer = $(field.getPlaceholder().string);
        $fieldContainer.appendTo($fieldValue);

        // Store the field in the data attributes.
        $row.data('nameField', field);

        this._renderField(field, $fieldContainer);

        if (data.name) {
            this.initOperatorField($row);
        }
        return $row;
    },


    /**
     * Remove a row
     * @param {Event} e
     */
    removeRow: function(e) {
        var $row = this.$(e.currentTarget).closest('[data-filter=row]'),
            fieldOpts = [
                {field: 'nameField', value: 'name'},
                {field: 'operatorField', value: 'operator'},
                {field: 'valueField', value: 'value'}
            ];

        this._disposeRowFields($row, fieldOpts);
        $row.remove();
        this.layout.trigger('filter:toggle:savestate', true);
        if (this.$('[data-filter=row]').length === 0) {
            this.addRow();
        }
    },

    /**
     * Validate all filter rows.
     *
     * @param {Array} rows A list of rows to validate.
     * @return {Boolean} `true` if all filter rows are valid, `false`
     *   otherwise.
     */
    validateRows: function(rows) {
        return _.every(rows, this.validateRow, this);
    },

    /**
     * Verify the value of the row is not empty.
     *
     * @param {Element} $row The row to validate.
     * @return {Boolean} `true` if valid, `false` otherwise.
     *
     * TODO we should receive the data only and be jQuery agnostic.
     */
    validateRow: function(row) {
        var $row = $(row),
            data = $row.data();

        if (_.contains(this._operatorsWithNoValues, data.operator)) {
            return true;
        }

        // for empty value in currency we dont want to validate
        if (!_.isUndefined(data.valueField) && !_.isArray(data.valueField) && data.valueField.type ==='currency'
            && (_.isEmpty(data.value) || (_.isObject(data.value) &&
            _.isEmpty(data.valueField.model.get(data.name))))) {
            return false;
        }

        //For date range and predefined filters there is no value
        if (data.isDateRange || data.isPredefinedFilter) {
            return true;
        } else if (data.isFlexRelate) {
            return data.value ?
                _.reduce(data.value, function(memo, val) {
                    return memo && !_.isEmpty(val);
                }, true) :
                false;
        }

        //Special case for between operators where 2 values are needed
        if (_.contains(['$between', '$dateBetween'], data.operator)) {

            if (!_.isArray(data.value) || data.value.length !== 2) {
                return false;
            }

            switch (data.operator) {
                case '$between':
                    // FIXME: the fields should set a true number (see SC-3138).
                    return !(_.isNaN(parseFloat(data.value[0])) || _.isNaN(parseFloat(data.value[1])));
                case '$dateBetween':
                    return !_.isEmpty(data.value[0]) && !_.isEmpty(data.value[1]);
                default:
                    return false;
            }
        }

        return _.isNumber(data.value) || !_.isEmpty(data.value);
    },

    /**
     * Rerender the view with selected filter
     */
    populateFilter: function() {
        var name = this.context.editingFilter.get('name'),
            filterOptions = this.context.get('filterOptions') || {},
            populate = this.context.editingFilter.get('is_template') && filterOptions.filter_populate,
            filterDef = this.context.editingFilter.get('filter_template') ||
                this.context.editingFilter.get('filter_definition');

        this.render();
        this.layout.trigger('filter:set:name', name);

        if (populate) {
            filterDef = app.data.getBeanClass('Filters').prototype.populateFilterDefinition(filterDef, populate);
        }
        _.each(filterDef, function(row) {
            this.populateRow(row);
        }, this);
        //Set lastFilterDef because the filter has already been applied and fireSearch is called in _disposeRowFields
        this.lastFilterDef = this.buildFilterDef(true);
        this.lastFilterTemplate = this.buildFilterDef();
    },

    /**
     * Populates row fields with the row filter definition.
     *
     * In case it is a template filter that gets populated by values passed in
     * the context/metadata, empty values will be replaced by populated
     * value(s).
     *
     * @param {Object} rowObj The filter definition of a row.
     */
    populateRow: function(rowObj) {
        var moduleMeta = app.metadata.getModule(this.layout.currentModule);
        var fieldMeta = moduleMeta.fields;

        _.each(rowObj, function(value, key) {
            var isPredefinedFilter = (this.fieldList[key] && this.fieldList[key].predefined_filter === true);

            if (key === '$or') {
                var keys = _.reduce(value, function(memo, obj) {
                    return memo.concat(_.keys(obj));
                }, []);

                key = _.find(_.keys(this.fieldList), function(key) {
                    if (_.has(this.fieldList[key], 'dbFields')) {
                        return _.isEqual(this.fieldList[key].dbFields.sort(), keys.sort());
                    }
                }, this);

                // Predicates are identical, so we just use the first.
                value = _.values(value[0])[0];
            } else if (key === '$and') {
                var values = _.reduce(value, function(memo, obj) {
                        return _.extend(memo, obj);
                    }, {});
                var def = _.find(this.fieldList, function(fieldDef) {
                        return _.has(values, fieldDef.id_name || fieldDef.name);
                    }, this);

                var operator = '$equals';
                key = def ? def.name : key;

                //  We want to get the operator from our values object only for currency fields
                if (def && !_.isString(values[def.name]) && def.type === 'currency') {
                    operator = _.keys(values[def.name])[0];
                    values[key] = values[key][operator];
                }
                value = {};
                value[operator] = values;
            } else if (!fieldMeta[key] && !isPredefinedFilter) {
                return;
            }

            if (!this.fieldList[key]) {
                //Make sure we use name for relate fields
                var relate = _.find(this.fieldList, function(field) { return field.id_name === key; });
                // field not found so don't create row for it.
                if (!relate) {
                    return;
                }
                key = relate.name;
                // for relate fields in version < 7.7 we used `$equals` and `$not_equals` operator so for version
                // compatibility & as per TY-159 needed to fix this since 7.7 & onwards we will be using `$in` &
                // `$not_in` operators for relate fields
                if (_.isString(value) || _.isNumber(value)) {
                    value = {$in: [value]};
                } else if (_.keys(value)[0] === '$not_equals') {
                    var val = _.values([value])[0];
                    value = {$not_in: val};
                }
            }

            if (_.isString(value) || _.isNumber(value)) {
                value = {$equals: value};
            }
            _.each(value, function(value, operator) {
                this.initRow(null, {name: key, operator: operator, value: value});
            }, this);
        }, this);
    },

    /**
     * Fired when a user selects a field to filter by
     * @param {Event} e
     */
    handleFieldSelected: function(e) {
        var $el = this.$(e.currentTarget);
        var $row = $el.parents('[data-filter=row]');
        var fieldOpts = [
            {field: 'operatorField', value: 'operator'},
            {field: 'valueField', value: 'value'}
        ];
        this._disposeRowFields($row, fieldOpts);
        this.initOperatorField($row);
    },

    /**
     * Initializes the operator field.
     *
     * @param {jQuery} $row The related filter row.
     */
    initOperatorField: function($row) {
        var $fieldWrapper = $row.find('[data-filter=operator]');
        var data = $row.data();
        var fieldName = data.nameField.model.get('filter_row_name');
        var previousOperator = data.operator;

        // Make sure the data attributes contain the right selected field.
        data['name'] = fieldName;

        if (!fieldName) {
            return;
        }

        // For relate fields
        data.id_name = this.fieldList[fieldName].id_name;
        // For flex-relate fields
        data.type_name = this.fieldList[fieldName].type_name;

        //Predefined filters don't need operators and value field
        if (this.fieldList[fieldName].predefined_filter === true) {
            data.isPredefinedFilter = true;
            this.fireSearch();
            return;
        }

        // Get operators for this filter type
        var fieldType = this.fieldTypeMap[this.fieldList[fieldName].type] || this.fieldList[fieldName].type,
            payload = {},
            types = _.keys(this.filterOperatorMap[fieldType]);

        // For parent field with the operator '$equals', the operator field is
        // hidden and we need to display the value field directly. So here we
        // need to assign 'previousOperator' and 'data.operator variables' to let
        // the value field initialize.
        //FIXME: We shouldn't have a condition on the parent field. TY-352 will
        // fix it.
        if (fieldType === 'parent' && _.isEqual(types, ['$equals'])) {
            previousOperator = data.operator = types[0];
        }

        fieldType === 'parent' ?
            $fieldWrapper.addClass('hide').empty() :
            $fieldWrapper.removeClass('hide').empty();
        $row.find('[data-filter=value]').addClass('hide').empty();

        _.each(types, function(operand) {
            payload[operand] = app.lang.get(
                this.filterOperatorMap[fieldType][operand],
                [this.moduleName, 'Filters']
            );
        }, this);

        // Render the operator field
        var model = app.data.createBean(this.moduleName);

        if (previousOperator) {
            model.set('filter_row_operator', data.operator === '$dateRange' ? data.value : data.operator);
        }

        var field = this.createField(model, {
                name: 'filter_row_operator',
                type: 'enum',
                // minimumResultsForSearch set to 9999 to hide the search field,
                // See: https://github.com/ivaynberg/select2/issues/414
                searchBarThreshold: 9999,
                options: payload
            }),
            $field = $(field.getPlaceholder().string);

        $field.appendTo($fieldWrapper);
        data['operatorField'] = field;

        this._renderField(field, $field);

        var hide = fieldType === 'parent';
        this._hideOperator(hide, $row);

        // We want to go into 'initValueField' only if the field value is known.
        // We need to check 'previousOperator' instead of 'data.operator'
        // because even if the default operator has been set, the field would
        // have set 'data.operator' when it rendered anyway.
        if (previousOperator) {
            this.initValueField($row);
        }
    },

    /**
     * Shows or hides the operator field of the filter row specified.
     *
     * Automatically populates the operator field to have value `$equals` if it
     * is not in midst of populating the row.
     *
     * @param {boolean} hide Set to `true` to hide the operator field.
     * @param {jQuery} $row The filter row of interest.
     * @private
     */
    _hideOperator: function(hide, $row) {
        $row.find('[data-filter=value]')
            .toggleClass('span4', !hide)
            .toggleClass('span8', hide);
    },

    /**
     * Fired when a user selects an operator to filter by
     * @param {Event} e
     */
    handleOperatorSelected: function(e) {
        var $el = this.$(e.currentTarget);
        var $row = $el.parents('[data-filter=row]');
        var fieldOpts = [
            {'field': 'valueField', 'value': 'value'}
        ];
        this._disposeRowFields($row, fieldOpts);
        this.initValueField($row);
    },

    /**
     * Check if the selected filter operator is a collective type.
     *
     * @param {jQuery} $row The related filter row.
     */
    isCollectiveValue: function($row) {
        return $row.data('operator') === '$in' || $row.data('operator') === '$not_in';
    },

    /**
     * Initializes the value field.
     *
     * @param {jQuery} $row The related filter row.
     */
    initValueField: function($row) {
        var data = $row.data();
        var operation = data.operatorField.model.get('filter_row_operator');

        // Make sure the data attributes contain the right operator selected.
        data.operator = operation;
        if (!operation) {
            return;
        }

        if (_.contains(this._operatorsWithNoValues, operation)) {
            this.fireSearch();
            return;
        }

        // Patching fields metadata
        var moduleName = this.moduleName,
            module = app.metadata.getModule(moduleName),
            fields = app.metadata._patchFields(moduleName, module, app.utils.deepCopy(this.fieldList));

        // More patch for some field types
        var fieldName = $row.find('[data-filter=field] input[type=hidden]').select2('val'),
            fieldType = this.fieldTypeMap[this.fieldList[fieldName].type] || this.fieldList[fieldName].type,
            fieldDef = fields[fieldName];

        switch (fieldType) {
            case 'enum':
                fieldDef.isMultiSelect = this.isCollectiveValue($row);
                // Set minimumResultsForSearch to a negative value to hide the search field,
                // See: https://github.com/ivaynberg/select2/issues/489#issuecomment-13535459
                fieldDef.searchBarThreshold = -1;
                break;
            case 'bool':
                fieldDef.type = 'enum';
                fieldDef.options = fieldDef.options || 'filter_checkbox_dom';
                break;
            case 'int':
                fieldDef.auto_increment = false;
                //For $in operator, we need to convert `['1','20','35']` to `1,20,35` to make it work in a varchar field
                if (operation === '$in') {
                    fieldDef.type = 'varchar';
                    fieldDef.len = 200;
                    if (_.isArray($row.data('value'))) {
                        $row.data('value', $row.data('value').join(','));
                    }
                }
                break;
            case 'teamset':
                fieldDef.type = 'relate';
                fieldDef.isMultiSelect = this.isCollectiveValue($row);
                break;
            case 'datetimecombo':
            case 'date':
                fieldDef.type = 'date';
                //Flag to indicate the value needs to be formatted correctly
                data.isDate = true;
                if (operation.charAt(0) !== '$') {
                    //Flag to indicate we need to build the date filter definition based on the date operator
                    data.isDateRange = true;
                    this.fireSearch();
                    return;
                }
                break;
            case 'relate':
                fieldDef.auto_populate = true;
                fieldDef.isMultiSelect = this.isCollectiveValue($row);
                break;
            case 'parent':
                data.isFlexRelate = true;
                break;
        }
        fieldDef.required = false;
        fieldDef.readonly = false;

        // Create new model with the value set
        var model = app.data.createBean(moduleName);

        var $fieldValue = $row.find('[data-filter=value]');
        $fieldValue.removeClass('hide').empty();

        //fire the change event as soon as the user start typing
        var _keyUpCallback = function(e) {
            if ($(e.currentTarget).is(".select2-input")) {
                return; //Skip select2. Select2 triggers other events.
            }
            this.value = $(e.currentTarget).val();
            // We use "silent" update because we don't need re-render the field.
            model.set(this.name, this.unformat($(e.currentTarget).val()), {silent: true});
            model.trigger('change');
        };

        //If the operation is $between we need to set two inputs.
        if (operation === '$between' || operation === '$dateBetween') {
            var minmax = [];
            var value = $row.data('value') || [];
            if (fieldType === 'currency' && $row.data('value')) {
                value = $row.data('value') || {};
                model.set(value);
                value = value[fieldName] || [];
                // FIXME: Change currency.js to retrieve correct unit for currency filters (see TY-156).
                model.set('id', 'not_new');
            }

            model.set(fieldName + '_min', value[0] || '');
            model.set(fieldName + '_max', value[1] || '');
            minmax.push(this.createField(model, _.extend({}, fieldDef, {name: fieldName + '_min'})));
            minmax.push(this.createField(model, _.extend({}, fieldDef, {name: fieldName + '_max'})));

            if(operation === '$dateBetween') {
                minmax[0].label = app.lang.get('LBL_FILTER_DATEBETWEEN_FROM');
                minmax[1].label = app.lang.get('LBL_FILTER_DATEBETWEEN_TO');
            } else {
                minmax[0].label = app.lang.get('LBL_FILTER_BETWEEN_FROM');
                minmax[1].label = app.lang.get('LBL_FILTER_BETWEEN_TO');
            }

            data['valueField'] = minmax;

            _.each(minmax, function(field) {
                var fieldContainer = $(field.getPlaceholder().string);
                $fieldValue.append(fieldContainer);
                this.listenTo(field, 'render', function() {
                    field.$('input, select, textarea').addClass('inherit-width');
                    field.$('.input-append').prepend('<span class="add-on">' + field.label + '</span>');
                    field.$('.input-append').addClass('input-prepend');
                    // .date makes .inherit-width on input have no effect so we need to remove it.
                    field.$('.input-append').removeClass('date');
                    field.$('input, textarea').on('keyup', _.debounce(_.bind(_keyUpCallback, field), 400));
                });
                this._renderField(field, fieldContainer);
            }, this);
        } else if (data.isFlexRelate) {
            _.each($row.data('value'), function(value, key) {
                model.set(key, value);
            }, this);

            var field = this.createField(model, _.extend({}, fieldDef, {name: fieldName})),
                fieldContainer = $(field.getPlaceholder().string),
                findRelatedName = app.data.createBeanCollection(model.get('parent_type'));
            data['valueField'] = field;
            $fieldValue.append(fieldContainer);

            if (model.get('parent_id')) {
                findRelatedName.fetch({
                    params: {filter: [{'id': model.get('parent_id')}]},
                    complete: _.bind(function() {
                        if (!this.disposed) {
                            if (findRelatedName.first()) {
                                model.set(fieldName,
                                    findRelatedName.first().get(field.getRelatedModuleField()),
                                    {silent: true});
                            }
                            if (!field.disposed) {
                                this._renderField(field, fieldContainer);
                            }
                        }
                    }, this)
                });
            } else {
                this._renderField(field, fieldContainer);
            }
        } else {
            // value is either an empty object OR an object containing `currency_id` and currency amount
            if (fieldType === 'currency' && $row.data('value')) {
                // for stickiness & to retrieve correct saved values, we need to set the model with data.value object
                model.set($row.data('value'));
                // FIXME: Change currency.js to retrieve correct unit for currency filters (see TY-156).
                // Mark this one as not_new so that model isn't treated as new
                model.set('id', 'not_new');
            } else {
                model.set(fieldDef.id_name || fieldName, $row.data('value'));
            }
            // Render the value field
            var field = this.createField(model, _.extend({}, fieldDef, {name: fieldName})),
                fieldContainer = $(field.getPlaceholder().string);
            $fieldValue.append(fieldContainer);
            data['valueField'] = field;

            this.listenTo(field, 'render', function() {
                field.$('input, select, textarea').addClass('inherit-width');
                // .date makes .inherit-width on input have no effect so we need to remove it.
                field.$('.input-append').removeClass('date');
                field.$('input, textarea').on('keyup',_.debounce(_.bind(_keyUpCallback, field), 400));
            });
            if ((fieldDef.type === 'relate' || fieldDef.type === 'nestedset') &&
                !_.isEmpty($row.data('value'))
            ) {
                var self = this;
                var findRelatedName = app.data.createBeanCollection(fieldDef.module);
                var relateOperator = this.isCollectiveValue($row) ? '$in' : '$equals';
                var relateFilter = [{id: {}}];
                relateFilter[0].id[relateOperator] = $row.data('value');
                findRelatedName.fetch({fields: [fieldDef.rname], params: {filter: relateFilter},
                    complete: function() {
                        if (!self.disposed) {
                            if (findRelatedName.length > 0) {
                                model.set(fieldDef.id_name, findRelatedName.pluck('id'), { silent: true });
                                model.set(fieldName, findRelatedName.pluck(fieldDef.rname), { silent: true });
                            }
                            if (!field.disposed) {
                                self._renderField(field, fieldContainer);
                            }
                        }
                    }
                });
            } else {
                this._renderField(field, fieldContainer);
            }
        }
        // When the value change a quicksearch should be fired to update the results
        this.listenTo(model, "change", function() {
            this._updateFilterData($row);
            this.fireSearch();
        });

        // Manually trigger the filter request if a value has been selected lately
        // This is the case for checkbox fields or enum fields that don't have empty values.
        var modelValue = model.get(fieldDef.id_name || fieldName);

        // To handle case: value is an object with 'currency_id' = 'xyz' and 'likely_case' = ''
        // For currency fields, when value becomes an object, trigger change
        if (!_.isEmpty(modelValue) && modelValue !== $row.data('value')) {
            model.trigger('change');
        }
    },

    /**
     * Update filter data for this row
     * @param $row Row to update
     * @private
     */
    _updateFilterData: function($row){
        var data = $row.data(),
            field = data['valueField'],
            name = data['name'],
            valueForFilter;

        //Make sure we use ID for relate fields
        if (this.fieldList[name] && this.fieldList[name].id_name) {
            name = this.fieldList[name].id_name;
        }

        //If we have multiple fields we have to build an array of values
        if (_.isArray(field)) {
            valueForFilter = [];
            _.each(field, function(field) {
                var value = !field.disposed && field.model.has(field.name) ? field.model.get(field.name) : '';
                value = $row.data('isDate') ? (app.date.stripIsoTimeDelimterAndTZ(value) || '') : value;
                valueForFilter.push(value);
            });
        } else {
            var value = !field.disposed && field.model.has(name) ? field.model.get(name) : '';
            valueForFilter = $row.data('isDate') ? (app.date.stripIsoTimeDelimterAndTZ(value) || '') : value;
        }
        $row.data("value", valueForFilter); // Update filter value once we've calculated final value
    },

    /**
     * Check each row, builds the filter definition and trigger the filtering
     */
    fireSearch: _.debounce(function() {
        var filterDef = this.buildFilterDef(true),
            filterTemplate = this.buildFilterDef(),
            defHasChanged = !_.isEqual(this.lastFilterDef, filterDef),
            templateHasChanged = !_.isEqual(this.lastFilterTemplate, filterTemplate);

        // Save the current edit state
        if (defHasChanged || templateHasChanged) {
            this.saveFilterEditState(filterDef, filterTemplate);
            this.lastFilterDef = filterDef;
            this.lastFilterTemplate = filterTemplate;
            this.layout.trigger('filter:toggle:savestate', true);
        }
        if (!defHasChanged) {
            return;
        }
        // Needed in order to prevent filtering a global context collection (see filter.js:applyFilter()).
        if (this.context.get('applyFilter') !== false) {
            this.layout.trigger('filter:apply', null, filterDef);
        }
    }, 400),

    /**
     * Saves the current edit state into the cache
     *
     * @param {Object} [filterDef] Filter Definition. Defaults to the
     *   {@link #builtFilderDef} with only valid rows.
     * @param {Object} [templateDef] Filter template definition. Defaults to
     *   the {@link #builtFilderDef} with all rows.
     */
    saveFilterEditState: function(filterDef, templateDef) {
        if (!this.context.editingFilter) {
            return;
        }
        this.context.editingFilter.set({
            'filter_definition': filterDef || this.buildFilterDef(true),
            'filter_template': templateDef || this.buildFilterDef()
        });
        var filter = this.context.editingFilter.toJSON();

        // Make sure the filter-actions view is rendered, otherwise it will override the name with an empty name.
        if (this.layout.getComponent('filter-actions') &&
            this.layout.getComponent('filter-actions').$('input').length === 1
        ) {
            filter.name = this.layout.getComponent('filter-actions').getFilterName();
        }
        this.layout.getComponent('filter').saveFilterEditState(filter);
    },

    /**
     * Build filter definition for all rows.
     *
     * @param {Boolean} onlyValidRows Set `true` to retrieve only filter
     *   definition of valid rows, `false` to retrieve the entire field
     *   template.
     * @return {Array} Filter definition.
     */
    buildFilterDef: function(onlyValidRows) {
        var $rows = this.$('[data-filter=row]'),
            filter = [];

        _.each($rows, function(row) {
            var rowFilter = this.buildRowFilterDef($(row), onlyValidRows);

            if (rowFilter) {
                filter.push(rowFilter);
            }
        }, this);

        return filter;
    },

    /**
     * Build filter definition for this row.
     *
     * @param {jQuery} $row The related row.
     * @param {Boolean} onlyIfValid Set `true` to validate the row and return
     *   `undefined` if not valid, or `false` to build the definition anyway.
     * @return {Object} Filter definition for this row.
     */
    buildRowFilterDef: function($row, onlyIfValid) {
        var data = $row.data();
        if (onlyIfValid && !this.validateRow($row)) {
            return;
        }
        var operator = data['operator'],
            value = data['value'] || '',
            name = data['id_name'] || data['name'],
            filter = {};

        if (_.isEmpty(name)) {
            return;
        }

        if (data.isPredefinedFilter || !this.fieldList) {
            filter[name] = '';
            return filter;
        } else {
            if (this.fieldList[name] && _.has(this.fieldList[name], 'dbFields')) {
                var subfilters = [];
                _.each(this.fieldList[name].dbFields, function(dbField) {
                    var filter = {};
                    filter[dbField] = {};
                    filter[dbField][operator] = value;
                    subfilters.push(filter);
                });
                filter['$or'] = subfilters;
            } else {
                if (data.isFlexRelate) {
                    var valueField = data['valueField'],
                        idFilter = {},
                        typeFilter = {};

                    idFilter[data.id_name] = valueField.model.get(data.id_name);
                    typeFilter[data.type_name] = valueField.model.get(data.type_name);
                    filter['$and'] = [idFilter, typeFilter];
                // Creating currency filter. For all but `$between` operators we use type property from data.valueField.
                // For `$between`, data.valueField is an array and therefore we check for type==='currency' from
                // either of the elements.
                } else if (data['valueField'] && (data['valueField'].type === 'currency' ||
                    (_.isArray(data.valueField) && data.valueField[0].type === 'currency'))
                    ) {
                    // initially value is an array which we later convert into an object for saving and retrieving
                    // purposes (stickiness structure constraints)
                    var amountValue;
                    if (_.isObject(value) && !_.isUndefined(value[name])) {
                        amountValue = value[name];
                    } else {
                        amountValue = value;
                    }

                    var amountFilter = {};
                    amountFilter[name] = {};
                    amountFilter[name][operator] = amountValue;

                    // for `$between`, we use first element to get dataField ('currency_id') since it is same
                    // for both elements and also because data.valueField is an array
                    var dataField;
                    if (_.isArray(data.valueField)) {
                        dataField = data.valueField[0];
                    } else {
                        dataField = data.valueField;
                    }

                    var currencyId;
                    currencyId = dataField.getCurrencyField().name;

                    var currencyFilter = {};
                    currencyFilter[currencyId] = dataField.model.get(currencyId);

                    filter['$and'] = [amountFilter, currencyFilter];
                } else if (data.isDateRange) {
                    //Once here the value is actually a key of date_range_selector_dom and we need to build a real
                    //filter definition on it.
                    filter[name] = {};
                    filter[name].$dateRange = operator;
                } else if (operator === '$in' || operator === '$not_in') {
                    // IN/NOT IN require an array
                    filter[name] = {};
                    //If value is not an array, we split the string by commas to make it an array of values
                    if (_.isArray(value)) {
                        filter[name][operator] = value;
                    } else if (!_.isEmpty(value)) {
                        filter[name][operator] = (value + '').split(',');
                    } else {
                        filter[name][operator] = [];
                    }
                } else {
                    filter[name] = {};
                    filter[name][operator] = value;
                }
            }

            return filter;
        }
    },

    /**
     * Reset filter values on filter form. Called after a click on `Reset` button
     */
    resetFilterValues: function() {
        var $rows = this.$('[data-filter=row]');
        _.each($rows, function(row) {
            var $row = $(row);
            var valueField = $row.data('valueField');

            if (!valueField || valueField.disposed) {
                return;
            }
            if (!_.isArray(valueField)) {
                valueField.model.clear();
                return;
            }
            _.each(valueField, function(field) {
                field.model.clear();
            });
        });
    },

    /**
     * Disposes fields stored in the data attributes of the row element.
     *
     *     @example of an `opts` object param:
     *      [
     *       {field: 'nameField', value: 'name'},
     *       {field: 'operatorField', value: 'operator'},
     *       {field: 'valueField', value: 'value'}
     *      ]
     *
     * @param  {jQuery} $row The row which fields are to be disposed.
     * @param  {Array} opts An array of objects containing the field object and
     *  value to the data attributes of the row.
     */
    _disposeRowFields: function($row, opts) {
        var data = $row.data(), model;

        if (_.isObject(data) && _.isArray(opts)) {
            _.each(opts, function(val) {
                if (data[val.field]) {
                    //For in between filter we have an array of fields so we need to cover all cases
                    var fields = _.isArray(data[val.field]) ? data[val.field] : [data[val.field]];
                    data[val.value] = '';
                    _.each(fields, function(field) {
                        model = field.model;
                        if (val.field === "valueField" && model) {
                            model.clear({silent: true});
                            this.stopListening(model);
                        }
                        field.dispose();
                        field = null;
                    }, this);
                    return;
                }
                if (data.isDateRange && val.value === 'value') {
                    data.value = '';
                }
            }, this);
        }
        //Reset flags
        data.isDate = false;
        data.isDateRange = false;
        data.isPredefinedFilter = false;
        data.isFlexRelate = false;
        $row.data(data);
        this.fireSearch();
    }
}) },
"sweetspot-config-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotConfigHeaderpaneView
 * @alias SUGAR.App.view.views.BaseSweetspotConfigHeaderpaneView
 * @extends View.View
 */
({
	// Sweetspot-config-headerpane View (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._bindEvents();
    },

    /**
     * Binds events that this view uses.
     */
    _bindEvents: function() {
        this.context.on('sweetspot:config:enableButtons', this.toggleButtons, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this.registerShortcuts();
    },

    /**
     * Toggles the buttons in this view between enabled/disabled states.
     *
     * FIXME: This method should be updated to use `this.buttons` instead of
     * looping over all the fields. Update this when SC-3909 is merged.
     *
     * @param {boolean} [enable=false] Whether to enable or disable the action
     *   buttons. Defaults to `false`.
     */
    toggleButtons: function(enable) {
        var state = !_.isUndefined(enable) ? !enable : false;

        _.each(this.fields, function(field) {
            if (field instanceof app.view.fields.BaseButtonField) {
                field.setDisabled(state);
            }
        });
    },

    /**
     * Register keyboard shortcuts for various headerpane buttons.
     */
    registerShortcuts: function() {
        app.shortcuts.register({
            id: 'SweetSpot:Config:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_SAVE_CONFIG',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=save_button]');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'SweetSpot:Config:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.get(0).click();
                }
            }
        });
    }
}) },
"quickcreate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuickcreateView
 * @alias SUGAR.App.view.views.BaseQuickcreateView
 * @extends View.View
 */
({
	// Quickcreate View (base) 

    plugins: ['Dropdown'],

    /**
     * @param {Object} options
     * @inheritdoc
     */
    initialize: function(options) {
        app.events.on("app:sync:complete", this.render, this);
        app.view.View.prototype.initialize.call(this, options);

        //shortcut keys
        app.shortcuts.registerGlobal({
            id: 'Quickcreate:Toggle',
            keys: 'c',
            component: this,
            description: 'LBL_SHORTCUT_QUICK_CREATE',
            handler: function() {
                this.$('[data-toggle=dropdown]').click();
            }
        });
    },

    /**
     * @inheritdoc
     * @private
     */
    _renderHtml: function() {
        if (!app.api.isAuthenticated() || app.config.appStatus == 'offline') {
            return;
        }
        // loadAdditionalComponents fires render before the private metadata is ready, check for this
        if (app.isSynced) {
            this.createMenuItems = this._getMenuMeta(
                app.metadata.getModuleNames({filter: ['visible', 'quick_create'], access: 'create'})
            );
            app.view.View.prototype._renderHtml.call(this);
        }
    },

    /**
     * Retrieve the quickcreate metadata from each module in the list
     * Uses the visible flag on the metadata to determine if admin has elected to hide the module from the list
     *
     * @param {Array} module The module names
     * @return {Array} list of visible menu item metadata
     */
    _getMenuMeta: function(modules) {
        var returnList = [];
        _.each(modules, function(name) {
            var meta = app.metadata.getModule(name);
            if (meta && meta.menu && meta.menu.quickcreate) {
                var menuItem = _.clone(meta.menu.quickcreate.meta);
                if (menuItem.visible === true) {
                    menuItem.module = name;
                    menuItem.type = menuItem.type || 'quickcreate';
                    // apply default icon for compatibility with customizations from previous versions
                    // but leave the possibility to turn icon off by specifying empty value
                    if (!("icon" in menuItem)) {
                        menuItem.icon = "fa fa-plus";
                    }
                    //TODO: refactor sidecar field hbs helper so it can accept the module name directly
                    menuItem.model = app.data.createBean(name);
                    returnList.push(menuItem);
                }
            }
        }, this);
        return this._sortByOrder(returnList);
    },

    /**
     * Sorts the module list based upon the value of the order attribute.
     *
     * @param {Array} moduleList
     * @return {Array}
     * @private
     */
    _sortByOrder: function(moduleList) {
        return moduleList.sort(function(a, b) {
            var order = a['order'] - b['order'];
            return (order == 0) ? (a['label'] > b['label']) : order;
        });
    }
}) },
"dupecheck-list-multiselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListMultiselectView
 * @alias SUGAR.App.view.views.BaseDupecheckListMultiselectView
 * @extends View.Views.Base.DupecheckListView
 */
({
	// Dupecheck-list-multiselect View (base) 

    extendsFrom: 'DupecheckListView',
    additionalTableClasses: 'duplicates-multiselect',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['MassCollection']);
        this._super('initialize', [options]);
    }
}) },
"filter-filter-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for the filter dropdown.
 *
 * Part of {@link View.Layouts.Base.FilterLayout}.
 *
 * @class View.Views.Base.FilterFilterDropdownView
 * @alias SUGAR.App.view.views.BaseFilterFilterDropdownView
 * @extends View.View
 */
({
	// Filter-filter-dropdown View (base) 

    tagName: "span",
    className: "table-cell",

    events: {
        'click .choice-filter.choice-filter-clickable': 'handleEditFilter',
        'keydown .choice-filter.choice-filter-clickable': 'handleEditFilter',
        'click .choice-filter-close': 'handleClearFilter',
        'keydown .choice-filter-close': 'handleClearFilter',
    },

    /**
     * These labels are used in the filter dropdown
     *  - labelDropdownTitle        label used as the dropdown title. ie `Filter`
     *  - labelCreateNewFilter      label for create new filter action. ie `Create`
     *  - labelAllRecords           label used on record view when all related modules are selected. ie `All Records`
     *
     *  - labelAllRecordsFormatted  label used when all records are selected. ie `All <Module>s`
     *
     *                              It is set to null because already defined per module. However, some views are
     *                              allowed to override it because of the context. For instance, `dupecheck-list` view
     *                              wants to display `All duplicates` instead of `All <Module>s`
     */
    labelDropdownTitle:         'LBL_FILTER',
    labelCreateNewFilter:       'LBL_FILTER_CREATE_NEW',
    labelAllRecords:            'LBL_FILTER_ALL_RECORDS',
    labelAllRecordsFormatted:   null,


    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        app.view.View.prototype.initialize.call(this, opts);

        //Load partials
        this._select2formatSelectionTemplate = app.template.get("filter-filter-dropdown.selection-partial");
        this._select2formatResultTemplate = app.template.get("filter-filter-dropdown.result-partial");

        this.listenTo(this.layout, "filter:select:filter", this.handleSelect);
        this.listenTo(this.layout, "filter:change:module", this.handleModuleChange);
        this.listenTo(this.layout, "filter:render:filter", this._renderHtml);
        this.listenTo(this.layout, 'filter:create:close', this.formatSelection);
    },

    /**
     * Truthy when filter dropdown is enabled.  Updated whenever the filter module changes.
     */
    filterDropdownEnabled: true,

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        if (!this.layout.filters) {
            return;
        }
        this._super('_renderHtml');

        this.filterList = this.getFilterList();

        this._renderDropdown(this.filterList);
    },

    /**
     * Get the list of filters to fill the dropdown
     * @return {Array}
     */
    getFilterList: function() {
        var filters = [];
        if (this.layout.canCreateFilter()) {
            filters.push({id: "create", text: app.lang.get(this.labelCreateNewFilter)});
        }
        if (this.layout.filters.collection.get('all_records') && this.labelAllRecordsFormatted) {
            this.layout.filters.collection.get('all_records').set('name',  this.labelAllRecordsFormatted);
            this.layout.filters.collection.sort();
        }
        // This flag is used to determine when we have to add the border top (to separate categories)
        var firstNonEditable = false;
        this.layout.filters.collection.each(function(model) {
            var opts = {
                id: model.id,
                text: this.layout.filters.collection._getTranslatedFilterName(model)
            };
            if (model.get("editable") === false && !firstNonEditable) {
                opts.firstNonUserFilter = true;
                firstNonEditable = true;
            }
            filters.push(opts);
        }, this);

        return filters;
    },

    /**
     * Render select2 dropdown
     *
     * This function may be called even when this.render() is not because of
     * the "filter:render:filter" event listener.
     *
     * @private
     */
    _renderDropdown: function(data) {
        var self = this;
        this.filterNode = this.$(".search-filter");

        this.filterNode.select2({
            data: data,
            multiple: false,
            minimumResultsForSearch: 7,
            formatSelection: _.bind(this.formatSelection, this),
            formatResult: _.bind(this.formatResult, this),
            formatResultCssClass: _.bind(this.formatResultCssClass, this),
            dropdownCss: {width: 'auto'},
            dropdownCssClass: 'search-filter-dropdown',
            initSelection: _.bind(this.initSelection, this),
            escapeMarkup: function(m) {
                return m;
            },
            shouldFocusInput: function() {
                // We return false here so that we do not refocus on the field once
                // it has been blurred. If we return true, blur needs to happen
                // twice before it is really blurred.
                return false;
            },
            width: 'off'
        });

        // the shortcut keys need to be registered anytime this function is
        // called, not just on render
        app.shortcuts.register({
            id: 'Filter:Create',
            keys: ['f c', 'mod+alt+8'],
            component: this,
            description: 'LBL_SHORTCUT_FILTER_CREATE',
            handler: function() {
                // trigger the change event to open the edit filter drawer
                this.filterNode.select2('val', 'create', true);
            }
        });
        app.shortcuts.register({
            id: 'Filter:Edit',
            keys: 'f e',
            component: this,
            description: 'LBL_SHORTCUT_FILTER_EDIT',
            handler: function() {
                this.$('.choice-filter.choice-filter-clickable').click();
            }
        });
        app.shortcuts.register({
            id: 'Filter:Show',
            keys: 'f m',
            component: this,
            description: 'LBL_SHORTCUT_FILTER_SHOW',
            handler: function() {
                this.filterNode.select2('open');
            }
        });

        if (!this.filterDropdownEnabled) {
            this.filterNode.select2("disable");
        }

        this.filterNode.off("change");
        this.filterNode.on("change",
            /**
             * Called when the user selects a filter in the dropdown
             *
             * @triggers filter:change:filter on filter layout to indicate a new
             *   filter has been selected.
             *
             * @param {Event} e The `change` event.
             */
            function(e) {
                self.layout.trigger('filter:change:filter', e.val);
            }
        );
    },

    /**
     * This handler is useful for other components that trigger
     * `filter:select:filter` in order to select the dropdown value.
     *
     * @param {String} id The id of the filter to select in the dropdown.
     */
    handleSelect: function(id) {
        this.filterNode.select2('val', id, true);
    },

    /**
     * Get the dropdown labels for the filter
     * @param {Object} el
     * @param {Function} callback
     */
    initSelection: function(el, callback) {
        var data,
            model,
            val = el.val();

        if (val === 'create') {
            //It should show `Create`
            data = {id: "create", text: app.lang.get(this.labelCreateNewFilter)};

        } else {
            model = this.layout.filters.collection.get(val);

            //Fallback to `all_records` filter if not able to retrieve selected filter
            if (!model) {
                data = {id: "all_records", text: app.lang.get(this.labelAllRecords)};

            } else if (val === "all_records") {
                data = this.formatAllRecordsFilter(null, model);
            } else {
                data = {id: model.id, text: this.layout.filters.collection._getTranslatedFilterName(model)};
            }
        }

        callback(data);
    },

    /**
     * Update the text for the selected filter and returns template
     * @param {Object} item
     * @return {string}
     */
    formatSelection: function(item) {
        var ctx = {},
            safeString,
            a11yLabel = app.lang.get('LBL_FILTER_CREATE_FILTER'),
            a11yTabindex = 0;

        //Don't remove this line. We want to update the selected filter name but don't want to change to the filter
        //name displayed in the dropdown
        item = _.clone(item);

        this.toggleFilterCursor(this.isFilterEditable(item.id));

        if (item.id === 'all_records') {
            item = this.formatAllRecordsFilter(item);
        }

        //Escape string to prevent XSS injection
        safeString = Handlebars.Utils.escapeExpression(item.text);
        if (item.id !== 'all_records') {
            if (this.isFilterEditable(item.id)) {
                a11yTabindex = 0;
                a11yLabel = app.lang.get('LBL_FILTER_EDIT_FILTER') + ' ' + safeString;
            } else {
                a11yTabindex = -1;
                a11yLabel = safeString + ' ' + app.lang.get('LBL_FILTER');
            }
        } else {
            a11yTabindex = this.isFilterEditable(item.id) ? 0 : -1;
        }

        // Update the text for the selected filter.
        this.$('.choice-filter-label')
            .html(safeString)
            .attr('aria-label', a11yLabel)
            .attr('tabindex', a11yTabindex);

        this.$('.choice-filter-close').toggle(item.id !== 'all_records');
        this.$('.choice-filter').toggleClass('with-close', item.id !== 'all_records');

        ctx.label = app.lang.get(this.labelDropdownTitle);
        ctx.enabled = this.filterDropdownEnabled;

        return this._select2formatSelectionTemplate(ctx);
    },

    /**
     * Returns template
     * @param {Object} option
     * @return {string}
     */
    formatResult: function(option) {
        if (option.id === this.layout.getLastFilter(this.layout.layout.currentModule, this.layout.layoutType)) {
            option.icon = 'fa-check';
        } else if (option.id === 'create') {
            option.icon = 'fa-plus';
        } else {
            option.icon = undefined;
        }
        return this._select2formatResultTemplate(option);
    },

    /**
     * Adds a class to the `Create Filter` item (to add border bottom)
     * and a class to first user custom filter (to add border top)
     *
     * @param {Object} item
     * @return {string} css class to attach
     */
    formatResultCssClass: function(item) {
        if (item.id === 'create') { return 'select2-result-border-bottom'; }
        if (item.firstNonUserFilter) { return 'select2-result-border-top'; }
    },

    /**
     * Determine if a filter is editable
     *
     * @param {String} id
     * @return {boolean} `true` if filter is editable, `false` otherwise
     */
    isFilterEditable: function(id) {
        if (!this.layout.canCreateFilter() || !this.filterDropdownEnabled || this.layout.showingActivities) {
            return false;
        }
        if (id === "create" || id === 'all_records') {
            return true;
        } else {
            return !this.layout.filters.collection.get(id) || this.layout.filters.collection.get(id).get('editable') !== false;
        }
    },

    /**
     * Toggles cursor depending if the filter is editable or not.
     *
     * @param {boolean} active `true` for a pointer cursor, `false` for a not allowed cursor
     */
    toggleFilterCursor: function(editable) {
        this.$('.choice-filter')
            .css('cursor', editable ? 'pointer' : 'not-allowed')
            .toggleClass('choice-filter-clickable', editable);
    },

    /**
     * Formats label for `all_records` filter. When showing all subpanels, we expect `All records`
     *
     * @param {Object} item
     * @return {Object} item with formatted label
     */
    formatAllRecordsFilter: function (item, model) {
        item = item || {id: 'all_records'};

        //SP-1819: Seeing "All Leads" instead of "All Records" in sub panel
        //For the record view our Related means all subpanels (so should show `All Records`)
        var allRelatedModules = _.indexOf([this.module, 'all_modules'], this.layout.layout.currentModule) > -1;

        //If ability to create a filter
        if (this.isFilterEditable(item.id)) {
            item.text = app.lang.get(this.labelCreateNewFilter);
        } else if (this.layout.layoutType === 'record' && allRelatedModules) {
            item.text = app.lang.get(this.labelAllRecords);
            this.toggleFilterCursor(false);
        } else if (model) {
            item.text = this.layout.filters.collection._getTranslatedFilterName(model);
        }
        return item;
    },

    /**
     * Handler for when the user selects a filter in the filter bar,
     * or user clicks the filter button to create or edit.
     */
    handleEditFilter: function(evt) {
        if (evt && evt.type === 'keydown') {
            if (evt.keyCode !== $.ui.keyCode.SPACE && evt.keyCode !== $.ui.keyCode.ENTER) {
                return;
            }
            // Prevent scrolling page with space
            evt.preventDefault();
            evt.stopPropagation();
        }

        var filterId = this.filterNode.val(),
            filterModel,
            a11yTabindex = 0;

        if (filterId === 'all_records') {
            // Figure out if we have an edit state. This would mean user was editing the filter so we want him to retrieve
            // the filter form in the state he left it.
            this.layout.trigger("filter:select:filter", 'create');
            a11yTabindex = 0;
        } else {
            filterModel = this.layout.filters.collection.get(filterId);
            a11yTabindex = -1;
        }

        if (filterModel && filterModel.get("editable") !== false) {
            this.layout.trigger("filter:create:open", filterModel);
            a11yTabindex = 0;
        }

        this.$('.choice-filter-label')
            .attr('aria-label', app.lang.get('LBL_FILTER_EDIT_FILTER'))
            .attr('tabindex', a11yTabindex);
    },

    /**
     * Handler for when the user selects a module in the filter bar.
     */
    handleModuleChange: function(linkModuleName, linkName) {
        this.filterDropdownEnabled = (linkName !== "all_modules");
    },

    /**
     * When a click happens on the close icon, clear the last filter and trigger reinitialize
     * @param {Event} evt
     */
    handleClearFilter: function(evt) {
        if (evt && evt.type === 'keydown' &&
            !(evt.keyCode === $.ui.keyCode.ENTER ||  evt.keyCode === $.ui.keyCode.SPACE)) {
            return;
        }

        //This event is fired within .choice-filter and another event is attached to .choice-filter
        //We want to stop propagation so it doesn't bubble up.
        evt.stopPropagation();
        this.layout.clearLastFilter(this.layout.layout.currentModule, this.layout.layoutType);
        var filterId;
        if (this.context.get('currentFilterId') === this.layout.filters.collection.defaultFilterFromMeta) {
            filterId = 'all_records';
        } else {
            filterId = this.layout.filters.collection.defaultFilterFromMeta;
        }
        this.layout.trigger('filter:select:filter', filterId);
    },

    /**
     * @override
     * @private
     */
    _dispose: function() {
        if (!_.isEmpty(this.filterNode)) {
            this.filterNode.select2('destroy');
        }
        app.view.View.prototype._dispose.call(this);
    }
}) },
"themeroller": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ThemerollerView
 * @alias SUGAR.App.view.views.BaseThemerollerView
 * @extends View.View
 */
({
	// Themeroller View (base) 

    events: {
        'click [name=save_button]': 'saveTheme',
        'click [name=refresh_button]': 'loadTheme',
        'click [name=reset_button]': 'resetTheme',
        'blur input': 'previewTheme'
    },
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.set('skipFetch', true);
        this.customTheme = 'default';
        this.loadTheme();
    },
    parseLessVars: function() {
        if (this.lessVars && this.lessVars.rel && this.lessVars.rel.length > 0) {
            _.each(this.lessVars.rel, function(obj, key) {
                this.lessVars.rel[key].relname = this.lessVars.rel[key].value;
                this.lessVars.rel[key].relname = this.lessVars.rel[key].relname.replace('@', '');
            }, this);
        }
    },
    _renderHtml: function() {
        if (!app.acl.hasAccess('admin', 'Administration')) {
            return;
        }
        this.parseLessVars();
        app.view.View.prototype._renderHtml.call(this);
        _.each(this.$('.hexvar[rel=colorpicker]'), function(obj, key) {
            $(obj).blur(function() {
                $(this).parent().parent().find('.swatch-col').css('backgroundColor', $(this).val());
            });
        }, this);
        this.$('.hexvar[rel=colorpicker]').colorpicker();
        this.$('.rgbavar[rel=colorpicker]').colorpicker({format: 'rgba'});
    },
    loadTheme: function() {
        this.themeApi('read', {}, _.bind(function(data) {
            this.lessVars = data;
            if (this.disposed) {
                return;
            }
            this.render();
            this.previewTheme();
        }, this));
    },
    saveTheme: function() {
        var self = this;
        // get the value from each input
        var colors = this.getInputValues();

        this.showMessage('LBL_SAVE_THEME_PROCESS');
        this.themeApi('create', colors, function() {
            app.alert.dismissAll();
        });
    },
    resetTheme: function() {
        var self = this;
        app.alert.show('reset_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_RESET_THEME_MODAL_INFO'),
            onConfirm: function() {
                self.showMessage('LBL_RESET_THEME_PROCESS');
                self.themeApi('create', {'reset': true}, function(data) {
                    app.alert.dismissAll();
                    self.loadTheme();
                });
            }
        });
    },
    previewTheme: function() {
        var colors = this.getInputValues();
        this.context.set('colors', colors);
    },
    themeApi: function(method, params, successCallback) {
        var self = this;
        _.extend(params, {
            platform: 'portal',
            themeName: self.customTheme
        });
        var paramsGET = (method === 'read') ? params : {};
        var paramsPOST = (method === 'read') ? {} : params;
        var url = app.api.buildURL('theme', '', {}, paramsGET);
        app.api.call(method, url, paramsPOST,
            {
                success: successCallback,
                error: function(error) {
                    if (error.status === 412) {
                        self._handleMetadataSyncError(error, method, url, paramsPOST, successCallback);
                    } else {
                        app.error.handleHttpError(error);
                    }
                }
            },
            { context: self }
        );
    },
    getInputValues: function() {
        var colors = {};
        this.$('input').each(function() {
            var $this = $(this);
            colors[$this.attr('name')] = $this.hasClass('bgvar') ? '"' + $this.val() + '"' : $this.val();
        });
        return colors;
    },
    showMessage: function(messageKey) {
        app.alert.show('themeProcessing', {
            level: 'process',
            title: app.lang.get(messageKey),
            closeable: true,
            autoclose: true
        });
    },

    /**
     * Handles HTTP error 412 Metadata out of sync when saving the portal theme.
     * Syncs the metadata and tries to save the portal theme after the sync.
     *
     * @param {Object} error The error object.
     * @param {string} method The method used in the errored API call.
     * @param {string} url The URL used in the errored API call.
     * @param {Object} paramsPOST The POST params used in the errored API call.
     * @param {Function} successCallback The success callback used in the errored API call.
     * @private
     */
    _handleMetadataSyncError: function(error, method, url, paramsPOST, successCallback) {
        var self = this;
        app.metadata.sync(function() {
            app.api.call(method, url, paramsPOST,
                {
                    success: function() {
                        // The sync resets the colors displayed. We need to load
                        // the colors we just saved to display the correct
                        // colors.
                        self.loadTheme();
                        successCallback();
                    },
                    error: function(error) {
                        app.error.handleHttpError(error);
                    }
                },
                { context: self }
            );
        });
    }
}) },
"wizard-page": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * An abstract WizardPageView.
 *
 * Wizard pages should extend this and provide field metadata, custom logic,
 * etc. This view is detached from Wizard layout when it is not the current
 * page. When it becomes the current page it is appended to Wizard layout and
 * render is called.
 *
 * If you want to use the default Wizard template, you'll need to load it in
 * `initialize`.
 *
 * For example,
 *
 *     initialize: function(options){
 *         //Load the default wizard page template, if you want to.
 *         options.template = app.template.getView("wizard-page");
 *         this._super("initialize", [options]);
 *     }
 *
 * @class View.Views.Base.WizardPageView
 * @alias SUGAR.App.view.views.BaseWizardPageView
 * @extends View.View
 */
({
	// Wizard-page View (base) 

    plugins: ['GridBuilder', 'ErrorDecoration'],

    events: {
        'click [name=previous_button]:not(.disabled)': 'previous',
        'click [name=next_button]:not(.disabled)': 'next'
    },
    /**
     * Current progress through wizard, updated automatically on each render.
     */
    progress: null,
    /**
     * Flags if all required fields have at least one character or not. This is
     * used to determine whether we enable or disable the wizard's next button.
     * @type {Boolean}
     */
    areAllRequiredFieldsNonEmpty: false,
    /**
     * Initialize the wizard controller and load header and footer partials
     * @param  {options} options the options
     */
    initialize: function(options){
        this.fieldsToValidate = this._fieldsToValidate(options.meta);
        Handlebars.registerPartial("wizard-page.header", app.template.get("wizard-page.header"));
        Handlebars.registerPartial("wizard-page.footer", app.template.get("wizard-page.footer"));
        this._super('initialize', [options]);
    },
    /**
     * Additionally update current progress and button status during a render.
     *
     * @override
     * @private
     */
    _render: function(){
        this._buildGridsFromPanelsMetadata(this.meta.panels);
        this.progress = this.layout.getProgress();
        this.percentComplete = this._getPercentageComplete();
        this.wizardCompleted = (this.progress.page === this.progress.lastPage)?true:false;
        this._super('_render');
        this.checkIfPageComplete();

        this.layout.trigger("wizard-page:render:complete");
        return this;
    },

    /**
     * We have to check if required fields are pre-filled once we've sync'd. For example,
     * user might have valid required field values (in which case we enable next button).
     */
    bindDataChange: function() {
        var self = this;
        if (this.model) {
            this.listenTo(this.model, "sync", function() {
                self.checkIfPageComplete();
            });
            _.each(this.fieldsToValidate, function(field) {
               if (field && field.required) {
                  self.listenTo(self.model, 'change:'+field.name, function() {
                      self.checkIfPageComplete();
                  });
               }
            });
        }
    },
    /**
     * Used to build our multi-column grid (user wizard is 2 col panel).
     * @param  {Object} panels the meta.panels
     * @protected
     */
    _buildGridsFromPanelsMetadata: function(panels) {
        _.each(panels, function(panel) {
            if (_.isFunction(this.getGridBuilder)) {
                var options = {
                        fields:      panel.fields,
                        columns:     panel.columns,
                        labels:      panel.labels,
                        labelsOnTop: panel.labelsOnTop
                    },
                    gridResults = this.getGridBuilder(options).build();
                panel.grid   = gridResults.grid;
            }
        }, this);
    },
    /**
     * Gets the percentage of pages complete. We consider being on a page as counting towards
     * completed pages (as this seems to be the norm) e.g. arriving at 1 of 3 results in 33%
     * @protected
     * @return {Number} Percentage complete as int
     */
    _getPercentageComplete: function() {
        return Math.floor(this.progress.page / this.progress.lastPage * 100);
    },
    /**
     * Called after render to update status of next/previous buttons.
     */
    updateButtons: function(){
        var prevBtn = this.getField("previous_button");
        if (prevBtn) {
            if (this.progress && this.progress.page > 1) {
                prevBtn.show();
            } else {
                prevBtn.hide();
            }
        }
        var nextBtn = this.getField("next_button");
        if (nextBtn) {
            nextBtn.setDisabled(!this.isPageComplete());
        }
    },

    /**
     * Called after initialization of the wizard page but just before it gets
     * added as a component to the Wizard layout.  Allows implementers to
     * control when a wizard page is included. Default implementation hides
     * page if it will not render because of ACL checks.
     *
     * @property {boolean|Function} showPage
     * @return {boolean} `true` to show the page.
     */
    showPage: function() {
        return app.acl.hasAccessToModel(this.action, this.model);
    },

    /**
     * We can advance the page once we know it is complete. Wizard page's
     * should override this function to provide custom validation logic.
     *
     * @return {boolean} `true` if this page is complete
     * @override
     */
    isPageComplete: function(){
        return true;
    },
    /**
     * Listen to changes on required fields. If all required fields contain
     * at least one character, we enable the next button. Implementers of
     * wizard pages may override this method to customize if desired, although
     * you may be able to just override `requiredTypesToPrevalidate`.
     *
     * See {@link View.Views.Base.UserWizardPageView}.
     *
     * @param {Object} evt the event
     */
    checkIfPageComplete: function(evt) {
        var self = this;
        this.areAllRequiredFieldsNonEmpty = true;
        _.each(this.fields, function(field) {
            if (!field.def.required) return;
            var value = field.$(field.fieldTag + ".required").val();
            var invalid = app.validation.requiredValidator(field.def, field.name, field.model, value);
            if (invalid) {
                self.areAllRequiredFieldsNonEmpty = false;
            }
        });
        this.updateButtons();
    },
    /**
     * Only validate fields pertinent to wizard page
     * @param  {Object} meta The meta
     * @return {Object} fields The fields to validate on
     * @private
     */
    _fieldsToValidate: function(meta) {
        meta = meta || {};
        var fields = {};
        _.each(_.flatten(_.pluck(meta.panels, "fields")), function(field) {
            fields[field.name] = field;
        });
        return fields;
    },
    /**
     * Next button pressed
     */
    next: function() {
        var self = this;
        if (this.progress.page !== this.progress.lastPage) {
            this.beforeNext(function(success) {
                if (success) {
                    self.progress = self.layout.nextPage();
                } else {
                    app.logger.debug("There was an unknown issue after calling beforeNext from wizard");
                }
            });
        } else {
            this.beforeFinish(function(success) {
                if (success) {
                    self.finish();
                } else {
                    app.logger.debug("There was an unknown issue after calling beforeFinish from wizard");
                }
            });
        }
    },
    /**
     * Do any actions like http requests, etc., before allowing user to proceed to next
     * page. Implementers should override this.
     * @param {Function} callback The callback to call once actions are completed
     * @return {boolean} Whether action was performed successfully or not
     */
    beforeNext: function(callback) {
        app.logger.debug("wizard's beforeNext called directly. Derived controllers should have overridden this!");
        callback(true);
    },
    /**
     * Do any actions like http requests, etc., before allowing user to proceed to finish
     * the wizard. Implementers should override this.
     * @param {Function} callback The callback to call once actions are completed
     * @return {boolean} Whether action was performed successfully or not
     */
    beforeFinish: function(callback){
        app.logger.debug("wizard's beforeFinish called directly. Derived controller should have overridden this!");
        callback(true);
    },
    /**
     * Previous button pressed
     */
    previous: function(){
        this.progress = this.layout.previousPage();
    },
    /**
     * Next button pressed and this is the last page. We need to PUT /me to indicate that the
     * "instance is configured". Calls finished on WizardLayout on complete.
     */
    finish: function(){
        this.layout.finished();
    }

}) },
"dupecheck-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckHeaderView
 * @alias SUGAR.App.view.views.BaseDupecheckHeaderView
 * @extends View.View
 */
({
	// Dupecheck-header View (base) 


    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.context.on('dupecheck:collection:reset', this.updateCount, this);
     },

    updateCount: function() {
        var translatedString = app.lang.get(
            'LBL_DUPLICATES_FOUND',
            this.module,
            {'duplicateCount': this.collection.length}
        );
        this.$('span.duplicate_count').text(translatedString);
    }
}) },
"quicksearch-taglist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchTagListView
 * @alias SUGAR.App.view.views.BaseQuicksearchTagListView
 * @extends View.View
 */
({
	// Quicksearch-taglist View (base) 

    className: 'table-cell',

    events: {
        'click .tag-remove': 'removeTagClicked',
        'click .tag-name': 'highlightTagClicked'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.selectedTags = this.layout.selectedTags || [];

        this.activeIndex = null;

        // Listener for quicksearch tag additions
        this.layout.on('quicksearch:tag:add', this.addTag, this);

        this.layout.on('quicksearch:tags:remove', this.removeAllTags, this);

        //Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function(next) {
            if (next) {
                this.activeIndex = 0;
            } else {
                this.activeIndex = this.selectedTags.length - 1;
            }
            this._highlightActive();
            this.attachKeydownEvent();
        }, this);

        // Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.activeIndex = null;
            this.$('.tag-wrapper').removeClass('highlight');
            this.disposeKeydownEvent();
        }, this);

        app.events.on('app:sync:complete', function() {
            this.layout.off('route:search', this.populateTagsFromContext);
            this.layout.on('route:search', this.populateTagsFromContext, this);
        }, this);

        this.context.on('tagsearch:fire:new', this.populateTagsFromContext, this);
    },

    /**
     * Populate the taglist with the tags specified in the context. Call a search if param is true
     */
    populateTagsFromContext: function() {
        var tagNames = this.context.get('tagParams');
        // If no tagNames, just move onto the regular search
        if (!tagNames || !tagNames.length) {
            this.selectedTags.splice(0, this.selectedTags.length);
            this.render();
            this.context.set('tags', []);
            this.context.trigger('search:fire:new');
            return;
        }
        var tags = app.data.createBeanCollection('Tags');
        var self = this;
        var tagNamesLowerCase = _.map(tagNames, function(tagName) {
            return tagName.toLowerCase();
        });

        tags.filterDef = {
            'filter': [{
                'name_lower': { '$in': tagNamesLowerCase }
            }]
        };

        tags.fetch({
            // Arbitrary large number, in case user wants to search by more than 20 tags.
            limit: 100,
            success: function(collection) {
                //Remove internal tag list and then re add the ones that should be there
                self.selectedTags.splice(0, self.selectedTags.length);
                _.each(collection.models, function(tag) {
                    self.selectedTags.push({id: tag.get('id'), name: tag.get('name')});
                });
                self.render();

                //Push completed tag objects to context
                self.context.set('tags', self.selectedTags);
                self.layout.trigger('quicksearch:button:toggle', false);

                self.context.trigger('search:fire:new');
            },
            error: function() {
                app.alert.show('collections_error', {
                    level: 'error',
                    messages: 'LBL_TAG_FETCH_ERROR'
                });
            }
        });
    },

    /**
     * Returns true if there are tags to focus. Otherwise, false.
     */
    isFocusable: function() {
        return this.selectedTags && this.selectedTags.length;
    },

    /**
     * Attach the keydown events for the view.
     */
    attachKeydownEvent: function() {
        $(document).on('keydown.' + this.cid, _.bind(this.keydownHandler, this));
    },

    /**
     * Dispose the keydown events for the view.
     */
    disposeKeydownEvent: function() {
        $(document).off('keydown.' + this.cid);
    },

    /**
     * Handle the keydown events.
     * @param {Event} e
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 37: // left arrow
                this.moveLeft();
                break;
            case 39: // right arrow
                this.moveRight();
                break;
            case 8:  // backspace
            case 46: // del
                this.handleBackspace();
                e.stopPropagation();
                e.preventDefault();
                break;
            default:
                this.layout.trigger('navigate:to:component', 'quicksearch-bar');
                break;
        }
    },

    /**
     * Handler for the backspace/delete keys. Removes tag if one is highlighted, then highlights a new tag
     * or re-focuses the search bar
     */
    handleBackspace: function() {
        this.removeTag(false);

        if (this.selectedTags.length) {
            // If there is a tag to the left of the removed tag, highlight it
            // If tagIndex is 0, highlight whatever is left at index 0.
            if (this.activeIndex > 0) {
                this.activeIndex--;
            }
            this._highlightActive();
        } else {
            // If no tags are left, automatically give focus back to whatever is to the right
            this.moveRight();
        }
    },

    /**
     * Adds a tag to the page
     * @param {Object} tag
     */
    addTag: function(tag) {
        if (tag && tag.name) {
            // If tag already exists do nothing
            if (!_.find(this.selectedTags, function(tagToCheck) {
                return tagToCheck.name === tag.name;
            })) {
                this.selectedTags.push(tag);
                this.render();
                this.layout.trigger('quicksearch:fire:search', true);
            }
        }
    },

    /**
     * Remove a specific tag
     * @param {jQuery || boolean} $tagParam - jQuery representation of tag pill. Optional
     * (if it doesn't exist, default to activeIndex)
     */
    removeTag: function($tagParam) {
        // Only continue if we have either a $tag param or an activeIndex
        if (!$tagParam && _.isNull(this.activeIndex)) {
            return;
        }

        var $tag = $tagParam || this.$('.tag-wrapper:eq(' + this.activeIndex + ')');

        // Remove the selected tag from the internal tag list
        var index = _.indexOf(_.pluck(this.selectedTags, 'name'), $tag.attr('tag-name'));
        this.selectedTags.splice(index, 1);

        // Remove the selected tag from the DOM
        $tag.remove();

        this.layout.trigger('quicksearch:fire:search', true);
    },

    /**
     * Click handler for tag removal element
     * @param {Event} e
     */
    removeTagClicked: function(e) {
        e.preventDefault();
        e.stopPropagation();
        var $tag = this.$(e.target).parent();
        this.removeTag($tag);
        this.$('.tag-wrapper').removeClass('highlight');

        // Go back to the quicksearch bar to prevent any shenanigans (only on click)
        this.layout.trigger('navigate:to:component', 'quicksearch-bar');
    },

    /**
     * Removes all tags from search bar (When searchbar's "X" is clicked)
     */
    removeAllTags: function() {
        // Remove all tags from the tags array (and the layout tag array since other views share that)
        this.selectedTags.splice(0, this.selectedTags.length);
        this.activeIndex = null;
        this.$('.tag-wrapper').remove();
    },


    /**
     * Click handler for tag highlighting
     * @param {Event} e
     */
    highlightTagClicked: function(e) {
        this.requestFocus();

        // Set highlight class
        this.$('.tag-wrapper').removeClass('highlight');
        var $tag = this.$(e.target).parent();
        $tag.addClass('highlight');

        // Set activeIndex
        this.activeIndex = _.indexOf(_.pluck(this.selectedTags, 'name'), $tag.attr('tag-name'));
    },

    /**
     * Highlights a specific tag element.
     */
    _highlightActive: function() {
        this.$('.tag-wrapper').removeClass('highlight');
        this.$('.tag-wrapper:eq(' + this.activeIndex + ')').addClass('highlight');
    },

    /**
     * Request focus from the layout. This is used primarily for mouse clicks.
     */
    requestFocus: function() {
        this.layout.trigger('navigate:to:component', this.name);
    },

    /**
     * Move to the next the active element.
     */
    moveRight: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex < this.selectedTags.length - 1) {
            // We're in bounds, just go to the next element in this view.
            this.activeIndex++;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the next view
            this._handleBoundary(true);

        }
    },

    /**
     * Move to the previous the active element.
     */
    moveLeft: function() {
        // check to make sure we will be in bounds.
        if (this.activeIndex > 0) {
            // We're in bounds, just go to the previous element in this view
            this.activeIndex--;
            this._highlightActive();
        } else {
            // We're trying to move beyond the elements in this view. We need to try to move to the previous view
            this._handleBoundary(false);
        }
    },

    /**
     * Handle when the user uses their keyboard to try to navigate outside of the view. This handles both the top and
     * bottom boundaries.
     * @param {boolean} next - If true, we are checking the next element. If false, we are checking the previous.
     * @private
     */
    _handleBoundary: function(next) {
        var event = 'navigate:next:component';
        if (!next) {
            event = 'navigate:previous:component';
        }
        if (this.layout.triggerBefore(event)) {
            this.clearActive();
            this.layout.trigger(event);
        }
    },

    /**
     * Clear the active element and dispose key events
     */
    clearActive: function() {
        this.activeIndex = null;
        this.$('.tag-wrapper').removeClass('highlight');
        this.disposeKeydownEvent();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeydownEvent();
        this._super('unbind');
    }
}) },
"massaddtolist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassaddtolistView
 * @alias SUGAR.App.view.views.BaseMassaddtolistView
 * @extends View.Views.Base.MassupdateView
 */
({
	// Massaddtolist View (base) 

    extendsFrom: 'MassupdateView',
    addToListFieldName: 'prospect_lists',
    listModule: 'ProspectLists',
    massUpdateViewName: 'massaddtolist-progress',
    className: 'extend',

    initialize: function(options) {
        var additionalEvents = {};
        additionalEvents['click .btn[name=create_button]'] = 'createAndSelectNewList';
        this.events = _.extend({}, this.events, additionalEvents);
        this._super("initialize", [options]);
    },

    /**
     * Listen for just the massaddtolist event from the list view
     */
    delegateListFireEvents: function() {
        this.layout.on("list:massaddtolist:fire", this.show, this);
        this.layout.on("list:massaction:hide", this.hide, this);
    },

    /**
     * Pull out the target list link field from the field list and treat it like a relate field for later rendering
     * @param options
     */
    setMetadata: function(options) {
        var moduleMetadata = app.metadata.getModule(options.module);

        if (!moduleMetadata) {
            return;
        }

        var addToListField = _.find(moduleMetadata.fields, function(field) {
            return field.name === this.addToListFieldName;
        }, this);

        if (addToListField) {
            addToListField = app.utils.deepCopy(addToListField);
            addToListField.id_name = this.addToListFieldName + '_id';
            addToListField.name = this.addToListFieldName + '_name';
            addToListField.label = addToListField.label || addToListField.vname;
            addToListField.type = 'relate';
            addToListField.required = true;
            this.addToListField = addToListField;
        }
    },

    /**
     * Hide the view if we were not able to find the appropriate list field and somehow render is triggered
     */
    _render: function() {
        var result = this._super("_render");

        if(_.isUndefined(this.addToListField)) {
            this.hide();
        }
        return result;
    },

    /**
     * There is only one field for this view, so it is the default as well
     */
    setDefault: function() {
        this.defaultOption = this.addToListField;
    },

    /**
     * When adding to a target list, the API is expecting an array of IDs
     */
    getAttributes: function() {
        var attributes = {};
        attributes[this.addToListFieldName] = [
            this.model.get(this.addToListField.id_name)
        ];
        return attributes;
    },

    /**
     * Build dynamic success messages to be displayed if the API call is successful
     * Overridden to build different success messages from massupdate
     *
     * @param massUpdateModel - contains the attributes of what records are being updated
     */
    buildSaveSuccessMessages: function(massUpdateModel) {
        var doneLabel = 'TPL_MASS_ADD_TO_LIST_SUCCESS',
            queuedLabel = 'TPL_MASS_ADD_TO_LIST_QUEUED',
            listName = this.model.get(this.addToListField.name),
            listId = this.model.get(this.addToListField.id_name),
            listUrl = '#' + app.router.buildRoute(this.listModule, listId);

        return {
            done: app.lang.get(doneLabel, null, {
                listName: listName,
                listUrl: listUrl
            }),
            queued: app.lang.get(queuedLabel, null, {
                listName: listName,
                listUrl: listUrl
            })
        };
    },

    /**
     * Create a new target list and select it in the list
     */
    createAndSelectNewList: function() {
        app.drawer.open({
            layout: 'create-nodupecheck',
            context: {
                create: true,
                module: this.listModule
            }
        }, _.bind(this.selectNewlyCreatedList, this));
    },

    /**
     * Callback for create new target list - sets relate field with newly created list
     * @param context
     * @param model newly created target list model
     */
    selectNewlyCreatedList: function(context, model) {
        var relateField = this.getField('prospect_lists_name');
        if (relateField) {
            model.value = model.get('name');
            relateField.setValue(model);
        }
    }
}) },
"pii": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PiiView
 * @alias SUGAR.App.view.views.BasePiiView
 * @extends View.Views.Base.FilteredListView
 */
({
	// Pii View (base) 

    extendsFrom: 'FilteredListView',

    fallbackFieldTemplate: 'list-header',

    /**
     * @inheritdoc
     * Initialize and override the Pii collection.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.baseModule = this.context.get('pModule');
        this.baseRecord = this.context.get('pId');
        if (!this.collection) {
            this._initCollection();
        }
    },

    /**
     * Initialize the collection.
     *
     * @protected
     */
    _initCollection: function() {
        var self = this;
        var PiiCollection = app.BeanCollection.extend({
            baseModule: this.baseModule,
            baseRecordId: this.baseRecord,
            sync: function(method, model, options) {
                options.params = _.extend(options.params || {}, {erased_fields: true});
                var url = app.api.buildURL(this.baseModule, 'pii', {id: this.baseRecordId}, options.params);
                var callbacks = app.data.getSyncCallbacks(method, model, options);
                var defaultSuccessCallback = app.data.getSyncSuccessCallback(method, model, options);
                callbacks.success = function(data, request) {
                    data.records = self.mergePiiFields(data.fields);
                    self.applyDataToRecords(data);
                    return defaultSuccessCallback(data, request);
                };
                app.api.call(method, url, options.attributes, callbacks);
            }
        });
        this.collection = new PiiCollection();
    },

    /**
     * Combine module's fields with response data so we show all fields regardless of ACLs
     *
     * @param {Array} responseFields Fields from the PII endpoint
     * @return {Array} All PII fields for the baseModule
     */
    mergePiiFields: function(responseFields) {
        var piiFields = _.where(app.metadata.getModule(this.baseModule, 'fields'), {pii: true});

        var fields = [];
        _.each(piiFields, function(field) {
            var fieldName = field.name;
            var dataFields = _.where(responseFields, {field_name: fieldName});
            if (dataFields.length > 0) {
                _.each(dataFields, function(dataField) {
                    fields.push(_.extend({field_name: fieldName}, dataField));
                });
            } else {
                // We likely don't have ACL access but still want to show the field (without a value)
                fields.push({field_name: fieldName});
            }
        });
        return fields;
    },

    /**
     * @inheritdoc
     */
    loadData: function() {
        if (this.collection.dataFetched) {
            return;
        }
        this.collection.fetch();
    },

    /**
     * @inheritdoc
     *
     * Patch pii models fields with information of
     * original field available within parent model, in order to render
     * properly.
     */
    _renderData: function() {
        var fields = app.metadata.getModule(this.baseModule).fields;

        _.each(this.collection.models, function(model) {
            model.fields = app.utils.deepCopy(this.metaFields);

            var value = _.findWhere(model.fields, {name: 'value'});
            _.extend(value, fields[model.get('field_name')], {name: 'value'});
            if (_.contains(['multienum', 'enum'], value.type) && value.function) {
                value.type = 'base';
            }

            model.fields = app.metadata._patchFields(
                this.module,
                app.metadata.getModule(this.module),
                model.fields
            );
        }, this);

        this._super('_renderData');
    },

    /**
     * @override
     *
     * Overriding to return Pii view metadata, so filteredListView
     * can properly initialize filter when vardef is not available.
     */
    getFields: function() {
        return this._super('getFields', ['Pii']);
    },

    /**
     * Apply ACL and erased field information to the given record data.
     *
     * @param {Object} data Record data.
     */
    applyDataToRecords: function(data) {
        if (data._acl && data._acl.fields) {
            this._applyACLToRecords(data._acl.fields, data.records);
        }
        this._applyErasedFieldsToRecords(data._erased_fields, data.records);
    },

    /**
     * Apply ACLs to the given records.
     *
     * @param {Object} aclFields ACL fields object.
     * @param {Object[]} records Records to which you want ACLs applied.
     *
     * @private
     */
    _applyACLToRecords: function(aclFields, records) {
        _.each(records, function(record) {
            var fieldName = record.field_name;
            if (fieldName in aclFields) {
                record._acl = {
                    fields: {
                        value: aclFields[fieldName]
                    }
                };
            }
        });
    },

    /**
     * Apply erased field list to records.
     *
     * @param {string[]} erasedFields List of erased fields.
     * @param {Object[]} records The records where you want erased fields
     *  applied.
     *
     * @private
     */
    _applyErasedFieldsToRecords: function(erasedFields, records) {
        if (_.isEmpty(erasedFields)) {
            return;
        }
        var erasedFieldsMap = _.reduce(erasedFields, function(map, field) {
            map[field] = true;
            return map;
        }, {});
        _.each(records, function(record) {
            var fieldName = record.field_name;
            if (fieldName in erasedFieldsMap) {
                record._erased_fields = ['value'];
            }
        });
    }
}) },
"activitystream": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ActivitystreamView
 * @alias SUGAR.App.view.views.BaseActivitystreamView
 * @extends View.View
 */
({
	// Activitystream View (base) 

    events: {
        'change div[data-placeholder]': 'checkPlaceholder',
        'keydown div[data-placeholder]': 'checkPlaceholder',
        'keypress div[data-placeholder]': 'checkPlaceholder',
        'input div[data-placeholder]': 'checkPlaceholder',
        'click .reply': 'showAddComment',
        'click .reply-btn': 'addComment',
        'click .preview-btn:not(.disabled)': 'previewRecord',
        'click .comment-btn': 'toggleReplyBar',
        'click .more': 'fetchComments'
    },

    tagName: "li",
    className: "activitystream-posts-comments-container",
    plugins: ['RelativeTime', 'FileDragoff', 'Taggable'],
    cacheNamePrefix: "user:avatars:",
    cacheNameExpire: ":expiry",
    expiryTime: 36000000,   //1 hour in milliseconds
    thresholdRelativeTime: 2, //Show relative time for 2 days and then date time after

    _unformattedPost: null,
    _unformattedComments: {},

    // Based on regular expression from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
    // It is the JavaScript regular expression version of the one in LinkEmbed.php
    urlRegExp: /\b((?:https?:\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\'".,<>?]))/ig,

    _attachImageSelector: 'img[data-note-id]',

    /**
     * Modules placed in this array will have links to the module removed from the display
     * e.g. Quotas isn't a real module, has no record view, shouldn't have a link
     */
    blacklistModules: [
        'Quotas'
    ],

    initialize: function(options) {
        this.readonly = !!options.readonly;
        this.nopreview = !!options.nopreview;

        app.view.View.prototype.initialize.call(this, options);

        var lastComment = this.model.get("last_comment");
        this.commentsCollection = app.data.createRelatedCollection(this.model, "comments");

        if (lastComment && !_.isUndefined(lastComment.id)) {
            this.commentsCollection.reset([lastComment]);
        }

        this.model.set("comments", this.commentsCollection);

        // If comment_count is 0, we don't want to decrement the count by 1 since -1 is truthy.
        var count = parseInt(this.model.get('comment_count'), 10);
        this.remaining_comments = 0;
        this.more_tpl = "TPL_MORE_COMMENT";
        if (count) {
            this.remaining_comments = count - 1;

            // Pluralize the comment count label
            if (count > 2) {
                this.more_tpl += "S";
            }
        }

        this.preview = this.getPreviewData();
        var data = this.model.get('data');
        var activityType = this.model.get('activity_type');

        this.tpl = 'TPL_ACTIVITY_' + activityType.toUpperCase();

        if (data.object && !_.isUndefined(data.object.name) && data.object.name === 'LBL_VALUE_ERASED') {
            data.object.name = app.lang.get('LBL_VALUE_ERASED', activityType);
        }
        if (data.subject && !_.isUndefined(data.subject.name) && data.subject.name === 'LBL_VALUE_ERASED') {
            data.subject.name = app.lang.get('LBL_VALUE_ERASED', activityType);
        }

        switch (activityType) {
            case 'post':
                if (!data.value) {
                    this.tpl = null;
                }
                break;
            case 'update':
                data.updateStr = this.processUpdateActivityTypeMessage(data.changes);
                this.model.set('data', data);
                break;
            case 'attach':
                var url,
                    urlAttributes = {
                    module: 'Notes',
                    id: data.noteId,
                    field: 'filename'
                };

                if (data.mimetype && data.mimetype.indexOf("image/") === 0) {
                    url = app.api.buildFileURL(urlAttributes, {
                        htmlJsonFormat: false,
                        passOAuthToken: false,
                        cleanCache: true,
                        forceDownload: false
                    });

                    data.embeds = [{
                        type: "image",
                        src: url,
                        noteId: data.noteId
                    }];
                } else {
                    url = app.api.buildFileURL(urlAttributes);
                }

                data.url = url;
                this.$el.data(data);
                this.model.set('data', data);
                this.model.set('display_parent_type', 'Files');
                break;
        }

        this.processEmbed();
        this.toggleSubmitButton = _.debounce(this.toggleSubmitButton, 200);

        // Resize video when the browser window is resized
        this.resizeVideo = _.bind(_.throttle(this.resizeVideo, 500), this);
        $(window).on('resize.' + this.cid, this.resizeVideo);

        // specify the record that the tags are associated with
        this.setTaggableRecord(this.model.get('parent_type'), this.model.get('parent_id'));
    },

     /**
     * Creates the update message for the activity stream based on the fields changed.
     * @param {object} changes Object containing the changes for the fields of an update activity message
     * @return {string} The formatted message for the update
     */
     processUpdateActivityTypeMessage: function (changes) {
         var updateTpl = Handlebars.compile(app.lang.get('TPL_ACTIVITY_UPDATE_FIELD', 'Activities')),
             parentType = this.model.get("parent_type"),
             fields = app.metadata.getModule(parentType).fields,
             self = this,
             updateStr;

         updateStr = _.reduce(changes, function (memo, changeObj) {
             var fieldMeta = fields[changeObj.field_name],
                 field = app.view.createField({
                     def: fieldMeta,
                     view: self,
                     model: self.model,
                     viewName: 'detail'
                 });

             if (changeObj.before === 'LBL_VALUE_ERASED') {
                 changeObj.before = app.lang.get('LBL_VALUE_ERASED', parentType);
             } else {
                 changeObj.before = field.format(changeObj.before);
             }
             if (changeObj.after === 'LBL_VALUE_ERASED') {
                 changeObj.after = app.lang.get('LBL_VALUE_ERASED', parentType);
             } else {
                 changeObj.after = field.format(changeObj.after);
             }

             changeObj.field_label = app.lang.get(fields[changeObj.field_name].vname, parentType);

             if (memo) {
                 return updateTpl(changeObj) + ', ' + memo;
             }
             return updateTpl(changeObj);
         }, '');

         return updateStr;
     },

    /**
     * Get embed templates to be processed on render
     */
    processEmbed: function() {
        var data = this.model.get('data');

        if (!_.isEmpty(data.embeds)) {
            this.embeds = [];
            _.each(data.embeds, function(embed) {
                var typeParts = embed.type.split('.'),
                    type = typeParts.shift(),
                    embedTpl;

                _.each(typeParts, function(part) {
                    type = type + part.charAt(0).toUpperCase() + part.substr(1);
                });

                embedTpl = app.template.get(this.name + '.' + type + 'Embed');
                if (embedTpl) {
                    this.embeds.push(embedTpl(embed));
                }
            }, this);
        }
    },

    fetchComments: function() {
        var self = this;
        this.commentsCollection.fetch({
            //Don't show alerts for this request
            showAlerts: false,
            relate: true,
            success: function(collection) {
                self.remaining_comments = 0;
                self.render();
            }
        });
    },

    /**
     * Event handler for clicking comment button -- shows a post's comment box.
     * @param  {Event} e
     */
    showAddComment: function(e) {
        var currentTarget = this.$(e.currentTarget);

        currentTarget.closest('li').find('.activitystream-comment').toggle();
        currentTarget.closest('li').find('.activitystream-comment').find('.sayit').focus();

        e.preventDefault();
    },

    /**
     * Creates a new comment on a post.
     * @param {Event} event
     */
    addComment: function (event) {
        var self = this,
            parentId = this.model.id,
            payload = {
                parent_id: parentId,
                data: {}
            },
            bean;

        payload.data = this.getComment();

        if (payload.data.value && (payload.data.value.length > 0)) {
            bean = app.data.createRelatedBean(this.model, null, 'comments');
            bean.save(payload, {
                relate: true,
                success: _.bind(self.addCommentCallback, self)
            });
        }
    },

    /**
     * Callback for rendering a newly added comment into the activity stream view
     * @param  {Object} model
     */
    addCommentCallback: function (model) {
        var template, data;

        this.$('div.reply').empty().trigger('change');
        this.commentsCollection.add(model);
        this.toggleReplyBar();

        template = app.template.getView('activitystream.comment');

        data = model.get('data');
        data.value = this.formatTags(data.value);
        data.value = this.formatLinks(data.value);

        this.processAvatars();
        this.$('.comments').prepend(template(model.attributes));
        this.context.trigger('activitystream:post:prepend', this.model);
    },

    /**
     * Handler for previewing a record listed on the activity stream.
     * @param  {Event} event
     */
    previewRecord: function(event) {
        var el = this.$(event.currentTarget),
            data = el.data(),
            module = data.module,
            id = data.id;

        // Remove highlighted styling from all activities
        this.layout.clearRowDecorations();

        // If module/id data attributes don't exist, this user
        // doesn't have access to that record due to team security.
        if (module && id) {
            var model = app.data.createBean(module),
                collection = this.context.get("collection");

            model.set("id", id);
            this.decorateRow();
            app.events.trigger("preview:module:update", this.context.get("module"));
            app.events.trigger("preview:render", model, collection, true, this.cid);
        }

        event.preventDefault();
    },

    /**
     * Handles highlighting of current activity item and active state of preview button.
     */
    decorateRow: function() {
        this.$el.addClass('highlighted');
        this.$('.preview-btn')
            .addClass('active')
            .attr('aria-pressed', true);
    },

    _renderHtml: function(model) {
        // Save state of the reply bar before rendering
        var isReplyBarOpen = this.$(".comment-btn").hasClass("active") && this.$(".comment-btn").is(":visible"),
            replyVal = this.$(".reply").html();

        this.processAvatars();
        this.formatAllTagsAndLinks();

        this._setRelativeTimeAvailable();

        app.view.View.prototype._renderHtml.call(this);

        this.resizeVideo();

        // If the reply bar was previously open, keep it open (render hides it by default)
        if (isReplyBarOpen) {
            this.toggleReplyBar();
            this.$(".reply").html(replyVal);
        }

        this._addBrokenImageHandler();
    },

    /**
     * Add a listener for when activity has a broken image for attach type posts
     * Remove the broken image and remove link to broken image
     *
     * @private
     */
    _addBrokenImageHandler: function() {
        this.$(this._attachImageSelector).on('error', _.bind(function(event) {
            var $brokenImg = $(event.currentTarget),
                linkSelector = 'a[data-note-id="' + $brokenImg.data('note-id') + '"]';

            //first remove the link to the image which will also be broken
            //FIXME: this is hacky, but temporary until we fix how attachment posts are displayed in MAR-780
            this.$(linkSelector).contents().unwrap();
            //then remove the broken image
            $brokenImg.closest('div[class="embed"]').remove();
        }, this));
    },

    /**
     * Sets property on activity to show date created as a relative time or as date time.
     *
     * @private
     */
    _setRelativeTimeAvailable: function() {
        var diffInDays = app.date().diff(this.model.get('date_entered'), 'days', true);
        this.useRelativeTime = (diffInDays <= this.thresholdRelativeTime);
    },

    /**
     * Format all tags and link in post and comments.
     */
    formatAllTagsAndLinks: function() {
        var post = this.model.get('data');

        // Check to see if the post's module is in the blacklist, if so, delete
        // the module property from the object so it will not create a link to the record
        if (post.object && post.object.module && _.contains(this.blacklistModules, post.object.module)) {
            delete post.object.module;
        }

        this.unformatAllTagsAndLinks();

        if (post) {
            this._unformattedPost = post.value;
            post.value = this.formatLinks(post.value);
            post.value = this.formatTags(post.value);
        }

        this.commentsCollection.each(function(model) {
            var data = model.get('data');
            this._unformattedComments[model.get('id')] = data.value;
            data.value = this.formatLinks(data.value);
            data.value = this.formatTags(data.value);
        }, this);
    },

    /**
     * Revert back to the unformatted version of tags and links
     */
    unformatAllTagsAndLinks: function() {
        var post = this.model.get('data');
        if (post) {
            post.value = this._unformattedPost || post.value;
        }

        this.commentsCollection.each(function(model) {
            var data = model.get('data');
            data.value = this._unformattedComments[model.get('id')] || data.value;
        }, this);
    },

    /**
     * Searches the post to identify links and make them as actual links
     *
     * @param {String} post
     * @return {string}
     */
    formatLinks: function(post) {
        var formattedPost = '';

        if (post && (post.length > 0)) {
            formattedPost = post.replace(this.urlRegExp, function(url) {
                var href = url;
                if ((url.indexOf('http://') !== 0) && (url.indexOf('https://') !== 0)) {
                    href = 'http://' + url;
                }
                return '<a href="' + href + '" target="_blank">' + url + '</a>';
            });
        }

        return formattedPost;
    },

    /**
     * Resize the iframe that embeds video
     */
    resizeVideo: function() {
        // if this is disposed, then just bail as the code below with throw errors
        if (this.disposed === true) {
            return;
        }
        var data = this.model.get('data'),
            $embed = this.$('.embed'),
            $iframes = $embed.find('iframe'),
            videoCount = 0,
            embedWidth;

        if (_.isArray(data.embeds)) {
            embedWidth = $embed.width();
            _.each(data.embeds, function(embed) {
                var $iframe, iframeWidth, iframeHeight;

                if (((embed.type === 'video') || (embed.type === 'rich')) && ($iframes.length > 0)) {
                    $iframe = $iframes.eq(videoCount);

                    iframeWidth = Math.min(embedWidth, 480);
                    iframeHeight = parseInt(embed.height, 10) * (iframeWidth / parseInt(embed.width, 10));

                    $iframe.prop({
                        width: iframeWidth,
                        height: iframeHeight
                    });

                    videoCount++;
                }
            });
        }
    },

    /**
     * Sets the profile picture for activities based on the created by user.
     */
    processAvatars: function () {
        var comments = this.model.get('comments'),
            postPictureUrl;

        if (this.model.get('activity_type') === 'post' && !this.model.get('picture_url')) {
            postPictureUrl = this.getAvatarUrlForUser(this.model, 'post');
            this.model.set('picture_url', postPictureUrl);
        }

        if (comments) {
            comments.each(function (comment) {
                var commentPictureUrl = this.getAvatarUrlForUser(comment, 'comment');
                comment.set('picture_url', commentPictureUrl);
            }, this);
        }
    },

    /**
     * Builds and returns the url for the user's profile picture based on fetching from cache
     * @param model
     * @param activityType
     * @return {string}
     */
    getAvatarUrlForUser: function (model, activityType){
        var createdBy = model.get('created_by'),
            hasPicture = this.checkUserHasPicture(model, activityType);

        return hasPicture ? this.buildAvatarUrl(createdBy) : '';
    },

    /**
     * Checks cache to see if user has a picture, calls API if needed
     *
     * @param model The User
     * @param activityType
     * @return {boolean} whether user has a picture
     */
    checkUserHasPicture: function (model, activityType) {
        var createdBy = model.get('created_by'),
            hasPicture;

        // If processing the current user's avatar, no need to fetch
        if (createdBy === app.user.get('id')) {
            hasPicture = !_.isEmpty(app.user.get('picture'));
        } else {
            // Check cache
            hasPicture = this.getUserPictureStatus(createdBy);
        }

        // If not current user or cached, call api to check if user has a picture
        if (_.isUndefined(hasPicture)) {
            this.fetchUserPicture(model, activityType);
            hasPicture = false; // Use placeholder until api call finishes
        }

        return hasPicture;
    },

    /**
     * Retrieves a user and caches the results of whether the user has a profile picture.
     * Replaces the default icon with an image tag of the profile picture.
     *
     * @param model
     * @param activityType
     */
    fetchUserPicture: function(model, activityType) {
        var self = this,
            createdBy = model.get('created_by'),
            user = app.data.createBean('Users', {id: createdBy});

        user.fetch({
            fields: ["picture"],
            success: function () {
                var pictureUrl = self.buildAvatarUrl(createdBy),
                    hasPicture = !_.isEmpty(user.get('picture'));

                self.setUserPictureStatus(createdBy, hasPicture);

                // If picture exists, replace the activity image with the user's profile picture
                if (hasPicture) {
                    self.$('#avatar-' + activityType + '-' + model.get('id')).html("<img src='" + pictureUrl + "' alt='" + model.get('created_by_name') + "'>");
                }
            },
            error: function () {
                // Problem retrieving picture, use placeholder
                self.setUserPictureStatus(createdBy, false);
            }
        });
    },

    /**
     * Retrieve from the app cache whether user has a picture
     * Respects cache TTL, returns undefined if expired
     *
     * @param userId
     * @return {boolean|undefined} whether user has picture or `undefined` if cache not set or expired
     * @private
     */
    getUserPictureStatus: function(userId) {
        var hasPicture = app.cache.get(this.cacheNamePrefix + userId),
            cachedTTL = app.cache.get(this.cacheNamePrefix + userId + this.cacheNameExpire);

        return (cachedTTL < $.now()) ? undefined : hasPicture;
    },

    /**
     * Cache whether the user has a picture or not
     *
     * @param userId
     * @param hasPicture
     * @private
     */
    setUserPictureStatus: function(userId, hasPicture) {
        app.cache.set(this.cacheNamePrefix + userId, hasPicture);
        app.cache.set(this.cacheNamePrefix + userId + this.cacheNameExpire, $.now() + this.expiryTime);
    },

    /**
     * Build the file url for the given user's avatar
     *
     * @param userId
     * @return {string} The avatar url
     * @private
     */
    buildAvatarUrl: function(userId) {
        return app.api.buildFileURL({
            module: 'Users',
            id: userId,
            field: 'picture'
        });
    },

    toggleReplyBar: function() {
        var isHidden = this.$('.reply-area').hasClass('hide');
        this.$('.reply-area').toggleClass('hide', !isHidden);
        this.$('.comment-btn')
            .toggleClass('active', isHidden)
            .attr('aria-pressed', isHidden);
    },

    /**
     * Retrieve comment entered inside content editable and translate any tags into text format
     * so that it can be saved in the database as JSON string.
     *
     * @return {string}
     */
    getComment: function() {
        return this.unformatTags(this.$('div.reply'));
    },

    /**
     * Determines the status and label for the preview button.
     *
     * @return {Object}
     * @return {Boolean} return.enabled Whether the preview is enabled.
     * @return {String} return.label The label to display in the preview button
     *   tooltip.
     */
    getPreviewData: function () {
        var parentModel,
            preview = {
                enabled: true,
                label: 'LBL_PREVIEW'
            },
            isBwcEnabled,
            module = this.model.get('display_parent_type');

        if (module) {
            // assume modules without metadata are BWC by default.
            isBwcEnabled = true;
            var moduleMetadata = app.metadata.getModule(module);
            if (moduleMetadata && _.has(moduleMetadata, 'isBwcEnabled')) {
                isBwcEnabled = moduleMetadata.isBwcEnabled;
            }
        } else {
            isBwcEnabled = false;
        }

        if (isBwcEnabled) {
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_BWC_TOOLTIP';
        } else if (this.model.get("activity_type") === 'attach') { //no preview for attachments
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_DISABLED_ATTACHMENT';
        } else if (_.isEmpty(this.model.get('display_parent_id')) || _.isEmpty(this.model.get('display_parent_type'))) {  //no related record
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_DISABLED_NO_RECORD';
        } else if (!app.acl.hasAccess("view", this.model.get('display_parent_type'))) { //no access to related record
            preview.enabled = false;
            preview.label = 'LBL_PREVIEW_DISABLED_NO_ACCESS';
        } else if (this.model.get('preview_enabled') === false) { //deleted or no team access to related record
            preview.enabled = false;
            preview.label = this.model.get('preview_disabled_reason');
        } else {
            parentModel = this._getParentModel('record', this.context);
            // Check if the bean to be previewed is the same as the context.
            if (parentModel && parentModel.module == this.model.get('display_parent_type') && parentModel.id === this.model.get('display_parent_id')) {
                preview.enabled = false;
                preview.label = 'LBL_PREVIEW_DISABLED_SAME_RECORD';
            }
        }

        return preview;
    },

    /**
     * Traverse up the context hierarchy and look for given layout, retrieve the model from the layout's context
     *
     * @param layoutName to look for up the context hierarchy
     * @param context start of context hierarchy
     * @return {Mixed}
     * @private
     */
    _getParentModel: function(layoutName, context) {
        if (context) {
            if (context.get('layout') === layoutName) {
                return context.get('model');
            } else {
                return this._getParentModel(layoutName, context.parent);
            }
        } else {
            return null;
        }
    },

    /**
     * Toggle the Submit button disabled/enabled state.
     */
    toggleSubmitButton: function(enable) {
        if (!enable) {
            this.disableSubmitButton();
        } else {
            this.enableSubmitButton();
        }
    },

    /**
     * Enable Submit button
     */
    enableSubmitButton: function() {
        this.$('.reply-btn')
            .removeClass('disabled')
            .attr('aria-disabled', false)
            .attr('tabindex', 0);
    },

    /**
     * Disable Submit button
     */
    disableSubmitButton: function() {
        this.$('.reply-btn')
            .addClass('disabled')
            .attr('aria-disabled', true)
            .attr('tabindex', -1);
    },

    /**
     * If the reply area has content, remove placeholder and
     * enable the reply button
     */
    checkPlaceholder: function(e) {
        // We can't use any of the jQuery methods or use the dataset property to
        // set this attribute because they don't seem to work in IE 10. Dataset
        // isn't supported in IE 10 at all.
        var el = e.currentTarget;
        if (el.textContent) {
            el.setAttribute('data-hide-placeholder', 'true');
            this.toggleSubmitButton(true);
        } else {
            el.removeAttribute('data-hide-placeholder');
            this.toggleSubmitButton(false);
        }
    },

    /**
     * Data change event.
     */
    bindDataChange: function () {
        if (this.commentsCollection) {
            this.commentsCollection.on("add", function () {
                this.model.set('comment_count', this.model.get('comment_count') + 1);
            }, this);
        }
        app.view.View.prototype.bindDataChange.call(this);
    },

    unbindData: function() {
        if (this.commentsCollection) {
            this.commentsCollection.off();
        }
        app.view.View.prototype.unbindData.call(this);
    },

    _dispose: function() {
        $(window).off('resize.' + this.cid);
        this.$(this._attachImageSelector).off('error');
        app.view.View.prototype._dispose.call(this);
        this.commentsCollection = null;
    }
}) },
"dupecheck-list-edit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DupecheckListEditView
 * @alias SUGAR.App.view.views.BaseDupecheckListEditView
 * @extends View.Views.Base.DupecheckListView
 */
({
	// Dupecheck-list-edit View (base) 

    extendsFrom: 'DupecheckListView',
    additionalTableClasses: 'duplicates-selectedit',

    addActions: function() {
        if (this.actionsAdded) return;
        this._super('addActions');

        var firstRightColumn = this.rightColumns[0];
        if (firstRightColumn && _.isArray(firstRightColumn.fields)) {
            //Prepend Select and Edit action
            firstRightColumn.fields.unshift({
                type: 'rowaction',
                label: 'LBL_LISTVIEW_SELECT_AND_EDIT',
                css_class: 'btn btn-invisible btn-link ellipsis_inline',
                tooltip: 'LBL_LISTVIEW_SELECT_AND_EDIT',
                event: 'list:dupecheck-list-select-edit:fire'
            });
            this.rightColumns[0] = firstRightColumn;
        }
        this.actionsAdded = true;
    }
}) },
"quicksearch-tags": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchTagsView
 * @alias SUGAR.App.view.views.BaseQuicksearchTagsView
 * @extends View.View
 */

({
	// Quicksearch-tags View (base) 

    events: {
        'click .qs-tag a': 'handleTagSelection'
    },

    initialize: function(options) {
        this._super('initialize', [options]);

        // Initialize tag collections (search results and selected tags)
        this.tagCollection = [];
        this.selectedTags = this.layout.selectedTags || [];
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        /**
         * Stores the index of the currently highlighted list element.
         * This is used for keyboard navigation.
         * @{number} {null}
         */
        this.activeIndex = null;

        // If the layout has `quicksearch:close` called on it, that means the
        // whole thing is hidden
        this.layout.on('quicksearch:close quicksearch:results:close', function() {
            this.activeIndex = null;
            this.$('.active').removeClass('active');
            this.disposeKeyEvents();
            this.close();
        }, this);

        this.collection.on('sync', this.quicksearchHandler, this);

        //Listener for receiving focus for up/down arrow navigation:
        this.on('navigate:focus:receive', function() {
            this.activeIndex = 0;
            this._highlightActive();
            this.attachKeyEvents();
        }, this);

        //Listener for losing focus for up/down arrow navigation:
        this.on('navigate:focus:lost', function() {
            this.activeIndex = null;
            this.$('.active').removeClass('active');
            this.disposeKeyEvents();
        }, this);
    },

    /**
     * Handles the layout event indicating quicksearch fire
     * @param collection
     */
    quicksearchHandler: function(collection) {
        var selectedTags = this.selectedTags;

        if (collection && collection.tags) {
            // Filter out tags that already exist in selectedTags
            this.tagCollection = _.filter(collection.tags, function(tag) {
                return _.isUndefined(_.find(selectedTags, function(selectedTag) {
                    return selectedTag.name === tag.name;
                }));
            });
            this.render();
            if (this.tagCollection.length) {
                this.open();
            } else {
                this.close();
            }
        } else {
            this.close();
        }
    },

    /**
     * Highlight the active element and unhighlight the rest of the elements.
     */
    _highlightActive: function() {
        if (_.isNull(this.activeIndex)) {
            return;
        }

        this.$('.active').removeClass('active');
        this.$('.qs-tag:eq(' + this.activeIndex + ')')
            .addClass('active')
            .find('a').focus();
    },

    /**
     * Handler for tag selection
     * @param {Event} e
     */
    handleTagSelection: function(e) {
        if (e.target && e.target.text) {
            var self = this;
            var selectedTag = _.find(this.tagCollection, function(tag) {
                return tag.name === e.target.text;
            });

            this.layout.trigger('quicksearch:bar:clear:term');
            this.layout.trigger('quicksearch:tag:add', selectedTag);

            // Focus back to quicksearch-bar after tag selection. Defer it to prevent enter key-up
            // from navigating away
            _.defer(function() {
                self.layout.trigger('navigate:to:component', 'quicksearch-bar')
            });
        }
    },

    /**
     * Return true if tag view contains any tags. False if not
     * @return boolean
     */
    isFocusable: function() {
        return this.tagCollection &&
            this.tagCollection.length;
    },

    /**
     * Show the tag ribbon
     */
    open: function() {
        this.layout.trigger('quicksearch:tag:open');
        this.$('.quicksearch-tags').show();
    },

    /**
     * Hide the tag ribbon
     */
    close: function() {
        this.layout.trigger('quicksearch:tag:close');
        this.$('.quicksearch-tags').hide();
    },

    /**
     * Handle when the user uses their keyboard to try to navigate outside of the view. This handles both the top and
     * bottom boundaries.
     * @param {boolean} next - If true, we are checking the next element. If false, we are checking the previous.
     * @private
     */
    _handleBoundary: function(next) {
        var event = 'navigate:next:component';
        if (!next) {
            event = 'navigate:previous:component';
        }
        if (this.layout.triggerBefore(event)) {
            this.disposeKeyEvents();
            this.$('.active').removeClass('active');
            this.layout.trigger(event);
        }
    },

    moveDown: function() {
        this._handleBoundary(true);
    },

    moveRight: function() {
        var maxIndex = this.tagCollection.length;
        if (this.activeIndex < --maxIndex) {
            this.activeIndex++;
            this._highlightActive();
        }
    },

    moveLeft: function() {
        if (this.activeIndex > 0) {
            this.activeIndex--;
            this._highlightActive();
        }
    },

    moveUp: function() {
        this._handleBoundary(false);
    },

    /**
     * Handle the keydown events.
     * @param {Event} e
     */
    keydownHandler: function(e) {
        switch (e.keyCode) {
            case 40: // down arrow
                this.moveDown();
                break;
            case 39: // right arrow
                this.moveRight();
                break;
            case 38: // up arrow
                this.moveUp();
                break;
            case 37: // left arrow
                this.moveLeft();
                break;
            case 13: //enter
                e.preventDefault();
                e.stopImmediatePropagation();
                break;
        }
    },

    keyupHandler: function(e) {
        switch (e.keyCode) {
            case 13: //enter
                this.handleTagSelection(e);
                break;
        }
    },

    /**
     * Attach the keydown events for the view.
     */
    attachKeyEvents: function() {
        this.$el.on('keydown', _.bind(this.keydownHandler, this));
        this.$el.on('keyup', _.bind(this.keyupHandler, this));
    },

    /**
     * Dispose the keydown events for the view.
     */
    disposeKeyEvents: function() {
        this.$el.off('keydown keyup');
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this.disposeKeyEvents();
        this._super('unbind');
    }
}) },
"module-menu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Module menu provides a reusable and easy render of a module Menu.
 *
 * This also helps doing customization of the menu per module and provides more
 * metadata driven features.
 *
 * @class View.Views.Base.ModuleMenuView
 * @alias SUGAR.App.view.views.BaseModuleMenuView
 * @extends View.View
 */
({
	// Module-menu View (base) 

    tagName: 'span',

    events: {
        'click [data-event]': 'handleMenuEvent',
        'click [data-route]': 'handleRouteEvent',
        'shown.bs.dropdown': 'populateMenu'
    },

    /**
     * The possible actions that this module menu provides.
     *
     * This comes from the metadata files, like:
     *
     * - {custom}/modules/&lt;Module&gt;/clients/base/menus/header/header.php
     */
    actions: [],

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} favorites Number of records to show on the favorites
     *   container. Pass 0 if you don't want to support favorites.
     * - {Number} recently_viewed Number of records to show on the recently
     *   viewed container. Pass 0 if you don't want to support recently viewed.
     *
     * Example:
     * ```
     * // ...
     * 'settings' => array(
     *     'favorites' => 5,
     *     'recently_viewed' => 9,
     *     //...
     * ),
     * //...
     * ```
     *
     * @protected
     */
    _defaultSettings: {
        favorites: 3,
        recently_viewed: 3
    },

    /**
     * Settings after applied metadata settings on top of
     * {@link View.Views.BaseModuleMenuView#_defaultSettings default settings}.
     *
     * @protected
     */
    _settings: {},

    /**
     * @inheritdoc
     *
     * Adds listener for bootstrap drop down show event (`shown.bs.dropdown`).
     * This will trigger menuOpen method.
     */
    initialize: function(options) {

        options.meta = _.extend(
            {},
            options.meta,
            app.metadata.getView(null, options.name),
            app.metadata.getView(options.module, options.name)
        );

        this._super('initialize', [options]);
        this._initSettings();

        /**
         * The internal array of collections for favorites and recent.
         * The collections shouldn't be reused with different filters when
         * fetching in parallel.
         *
         * @property {Object}
         * @private
         */
        this._collections = {};
    },


    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseModuleMenuView} Instance of this view.
     * @protected
     */
    _initSettings: function() {

        this._settings = _.extend({},
            this._defaultSettings,
            this.meta && this.meta.settings || {}
        );

        return this;
    },

    /**
     * @inheritdoc
     *
     * Retrieves possible menus from the metadata already inSync.
     * Filters all menu actions based on ACLs to prevent user to click them and
     * get a `403` after click.
     */
    _renderHtml: function() {
        var meta = app.metadata.getModule(this.module) || {};

        this.actions = this.filterByAccess(meta.menu && meta.menu.header && meta.menu.header.meta);

        this._super('_renderHtml');

        if (!this.meta.short) {
            this.$el.addClass('btn-group');
        }
    },

    /**
     * Filters menu actions by ACLs for the current user.
     *
     * @param {Array} meta The menu metadata to check access.
     * @return {Array} Returns only the list of actions the user has access.
     */
    filterByAccess: function(meta) {

        var result = [];

        _.each(meta, function(menuItem) {
            if (app.acl.hasAccess(menuItem.acl_action, menuItem.acl_module)) {
                result.push(menuItem);
            }
        });

        return result;
    },

    /**
     * Method called when a `show.bs.dropdown` event occurs.
     *
     * Populate the favorites and recently viewed records every time we open
     * the menu. This is only supported on modules that have fields.
     */
    populateMenu: function() {

        var meta = app.metadata.getModule(this.module) || {};

        if (_.isEmpty(_.omit(meta.fields, '_hash'))) {
            return;
        }

        if (meta.favoritesEnabled) {
            this.populate('favorites', [{
                '$favorite': ''
            }], this._settings.favorites);
        }

        this.populate('recently-viewed', [{
            '$tracker': '-7 DAY'
        }], this._settings.recently_viewed);
    },


    /**
     * Return `true` if this menu is open, `false` otherwise.
     * @return {Boolean} `true` if this menu is open, `false` otherwise.
     */
    isOpen: function() {
        return !!this.$el.hasClass('open');
    },

    /**
     * Populates records templates based on filter given.
     *
     * @param {String} tplName The template to use to populate data.
     * @param {String} filter The filter to be applied.
     * @param {Number} limit The number of records to populate. Needs to be an
     *   integer `> 0`.
     */
    populate: function(tplName, filter, limit) {
        if (limit <= 0) {
            return;
        }

        this.getCollection(tplName).fetch({
            'showAlerts': false,
            'fields': ['id', 'name'],
            // TODO SC-3696 this filter can be initialized once in the
            // getCollection() and be metadata driven.
            'filter': filter,
            'limit': limit,
            'success': _.bind(function() {
                this._renderPartial(tplName);
            }, this)
        });
    },

    /**
     * Get the collection for the partial (favorites or recently viewed).
     *
     * @param {string} tplName The name of the partial template that will use
     *   this collection.
     * @return {Data.BeanCollection} The collection of this module.
     */
    getCollection: function(tplName) {
        if (!this._collections[tplName]) {
            this._collections[tplName] =
                app.data.createBeanCollection(this.module, [], {params: {erased_fields: true}});
            // TODO SC-3696 create the initial filter based on metadata for the
            // partials
        }

        return this._collections[tplName];
    },

    /**
     * Renders the data in the partial template given.
     *
     * The partial template can receive more data from the options parameter.
     *
     * @param {String} tplName The template to use to render the partials.
     * @param {Object} [options] Other optional data to pass to the template.
     * @protected
     */
    _renderPartial: function(tplName, options) {
        if (this.disposed || !this.isOpen()) {
            return;
        }
        options = options || {};

        var tpl = app.template.getView(this.name + '.' + tplName, this.module) ||
            app.template.getView(this.name + '.' + tplName);

        var self = this;
        var collection = this.getCollection(tplName);
        _.each(collection.models, function(model) {
            if (app.utils.isNameErased(model)) {
                model.set('erased', true);
                model.set('erasedText', app.lang.get('LBL_VALUE_ERASED'));
            }
        });

        var $placeholder = this.$('[data-container="' + tplName + '"]');
        var $old = $placeholder.nextUntil('.divider');

        //grab the focused element's route (if exists) for later re-focusing
        var focusedRoute = $old.find(document.activeElement).data('route');

        //replace the partial using newly updated collection
        $old.remove();
        $placeholder.after(tpl(_.extend({'collection': collection}, options)));

        //if there was a focused element previously, restore its focus
        if (focusedRoute) {
            var $new = $placeholder.nextUntil('.divider');
            var focusSelector = '[data-route="' + focusedRoute + '"]';
            var $newFocus = $new.find(focusSelector);
            if ($newFocus.length > 0) {
                $newFocus.focus();
            }
        }
    },

    /**
     * This gives support to any events that might exist in the menu actions.
     *
     * Out of the box we don't have any use case for actions that are event
     * driven. Since it was already provided since 7.0.0 we will keep it util
     * further notice.
     *
     * @param {Event} evt The event that triggered this (normally a click
     *   event).
     */
    handleMenuEvent: function(evt) {
        var $currentTarget = this.$(evt.currentTarget);
        app.events.trigger($currentTarget.data('event'), this.module, evt);
    },

    /**
     * This triggers router navigation on both menu actions and module links.
     *
     * Since we normally trigger the drawer for some actions, we prevent it
     * when using the click with the `ctrlKey` (or `metaKey` in Mac OS).
     * We also prevent the routing to be fired when this happens.
     *
     * When we are triggering the same route that we already are in, we just
     * trigger a {@link Core.Routing#refresh}.
     *
     * @param {Event} event The event that triggered this (normally a click
     *   event).
     */
    handleRouteEvent: function(event) {
        var currentRoute,
            $currentTarget = this.$(event.currentTarget),
            route = $currentTarget.data('route');

        event.preventDefault();
        if ((!_.isUndefined(event.button) && event.button !== 0) || event.ctrlKey || event.metaKey || $currentTarget.data('openwindow') === true) {
            event.stopPropagation();
            window.open(route, '_blank');
            return false;
        }

        currentRoute = '#' + Backbone.history.getFragment();
        (currentRoute === route) ? app.router.refresh() : app.router.navigate(route, {trigger: true});
    }

}) },
"forgotpassword": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Forgot password form view.
 *
 * @class View.Views.Base.ForgotpasswordView
 * @alias SUGAR.App.view.views.BaseForgotpasswordView
 * @extends View.View
 */
({
	// Forgotpassword View (base) 

    plugins: ['ErrorDecoration'],

    events: {
        'click [name=cancel_button]': 'cancel',
        'click [name=forgotPassword_button]': 'forgotPassword',
        'change select[name=country]': 'render'
    },

    /**
     * Get the fields metadata from panels and declare a Bean with the metadata
     * attached.
     *
     * {@link View.Views.Base.LoginView}
     *
     * @param {Object} meta The view's metadata supplied.
     * @private
     */
    _declareModel: function(meta) {
        meta = meta || {};

        var fields = {};
        _.each(_.flatten(_.pluck(meta.panels, "fields")), function(field) {
            fields[field.name] = field;
        });
        /**
         * Fields metadata needs to be converted to this format for App.data.declareModel
         *  {
          *     "first_name": { "name": "first_name", ... },
          *     "last_name": { "name": "last_name", ... },
          *      ...
          * }
         */
        app.data.declareModel('Forgotpassword', {fields: fields});
    },

    /**
     * @override
     * @param options
     */
    initialize: function(options) {
        // Declare a Bean so we can process field validation
        this._declareModel(options.meta);

        // Reprepare the context because it was initially prepared without metadata
        options.context.prepare(true);

        app.view.View.prototype.initialize.call(this, options);
        this._showResult = false;
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (!(app.config && app.config.forgotpasswordON === true)) {
            return;
        }
        if (app.config.idmModeEnabled === true) {
            window.location.href = app.config.cloudConsoleForgotPasswordUrl;
        }
        this.logoUrl = app.metadata.getLogoUrl();
        app.view.View.prototype._render.call(this);

        return this;
    },

    /**
     * Basic cancel button
     */
    cancel: function() {
        app.router.goBack();
    },

    /**
     * Handles forgot password request
     */
    forgotPassword: function() {
        var self = this;

        self.model.doValidate(null, function(isValid) {
            if (isValid) {

                // a robot has reached into the honey pot. do not submit
                if (app.config.honeypot_on && app.config.honeypot_on === true &&
                    (self.$('input[name="first_name"]').val() || self.model.get('first_name'))) return;

                app.$contentEl.hide();
                app.alert.show('forgotPassword', {level: 'process', title: app.lang.get('LBL_LOADING'), autoClose: false});

                var emails = self.model.get('email');
                var params = {
                    username: self.model.get('username')
                };

                if (emails && emails[0] && emails[0].email_address) {
                    params.email =  emails[0].email_address;
                }

                var url = app.api.buildURL('password/request','',{},params);
                app.api.call('READ', url,{},{
                    success: function(response){
                        // result flags
                        self._showSuccess = true;
                        self._showResult = true;
                        self.resultLabel = "LBL_PASSWORD_REQUEST_SENT";
                        self.model.clear();
                        if (!self.disposed) {
                            self.render();
                        }
                    },
                    error: function(err){
                        // result flags
                        self._showSuccess = false;
                        self._showResult = true;

                            self.resultLabel = err.message || 'LBL_PASSWORD_REQUEST_ERROR';

                        if (!self.disposed) {
                            self.render();
                        }
                    },
                    complete: function() {
                        app.alert.dismiss('forgotPassword');
                        app.$contentEl.show();
                    }
                })
            }
        }, self);
    },

    /**
     * Really basic metadata for the Back button displayed on password reset
     */
    _backButton: [
        {
            name: 'cancel_button',
            type: 'button',
            label: 'LBL_BACK',
            value: 'forgotPassword',
            primary: false
        }
    ]
}) },
"subpanel-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Custom RecordlistView used within Subpanel layouts.
 *
 * @class View.Views.Base.SubpanelListView
 * @alias SUGAR.App.view.views.BaseSubpanelListView
 * @extends View.Views.Base.RecordlistView
 */
({
	// Subpanel-list View (base) 

    extendsFrom: 'RecordlistView',
    fallbackFieldTemplate: 'list',
    plugins: ['ErrorDecoration', 'Editable', 'SugarLogic', 'Pagination',
        'ResizableColumns', 'MassCollection'],

    contextEvents: {
        "list:editall:fire": "toggleEdit",
        "list:editrow:fire": "editClicked",
        "list:unlinkrow:fire": "warnUnlink"
    },

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        // `dataView` corresponds to the list of fields the API should retrieve.
        // Inherit from the layout unless not defined.
        this.dataView = (options.layout && options.layout.dataView) || options.name || 'subpanel-list';

        this._super("initialize", [options]);

        // Setup max limit on collection's fetch options for this subpanel's context
        var limit = this.context.get('limit') || app.config.maxSubpanelResult;

        if (limit) {
            this.context.set('limit', limit);
            //supanel-list extends indirectly ListView, and `limit` determines # records displayed
            this.limit = limit;
        }

        //Override the recordlist row template
        this.rowTemplate = app.template.getView('recordlist.row');

        //event register for preventing actions
        //when user escapes the page without confirming deletion
        app.routing.before("route", this.beforeRouteUnlink, this);
        $(window).on("beforeunload.unlink" + this.cid, _.bind(this.warnUnlinkOnRefresh, this));
    },

    /**
     * When parent recordlist's initialize is invoked (above), this will get called
     * and populate our the list's meta with the proper view subpanel metadata.
     *
     * @private
     * @param {Object} options
     * @return {Object} The view metadata for this module's subpanel.
     */
    _initializeMetadata: function(options) {
        return  _.extend({},
            app.metadata.getView(null, 'subpanel-list'),
            app.metadata.getView(options.module, 'record-list'),
            app.metadata.getView(options.module, 'subpanel-list')
        );
    },

    /**
     * Unlink (removes) the selected model from the list view's collection
     */
    unlinkModel: function() {
        var self = this,
            model = this._modelToUnlink;

        model.destroy({
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: self.getUnlinkMessages(self._modelToUnlink).success
                }
            },
            relate: true,
            success: function() {
                var redirect = self._targetUrl !== self._currentUrl;
                self._modelToUnlink = null;
                var options = {
                    previousModels: _.clone(self.collection.models),
                    context: self.context
                };
                self.collection.remove(model, { silent: redirect });

                if (redirect) {
                    self.unbindBeforeRouteUnlink();
                    //Replace the url hash back to the current staying page
                    app.router.navigate(self._targetUrl, {trigger: true});
                    return;
                }

                // We trigger reset after removing the model so that
                // panel-top will re-render and update the count.
                self.collection.trigger('reset', self.collection, options);
                self.render();
            }
        });
    },

    /**
     * Pre-event handler before current router is changed
     *
     * @return {Boolean} true to continue routing, false otherwise
     */
    beforeRouteUnlink: function () {
        if (this._modelToUnlink) {
            this.warnUnlink(this._modelToUnlink);
            return false;
        }
        return true;
    },

    /**
     * Formats the messages to display in the alerts when unlinking a record.
     *
     * @param {Data.Bean} model The model concerned.
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getUnlinkMessages: function(model) {
        var messages = {};
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;

        messages.confirmation = app.utils.formatString(app.lang.get('NTC_UNLINK_CONFIRMATION_FORMATTED'), [context]);
        messages.success = app.utils.formatString(app.lang.get('NTC_UNLINK_SUCCESS'), [context]);
        return messages;
    },

    /**
     * Popup dialog message to confirm unlink action
     *
     * @param {Backbone.Model} model the bean to unlink
     */
    warnUnlink: function(model) {
        var self = this;
        this._modelToUnlink = model;

        self._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (self._targetUrl !== self._currentUrl) {
            app.router.navigate(this._currentUrl, {trigger: false, replace: true});
        }

        app.alert.show('unlink_confirmation', {
            level: 'confirmation',
            messages: self.getUnlinkMessages(model).confirmation,
            onConfirm: _.bind(self.unlinkModel, self),
            onCancel: function() {
                self._modelToUnlink = null;
            }
        });
    },

    /**
     * Popup browser dialog message to confirm unlink action
     *
     * @return {String} the message to be displayed in the browser alert
     */
    warnUnlinkOnRefresh: function() {
        if (this._modelToUnlink) {
            return this.getUnlinkMessages(this._modelToUnlink).confirmation;
        }
    },

    /**
     * Detach the event handlers for warning unlink
     */
    unbindBeforeRouteUnlink: function() {
        app.routing.offBefore("route", this.beforeRouteUnlink, this);
        $(window).off("beforeunload.unlink" + this.cid);
    },

    /**
     * @override
     * @private
     */
    _dispose: function() {
        this.unbindBeforeRouteUnlink();
        this._super('_dispose');
    }
}) },
"list-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ListBottomView
 * @alias SUGAR.App.view.views.BaseListBottomView
 * @extends View.View
 */
({
	// List-bottom View (base) 

    events: {
        'click [data-action="show-more"]': 'showMoreRecords'
    },

    initialize: function(options) {
        this._super('initialize', [options]);
        // This component should always have a `list` action.
        this.action = 'list';

        /**
         * Label key used for {@link #showMoreLabel}.
         *
         * You can define it in metadata under `label` property. Defaults to
         * `TPL_SHOW_MORE_MODULE`.
         *
         * @type {string}
         * @private
         */
        this._showMoreLabel = this.meta && this.meta.label || 'TPL_SHOW_MORE_MODULE';
        this._initPagination();
    },

    /**
     * Initialize pagination component in order to react the show more link.
     * @private
     */
    _initPagination: function() {
        this.paginationComponent = _.find(this.layout._components, function(component) {
            return _.contains(component.plugins, 'Pagination');
        }, this);
    },

    /**
     * Retrieving the next page records by pagination plugin.
     *
     * Please see the {@link app.plugins.Pagination#getNextPagination}
     * for detail.
     */
    showMoreRecords: function() {
        if (!this.paginationComponent) {
            return;
        }

        var options = {};
        options.success = _.bind(function() {
            this.layout.trigger('list:paginate:success');
            // FIXME: This should trigger on `this.collection` instead of
            // `this.context`. Will be fixed as part of SC-2605.
            this.context.trigger('paginate');
            this.render();
        }, this);

        this.paginationComponent.getNextPagination(options);
        this.render();
    },

    /**
     * Assign proper label for 'show more' link.
     * Label should be "More <module name>...".
     */
    setShowMoreLabel: function() {
        var model = this.collection.at(0);
        var module = model ? model.module : this.context.get('module');
        var context = {
            count: this.collection.length,
            offset: this.collection.next_offset >= 0
        };
        if (module) {
            context.module = new Handlebars.SafeString(app.lang.getModuleName(module, {plural: true}).toLowerCase());
        }

        /**
         * Label used in the template to display Show more message.
         *
         * By default it will display "More {module}...".
         *
         * @type {string}
         * @private
         */
        this.showMoreLabel = app.lang.get(this._showMoreLabel, module, context);
    },

    /**
     * Reset previous collection handlers and
     * bind the listeners for new collection.
     */
    onCollectionChange: function() {
        var prevCollection = this.context.previous('collection');
        if (prevCollection) {
            prevCollection.off(null, null, this);
        }
        this.collection = this.context.get('collection');
        this.collection.on('add remove reset', this.render, this);
        this.render();
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this.setShowMoreLabel();
        this._super('_renderHtml');
    },

    /**
     * @inheritdoc
     *
     * Bind listeners for collection updates.
     * The pagination link synchronizes its visibility with the collection's
     * status.
     */
    bindDataChange: function() {
        this.context.on('change:collection', this.onCollectionChange, this);
        this.collection.on('add remove reset', this.render, this);
    },

    /**
     * @inheritdoc
     *
     * Add dashlet placeholder's class in order to handle the custom css style.
     */
    show: function() {
        this._super('show');
        if (!this.paginationComponent) {
            return;
        }
        this.paginationComponent.layout.$el.addClass('pagination');
    },

    /**
     * @inheritdoc
     *
     * Remove pagination custom CSS class on dashlet placeholder.
     */
    hide: function() {
        this._super('hide');
        if (!this.paginationComponent) {
            return;
        }
        this.paginationComponent.layout.$el.removeClass('pagination');
    }
}) },
"helplet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * A `helplet` is a view similar to a dashlet thats lives in the help
 * component.
 *
 * TODO: SC-4808: Once MAR-2995 gets merged, we can instead have a collection of
 * helplet views that get iterated over in a helplet-list layout. This will
 * improve performance and provide better flexibility for managing independent
 * helplets.
 *
 * @class View.Views.Base.HelpletView
 * @alias SUGAR.App.view.views.BaseHelpletView
 * @extends View.View
 */
({
	// Helplet View (base) 

    /**
     * Holds the Object returned by `app.help.get()`. Example:
     * <pre><code>
     * {
     *    body: '',
     *    more_help: ''
     * }
     * </code></pre>
     *
     * @type {Object}
     */
    helpObject: {},

    /**
     * Boolean to indicate if the current view's tour is enabled.
     *
     * @type {boolean} `true` if tour is enabled, otherwise `false`.
     * @private
     */
    _tourEnabled: false,

    events: {
        'click [data-action=tour]': 'showTour'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.createHelpObject();
        this.on('render', this.toggleTourLink, this);
    },

    /**
     * Checks if the current view's tour is enabled.
     *
     * @return {boolean} `true` if tour is enabled, otherwise `false`.
     */
    isTourEnabled: function() {
        return this._tourEnabled;
    },

    /**
     * Method to fetch the help object from the app.help utility.
     */
    createHelpObject: function() {
        var helpUrl = {
            more_info_url: this._createMoreHelpLink(),
            more_info_url_close: '</a>'
        };
        var ctx = this.context.parent || this.context;
        this.helpObject = app.help.get(ctx.get('module'), ctx.get('layout'), helpUrl);
    },

    /**
     * Method to set the `tourEnabled` flag based on current module and layout.
     */
    toggleTourLink: function() {
        var ctx = app.controller.context;
        if (app.tutorial.hasTutorial(ctx.get('layout'), ctx.get('module'))) {
            this._tourEnabled = true;
            this.$('[data-action=tour]').removeClass('disabled');
        } else {
            this._tourEnabled = false;
            this.$('[data-action=tour]').addClass('disabled');
        }
    },

    /**
     * Click handler for tour link.
     *
     * Displays the tour and closes the help popup.
     */
    showTour: function() {
        if (!this.isTourEnabled() || app.tutorial.instance) {
            return;
        }

        var ctx = app.controller.context;
        var helpLayout = this.layout.closestComponent('help');
        if (helpLayout && !helpLayout.disposed) {
            helpLayout.toggle(false);
        }

        app.tutorial.resetPrefs();
        app.tutorial.show(ctx.get('layout'), {module: ctx.get('module')});
    },

    /**
     * Collects server version, language, module, and route and returns an HTML
     * link to be used in the template.
     *
     * @private
     * @return {string} The anchor tag for the 'More Help' link.
     */
    _createMoreHelpLink: function() {
        var serverInfo = app.metadata.getServerInfo();
        var lang = app.lang.getLanguage();
        var module = app.controller.context.get('module');
        var route = app.controller.context.get('layout');

        if (route === 'records') {
            route = 'list';
        }

        var url = 'http://www.sugarcrm.com/crm/product_doc.php?' +
            'edition=' + serverInfo.flavor +
            '&version=' + serverInfo.version +
            '&lang=' + lang +
            '&module=' + module +
            '&route=' + route;

        if (route === 'bwc') {
            // Parse `action` URL param.
            var action = window.location.hash.match(/#bwc.*action=(\w*)/i);
            if (action && !_.isUndefined(action[1])) {
                url += '&action=' + action[1];
            }
        }

        return '<a href="' + url + '" target="_blank">';
    }
}) },
"panel-top-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Header section for Subpanel layouts.
 *
 * @class View.Views.Base.PanelTopView
 * @alias SUGAR.App.view.views.BasePanelTopView
 * @extends View.View
 */
({
	// Panel-top-create View (base) 

    extendsFrom: 'PanelTopView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.set('collapsed', false);
    },

    /**
     * @inheritdoc
     *
     * Overrides the default related-record create to add the new item inline
     *
     * @override
     */
    createRelatedClicked: function(event) {},

    /**
     * @inheritdoc
     *
     * Overrides the parent togglePanel since we don't allow panel toggling in create
     *
     * @override
     */
    togglePanel: function() {}
}) },
"vcard-import": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.VcardImportView
 * @alias SUGAR.App.view.views.BaseVcardImportView
 * @extends View.View
 */
({
	// Vcard-import View (base) 

    /**
     * @inheritdoc
     * Imports a vcf file and creates a record based on person type
     */
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.context.on('vcard:import:finish', this.importVCard, this);
        this.on('render', this._setFileField, this);
    },

    /**
     * Sets up the file field to edit mode
     *
     * @param {View.Field} field
     * @private
     */
    _setFileField: function() {
        var field = this.getField('vcard_import');
        field.setMode('edit');
    },

    /**
     * Event to trigger the uploading of the vcf and record creation
     */
    importVCard: function() {
        var vcardFieldName = 'vcard_import',
            $vcardFile = this.$('[name=vcard_import]');

        if (_.isEmpty($vcardFile.val())) {
            app.alert.show('error_validation_vcard', {
                level: 'error',
                messages: 'LBL_EMPTY_VCARD'
            });
        } else {
            var ajaxParams = {
                    temp: false,
                    deleteIfFails: false
                },
                fields = {},
                field = this.getField(vcardFieldName);

            fields[vcardFieldName] = field.def;

            this.context.trigger('vcard:import-finish-button:toggle', false);
            app.alert.show('vcard_importing', {
                level: 'process',
                title: app.lang.get('LBL_SAVING', this.module)
            });
            this.model.uploadFile(vcardFieldName, $vcardFile, {
                success: _.bind(this._doValidateFileSuccess, this),
                error: _.bind(this._doValidateFileError, this)
            }, ajaxParams);
        }
    },

    /**
     * Success callback for the {@link #importVCard} function.
     *
     * @param {Object} data File data returned from the successful file upload.
     */
    _doValidateFileSuccess: function(data) {
        var route = app.router.buildRoute(this.module, data.vcard_import);
        app.router.navigate(route, {trigger: true});
        app.alert.dismiss('vcard_importing');
        app.alert.show('vcard-import-saved', {
            level: 'success',
            messages: app.lang.get('LBL_IMPORT_VCARD_SUCCESS', this.module),
            autoClose: true
        });
    },

    /**
     * Error callback for the {@link #importVCard} function.
     *
     * @param {Object} error Error object returned from the API.
     */
    _doValidateFileError: function(error) {
        this.context.trigger('vcard:import-finish-button:toggle', true);
        app.alert.dismiss('vcard_importing');
        app.alert.show('error_validation_vcard', {
            level: 'error',
            messages: app.lang.get('TPL_IMPORT_VCARD_FAILURE', this.module, {module: this.module})
        });
    }
}) },
"filtered-search": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FilteredSearchView
 * @alias SUGAR.App.view.views.BaseFilteredSearchView
 * @extends View.View
 */
({
	// Filtered-search View (base) 

    events: {
        'keyup [data-searchfield]': 'searchFired'
    },

    /**
     * @inheritdoc
     *
     * Update searchable fields.
     */
    bindDataChange: function() {
        this.context.on('filteredlist:filter:set', this.setFilter, this);
    },

    /**
     * Update quick search placeholder to display searchable fields.
     * @param {Array} filter List of field name.
     */
    setFilter: function(filter) {
        var label = app.lang.get('LBL_SEARCH_BY') + ' ' + filter.join(', ') + '...';
        this.$('[data-searchfield]').attr('placeholder', label);
    },

    /**
     * Updated current typed search term.
     */
    searchFired: _.debounce(function(evt) {
        var value = $(evt.currentTarget).val();
        this.context.trigger('filteredlist:search:fired', value);
    }, 100)
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CreateView
 * @alias SUGAR.App.view.views.CreateView
 * @extends View.Views.Base.RecordView
 */
({
	// Create View (base) 

    extendsFrom: 'RecordView',
    editAllMode: false,

    enableDuplicateCheck: false,
    dupecheckList: null, //duplicate list layout

    saveButtonName: 'save_button',
    cancelButtonName: 'cancel_button',
    restoreButtonName: 'restore_button',

    /**
     * If this create view has subpanel models to save
     */
    hasSubpanelModels: false,

    /**
     * A collection of alert messages to be used in this view. The alert methods
     * should be invoked by Function.prototype.call(), passing in an instance of
     * a sidecar view. For example:
     *
     *     // ...
     *     this.alerts.showInvalidModel.call(this);
     *     // ...
     *
     * FIXME: SC-3451 will refactor this `alerts` structure.
     * @property {Object}
     */
    alerts: {
        showInvalidModel: function() {
            if (!this instanceof app.view.View) {
                app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                return;
            }
            var name = 'invalid-data';
            this._viewAlerts.push(name);
            app.alert.show(name, {
                level: 'error',
                messages: 'ERR_RESOLVE_ERRORS'
            });
        },
        showServerError: function() {
            if (!this instanceof app.view.View) {
                app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                return;
            }
            var name = 'server-error';
            this._viewAlerts.push(name);
            app.alert.show(name, {
                level: 'error',
                messages: 'ERR_GENERIC_SERVER_ERROR'
            });
        },
        showSuccessButDeniedAccess: function() {
            if (!this instanceof app.view.View) {
                app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                return;
            }
            var name = 'invalid-data';
            this._viewAlerts.push(name);
            app.alert.show(name, {
                level: 'warning',
                messages: 'LBL_RECORD_SAVED_ACCESS_DENIED',
                autoClose: true,
                autoCloseDelay: 9000
            });
        }
    },

    /**
     * Initialize the view and prepare the model with default button metadata
     * for the current layout.
     */
    initialize: function (options) {
        this.plugins = _.union(this.plugins || [], [
            'FindDuplicates'
        ]);

        //add states for create view
        this.STATE = _.extend({}, this.STATE, {
            CREATE: 'create',
            SELECT: 'select',
            DUPLICATE: 'duplicate'
        });

        //inherit base create metadata for purpose of initialization
        options.meta = _.extend({}, app.metadata.getView(null, 'create'), options.meta);

        this._super("initialize", [options]);

        // FIXME: SC-3451 will refactor this `alerts` structure.
        this.alerts = _.extend({}, this.alerts, {
            showServerError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'server-error';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_GENERIC_SERVER_ERROR'
                });
            },
            showNoAccessError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'server-error';
                this._viewAlerts.push(name);
                this.cancel();
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_HTTP_404_TEXT_LINE1'
                });
            },
            showSuccessButDeniedAccess: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'invalid-data';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'warning',
                    messages: 'LBL_RECORD_SAVED_ACCESS_DENIED',
                    autoClose: true,
                    autoCloseDelay: 9000
                });
            }
        });

        this.model.off("change", null, this);

        //keep track of what post-save action was chosen in case user chooses to ignore dupes
        this.context.lastSaveAction = null;

        //listen for the select and edit button
        this.context.on('list:dupecheck-list-select-edit:fire', this.editExisting, this);

        //enable buttons if there is an error
        this.model.on('error:validation', this.enableButtons, this);

        //extend the record view definition
        this.meta = _.extend({}, app.metadata.getView(this.module, 'record'), this.meta);

        //enable or disable duplicate check?
        var moduleMetadata = app.metadata.getModule(this.module);
        this.enableDuplicateCheck = (moduleMetadata && moduleMetadata.dupCheckEnabled) || false;

        // If user has no list acl it doesn't make sense to enable dupecheck
        if (!app.acl.hasAccess('list', this.module)) {
            this.enableDuplicateCheck = false;
        }

        var fields = (moduleMetadata && moduleMetadata.fields) ? moduleMetadata.fields : {};

        this.model.relatedAttributes = this.model.relatedAttributes || {};

        var assignedUserField = _.find(fields, function(field) {
            return field.type === 'relate' &&
                (field.name === 'assigned_user_id' || field.id_name === 'assigned_user_id');
        });
        if (assignedUserField) {
            // set the default assigned user as current user, unless we are copying another record
            var isDuplicate = this.model.has('assigned_user_id') && this.model.has('assigned_user_name');
            if (!isDuplicate) {
                this.model.setDefault({
                    'assigned_user_id': app.user.id,
                    'assigned_user_name': app.user.get('full_name')
                });
            }
            this.model.relatedAttributes.assigned_user_id = app.user.id;
            this.model.relatedAttributes.assigned_user_name = app.user.get('full_name');
        }

        // need to reset the default attributes because the plugin may have
        // calculated default values.
        this.on('sugarlogic:initialize', function() {
            this.model.setDefault(this.model.attributes);
        }, this);
    },

    /**
     * Extends in order to set the {@link #action} to `create` while the fields
     * are rendering.
     *
     * This is a temporary fix that will be reviewed in 7.8. The action should
     * be `create` at all times but doing the proper fix may have bad impacts on
     * ACLs/non editable fields. Follow up in SC-4511.
     *
     * @inheritdoc
     */
    _renderFields: function() {
        var current = this.action;
        this.action = 'create';
        this._super('_renderFields');
        this.action = current;
    },

    /**
     * @inheritdoc
     */
    /**
     * Check unsaved changes.
     * This method is called by {@link app.plugins.Editable}.
     *
     * @return {Boolean} `true` if current model contains unsaved changes,
     *  `false` otherwise.
     */
    hasUnsavedChanges: function() {
        var defaults,
            nonDefaultedAttributesChanged,
            defaultedAttributesChanged;

        if (this.resavingAfterMetadataSync) {
            return false;
        }

        defaults = this.model.getDefault() || {};
        nonDefaultedAttributesChanged = !_.isEqual(_.keys(defaults), _.keys(this.model.attributes));
        defaultedAttributesChanged = !_.isEmpty(this.model.changedAttributes(defaults));

        return (this.model.isNew() && (nonDefaultedAttributesChanged || defaultedAttributesChanged));
    },

    /**
     * @inheritdoc
     *
     * Wires up the save buttons.
     */
    delegateButtonEvents: function() {
        this.context.on('button:' + this.saveButtonName + ':click', this.save, this);
        this.context.on('button:' + this.cancelButtonName + ':click', this.cancel, this);
        this.context.on('button:' + this.restoreButtonName + ':click', this.restoreModel, this);
    },

    _render: function () {
        this._super("_render");

        this.setButtonStates(this.STATE.CREATE);

        // Don't need to add dupecheck layout if dupecheck disabled
        if (this.enableDuplicateCheck) {
            this.renderDupeCheckList();
        }

        //SP-1502: Broadcast model changes so quickcreate field can keep track of unsaved changes
        app.events.trigger('create:model:changed', false);
        this.model.on('change', function() {
            app.events.trigger('create:model:changed', this.hasUnsavedChanges());
        }, this);
    },

    /**
     * Defaults to {@link #saveAndClose}.
     */
    save: function() {
        this.saveAndClose();
    },

    /**
     * Save and close drawer
     */
    saveAndClose: function () {
        this.initiateSave(_.bind(function () {
            if (this.closestComponent('drawer')) {
                app.drawer.close(this.context, this.model);
            } else {
                app.navigate(this.context, this.model);
            }
        }, this));
    },

    /**
     * Handle click on the cancel link
     */
    cancel: function () {
        //Clear unsaved changes on cancel.
        app.events.trigger('create:model:changed', false);
        this.$el.off();
        if (app.drawer.count()) {
            app.drawer.close(this.context);
            this._dismissAllAlerts();
        } else {
            app.router.navigate(this.module, {trigger: true});
        }
    },

    /**
     * Handle click on restore to original link
     */
    restoreModel: function () {
        this.model.clear();
        if (this._origAttributes) {
            this.model.set(this._origAttributes);
            this.model.isCopied = true;
        }

        // reset subpanels
        if (this.hasSubpanelModels) {
            // loop through subpanels and call resetCollection on create subpanels
            _.each(this.context.children, function(child) {
                if (child.get('isCreateSubpanel')) {
                    this.context.trigger('subpanel:resetCollection:' + child.get('link'), true);
                }
            }, this);

            // reset the hasSubpanelModels flag
            this.hasSubpanelModels = false;
        }
        
        this.createMode = true;
        if (!this.disposed) {
            this.render();
        }
        this.setButtonStates(this.STATE.CREATE);
    },

    /**
     * Check for possible duplicates before creating a new record
     * @param callback
     */
    initiateSave: function (callback) {
        this.disableButtons();
        async.waterfall([
            _.bind(this.validateSubpanelModelsWaterfall, this),
            _.bind(this.validateModelWaterfall, this),
            _.bind(this.dupeCheckWaterfall, this),
            _.bind(this.createRecordWaterfall, this)
        ], _.bind(function (error) {
            this.enableButtons();
            if (error && error.status == 412 && !error.request.metadataRetry) {
                this.handleMetadataSyncError(error);
            } else if (!error && !this.disposed) {
                this.context.lastSaveAction = null;
                callback();
            }
        }, this));
    },
    /**
     * Check to see if all fields are valid
     * @param callback
     */
    validateModelWaterfall: function(callback) {
        this.model.doValidate(this.getFields(this.module), function(isValid) {
            callback(!isValid);
        });
    },

    /**
     * Check to see if there are subpanel create models on this view
     * And trigger an event to tell the subpanel to validate itself
     *
     * @param callback
     * @return {Mixed}
     */
    validateSubpanelModelsWaterfall: function(callback) {
        this.hasSubpanelModels = false;
        _.each(this.context.children, function(child) {
            if (child.get('isCreateSubpanel')) {
                this.hasSubpanelModels = true;
                this.context.trigger('subpanel:validateCollection:' + child.get('link'), callback, true);
            }
        }, this);

        // If there are no subpanel models, callback false so the waterfall can continue
        if (!this.hasSubpanelModels) {
            return callback(false);
        }
    },

    /**
     * Check for possible duplicate records
     * @param callback
     */
    dupeCheckWaterfall: function (callback) {
        var success = _.bind(function (collection) {
                if (this.disposed) {
                    callback(true);
                }
                if (collection.models.length > 0) {
                    this.handleDuplicateFound(collection);
                    callback(true);
                } else {
                    this.resetDuplicateState();
                    this.disableButtons();
                    callback(false);
                }
            }, this),
            error = _.bind(function(model, e) {
                if (e.status == 412 && !e.request.metadataRetry) {
                    this.handleMetadataSyncError(e);
                } else {
                    callback(true);
                }
            }, this);

        if (this.skipDupeCheck() || !this.enableDuplicateCheck) {
            callback(false);
        } else {
            this.checkForDuplicate(success, error);
        }
    },

    /**
     * Create new record
     * @param callback
     */
    createRecordWaterfall: function (callback) {
        var success = _.bind(function () {
                var acls = this.model.get('_acl');
                if (!_.isEmpty(acls) && acls.access === 'no' && acls.view === 'no') {
                    //This happens when the user creates a record he won't have access to.
                    //In this case the POST request returns a 200 code with empty response and acls set to no.
                    this.alerts.showSuccessButDeniedAccess.call(this);
                    callback(false);
                } else {
                    this._dismissAllAlerts();
                    app.alert.show('create-success', {
                        level: 'success',
                        messages: this.buildSuccessMessage(this.model),
                        autoClose: true,
                        autoCloseDelay: 10000,
                        onLinkClick: function() {
                            app.alert.dismiss('create-success');
                        }
                    });
                    callback(false);
                }
            }, this),
            error = _.bind(function(model, e) {
                if (e.status == 412 && !e.request.metadataRetry) {
                    this.handleMetadataSyncError(e);
                } else {
                    if (e.status == 403) {
                        this.alerts.showNoAccessError.call(this);
                    } else {
                        this.alerts.showServerError.call(this);
                    }
                    callback(true);
                }
            }, this);

        this.saveModel(success, error);
    },

    /**
     * Check the server to see if there are possible duplicate records.
     * @param success
     * @param error
     */
    checkForDuplicate: function (success, error) {
        var options = {
            //Show alerts for this request
            showAlerts: true,
            success: success,
            error: error
        };

        this.context.trigger("dupecheck:fetch:fire", this.model, options);
    },

    /**
     * Duplicate found: display duplicates and change buttons
     */
    handleDuplicateFound: function () {
        this.setButtonStates(this.STATE.DUPLICATE);
        this.dupecheckList.show();
    },

    /**
     * Clear out all things related to duplicate checks
     */
    resetDuplicateState: function () {
        this.setButtonStates(this.STATE.CREATE);
        this.hideDuplicates();
    },

    /**
     * Called when current record is being saved to allow customization of options and params
     * during save
     *
     * Override to return set of custom options
     *
     * @param {Object} options The current set of options that is going to be used.  This is hand for extending
     */
    getCustomSaveOptions: function (options) {
        return {};
    },

    /**
     * Create a new record
     * @param success
     * @param error
     */
    saveModel: function (success, error) {
        var self = this,
            options;
        options = {
            success: success,
            error: error,
            viewed: true,
            relate: (self.model.link) ? true : null,
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': false,
                'error': false //error callback implements its own error handler
            },
            lastSaveAction: this.context.lastSaveAction
        };
        this.applyAfterCreateOptions(options);

        // Check if this has subpanel create models
        if (this.hasSubpanelModels) {
            _.each(this.context.children, function(child) {
                if (child.get('isCreateSubpanel')) {
                    // create the child collection JSON structure to save
                    var childCollection = {
                            create: []
                        },
                        linkName = child.get('link');
                    if (this.model.has(linkName)) {
                        // the model already has the link name, there must be rollup formulas
                        // on the create form between the model and the subpanel
                        childCollection = this.model.get(linkName);
                        // make sure there is a create key on the childCollection
                        if (!_.has(childCollection, 'create')) {
                            childCollection['create'] = [];
                        }
                    }
                    // loop through the models in the collection and push each model's JSON
                    // data to the 'create' array
                    _.each(child.get('collection').models, function(model) {
                        childCollection.create.push(model.toJSON());
                    }, this);

                    // set the child JSON collection data to the model
                    this.model.set(linkName, childCollection);
                }
            }, this);
        }

        options = _.extend({}, options, self.getCustomSaveOptions(options));
        self.model.save(null, options);
    },

    /**
     * Apply after_create parameters to the URL to specify operations to execute after creating a record.
     * @param options
     */
    applyAfterCreateOptions: function(options) {
        var copiedFromModelId = this.context.get('copiedFromModelId');

        if (copiedFromModelId && this.model.isCopy()) {
            options.params = options.params || {};
            options.params.after_create = {
                copy_rel_from: copiedFromModelId
            };
        }
    },

    /**
     * Using the model returned from the API call, build the success message
     * @param model
     * @return {string}
     */
    buildSuccessMessage: function(model) {
        var modelAttributes,
            successLabel = 'LBL_RECORD_SAVED_SUCCESS',
            successMessageContext;

        //if we have model attributes, use them to build the message, otherwise use a generic message
        if (model && model.attributes) {
            modelAttributes = model.attributes;
        } else {
            modelAttributes = {};
            successLabel = 'LBL_RECORD_SAVED';
        }

        //use the model attributes combined with data from the view to build the success message context
        successMessageContext = _.extend({
            module: this.module,
            moduleSingularLower: app.lang.getModuleName(this.module).toLowerCase()
        }, modelAttributes);

        return app.lang.get(successLabel, this.module, successMessageContext);
    },

    /**
     * Check to see if we should skip duplicate check.
     *
     * Duplicate check should be skipped if we are displaying duplicates or user
     * has switched over to editing an existing duplicate record.
     *
     * @return {boolean}
     */
    skipDupeCheck: function () {
        var skipStates = [this.STATE.DUPLICATE, this.STATE.SELECT];
        return (_.contains(skipStates, this.getCurrentButtonState()));
    },

    /**
     * Clears out field values
     */
    clear: function () {
        this.model.clear();
        if (!this.disposed) {
            this.render();
        }
    },

    /**
     * Make the specified record as the data to be edited, and merge the existing data.
     * @param model
     */
    editExisting: function (model) {
        var origAttributes = this.saveFormData();

        this.model.clear();
        this.model.set(this.extendModel(model, origAttributes));

        if (this.model.link) {
            this.model.link.isNew = false;
        }

        this.createMode = false;
        if (!this.disposed) {
            this.render();
        }
        this.toggleEdit(true);

        this.hideDuplicates();
        this.setButtonStates(this.STATE.SELECT);
    },

    /**
     * Merge the selected record with the data entered in the form
     * @param newModel
     * @param origAttributes
     * @return {Object}
     */
    extendModel: function (newModel, origAttributes) {
        var modelAttributes = _.clone(newModel.attributes);

        _.each(modelAttributes, function (value, key) {
            if (_.isUndefined(value) || _.isNull(value) ||
                ((_.isObject(value) || _.isArray(value) || _.isString(value)) && _.isEmpty(value))) {
                delete modelAttributes[key];
            }
        });

        return _.extend({}, origAttributes, modelAttributes);
    },

    /**
     * Save the data entered in the form
     * @return {Object}
     */
    saveFormData: function () {
        this._origAttributes = _.clone(this.model.attributes);
        return this._origAttributes;
    },

    /**
     * Sets the dupecheck list type
     *
     * @param {String} type view to load
     */
    setDupeCheckType: function(type) {
        this.context.set('dupelisttype', type);
    },

    /**
     * Render duplicate check list table
     */
    renderDupeCheckList: function () {
        this.setDupeCheckType('dupecheck-list-edit');
        this.context.set('collection', this.createDuplicateCollection(this.model));

        if (_.isNull(this.dupecheckList)) {
            this.dupecheckList = app.view.createLayout({
                context: this.context,
                name: 'create-dupecheck',
                module: this.module
            });
            this.dupecheckList.initComponents();
            this.addToLayoutComponents(this.dupecheckList);
        }

        this.$('.headerpane').after(this.dupecheckList.$el);
        this.dupecheckList.hide();
        this.dupecheckList.render();
    },

    /**
     * Add component to layout's component list so it gets cleaned up properly on dispose
     *
     * FIXME: SC-6041 should handle deprecating this method.
     *
     * @param component
     */
    addToLayoutComponents: function (component) {
        this.layout._components.push(component);
    },

    /**
     * If initialized (depends on this.enableDuplicateCheck flag) hides the
     * duplicate list.
     */
    hideDuplicates: function () {
        if (this.dupecheckList) {
            this.dupecheckList.hide();
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.dupecheckList) {
            this.dupecheckList.dispose();
        }
        this._super('_dispose');
    },

    /**
     * Disable buttons
     */
    disableButtons: function () {
        this.toggleButtons(false);
    },

    /**
     * Enable buttons
     */
    enableButtons: function () {
        this.toggleButtons(true);
    },

    registerShortcuts: function() {
        this._super('registerShortcuts');

        app.shortcuts.register({
            id: 'Create:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=' + this.saveButtonName + ']');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.get(0).click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Create:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=' + this.cancelButtonName + ']');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.get(0).click();
                }
            }
        });
    },

    /**
     * We don't want the locked fields warning on create
     * @override
     */
    warnLockedFields: _.noop
}) },
"audit-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.AuditHeaderpaneView
 * @alias SUGAR.App.view.views.BaseAuditHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Audit-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=close_button]': 'close'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //shortcut keys
        app.shortcuts.register({
            id: 'AuditHeaderPanel:Close',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $closeButton = this.$('a[name=close_button]');
                if ($closeButton.is(':visible') && !$closeButton.hasClass('disabled')) {
                    $closeButton.click();
                }
            }
        });
    },

    /**
     * Closes the drawer.
     */
    close: function() {
        app.drawer.close();
    },

    /**
     * @override
     *
     * Overriding to show record name on title header if it is available;
     * if not, use the standard title.
     */
    _formatTitle: function(title) {
        var model = this.context.get('model');
        var recordName = app.utils.getRecordName(model);
        if (recordName) {
            return app.lang.get('TPL_AUDIT_LOG_TITLE', model.module, {name: recordName});
        } else if (title) {
            return app.lang.get(title, this.module);
        } else {
            return '';
        }
    }
}) },
"sweetspot-searchbar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SweetspotSearchbarView
 * @alias SUGAR.App.view.views.BaseSweetspotSearchbarView
 * @extends View.View
 */
({
	// Sweetspot-searchbar View (base) 

    className: 'sweetspot-searchbar',
    events: {
        'keyup input': 'keyUpHandler',
        'click [data-action=configure]': 'initConfig'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        app.events.on('app:sync:complete sweetspot:reset', this.initLibrary, this);
        this.lastTerm = '';

        this.layout.on('hide', function() {
            this.lastTerm = '';
        }, this);
    },

    initConfig: function(evt) {
        this.layout.toggle();
        this.layout.trigger('sweetspot:config');
    },

    /**
     * Initializes the libraries.
     *
     * - Adds all the mega menu actions to {@link #internalLibrary}.
     */
    initLibrary: function() {
        /**
         * Static library.
         *
         * Contains mega menu actions and system commands.
         *
         * @type {Array}
         */
        this.internalLibrary = [];

        /**
         * Temporary library.
         *
         * Contains records from the search API, but these are only kept for
         * 5 minutes (for better user experience).
         *
         * @type {Object}
         */
        this.temporaryLibrary = {};

        this.addToInternalLibrary(this.getSweetspotActions());

        this.internalLibrary = this._formatInternalLib();
    },

    /**
     * Formats the {@link #internalLibrary internal library} by parsing it to
     * remove duplicate results.
     *
     * @return {Array} The formatted library of actions/commands.
     */
    _formatInternalLib: function() {
        var lib = _.chain(this.internalLibrary)
            .map(function(item) {
                return JSON.stringify(item);
            })
            .uniq()
            .map(function(item) {
                return JSON.parse(item)
            })
            .value();

        return lib;
    },

    getSweetspotActions: function() {
        var actionsById = app.metadata.getSweetspotActions();
        var prefs = app.user.getPreference('sweetspot');
        var data = prefs && prefs.hotkeys;

        _.each(data, function(customSetting) {
            if (!actionsById[customSetting.action]) {
                return;
            }
            actionsById[customSetting.action].keyword = customSetting.keyword;
        });
        return _.toArray(actionsById);
    },

    /**
     * Adds some items to the {@link #internalLibrary}.
     *
     * @param {Array} items Items to add.
     */
    addToInternalLibrary: function(items) {
        this.internalLibrary = this.internalLibrary.concat(items);
    },

    /**
     * Adds some records to the {@link #temporaryLibrary}
     *
     * @param {Array} items Records to add.
     */
    addToTemporaryLibrary: function(items) {
        _.each(items, function(item) {
            this.temporaryLibrary[item.id] = item;
        }, this);
    },

    /**
     * Gets the records from the {@link #temporaryLibrary}.
     *
     * Records that are here for more than 5 minutes are removed.
     *
     * @return {Array} The list of records.
     */
    getTemporaryLibrary: function() {
        var now = new Date().getTime();
        var tooOld = now - 300000;
        var updatedLibrary = {};
        var recordList = [];
        _.each(this.temporaryLibrary, function(item) {
            if (item.timestamp > tooOld) {
                updatedLibrary[item.id] = item;
                recordList.push(item);
            }
        });
        this.temporaryLibrary = updatedLibrary;
        return recordList;
    },

    /**
     * Gets the library to perform the search.
     *
     * Concats {@link #internalLibrary} and {@link #temporaryLibrary}.
     *
     * @return {Array} The list of items to perform the search.
     */
    getLibrary: function() {
        return this.internalLibrary.concat(this.getTemporaryLibrary());
    },



    /**
     * Triggers the search and send results.
     *
     * @param {boolean} later `true` if triggered from the search API callback.
     */
    applyQuickSearch: function(later) {
        var term = this.$('input').val();
        if (!later && term === this.lastTerm) {
            return;
        }
        var results = {};
        if (!later && !_.isEmpty(term)) {
            this.fireSearchRequest(term);
        }
        if (!_.isEmpty(term)) {
            results = this.doSearch(term);
        }
        this.sendResults(results);
        this.lastTerm = term;
    },

    /**
     * Performs the actual search in the library.
     *
     * @param {string} term The term to search
     * @return {Array} Hopefully a list of results.
     */
    doSearch: function(term) {
        var options = {
            keys: ['module', 'name'],
            threshold: '0.3',
            includeScore: true
        };
        var keywordFuse = new Fuse(this.internalLibrary, {keys: ['keyword'], threshold: '0.0'});
        var keywords = keywordFuse.search(term);
        keywords = keywords.slice(0, 5);

        var actionsFuse = new Fuse(_.difference(this.internalLibrary, keywords), options);
        var actions = actionsFuse.search(term);
        actions = _.sortBy(actions, function(obj) {
            return [obj.score, obj.item.weight];
        });
        actions = actions.slice(0, 6);

        var recordsFuse = new Fuse(_.toArray(this.temporaryLibrary), options);
        var records = recordsFuse.search(term);
        var showMore = records.length > 3;

        records = records.slice(0, 3);
        return {
            actions: _.compact(_.pluck(actions, 'item')),
            keywords: keywords,
            records: _.compact(_.pluck(records, 'item')),
            showMore: showMore,
            term: term
        };
    },

    /**
     * Triggers `sweetspot:results` with the results of the search.
     *
     * @param {Array} Hopefully a list of results.
     */
    sendResults: function(results) {
        this.layout.trigger('sweetspot:results', results);
    },

    /**
     * Handles the keyup events.
     *
     * @param {event} evt The `keyup` event.
     */
    keyUpHandler: function(evt) {
        if (!this.layout.isVisible()) {
            return;
        }
        this.debouncedSearch(evt);
    },

    /**
     * Calls {@link #applyQuickSearch} with a debounce of 200ms.
     */
    debouncedSearch: _.debounce(function(event) {
        this.applyQuickSearch();
    }, 200),

    /**
     * Makes a request to the search API to find records.
     *
     * On success it calls {@link #addToTemporaryLibrary} to add the records
     * to the temporary library and calls {@link #applyQuickSearch} to re-apply
     * the search.
     *
     * @param {string} term The search term.
     */
    fireSearchRequest: function(term) {
        var self = this;
        this.collection.query = term;
        this.collection.fetch({
            query: term,
            fields: ['name', 'id'],
            module_list: [],
            limit: 4,
            success: function(collection) {
                var now = new Date().getTime();
                var formattedRecords = [];
                _.each(collection.toJSON(), function(record) {
                    if (!record.id) {
                        return; // Elastic Search may return records without id and record names.
                    }
                    var formattedRecord = {
                        id: record.id,
                        name: record.name || app.utils.formatNameModel(record._module, record),
                        module: record._module,
                        label: app.lang.getModuleIconLabel(record._module),
                        route: '#' + app.router.buildRoute(record._module, record.id),
                        timestamp: now,
                        weight: 40
                    };

                    formattedRecords.push(formattedRecord);
                });
                self.addToTemporaryLibrary(formattedRecords);
                self.applyQuickSearch(true);
            }
        });
    }

}) },
"mass-link": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MassLinkView
 * @alias SUGAR.App.view.views.BaseMassLinkView
 * @extends View.Views.Base.MassupdateView
 */
({
	// Mass-link View (base) 

    extendsFrom: 'MassupdateView',
    massUpdateViewName: 'masslink-progress',
    _defaultLinkSettings: {
        mass_link_chunk_size: 20
    },

    initialize: function(options) {
        this._super('initialize', [options]);

        var configSettings = (app.config.massActions && app.config.massActions.massLinkChunkSize) ?
                {mass_link_chunk_size: app.config.massActions.massLinkChunkSize} :
                {};

        this._settings = _.extend(
            {},
            this._defaultLinkSettings,
            configSettings,
            this.meta && this.meta.settings || {}
        );
    },

    /**
     * Overrides parent. Sets mass link related events
     */
    delegateListFireEvents: function() {
        this.layout.on('list:masslink:fire', _.bind(this.beginMassLink, this));
    },

    /**
     * Link multiple records in chunks
     */
    beginMassLink: function(options) {
        var parentModel = this.context.get('recParentModel'),
            link = this.context.get('recLink'),
            massLink = this.getMassUpdateModel(this.module),
            progressView = this.getProgressView();

        massLink.setChunkSize(this._settings.mass_link_chunk_size);

        //Extend existing model with a link function
        massLink = _.extend({}, massLink, {
            maxLinkAllowAttempt: options && options.maxLinkAllowAttempt || this.maxAllowAttempt,
            link: function(options) {
                //Slice a new chunk of models from the mass collection
                this.updateChunk();
                var model = this,
                    apiMethod = 'create',
                    linkCmd = 'link',
                    parentData = {
                        id: parentModel.id
                    },
                    url = app.api.buildURL(parentModel.module, linkCmd, parentData),
                    linkData = {
                        link_name: link,
                        ids: _.pluck(this.chunks, 'id')
                    },
                    callbacks = {
                        success: function(data, response) {
                            model.attempt = 0;
                            model.updateProgress();
                            if (model.length === 0) {
                                model.trigger('massupdate:end');
                                if (_.isFunction(options.success)) {
                                    options.success(model, data, response);
                                }
                            } else {
                                model.trigger('massupdate:always');
                                model.link(options);
                            }
                        },
                        error: function() {
                            model.attempt++;
                            model.trigger('massupdate:fail');
                            if (model.attempt <= this.maxLinkAllowAttempt) {
                                model.link(options);
                            } else {
                                app.alert.show('error_while_mass_link', {
                                    level: 'error',
                                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                                });
                            }
                        }
                    };
                app.api.call(apiMethod, url, linkData, callbacks);
            }
        });

        progressView.initCollection(massLink);
        massLink.link({
            success: _.bind(function(model, data, response) {
                this.layout.trigger('list:masslink:complete', model, data, response);
            }, this)
        });
    }
}) },
"casessummary": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.CasessummaryView
 * @alias SUGAR.App.view.views.BaseCasessummaryView
 * @extends View.View
 */
({
	// Casessummary View (base) 

    events: {
        'shown.bs.tab a[data-toggle="tab"]': 'resize',
    },

    plugins: ['Dashlet', 'Chart'],
    className: 'cases-summary-wrapper',

    tabData: null,
    tabClass: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.tooltipTemplate = app.template.getField('chart', 'singletooltiptemplate', this.module);
        this.locale = SUGAR.charts.getSystemLocale();

        this.chart = sucrose.charts.pieChart()
                .margin({top: 0, right: 0, bottom: 0, left: 0})
                .donut(true)
                .donutLabelsOutside(true)
                .donutRatio(0.447)
                .rotateDegrees(0)
                .arcDegrees(360)
                .maxRadius(110)
                .hole(this.total)
                .showTitle(false)
                .tooltips(true)
                .showLegend(false)
                .direction(app.lang.direction)
                .colorData('data')
                .tooltipContent(_.bind(function(eo, properties) {
                    var point = {};
                    point.key = this.chart.getKey()(eo);
                    point.label = app.lang.get('LBL_CHART_COUNT');
                    point.value = this.chart.getValue()(eo);
                    point.percent = sucrose.utility.numberFormatPercent(point.value, properties.total, this.locality);
                    return this.tooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
                }, this))
                .strings({
                    noData: app.lang.get('LBL_CHART_NO_DATA'),
                    noLabel: app.lang.get('LBL_CHART_NO_LABEL')
                })
                .locality(this.locale);

        this.locality = this.chart.locality();
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        // Set value of label inside donut chart
        this.chart.hole(this.total);
        d3sugar.select(this.el).select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.update);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * Build content with favorite fields for content tabs
     */
    addFavs: function() {
        var self = this;
        //loop over metricsCollection
        _.each(this.tabData, function(tabGroup) {
            if (tabGroup.models && tabGroup.models.length > 0) {
                _.each(tabGroup.models, function(model) {
                    var field = app.view.createField({
                            def: {type: 'favorite'},
                            model: model,
                            meta: {view: 'detail'},
                            viewName: 'detail',
                            view: self
                        });
                    field.setElement(self.$('[data-model-id="' + model.id + '"]'));
                    field.render();
                });
            }
        });
    },

    /* Process data loaded from REST endpoint so that d3 chart can consume
     * and set general chart properties
     */
    evaluateResult: function(data) {
        this.total = data.models.length;

        var countClosedCases = data.where({status: 'Closed'})
                .concat(data.where({status: 'Rejected'}))
                .concat(data.where({status: 'Duplicate'})).length,
            countOpenCases = this.total - countClosedCases;

        this.chartCollection = {
            data: [],
            properties: {
                title: app.lang.get('LBL_CASE_SUMMARY_CHART'),
                value: 3,
                label: this.total
            }
        };
        this.chartCollection.data.push({
            key: app.lang.get('LBL_DASHLET_CASESSUMMARY_CLOSE_CASES'),
            classes: 'sc-fill-green',
            value: countClosedCases
        });
        this.chartCollection.data.push({
            key: app.lang.get('LBL_DASHLET_CASESSUMMARY_OPEN_CASES'),
            classes: 'sc-fill-red',
            value: countOpenCases
        });

        if (!_.isEmpty(data.models)) {
            this.processCases(data);
        }
    },

    /**
     * Build tab related data and set tab class name based on number of tabs
     * @param {data} object The chart related data.
     */
    processCases: function(data) {
        this.tabData = [];

        var status2css = {
                'Rejected': 'label-success',
                'Closed': 'label-success',
                'Duplicate': 'label-success'
            },
            stati = _.uniq(data.pluck('status')),
            statusOptions = app.metadata.getModule('Cases', 'fields').status.options || 'case_status_dom';

        _.each(stati, function(status, index) {
            if (!status2css[status]) {
                this.tabData.push({
                    index: index,
                    status: status,
                    statusLabel: app.lang.getAppListStrings(statusOptions)[status],
                    models: data.where({'status': status}),
                    cssClass: status2css[status] ? status2css[status] : 'label-important'
                });
            }
        }, this);

        this.tabClass = ['one', 'two', 'three', 'four', 'five'][this.tabData.length] || 'four';
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            oppID,
            accountBean,
            relatedCollection;
        if (this.meta.config) {
            return;
        }
        oppID = this.model.get('account_id');
        if (oppID) {
            accountBean = app.data.createBean('Accounts', {id: oppID});
        }
        relatedCollection = app.data.createRelatedCollection(accountBean || this.model, 'cases');
        relatedCollection.fetch({
            relate: true,
            success: function(data) {
                self.evaluateResult(data);
                if (!self.disposed) {
                    // we have to rerender the entire dashlet, not just the chart,
                    // because the HBS file is dependant on processCases completion
                    self.render();
                    self.addFavs();
                }
            },
            error: _.bind(function() {
                this.displayNoData(true);
            }, this),
            complete: options ? options.complete : null,
            limit: -1,
            fields: this.getFieldNames()
        });
    },

    /**
     * Get the list of field names to render the dashlet correctly
     * @return {string[]} The list of fields we need to fetch
     * @override
     */
    getFieldNames: function() {
        // FIXME TY-920: we shouldn't have to override this per-dashlet
        return this.dashletConfig && this.dashletConfig.dashlets[0].fields || [];
    }
}) },
"pmse-case": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Pmse-case View (base) 

    extendsFrom: 'RecordView',

    events: {
        'click .record-edit-link-wrapper': 'handleEdit'
    },

    /**
     * @deprecated Since 7.8. Will be removed in 7.10.
     * @param options
     */
    initialize: function(options) {
        app.logger.warn('View.Views.Base.PmseCaseView is deprecated and will be removed in 7.10');
        this.case = options.context.get('case');
        this.plugins = _.union(this.plugins || [], ['ProcessActions']);
        options.meta = _.extend({}, app.metadata.getView(options.module, 'record'), options.meta);
        options.meta.hashSync = _.isUndefined(options.meta.hashSync) ? true : options.meta.hashSync;
        options.meta.buttons = this.case.buttons;
        this._super('initialize', [options]);
        this.context.set("layout", "record");
        this.buttons = {};
        this.createMode = this.context.get('create') ? true : false;
        this.action = 'detail';
        this.context.on('change:record_label', this.setLabel, this);
        this.context.set('viewed', true);
        this.context.set('dataView', 'record');
        this.model.on('duplicate:before', this.setupDuplicateFields, this);
        this.on('editable:keydown', this.handleKeyDown, this);
        this.on('editable:mousedown', this.handleMouseDown, this);
        this.on('field:error', this.handleFieldError, this);
        this.context.on('button:cancel_button:click', this.cancelClicked, this);
        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before('route', this.beforeRouteDelete, this);
        $(window).on('beforeunload.delete' + this.cid, _.bind(this.warnDeleteOnRefresh, this));

        if (this.createMode) {
            this.model.isNotEmpty = true;
        }

        this.noEditFields = [];
        // properly namespace SHOW_MORE_KEY key
        this.MORE_LESS_KEY = app.user.lastState.key(this.MORE_LESS_KEY, this);
        this.adjustHeaderpane = _.bind(_.debounce(this.adjustHeaderpane, 50), this);
        $(window).on('resize.' + this.cid, this.adjustHeaderpane);

        $(window).on('resize.' + this.cid, _.bind(this.overflowTabs, this));

        // initialize tab view after the component is attached to DOM
        this.on('append', function() {
            this.overflowTabs();
            this.handleActiveTab();
        }, this);

    },

    validationComplete: function(isValid) {
        if (isValid) {
            this.setButtonStates(this.STATE.VIEW);
            this.handleSave();
        }
    },

    delegateButtonEvents: function() {
        this.context.on('button:edit_button:click', this.editClicked, this);

        this.context.on('case:cancel', this.cancelCase, this);
        this.context.on('case:claim', this.caseClaim, this);
        this.context.on('case:approve', this.caseApprove, this);
        this.context.on('case:reject', this.caseReject, this);
        this.context.on('case:route', this.caseRoute, this);

        this.context.on('case:history', this.caseHistory, this);
        this.context.on('case:status', this.caseStatus, this);
        this.context.on('case:add:notes', this.caseAddNotes, this);
        this.context.on('case:change:owner', this.caseChangeOwner, this);
        this.context.on('case:reassign', this.caseReassign, this);
    },

    cancelCase: function () {
        this.redirectCase();
    },

    caseClaim: function () {
        app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
        var frm_action = 'Claim';
        var value = this.model.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        value.cas_id = this.case.flow.cas_id;
        value.cas_index = this.case.flow.cas_index;
        value.taskName = this.case.title.activity;
        var self = this;
        var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_claim','',{},{});
        app.api.call('update', pmseInboxUrl, value,{
            success: function (){
                app.alert.dismiss('upload');
                self.redirectCase(frm_action);
            }
        });
    },

    caseApprove: function () {
        this.model.doValidate(this.getFields(this.module), _.bind(this.validationCompleteApprove, this));
    },

    validationCompleteApprove: function (isValid) {
        if (isValid) {
            app.alert.show('confirm_approve', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PA_PROCESS_APPROVE_QUESTION', 'pmse_Inbox'),
                onConfirm: _.bind(function () {
                    app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
                    var value = this.model.attributes;
                    value.frm_action = 'Approve';
                    value.idFlow = this.case.flowId;
                    value.idInbox = this.case.inboxId;
                    value.cas_id = this.case.flow.cas_id;
                    value.cas_index = this.case.flow.cas_index;
                    value.moduleName = this.case.flow.cas_sugar_module;
                    value.beanId = this.case.flow.cas_sugar_object_id;
                    value.taskName = this.case.title.activity;
                    var self = this;
                    var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_route', '', {}, {});
                    app.api.call('update', pmseInboxUrl, value, {
                        success: function () {
                            app.alert.show('success_approve', {
                                level: 'success',
                                messages: app.lang.get('LBL_PA_PROCESS_APPROVED_SUCCESS', 'pmse_Inbox'),
                                autoClose: true
                            });
                            self.model.setSyncedAttributes(self.model.attributes);
                            self.redirectCase();
                        }
                    });
                }, this),
                onCancel: $.noop
            });
        }
    },

    caseReject: function () {
        this.model.doValidate(this.getFields(this.module), _.bind(this.validationCompleteReject, this));
    },

    validationCompleteReject: function (isValid) {
        if (isValid) {
            app.alert.show('confirm_reject', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PA_PROCESS_REJECT_QUESTION', 'pmse_Inbox'),
                onConfirm: _.bind(function () {
                    app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
                    var value = this.model.attributes;
                    value.frm_action = 'Reject';
                    value.idFlow = this.case.flowId;
                    value.idInbox = this.case.inboxId;
                    value.cas_id = this.case.flow.cas_id;
                    value.cas_index = this.case.flow.cas_index;
                    value.moduleName = this.case.flow.cas_sugar_module;
                    value.beanId = this.case.flow.cas_sugar_object_id;
                    value.taskName = this.case.title.activity;
                    var self = this;
                    var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_route', '', {}, {});
                    app.api.call('update', pmseInboxUrl, value, {
                        success: function () {
                            app.alert.show('success_reject', {
                                level: 'success',
                                messages: app.lang.get('LBL_PA_PROCESS_REJECTED_SUCCESS', 'pmse_Inbox'),
                                autoClose: true
                            });
                            self.model.setSyncedAttributes(self.model.attributes);
                            self.redirectCase();
                        }
                    });
                }, this),
                onCancel: $.noop
            });
        }
    },

    caseRoute: function () {
        this.model.doValidate(this.getFields(this.module), _.bind(this.validationCompleteRoute, this));
    },

    validationCompleteRoute: function (isValid) {
        if (isValid) {
            app.alert.show('confirm_route', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PA_PROCESS_ROUTE_QUESTION', 'pmse_Inbox'),
                onConfirm: _.bind(function () {
                    var value = this.model.attributes;
                    value.frm_action = 'Route';
                    value.idFlow = this.case.flowId;
                    value.idInbox = this.case.inboxId;
                    value.cas_id = this.case.flow.cas_id;
                    value.cas_index = this.case.flow.cas_index;
                    value.moduleName = this.case.flow.cas_sugar_module;
                    value.beanId = this.case.flow.cas_sugar_object_id;
                    value.taskName = this.case.title.activity;
                    if (this.case.taskContinue) {
                        value.taskContinue = true;
                    }
                    var self = this;
                    var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_route', '', {}, {});
                    app.api.call('update', pmseInboxUrl, value, {
                        success: function () {
                            app.alert.show('success_route', {
                                level: 'success',
                                messages: app.lang.get('LBL_PA_PROCESS_ROUTED_SUCCESS', 'pmse_Inbox'),
                                autoClose: true
                            });
                            self.redirectCase();
                        }
                    });
                }, this),
                onCancel: $.noop
            });
        }
    },

    redirectCase: function(isRoute){
        app.alert.dismiss('upload');
        switch(isRoute){
            case 'Claim':
                window.location.reload();
                break;
            default:
                app.router.list("Home");
                break;
        };
    },

    /**
     * Shows a window with current history of the record
     *
     */
    caseHistory: function () {
        this.getHistory(this.case.flow.cas_id);
    },

    /**
     * Shows window with picture of current status of the process
     *
     */
    caseStatus: function() {
        this.showStatus(this.case.flow.cas_id);
    },

    /**
     * Shows window with notes of current process
     *
     */
    caseAddNotes: function () {
        this.showNotes(this.case.flow.cas_id, this.case.flow.cas_index);
    },

    caseChangeOwner: function () {
        var value = this.model.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        showForm(this.case.flow.cas_id, this.case.flow.cas_index, this.case.flowId, this.case.inboxId, this.case.title.activity, value, 'adhoc', this.model);
    },

    caseReassign: function () {
        var value = this.model.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        showForm(this.case.flow.cas_id, this.case.flow.cas_index, this.case.flowId, this.case.inboxId, this.case.title.activity, value, 'reassign', this.model);
    },

    setEditableFields: function() {
        delete this.editableFields;
        this.editableFields = [];
        var previousField, firstField;
        _.each(this.fields, function(field) {
            if(this.checkReadonly(field)){
                field.def.readonly = true;
            }
            if (field.fields && _.isArray(field.fields)) {
                var that = this;
                var basefield = field;
                _.each(field.fields, function (field) {
                    if (that.checkReadonly(field)) {
                        field.action = "disabled";
                        // Some fields use shouldDisable to enable readonly property,
                        // like 'body' in KBContents
                        if (!_.isUndefined(field.shouldDisable)) {
                            field.setDisabled(true);
                            basefield.def.readonly = true;
                        }
                        return;
                    }
                    // If the field is not readonly, verify if it's required
                    if (that.checkRequired(field)) {
                        field.def.required = true;
                    }
                });
            }
            var readonlyField = field.def.readonly ||
                _.indexOf(this.noEditFields, field.def.name) >= 0 ||
                field.parent || (field.name && this.buttons[field.name]);

            if (readonlyField) {
                // exclude read only fields
                return;
            }
            if(this.checkRequired(field)){
                field.def.required = true;
            }
            if (previousField) {
                previousField.nextField = field;
                field.prevField = previousField;
            } else {
                firstField = field;
            }
            previousField = field;
            this.editableFields.push(field);

        }, this);

        if (previousField) {
            previousField.nextField = firstField;
            firstField.prevField = previousField;
        }

    },

    handleSave: function() {
        this.inlineEditMode = false;

        this._saveModel();
        self.$('.record-save-prompt').hide();
        if (!self.disposed) {
            self.render();
        }
    },
    toggleViewButtons: function(isEdit) {
        this.$('.headerpane span[data-type="badge"]').toggleClass('hide', isEdit);
        this.$('.headerpane span[data-type="favorite"]').toggleClass('hide', isEdit);
        this.$('.headerpane span[data-type="follow"]').toggleClass('hide', isEdit);
        this.$('.headerpane .btn-group-previous-next').toggleClass('hide', isEdit);
    },

    _saveModel: function() {
        var options,
            successCallback = _.bind(function() {
                // Loop through the visible subpanels and have them sync. This is to update any related
                // fields to the record that may have been changed on the server on save.
                _.each(this.context.children, function(child) {
                    if (child.get('isSubpanel') && !child.get('hidden')) {
                        if (child.get('collapsed')) {
                            child.resetLoadFlag({recursive: false});
                        } else {
                            child.reloadData({recursive: false});
                        }
                    }
                });
                if (this.createMode) {
                    app.navigate(this.context, this.model);
                } else if (!this.disposed) {
                    this.render();
                }
            }, this);

        //Call editable to turn off key and mouse events before fields are disposed (SP-1873)
        this.turnOffEvents(this.fields);

        options = {
            showAlerts: true,
            success: successCallback,
            error: _.bind(function(model, error) {
                if (error.status === 412 && !error.request.metadataRetry) {
                    this.handleMetadataSyncError(error);
                } else if (error.status === 409) {
                    app.utils.resolve409Conflict(error, this.model, _.bind(function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                successCallback();
                            } else {
                                this._saveModel();
                            }
                        }
                    }, this));
                } else {
                    this.editClicked();
                }
            }, this),
            lastModified: this.model.get('date_modified'),
            viewed: true
        };

        options = _.extend({}, options, this.getCustomSaveOptions(options));

        this.model.save({}, options);
    },


    _buildGridsFromPanelsMetadata: function(panels) {
        var lastTabIndex = 0;
        this.noEditFields = [];

        _.each(panels, function(panel) {
            // it is assumed that a field is an object but it can also be a string
            // while working with the fields, might as well take the opportunity to check the user's ACLs for the field
            _.each(panel.fields, function(field, index) {
                if(this.checkReadonly(field)){
                    field.readonly = true;
                }
                if (_.isString(field)) {
                    panel.fields[index] = field = {name: field};
                }

                var keys = _.keys(field);

                // Make filler fields readonly
                if (keys.length === 1 && keys[0] === 'span')  {
                    field.readonly = true;
                }

                // disable the pencil icon if the user doesn't have ACLs
                if (field.type === 'fieldset') {
                    if (field.readonly || _.every(field.fields, function(field) {
                        return !app.acl.hasAccessToModel('edit', this.model, field.name);
                    }, this)) {
                        this.noEditFields.push(field.name);
                    }
                } else if (field.readonly || !app.acl.hasAccessToModel('edit', this.model, field.name)) {
                    this.noEditFields.push(field.name);
                }
            }, this);

            // Set flag so that show more link can be displayed to show hidden panel.
            if (panel.hide) {
                this.hiddenPanelExists = true;
            }

            // labels: visibility for the label
            if (_.isUndefined(panel.labels)) {
                panel.labels = true;
            }

            if (_.isFunction(this.getGridBuilder)) {
                var options = {
                        fields: panel.fields,
                        columns: panel.columns,
                        labels: panel.labels,
                        labelsOnTop: panel.labelsOnTop,
                        tabIndex: lastTabIndex
                    },
                    gridResults = this.getGridBuilder(options).build();

                panel.grid = gridResults.grid;
                lastTabIndex = gridResults.lastTabIndex;
            }
        }, this);
    },


    getFieldNames: function(module) {

        var fields = app.view.View.prototype.getFieldNames.call(this, module);
        var favorite = _.find(this.meta.panels, function(panel) {
             return _.find(panel.fields, function(field) {
                 return field.type === 'favorite';
             });
        });
        var follow = _.find(this.meta.panels, function(panel) {
             return _.find(panel.fields, function(field) {
                 return field.type === 'follow';
             });
        });
        if (favorite) {
            fields = _.union(fields, ['my_favorite']);
        }
        if (follow) {
            fields = _.union(fields, ['following']);
        }
        return fields;
    },


    checkReadonly: function(field){
        var isReadonly = false;
        _.each(this.case.readonly, function(caseField){
            if(field.name=== caseField){
                isReadonly = true;
            }
        }, this);
        return isReadonly;
    },

    checkRequired: function(field){
        var isRequired = false;
        _.each(this.case.required, function(caseField){
            if(field.name=== caseField){
                isRequired = true;
            }
        }, this);
        return isRequired;
    },

    /**
     * @override
     */
    bindDataChange: function() {
        this.model.on('change', function() {
            if (this.model.isNotEmpty !== true) {
                this.model.isNotEmpty = true;
                if (!this.disposed) {
                    this.render();
                }
            }
        }, this);
    }

}) },
"history-summary-list-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryListBottomView
 * @alias SUGAR.App.view.views.BaseHistorySummaryListBottomView
 * @extends View.Views.Base.ListBottomView
 */
({
	// History-summary-list-bottom View (base) 

    extendsFrom: 'ListBottomView',

    /**
     * Assigns label for "More history..." since History isn't
     * a proper module and doesn't fetch lang strings
     * @override
     */
    setShowMoreLabel: function() {
        this.showMoreLabel = app.lang.get('LBL_MORE_HISTORY');
    }
}) },
"login": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Login form view.
 *
 * @class View.Views.Base.LoginView
 * @alias SUGAR.App.view.views.BaseLoginView
 * @extends View.View
 */
({
	// Login View (base) 

    /**
     * @inheritdoc
     */
    plugins: ['ErrorDecoration'],

    /**
     * @inheritdoc
     */
    fallbackFieldTemplate: 'edit',

    /**
     * @inheritdoc
     */
    events: {
        'click [name=login_button]': 'login',
        'keypress': 'handleKeypress',
        "click [name=external_login_button]": "external_login",
        "click [name=login_form_button]": "login_form"
    },

    /**
     * An object containing the keys of the alerts that may be displayed in this
     * view.
     *
     * @type {Object}
     */
    _alertKeys: {
        adminOnly: 'admin_only',
        invalidGrant: 'invalid_grant_error',
        login: 'login',
        needLogin: 'needs_login_error',
        offsetProblem: 'offset_problem',
        loading: 'loading'
    },

    /**
     * Flag to indicate if the link to reset the password should be displayed.
     *
     * @type {Boolean}
     */
    showPasswordReset: false,

    /**
     * The company logo url.
     *
     * @type {String}
     */
    logoUrl: null,

    /**
     * Is external login in progress?
     *
     * @type {boolean}
     */
    isExternalLoginInProgress: false,

    /**
     * Save login popup handler
     */
    childLoginPopup: null,

    /**
     * Process login on key `Enter`.
     *
     * @param {Event} event The `keypress` event.
     */
    handleKeypress: function(event) {
        if (event.keyCode === 13) {
            this.$('input').trigger('blur');
            this.login();
        }
    },

    /**
     * Get the fields metadata from panels and declare a Bean with the metadata
     * attached.
     *
     * Fields metadata needs to be converted to {@link Data.Bean#declareModel}
     * format.
     *
     *     @example
     *      {
     *        "username": { "name": "username", ... },
     *        "password": { "name": "password", ... },
     *        ...
     *      }
     *
     * @param {Object} meta The view metadata.
     * @private
     */
    _declareModel: function(meta) {
        meta = meta || {};

        var fields = {};
        _.each(_.flatten(_.pluck(meta.panels, 'fields')), function(field) {
            fields[field.name] = field;
        });
        app.data.declareModel('Login', {fields: fields});
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        if (app.progress) {
            app.progress.hide();
        }
        // Declare a Bean so we can process field validation
        this._declareModel(options.meta);

        // Reprepare the context because it was initially prepared without metadata
        options.context.prepare(true);

        this._super('initialize', [options]);

        var config = app.metadata.getConfig();
        if (config && app.config.forgotpasswordON === true) {
            this.showPasswordReset = true;
        }

        /**
         * Set window open handler to save popup handler
         */
        app.api.setExternalLoginUICallback(_.bind(function(url, name, params) {
            this.closeLoginPopup();
            this.childLoginPopup = window.open(url, name, params);
        }, this));

        if ((config &&
            app.config.externalLogin === true && 
            app.config.externalLoginSameWindow === true) || app.config.idmModeEnabled
        ) {
            this.externalLoginForm = true;
            this.externalLoginUrl = app.config.externalLoginUrl;
            app.api.setExternalLoginUICallback(_.bind(function(url) {
                this.externalLoginUrl = app.config.externalLoginUrl = url;
                if (this.isExternalLoginInProgress || app.config.idmModeEnabled) {
                    this.isExternalLoginInProgress = false;
                    app.api.setRefreshingToken(true);
                    window.location.replace(this.externalLoginUrl);
                } else {
                    this.render();
                }
            }, this));
        }

        // Set the page title to 'SugarCRM' while on the login screen
        $(document).attr('title', 'SugarCRM');
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (app.config.idmModeEnabled) {
            app.alert.show(this._alertKeys.loading, {
                level: 'process',
                title: app.lang.get('LBL_LOADING'),
                autoClose: false
            });
            return;
        }
        this.logoUrl = app.metadata.getLogoUrl();
        //It's possible for errors to prevent the postLogin from triggering so contentEl may be hidden.
        app.$contentEl.show();

        this._super('_render');

        this.refreshAdditionalComponents();

        var config = app.metadata.getConfig(),
            level = config.system_status && config.system_status.level;

        if (level === 'maintenance' || level === 'admin_only') {
            app.alert.show(this._alertKeys.adminOnly, {
                level: 'warning',
                title: '',
                messages: [
                    '',
                    app.lang.get(config.system_status.message)
                ]
            });
        }
        app.alert.dismiss(this._alertKeys.offsetProblem);
        return this;
    },

    /**
     * Refresh additional components
     */
    refreshAdditionalComponents: function() {
        _.each(app.additionalComponents, function(component) {
            component.render();
        });
    },

    /**
     * Process login.
     *
     * We have to manually set `username` and `password` to the model because
     * browser autocomplete does not always trigger DOM change events that would
     * propagate changes into the model.
     */
    login: function() {
        //FIXME: Login fields should trigger model change (SC-3106)
        this.model.set({
            password: this.$('input[name=password]').val(),
            username: this.$('input[name=username]').val()
        });

        // Prepare local auth variables if user chooses local auth
        if (app.api.isExternalLogin() &&
            app.config.externalLogin === true &&
            !_.isNull(app.config.externalLoginSameWindow) &&
            app.config.externalLoginSameWindow === false
        ) {
            app.config.externalLogin = false;
            app.config.externalLoginUrl = undefined;
            app.api.setExternalLogin(false);
            this.closeLoginPopup();
        }

        this.model.doValidate(null,
            _.bind(function(isValid) {
                if (isValid) {
                    app.$contentEl.hide();

                    app.alert.show(this._alertKeys.login, {
                        level: 'process',
                        title: app.lang.get('LBL_LOADING'),
                        autoClose: false
                    });

                    var args = {
                        password: this.model.get('password'),
                        username: this.model.get('username')
                    };

                    app.login(args, null, {
                        error: _.bind(function(error) {
                            this.showSugarLoginForm(error);
                        }, this),
                        success: _.bind(function() {
                            app.logger.debug('logged in successfully!');
                            app.alert.dismiss(this._alertKeys.invalidGrant);
                            app.alert.dismiss(this._alertKeys.needLogin);
                            app.alert.dismiss(this._alertKeys.login);
                            //External login URL should be cleaned up if the login form was successfully used instead.
                            app.config.externalLoginUrl = undefined;

                            app.events.on('app:sync:complete', function() {
                                app.events.trigger('data:sync:complete', 'login', null, {
                                    'showAlerts': {'process': true}
                                });
                                app.api.setRefreshingToken(false);
                                app.logger.debug('sync in successfully!');
                                _.defer(_.bind(this.postLogin, this));
                            }, this);
                        }, this),
                        complete: _.bind(function(request) {
                            if (request.xhr.status == 401) {
                                this.showSugarLoginForm();
                            }
                        }, this)
                    });
                }
            }, this)
        );

        app.alert.dismiss('offset_problem');
    },

    /**
     * When SAML enabled app login error callback will be run only when _refreshToken = true and
     * app login complete callback will be run when _refreshToken = false
     * So to avoid form disappearance after second incorrect login we need to run the same code into to two callbacks
     */
    showSugarLoginForm: function(error) {
        if (error !== undefined && error.code == 'license_seats_needed') {
            app.alert.show(this._alertKeys.adminOnly, {
                level: 'error',
                title: '',
                messages: [
                    '',
                    error.message
                ]
            });
            app.logger.debug('Number of seats exceeded license limit.');
        }
        app.alert.dismiss(this._alertKeys.login);
        app.api.setExternalLogin(false);
        app.config.externalLoginUrl = undefined;
        app.$contentEl.show();
        app.logger.debug('login failed!');
    },

    /**
     * close log in popup
     */
    closeLoginPopup: function() {
        if (!_.isNull(this.childLoginPopup)) {
            this.childLoginPopup.close();
            this.childLoginPopup = null;
        }
    },

    /**
     * After login and app:sync:complete, we need to see if there's any post
     * login setup we need to do prior to rendering the rest of the Sugar app.
     */
    postLogin: function() {
        if (!app.user.get('show_wizard') && !app.user.get('is_password_expired')) {

            this.refreshAdditionalComponents();

            if (new Date().getTimezoneOffset() != (app.user.getPreference('tz_offset_sec') / -60)) {
                var link = new Handlebars.SafeString('<a href="#' +
                    app.router.buildRoute('Users', app.user.id, 'edit') + '">' +
                    app.lang.get('LBL_TIMEZONE_DIFFERENT_LINK') + '</a>');

                var message = app.lang.get('TPL_TIMEZONE_DIFFERENT', null, {link: link});

                app.alert.show(this._alertKeys.offsetProblem, {
                    messages: message,
                    closeable: true,
                    level: 'warning'
                });
            }
        }
        app.$contentEl.show();
    },

    /**
     * Process Login
     */
    external_login: function() {
        this.isExternalLoginInProgress = true;
        app.api.setRefreshingToken(false);
        app.api.ping(null, {});
    },
    
    /**
     * Show Login form
     */
    login_form: function() {
        app.config.externalLogin = false;
        app.api.setExternalLogin(false);
        app.controller.loadView({
            module: "Login",
            layout: "login",
            create: true
        });
    }
}) },
"multi-selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The MultiSelectionListView extends SelectionListView and adds the ability to
 * select multiple records in the list and get the selected items as the output.
 * The way to use it is similar to the SelectionListView.
 *
 * It adds the following properties which have to be set in the context:
 *
 * - `maxSelectedRecords` The max number of records the user can select in the
 *    case of multiselect selection list.
 * - `independentMassCollection` {boolean} `true` if the selected records should
 *   be handled independently from the view collection. If `false` selected
 *   records are tied to the view collection, which means they are reset if the
 *   view collection is reset.
 *
 * @class View.Views.Base.MultiSelectionListView
 * @alias SUGAR.App.view.views.BaseMultiSelectionListView
 * @extends View.Views.Base.SelectionListView
 */
({
	// Multi-selection-list View (base) 

    extendsFrom: 'SelectionListView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['MassCollection']);

        /**
         * Maximum number of records a user can select.
         *
         * @property {number}
         */
        this.maxSelectedRecords = options.context.get('maxSelectedRecords');

        /**
         * Boolean to know whether the selected records called `mass collection`
         * should be tied to the view collection or independent.
         *
         * If tied, selected records would have to be in the current view collection.
         * As soon as the view collection is reset, the mass collection would be
         * reset.
         *
         * @property {boolean} `true` for an independent mass collection. `false`
         *   for the mass collection to be tied to the view collection.
         */
        this.independentMassCollection = options.context.get('independentMassCollection') || true;
        // if no metadata defined for `multi-selection-list`, use `selection-list`
        options.meta = _.extend({}, app.metadata.getView(options.module, 'selection-list'), options.meta);
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     * FIXME: SC-4075 will remove this method.
     */
    setSelectionMeta: function(options) {
        options.meta.selection = {
            type: 'multi',
            isSearchAndSelectAction: true,
            disable_select_all_alert: !!this.maxSelectedRecords
        };
    },

    /**
     * Sets up events.
     *
     * @override
     */
    initializeEvents: function() {
        this.context.on('selection:select:fire', this._validateSelection, this);
    },

    /**
     * Closes the drawer passing the selected models attributes to the callback.
     *
     * @protected
     */
    _validateSelection: function() {
        var selectedModels = this.context.get('mass_collection');
        if (selectedModels.length > this.maxSelectedRecords) {
            this._showMaxSelectedRecordsAlert();
            return;
        }
        app.drawer.close(this._getCollectionAttributes(selectedModels));
    },

    /**
     * Displays error message since the number of selected records exceeds the
     * maximum allowed.
     *
     * @private
     */
    _showMaxSelectedRecordsAlert: function() {
        var msg = app.lang.get('TPL_FILTER_MAX_NUMBER_RECORDS', this.module, {
            maxRecords: this.maxSelectedRecords
        });
        app.alert.show('too-many-selected-records', {
            level: 'error',
            messages: msg,
            autoClose: false
        });
    },

    /**
     * Returns an array of attributes given a collection.
     *
     * @param {Data.BeanCollection} collection A collection of records.
     * @return {Object[]} attributes An array containing the attribute object of
     *   each model.
     *
     * @private
     */
    _getCollectionAttributes: function(collection) {
        var attributes = _.map(collection.models, this._getModelAttributes, this);
        return attributes;
    }
}) },
"logout": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.LogoutView
 * @alias SUGAR.App.view.views.BaseLogoutView
 * @extends View.View
 */
({
	// Logout View (base) 

    events: {
        "click [name=login_button]": "login",
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this.logoUrl = app.metadata.getLogoUrl();
        app.view.View.prototype._render.call(this);
        this.refreshAddtionalComponents();
        return this;
    },

    /**
     * Refresh additional components
     */
    refreshAddtionalComponents: function() {
        _.each(app.additionalComponents, function(component) {
            component.render();
        });
    },

    /**
     * @deprecated
     */
    login_form: function() {
        app.logger.warn('`View.Views.Base.LogoutView#login_form` has been deprecated since 7.9.1.0 and' +
            ' will be removed in a future release. Please use `View.Views.Base.LogoutView#login`.');
        this.login();
    },

    /**
     * Process Login
     */
    login: function() {
        app.router.login();
    }
}) },
"filter-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Actions for {@link View.Views.Base.FilterRowsView}.
 *
 * Part of {@link View.Layouts.Base.FilterpanelLayout}.
 *
 * @class View.Views.Base.FilterActionsView
 * @alias SUGAR.App.view.views.BaseFilterActionsView
 * @extends View.View
 */
({
	// Filter-actions View (base) 

    events: {
        'change input': 'filterNameChanged',
        'keyup input': 'filterNameChanged',
        'click [data-action=filter-reset]': 'triggerReset',
        'click [data-action=filter-close]': 'triggerClose',
        'click [data-action=filter-delete]:not(.hide)': 'triggerDelete',
        'click [data-action=filter-save]:not(.disabled)': 'triggerSave'
    },

    className: 'filter-header',

    /**
     * @type {Boolean} `true` if the button is enabled, `false` otherwise.
     */
    saveState: false,

    /**
     * @type {Boolean} Whether or not to display the filter action buttons.
     */
    showActions: true,

    /**
     * @inheritdoc
     */
    initialize: function(opts) {
        this._super('initialize', [opts]);

        this.layout.on('filter:create:open', function(model) {
            this.toggle(model);
            var name = model ? model.get('name') : '';
            this.setFilterName(name);

            //shortcut keys
            app.shortcuts.register({
                id: 'Filter:Close',
                keys: ['esc', 'mod+alt+l'],
                component: this,
                description: 'LBL_SHORTCUT_FILTER_CLOSE',
                callOnFocus: true,
                handler: function() {
                    this.$('[data-action=filter-close]').click();
                }
            });
            app.shortcuts.register({
                id: 'Filter:Save',
                keys: ['mod+s', 'mod+alt+a'],
                component: this,
                description: 'LBL_SHORTCUT_FILTER_SAVE',
                callOnFocus: true,
                handler: function() {
                    this.$('[data-action=filter-save]:not(.disabled)').click();
                }
            });
            app.shortcuts.register({
                id: 'Filter:Delete',
                keys: 'd',
                component: this,
                description: 'LBL_SHORTCUT_FILTER_DELETE',
                handler: function() {
                    this.$('[data-action=filter-delete]:not(.hide)').click();
                }
            });
            app.shortcuts.register({
                id: 'Filter:Reset',
                keys: 'r',
                component: this,
                description: 'LBL_SHORTCUT_FILTER_RESET',
                handler: function() {
                    this.$('[data-action=filter-reset]').click();
                }
            });
        }, this);

        this.listenTo(this.layout, 'filter:toggle:savestate', this.toggleSave);
        this.listenTo(this.layout, 'filter:set:name', this.setFilterName);
        this.listenTo(this.context, 'change:filterOptions', this.render);

        this.before('render', this.setShowActions, this);
    },

    /**
     * This function sets the `showActions` object on the controller.
     * `true` when `show_actions` is set to `true` on the `filterOptions`
     * object on the context (originating from filterpanel metadata),
     * `false` otherwise.
     */
    setShowActions: function() {
        var filterOptions = this.context.get('filterOptions') || {};
        this.showActions = !!filterOptions.show_actions;
    },

    /**
     * Get the filter name.
     *
     * @return {String} The value of the input.
     */
    getFilterName: function() {
        var filterName = this.$('input').val();
        return filterName.trim();
    },

    /**
     * Shows or hides this view.
     *
     * This view will be hidden when the filter is a template that is populated
     * on the fly.
     *
     * @param {Data.Bean} filter The filter being edited.
     */
    toggle: function(filter) {
        this.$el.toggleClass('hide', !!filter.get('is_template'));
    },

    /**
     * Set input value and hide the delete button if we're clearing the name.
     *
     * @param {String} name The filter name.
     */
    setFilterName: function(name) {
        var input = this.$('input').val(name);
        // We have this.context.editingFilter if we're setting the name.
        this.toggleDelete(!_.isUndefined(this.context.get('currentFilterId')));
    },

    /**
     * Fired when the filter name changed.
     *
     * @param {Event} event The `change` event.
     */
    filterNameChanged: _.debounce(function(event) {
        if (this.disposed || !this.context.editingFilter) {
            return;
        }

        var name = this.getFilterName();
        this.context.editingFilter.set('name', name);
        this.layout.trigger('filter:toggle:savestate', true);

        if (this.layout.getComponent('filter-rows')) {
            this.layout.getComponent('filter-rows').saveFilterEditState();
        }
    }, 200),

    /**
     * Toggle delete button.
     *
     * @param {Boolean} enable `true` to enable the button, `false` otherwise.
     */
    toggleDelete: function(enable) {
        this.$('[data-action=filter-delete]').toggleClass('hide', !enable);
    },

    /**
     * Toggle save button.
     *
     * @param {Boolean} enable `true` to enable the button, `false` otherwise.
     */
    toggleSave: function(enable) {
        this.saveState = _.isUndefined(enable) ? !this.saveState : !!enable;
        var isEnabled = this.getFilterName() && this.saveState;
        this.$('[data-action=filter-save]').toggleClass('disabled', !isEnabled);
    },

    /**
     * Handler for canceling form editing.
     *
     * First, it will revert model attributes (back to synced attributes), and
     * remove the current edit state.
     * Second,
     * - if the filter has changed, the collection is refreshed.
     * - if we were creating a new filter, the cached selected filter id is
     * cleared (so that we will get back to the default filter), otherwise we
     * just close the form.
     *
     * @triggers filter:apply to apply the previous filter definition.
     * @triggers filter:select:filter to switch back to the default filter.
     * @triggers filter:create:close to close the filter creation form.
     */
    triggerClose: function() {
        var filter = this.context.editingFilter,
            filterLayout = this.layout.getComponent('filter'),
            id = filter.get('id'),
            changedAttributes = filter.changedAttributes(filter.getSynced());
            filter.revertAttributes();

        filterLayout.clearFilterEditState();

        //Apply the previous filter definition if something has changed meanwhile
        if (changedAttributes && changedAttributes.filter_definition) {
            this.layout.trigger(
                /**
                 * @event
                 * See {@link View.Layouts.Base.FilterPanelLayout#filter:apply}.
                 */
                'filter:apply', null, filter.get('filter_definition'));
        }
        if (!id) {
            filterLayout.clearLastFilter(this.layout.currentModule, filterLayout.layoutType);
            filterLayout.trigger(
                /**
                 * @event
                 * See {@link View.Layouts.Base.FilterLayout#filter:select:filter}.
                 */
                'filter:select:filter', filterLayout.filters.collection.defaultFilterFromMeta);
            return;
        }
        this.layout.trigger(
            /**
             * @event
             * See {@link View.Layouts.Base.FilterLayout#filter:create:close}.
             */
            'filter:create:close');
    },

    /**
     * Call a method on filter-rows to reset filter values.
     */
    triggerReset: function() {
        this.layout.getComponent('filter-rows').resetFilterValues();
    },

    /**
     * Trigger `filter:create:save` to save the created filter.
     */
    triggerSave: function() {
        var filterName = this.getFilterName();
        this.context.trigger('filter:create:save', filterName);
    },

    /**
     * Trigger `filter:create:delete` to delete the created filter.
     */
    triggerDelete: function() {
        this.layout.trigger('filter:create:delete');
    }
}) },
"help-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for managing the help component's header bar.
 *
 * @class View.Views.Base.HelpHeaderView
 * @alias SUGAR.App.view.views.BaseHelpHeaderView
 * @extends View.View
 */
({
	// Help-header View (base) 

    /**
     * @deprecated Since 7.9. Will be removed in 7.11.
     * Please use {@link View.Layouts.Base.HelpLayout.close} instead.
     */
    triggerClose: function() {
        app.logger.warn('The function `View.Layouts.Base.Help-HeaderView.triggerClose`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0.' +
            'Please use `View.Layouts.Base.HelpLayout.close` instead.');
        app.events.trigger('app:help:toggle', false, this);
    }
}) },
"footer-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FooterActionsView
 * @alias SUGAR.App.view.views.BaseFooterActionsView
 * @extends View.View
 */
({
	// Footer-actions View (base) 

    events: {
        'click [data-action=shortcuts]': 'shortcuts',
        'click [data-action=feedback]': 'feedback',
        'click [data-action=help]': 'help'
    },
    tagName: 'span',
    layoutName: '',

    /**
     * Flag to indicate if the footer is currently watching for the help status.
     *
     * @property {boolean}
     */
    watchingForHelp: false,

    /**
     * Array of layout names where the help button should be disabled
     */
    helpBtnDisabledLayouts: [
        'about',
        'first-login-wizard'
    ],

    /**
     * Enable or disable buttons on the footer depending on view.
     * @param {string|Object} layout The type of the layout we are changing to.
     * @param {Object} params Additional parameters.
     */
    handleViewChange: function(layout, params) {
        this.module = params && params.module ? params.module : app.controller.context.get('module');
        // should we disable the help button or not, this only happens when layout is 'bwc'
        this.layoutName = _.isObject(layout) ? layout.name : layout;
        this.toggleHelpButton(this._shouldHelpBeActive(params.drawer));
        this.disableHelpButton(true);
    },

    handleRouteChange: function(route, params) {
        this.routeParams = {'route': route, 'params': params};
    },

    /**
     * Enable the (now non-existent) tour button.
     *
     * @deprecated 7.9 Will be removed in 7.11.
     *   Please use `HelpletView.toggleTourLink` instead.
     */
    enableTourButton: function() {
        app.logger.warn('The function `View.Views.Base.FooterActionsView.enableTourButton`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0. ' +
            'Please use `View.Views.Base.HelpletView.toggleTourLink` instead.');
        this.$('[data-action=tour]').removeClass('disabled');
        this.events['click [data-action=tour]'] = 'showTutorialClick';
        this.undelegateEvents();
        this.delegateEvents();
    },

    /**
     * Disable the (now non-existent) tour button.
     *
     * @deprecated 7.9 Will be removed in 7.11.
     *   Please use `HelpletView.toggleTourLink` instead.
     */
    disableTourButton: function() {
        app.logger.warn('The function `View.Views.Base.FooterActionsView.disableTourButton`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0. ' +
            'Please use `View.Views.Base.HelpletView.toggleTourLink` instead.');
        this.$('[data-action=tour]').addClass('disabled');
        delete this.events['click [data-action=tour]'];
        this.undelegateEvents();
        this.delegateEvents();
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        app.events.on('app:view:change', this.handleViewChange, this);
        var self = this;
        app.utils.doWhen(function() {
            return !_.isUndefined(app.router);
        }, function() {
            self.listenTo(app.router, 'route', self.handleRouteChange);
        });

        app.events.on('app:help', function() {
            this.help();
        }, this);

        app.events.on('app:help:shown', function() {
            this.toggleHelpButton(true);
            this.disableHelpButton(false);
        }, this);

        app.events.on('app:help:hidden', function() {
            this.toggleHelpButton(false);
            this.disableHelpButton(true);
        }, this);

        app.events.on('alert:cancel:clicked', function() {
            // re-check if help should be disabled or not and set accordingly
            this.disableHelpButton(this.shouldHelpBeDisabled());
        }, this);

        // Create a doWhen to update the help button in the footer.
        this._watchForHelpActive();

        app.shortcuts.registerGlobal({
            id: 'Shortcut:Help',
            keys: '?',
            component: this,
            description: 'LBL_SHORTCUT_HELP',
            handler: this.shortcuts
        });

        app.user.lastState.preserve(app.user.lastState.key('toggle-show-tutorial', this));

        this.before('render', function() {
            if (this._feedbackView) {
                this._feedbackView.dispose();
            }

            if (this._helpLayout) {
                this._helpLayout.dispose();
            }
        }, this);
    },

    /**
     * Watch the app state for when the help button needs to be active.
     * @private
     */
    _watchForHelpActive: function() {
        if (this.watchingForHelp) {
            return;
        }
        this.watchingForHelp = true;

        app.utils.doWhen(this.helpActiveCheck, _.bind(function() {
            // If the layout check passes, enable the help button
            this.watchingForHelp = false;
            this.disableHelpButton(false);
        }, this));
    },

    /**
     * Check to see if the help button should be active based on the current layout.
     *
     * @return {boolean} Returns true if the app state should always highlight
     *  the help button.
     */
    helpActiveCheck: function() {
        if (app.drawer && !app.drawer.isActive(this.$el)) {
            return false;
        }

        return true;
    },

    /**
     * Checks any criteria to see if help button should be disabled
     * @return {boolean}
     */
    shouldHelpBeDisabled: function() {
        return (_.indexOf(this.helpBtnDisabledLayouts, this.layoutName) !== -1);
    },

    /**
     * Checks if the help button should be set active.
     *
     * @param {boolean} drawer `true` should be passed when this method is called when
     * a drawer is closing or opening.
     * @return {boolean}
     * @private
     */
    _shouldHelpBeActive: function(drawer) {
        return drawer ? this.helpButton && this.helpButton.hasClass('active') : false;
    },

    _renderHtml: function() {
        this.isAuthenticated = app.api.isAuthenticated();
        this.isShortcutsEnabled = (this.isAuthenticated && app.shortcuts.isEnabled());
        this._super('_renderHtml');
        this.helpButton = this.$('[data-action=help]');
    },

    /**
     * Toggles feedback popup on click (open or close).
     * TODO move this to a feedback field
     *
     * This currently sets and uses the internal `_feedbackIsOpen` flag to
     * create and dispose the {@link FeedbackView}.
     * FIXME this shouldn't work that way and should trigger an event that the
     * additionalComponent (the feedback layout) is listening to and the toggle
     * will simply trigger the event for the layout to show and hide.
     * This will improve performance (no more layout being disposed and created
     * on click).
     *
     * If the app isn't yet in sync (all metadata loaded to create the view)
     * the button doesn't do anything.
     *
     * @param {Event} evt the `click` event.
     */
    feedback: function(evt) {
        if (!app.isSynced) {
            return;
        }

        if (!this._feedbackView || this._feedbackView.disposed) {
            this._feedbackView = app.view.createView({
                module: 'Feedbacks',
                type: 'feedback',
                button: this.$('[data-action="feedback"]')
            });

            this.listenTo(this._feedbackView, 'show hide', function(view, active) {
                this.$('[data-action="feedback"]').toggleClass('active', active);
            });
        }
        this._feedbackView.toggle();
    },

    /**
     * Open the SugarCRM support website in another tab.
     *
     * @deprecated 7.9. Will be removed in 7.11.
     */
    support: function() {
        app.logger.warn('The function `View.Views.Base.FooterActionsView.support`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0.');
        window.open('http://support.sugarcrm.com', '_blank');
    },

    /**
     * Help button click event listener.
     */
    help: function() {
        if (!app.isSynced) {
            return;
        }

        if (this.helpButton.hasClass('disabled')) {
            return;
        }

        // For bwc modules and the About page, handle the help click differently.
        if (this.layoutName === 'bwc' || this.layoutName === 'about') {
            this.bwcHelpClicked();
            return;
        }

        if (!this._helpLayout || this._helpLayout.disposed) {
            this._createHelpLayout();
        }

        this._helpLayout.toggle();
    },

    /**
     * Creates the help layout.
     *
     * @param {jQuery} button The Help button.
     * @private
     */
    _createHelpLayout: function() {
        this._helpLayout = app.view.createLayout({
            module: app.controller.context.get('module'),
            type: 'help',
            button: this.helpButton
        });

        this._helpLayout.initComponents();

        this.listenTo(this._helpLayout, 'show hide', function(view, active) {
            this.helpButton.toggleClass('active', active);
        });
    },

    /**
     * Disable the help button
     *
     * @param {boolean} [disable=true]      Should we disable it or enable it, if not passed will default to true
     */
    disableHelpButton: function(disable) {
        disable = _.isUndefined(disable) ? true : disable;
        if (this.helpButton) {
            this.helpButton.toggleClass('disabled', disable);
        }

        if (disable) {
            this._watchForHelpActive();
        }

        return disable;
    },

    /**
     * Utility Method to toggle the help button on and off.
     *
     * @param {Boolean} active      Set or remove the active state of the button
     * @param {Object} (button)     Button Object (optional), will be found if not passed in
     */
    toggleHelpButton: function(active, button) {
        if (_.isUndefined(button)) {
            button = this.helpButton;
        }

        if (button) {
            button
                .toggleClass('active', active)
                .attr('aria-pressed', active);
        }
    },

    /**
     * Open shortcut help.
     * @param event
     */
    shortcuts: function(event) {
        var activeDrawerLayout = app.drawer.getActive(),
            $shortcutButton = this.$('[data-action=shortcuts]');

        if (!activeDrawerLayout || activeDrawerLayout.type !== 'shortcuts') {
            $shortcutButton.addClass('active');
            app.drawer.open({
                layout: 'shortcuts'
            }, function() {
                $shortcutButton.removeClass('active');
            });
        } else {
            app.drawer.close();
        }
    },

    /**
     * Click event for the (now non-existent) show tour icon.
     *
     * @param {Object} e click event.
     * @deprecated 7.9. Will be removed in 7.11.
     *   Please use `HelpletView.showTour` instead.
     */
    showTutorialClick: function(e) {
        app.logger.warn('The function `View.Views.Base.FooterActionsView.showTutorialClick`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0.');
        if (!app.tutorial.instance) {
            this.showTutorial();
            e.currentTarget.blur();
        }
    },

    /**
     * Show tour overlay.
     *
     * @param {Object} prefs preferences to preserve.
     * @deprecated 7.9. Will be removed in 7.11.
     */
    showTutorial: function(prefs) {
        app.logger.warn('The function `View.Views.Base.FooterActionsView.showTutorial`' +
            ' is deprecated in 7.9.0.0 and will be removed in 7.11.0.0. '  +
            'Please use `View.Views.Base.HelpletView.showTour` instead.');
        app.tutorial.resetPrefs(prefs);
        app.tutorial.show(app.controller.context.get('layout'), {module: app.controller.context.get('module')});
    },

    /**
     * Calls the old Help Docs if in BWC mode
     */
    bwcHelpClicked: function() {
        var serverInfo = app.metadata.getServerInfo(),
            lang = app.lang.getLanguage(),
            module = app.controller.context.get('module'),
            route = this.routeParams.route,
            url = 'http://www.sugarcrm.com/crm/product_doc.php?edition=' + serverInfo.flavor +
                '&version=' + serverInfo.version + '&lang=' + lang + '&module=' + module + '&route=' + route;
        if (route == 'bwc') {
            var action = window.location.hash.match(/#bwc.*action=(\w*)/i);
            if (action && !_.isUndefined(action[1])) {
                url += '&action=' + action[1];
            }
        }
        app.logger.info("help URL: " + url);
        window.open(url);
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PreviewView
 * @alias SUGAR.App.view.views.BasePreviewView
 * @extends View.Views.Base.RecordView
 */
({
	// Preview View (base) 

    extendsFrom: 'RecordView',
    plugins: ['ToggleMoreLess', 'Editable', 'ErrorDecoration', 'SugarLogic'],
    fallbackFieldTemplate: 'detail',
    /**
     * Events related to the preview view:
     *  - preview:open                  indicate we must show the preview panel
     *  - preview:render                indicate we must load the preview with a model/collection
     *  - preview:collection:change     indicate we want to update the preview with the new collection
     *  - preview:close                 indicate we must hide the preview panel
     *  - preview:pagination:fire       (on layout) indicate we must switch to previous/next record
     *  - preview:pagination:update     (on layout) indicate the preview header needs to be refreshed
     *  - list:preview:fire             indicate the user clicked on the preview icon
     *  - list:preview:decorate         indicate we need to update the highlighted row in list view
     */

    // "binary semaphore" for the pagination click event, this is needed for async changes to the preview model
    switching: false,

    hiddenPanelExists: false,

    initialize: function(options) {
        // Use preview view if available, otherwise fallback to record view
        this.dataView = 'preview';
        var previewMeta = app.metadata.getView(options.module, 'preview');
        var recordMeta = app.metadata.getView(options.module, 'record');

        if (_.isEmpty(previewMeta) || _.isEmpty(previewMeta.panels)) {
            this.dataView = 'record';
        }

        this._super('initialize', [options]);
        this.meta = _.extend(this.meta, this._previewifyMetadata(_.extend({}, recordMeta, previewMeta)));
        this.action = 'detail';
        this._delegateEvents();

        /**
         * An array of the {@link #alerts alert} names in this view.
         *
         * @property {Array}
         * @protected
         */
        this._viewAlerts = [];

        /**
         * A collection of alert messages to be used in this view. The alert methods
         * should be invoked by Function.prototype.call(), passing in an instance of
         * a sidecar view. For example:
         *
         *     // ...
         *     this.alerts.showInvalidModel.call(this);
         *     // ...
         *
         * FIXME: SC-3451 will refactor this `alerts` structure.
         * @property {Object}
         */
        this.alerts = {
            showInvalidModel: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'invalid-data';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_RESOLVE_ERRORS'
                });
            },
            showNoAccessError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                // dismiss the default error
                app.alert.dismiss('data:sync:error');
                // display no access error
                app.alert.show('server-error', {
                    level: 'error',
                    messages: 'ERR_HTTP_404_TEXT_LINE1'
                });
                // discard any changes before redirect
                this.handleCancel();
                // redirect to list view
                var route = app.router.buildRoute(this.module);
                app.router.navigate(route, {trigger: true});
            }
        };
    },

    /**
     * @inheritdoc
     *
     * @override Overriding to get preview specific buttons
     */
    toggleButtons: function(enable) {
        if (this.layout.previewEdit) {
            var previewLayout = this.layout.getComponent('preview-header');
            previewLayout.getField('save_button').setDisabled(!enable);
            previewLayout.getField('cancel_button').setDisabled(!enable);
        }
    },

    /**
     * Runs when validation is successful
     * Returns the preview to detail view
     *
     * @override Overriding because we need to trigger 'preview:edit:complete'
     * and not do record view specific actions like: this.inlineEditMode = false;
     */
    handleSave: function() {
        if (this.disposed) {
            return;
        }
        this._saveModel();
        this.layout.trigger('preview:edit:complete');
        this.unsetContextAction();
        this.toggleFields(this.editableFields, false);
        this.toggleLocks(false);
    },

    /**
     * When clicking cancel, return the preview view to detail state
     * and revert the model
     *
     * @override Overriding in order to trigger 'preview:edit:complete'
     */
    cancelClicked: function() {
        this.model.revertAttributes();
        this.toggleFields(this.editableFields, false);
        this.toggleLocks(false);
        this._dismissAllAlerts();
        this.clearValidationErrors(this.editableFields);
        this.unsetContextAction();
        this.layout.trigger('preview:edit:complete');
    },

    /**
     * Add event listeners
     *
     * @private
     */
    _delegateEvents: function() {
        app.events.on('preview:collection:change', this.showPreviousNextBtnGroup, this);
        //FIXME: SC-4915 will delete this listener.
        app.events.on('app:help:shown', function() {
            app.events.trigger('list:preview:decorate', false);
            this.closePreview();
        }, this);

        // TODO: Remove when pagination on activity streams is fixed.
        app.events.on('preview:module:update', this.updatePreviewModule, this);

        if (this.layout) {
            this.layout.on('preview:pagination:fire', this.switchPreview, this);
        }
    },

    /**
     * Setup event listeners for buttons
     *
     * @override Override because we only want to set events if
     * previewEdit is enabled
     */
    delegateButtonEvents: function() {
        if (this.layout && this.layout.previewEdit) {
            this.context.on('button:save_button:click', this.saveClicked, this);
            this.context.on('button:cancel_button:click', this.cancelClicked, this);
            this.layout.on('preview:edit', this.handleEdit, this);
        }
    },

    /**
     * Calls `View.Views.Base.PreviewView#showPreviousNextBtnGroup`.
     *
     * @deprecated since 7.8, will be removed in 7.9.
     * @param {Data.BeanCollection} collection the given collection (unused)
     */
    updateCollection: function(collection) {
        app.logger.warn('View.Views.Base.PreviewView#updateCollection is deprecated since 7.8 and will be' +
            ' removed in 7.9. Since the preview layout now share the view collection, this method is obsolete.');

        this.showPreviousNextBtnGroup();
    },

    // TODO: Remove when pagination on activity streams is fixed.
    updatePreviewModule: function(module) {
        this.previewModule = module;
    },

    filterCollection: function() {
        this.collection.remove(_.filter(this.collection.models, function(model){
            return !app.acl.hasAccessToModel('view', model);
        }, this), { silent: true });
    },

    _renderHtml: function(){
        this.showPreviousNextBtnGroup();
        app.view.View.prototype._renderHtml.call(this);
    },

    /**
     * Show previous and next buttons groups on the view.
     *
     * This gets called everytime the collection gets updated. It also depends
     * if we have a current model or layout.
     *
     * TODO we should check if we have the preview open instead of doing a bunch
     * of if statements.
     */
    showPreviousNextBtnGroup: function () {
        if (!this.model || !this.layout) {
            return;
        }

        var collection = this.collection;
        if (!collection || !collection.size()) {
            this.layout.hideNextPrevious = true;
            // Need to rerender the preview header
            this.layout.trigger('preview:pagination:update');
            return;
        }

        var recordIndex = collection.indexOf(collection.get(this.model.id));
        this.layout.previous = collection.models[recordIndex-1] ? collection.models[recordIndex-1] : undefined;
        this.layout.next = collection.models[recordIndex+1] ? collection.models[recordIndex+1] : undefined;
        this.layout.hideNextPrevious = _.isUndefined(this.layout.previous) && _.isUndefined(this.layout.next);

        // Need to rerender the preview header
        this.layout.trigger('preview:pagination:update');
    },

    /**
     * Renders the preview dialog with the data from the current model and collection.
     *
     * @deprecated Deprecated since 7.8.0. Will be removed in 7.10.0.
     * @param model Model for the object to preview
     * @param collection Collection of related objects to the current model
     * @param {Boolean} fetch Optional Indicates if model needs to be synched with server to populate with latest data
     * @param {Number|String} previewId Optional identifier use to determine event origin. If event origin is not the same
     * but the model id is the same, preview should still render the same model.
     * @private
     */
    _renderPreview: function(model, collection, fetch, previewId) {
        app.logger.warn('`Base.PreviewView#_renderPreview` has been deprecated since 7.8.0 and' +
            'will be removed in 7.10.0.');

        var self = this;

        // If there are drawers there could be multiple previews, make sure we are only rendering preview for active drawer
        if(app.drawer && !app.drawer.isActive(this.$el)){
            return;  //This preview isn't on the active layout
        }

        // Close preview if we are already displaying this model
        if (this.model && model && (this.model.get('id') == model.get('id') && previewId == this.previewId)) {
            // Remove the decoration of the highlighted row
            app.events.trigger('list:preview:decorate', false);
            // Close the preview panel
            app.events.trigger('preview:close');
            return;
        }

        if (app.metadata.getModule(model.module).isBwcEnabled) {
            // if module is in BWC mode, just return
            return;
        }

        if (model) {
            // Use preview view if available, otherwise fallback to record view
            var viewName = 'preview',
                previewMeta = app.metadata.getView(model.module, 'preview'),
                recordMeta = app.metadata.getView(model.module, 'record');
            if (_.isEmpty(previewMeta) || _.isEmpty(previewMeta.panels)) {
                viewName = 'record';
            }
            this.meta = this._previewifyMetadata(_.extend({}, recordMeta, previewMeta));
            this.renderPreview(model, collection);
            fetch && model.fetch({
                showAlerts: true,
                view: viewName
            });
        }

        this.previewId = previewId;
    },
    /**
     * Use the given model to render preview.
     * @param {Bean} model Model to render preview
     */
    switchModel: function(model) {
        this.model && this.model.abortFetchRequest();
        this.stopListening(this.model);
        this.model = model;

        // Close preview when model destroyed by deleting the record
        this.listenTo(this.model, 'destroy', function() {
            // Remove the decoration of the highlighted row
            app.events.trigger('list:preview:decorate', false);
            // Close the preview panel
            app.events.trigger('preview:close');
        });
    },
    /**
     * Renders the preview dialog with the data from the current model and collection
     *
     * @deprecated Deprecated since 7.8.0. Will be removed in 7.10.0.
     * @param model Model for the object to preview
     * @param collection Collection of related objects to the current model
     */
    renderPreview: function(model, newCollection) {
        app.logger.warn('`Base.PreviewView#renderPreview` has been deprecated since 7.8.0 and' +
            'will be removed in 7.10.0.');

        if(newCollection) {
            this.collection.reset(newCollection.models);
        }

        if (model) {
            this.switchModel(model);
            if (this.layout) {
                this.layout.trigger('previewheader:ACLCheck', model);
            }

            // TODO: Remove when pagination on activity streams is fixed.
            if (this.previewModule && this.previewModule === 'Activities') {
                // We need to set previewEdit to false before render but set
                // hideNextPreview and trigger 'preview:pagination:update' after
                this.layout.previewEdit = false;
                this.render();
                this.layout.hideNextPrevious = true;
                this.layout.trigger('preview:pagination:update');
            } else {
                // If we aren't on activitystream, then just render
                this.render();
            }
            // Open the preview panel
            app.events.trigger('preview:open', this);
            // Highlight the row
            app.events.trigger('list:preview:decorate', this.model, this);
        }
    },

    /**
     * Normalizes the metadata, and removes favorite/follow fields that gets
     * shown in Preview dialog.
     *
     * @param meta Layout metadata to be trimmed
     * @return Returns trimmed metadata
     * @private
     */
    _previewifyMetadata: function(meta){
        this.hiddenPanelExists = false; // reset
        _.each(meta.panels, function(panel){
            if(panel.header){
                panel.header = false;
                panel.fields = _.filter(panel.fields, function(field){
                    //Don't show favorite or follow in Preview, it's already on list view row
                    return field.type != 'favorite' && field.type != 'follow';
                });
            }
            //Keep track if a hidden panel exists
            if(!this.hiddenPanelExists && panel.hide){
                this.hiddenPanelExists = true;
            }
        }, this);
        return meta;
    },
    /**
     * Switches preview to left/right model in collection.
     * @param {Object} data
     * @param {String} data.direction Direction that we are switching to, either 'left' or 'right'.
     * @param index Optional current index in list
     * @param id Optional
     * @param module Optional
     */
    switchPreview: function(data, index, id, module) {
        var currID = id || this.model.get('id'),
            currIndex = index || _.indexOf(this.collection.models, this.collection.get(currID));

        if( this.switching || this.collection.models.length < 2) {
            // We're currently switching previews or we don't have enough models, so ignore any pagination click events.
            return;
        }
        this.switching = true;

        if (data.direction === 'left' && (currID === _.first(this.collection.models).get('id')) ||
            data.direction === 'right' && (currID === _.last(this.collection.models).get('id'))) {
            this.switching = false;
            return;
        } else {
            // We can increment/decrement
            data.direction === 'left' ? currIndex -= 1 : currIndex += 1;

            //Reset the preview
            app.events.trigger('preview:render', this.collection.models[currIndex], this.collection, true);
            this.switching = false;
        }
    },

    /**
     * @deprecated Deprecated since 7.8.0. Will be removed in 7.10.0.
     */
    closePreview: function() {
        app.logger.warn('`Base.PreviewView#closePreview` has been deprecated since 7.8.0 and' +
            ' will be removed in 7.10.0.');

        if(_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)){
            this.switching = false;
            delete this.model;
            this.collection.reset();
        }
    },

    bindDataChange: function() {
        if(this.collection) {
            this.collection.on('reset', this.filterCollection, this);
            // when remove active model from collection then close preview
            this.collection.on('remove', function(model) {
                if (model && this.model && (this.model.get('id') == model.get('id'))) {
                    // Remove the decoration of the highlighted row
                    app.events.trigger('list:preview:decorate', false);
                    // Close the preview panel
                    app.events.trigger('preview:close');
                }
            }, this);
        }
        // When the preview layout sets the new model in the context, the view
        // needs to switch the model and render for the fields to listen to the new
        // model changes.
        // Since the layout calls loadData, the fields will rerender when the data comes back
        // from the sever.
        this.context.on('change:model', function(ctx, model) {
            this.switchModel(model);
            this.render();
        }, this);
    },

    /**
     * When clicking on the pencil icon, toggle all editable fields
     * to edit mode
     */
    handleEdit: function() {
        this.setEditableFields();
        this.toggleFields(this.editableFields, true);
        this.toggleButtons(true);
        this.setButtonStates(this.STATE.EDIT);
        this.toggleLocks(true);
    },

    /**
     * Show or hide lock icons for locked fields
     *
     * @param {boolean} activate `true` to show lock icon on locked fields
     */
    toggleLocks: function(activate) {
        // Get the locked fields from the model
        var lockedFields = this.model.get('locked_fields') || [];

        if (!this._hasLockedFields) {
            return;
        }

        if (activate) {
            this.warnLockedFields();
        }
        _.each(this.fields, function(field) {
            if (_.contains(lockedFields, field.name)) {
                this.$('.preview-lock-link-wrapper[data-name=' + field.name + ']').toggleClass('hide', !activate);
            }
        }, this);
    },

    /**
     * Set a list of editable fields
     *
     * @override Overriding to checking field def if preview edit
     * is allowed
     */
    setEditableFields: function() {
        // Get the locked fields from the model
        var lockedFields = this.model.get('locked_fields') || [];

        // Clear any old locked fields that may have been set
        this._hasLockedFields = false;

        // we only want to edit non readonly fields
        this.editableFields = _.reject(this.fields, function(field) {
            // Locked fields should not be editable
            if (_.contains(lockedFields, field.name)) {
                this._hasLockedFields = true;
                return true;
            }
            return field.def.readOnly || field.def.calculated ||
                //Added for SugarLogic fields since they are not supported
                //Fixme: PAT-2241 will remove this
                field.def.previewEdit === false ||
                !app.acl.hasAccessToModel('edit', this.model, field.name);
        }, this);
    },

    /**
     * @inheritdoc
     */
    hasUnsavedChanges: function() {
        if (_.isUndefined(this.model)) {
            return false;
        }
        return this._super('hasUnsavedChanges');
    }
}) },
"convert-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConvertResultsView
 * @alias SUGAR.App.view.views.BaseConvertResultsView
 * @extends View.View
 */
({
	// Convert-results View (base) 

    associatedModels: null,

    events:{
        'click .preview-list-item':'previewRecord'
    },

    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        app.events.on("list:preview:decorate", this.decorateRow, this);
        this.associatedModels = app.data.createMixedBeanCollection();
    },

    bindDataChange: function() {
        this.model.on("change", this.populateResults, this);
    },

    /**
     * Build a collection of associated models and re-render the view.
     * Override this method for module specific functionality.
     */
    populateResults: function() {
        this.associatedModels.reset();
        app.view.View.prototype.render.call(this);
    },

    /**
     * Handle firing of the preview render request for selected row
     *
     * @param e
     */
    previewRecord: function(e) {
        var $el = this.$(e.currentTarget),
            data = $el.data(),
            model = app.data.createBean(data.module, {id:data.id});

        model.fetch({
            //Show alerts for this request
            showAlerts: true,
            success: _.bind(function(model) {
                model.module = data.module;
                app.events.trigger("preview:render", model, this.associatedModels);
            }, this)
        });
    },

    /**
     * Decorate a row in the list that is being shown in Preview
     * @param model Model for row to be decorated.  Pass a falsy value to clear decoration.
     */
    decorateRow: function(model){
        this.$("tr.highlighted").removeClass("highlighted current above below");
        if(model){
            var rowName = model.module+"_"+ model.get("id");
            var curr = this.$("tr[name='"+rowName+"']");
            curr.addClass("current highlighted");
            curr.prev("tr").addClass("highlighted above");
            curr.next("tr").addClass("highlighted below");
        }
    }
}) },
"config-header-buttons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ConfigHeaderButtonsView
 * @alias SUGAR.App.view.views.BaseConfigHeaderButtonsView
 * @extends  View.View
 */
({
	// Config-header-buttons View (base) 

    events: {
        'click a[name="cancel_button"]': 'cancelConfig',
        'click a[name="save_button"]:not(.disabled)': 'saveConfig'
    },

    /**
     * Holds an object with the current module in it for parsing language strings
     *
     * <pre><code>
     *  { module: this.module }
     * </pre></code>
     */
    moduleLangObj: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.moduleLangObj = {
            // get the actual plural module name
            module: app.lang.getModuleName(this.module, { plural: true })
        };

        this.before('save', this._beforeSaveConfig, this);
        this.before('cancel', this._beforeCancelConfig, this);
    },

    /**
     * Click handler for the save button, triggers save event
     */
    saveConfig: function() {
        if (this.triggerBefore('save')) {
            this.getField('save_button').setDisabled(true);
            this._saveConfig();
        }
    },

    /**
     * Calls the context model save and saves the config model in case
     * the default model save needs to be overwritten
     *
     * @protected
     */
    _saveConfig: function() {
        app.api.call(
            'create',
            this._getSaveConfigURL(),
            this._getSaveConfigAttributes(),
            {
                success: _.bind(function() {
                    this.showSavedConfirmation();
                    if (app.drawer.count()) {
                        // close the drawer and return to Opportunities
                        app.drawer.close(this.context, this.context.get('model'));
                        // Config changed... reload metadata
                        app.sync();
                    } else {
                        app.router.navigate(this.module, {trigger: true});
                    }
                }, this),
                error: _.bind(function() {
                    this.getField('save_button').setDisabled(false);
                }, this)
            }
        );
    },

    /**
     * Extensible function that returns the module/config URL for save
     *
     * @return {string} The Config Save URL
     * @protected
     */
    _getSaveConfigURL: function() {
        return app.api.buildURL(this.module, 'config');
    },

    /**
     * Extensible function that returns the model attributes for save
     *
     * @return {Object} The Config Save attributes object
     * @protected
     */
    _getSaveConfigAttributes: function() {
        return this.model.toJSON();
    },

    /**
     * Noop for use if model needs updating before save.
     * Gets called before the model actually saves.
     *
     * Override this method to provide custom logic.
     *
     * @protected
     * @template
     * @return {boolean} The default implementation returns `true` allowing the save.
     */
    _beforeSaveConfig: function() {
        return true;
    },

    /**
     * Show the saved confirmation alert
     *
     * @param {Object|Undefined} [onClose] the function fired upon closing.
     */
    showSavedConfirmation: function(onClose) {
        onClose = onClose || function() {};
        var alert = app.alert.show('module_config_success', {
            level: 'success',
            title: app.lang.get('LBL_CONFIG_TITLE_MODULE_SETTINGS', this.module, this.moduleLangObj) + ':',
            messages: app.lang.get('LBL_CONFIG_MODULE_SETTINGS_SAVED', this.module, this.moduleLangObj),
            autoClose: true,
            autoCloseDelay: 10000,
            onAutoClose: _.bind(function() {
                alert.getCloseSelector().off();
                onClose();
            })
        });
        var $close = alert.getCloseSelector();
        $close.on('click', onClose);
        app.accessibility.run($close, 'click');
    },

    /**
     * Cancels the config setup process and redirects back
     */
    cancelConfig: function() {
        if (this.triggerBefore('cancel')) {
            // If we're inside a drawer
            if (app.drawer.count()) {
                // close the drawer
                app.drawer.close(this.context, this.context.get('model'));
            } else {
                app.router.navigate(this.module, {trigger: true});
            }
        }
    },

    /**
     * Noop for use if model needs updating before cancel
     * Gets called before the model actually cancels
     *
     * Override this method to provide custom logic.
     *
     * @protected
     * @template
     * @return {boolean} The default implementation returns `true` allowing the cancel.
     */
    _beforeCancelConfig: function() {
        return true;
    }
}) },
"find-duplicates-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FindDuplicatesHeaderpaneView
 * @alias SUGAR.App.view.views.BaseFindDuplicatesHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Find-duplicates-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=cancel_button]': 'cancel',
        'click a[name=merge_duplicates_button]:not(".disabled")': 'mergeDuplicatesClicked'
    },

    plugins: ['MergeDuplicates'],

    /**
     * Wait for the mass_collection to be set up so we can add listener
     */
    bindDataChange: function() {
        this._super("bindDataChange");
        this.on('mergeduplicates:complete', this.mergeComplete, this);
        this.context.on('change:mass_collection', this.addMassCollectionListener, this);
    },

    /**
     * @inheritdoc
     * Dispose safe for mass_collection
     */
    unbindData: function() {
        var massCollection = this.context.get('mass_collection');

        if (massCollection) {
            massCollection.off(null, null, this);
        }
        app.view.View.prototype.unbindData.call(this);
    },

    /**
     * Set up `add`, `remove` and `reset` listeners on the `mass_collection` so
     * we can enable/disable the merge button whenever the collection changes.
     */
    addMassCollectionListener: function() {
        var massCollection = this.context.get('mass_collection');
        massCollection.on('add remove reset', this.toggleMergeButton, this);
    },

    /**
     * Enable the merge button when a duplicate has been checked
     * Disable when all are unchecked
     */
    toggleMergeButton: function() {
        var disabled;
        if (this.context.get('mass_collection').length > 0) {
            disabled = false;
        } else {
            disabled = true;
        }
        this.$("[name='merge_duplicates_button']").toggleClass('disabled', disabled);
    },

    /**
     * Cancel and close the drawer
     */
    cancel: function() {
        app.drawer.close();
    },

    /**
     * Close the current drawer window by passing merged primary record
     * once merge process is complete.
     *
     * @param {Backbone.Model} primaryRecord Primary Record.
     */
    mergeComplete: function(primaryRecord) {
        app.drawer.closeImmediately(true, primaryRecord);
    },

    /**
     * Merge records handler.
     */
    mergeDuplicatesClicked: function() {
        this.mergeDuplicates(this.context.get('mass_collection'), this.collection.dupeCheckModel);
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.RecordView
 * @alias SUGAR.App.view.views.BaseRecordView
 * @extends View.View
 */
({
	// Record View (base) 

    /**
     * @inheritdoc
     */
    dataView: 'record',

    inlineEditMode: false,

    createMode: false,

    plugins: [
        'SugarLogic',
        'ErrorDecoration',
        'GridBuilder',
        'Editable',
        'Audit',
        'Pii',
        'FindDuplicates',
        'ToggleMoreLess'
    ],

    enableHeaderButtons: true,

    enableHeaderPane: true,

    events: {
        'click .record-edit-link-wrapper': 'handleEdit',
        'click a[name=cancel_button]': '_deprecatedCancelClicked',
        'click [data-action=scroll]': 'paginateRecord',
        'click .record-panel-header': 'togglePanel',
        'click #recordTab > .tab > a:not(.dropdown-toggle)': 'setActiveTab',
        'click .tab .dropdown-menu a': 'triggerNavTab'
    },

    /**
     * Button fields defined in view definition.
     */
    buttons: null,

    /**
     * Button states.
     */
    STATE: {
        EDIT: 'edit',
        VIEW: 'view'
    },

    // current button states
    currentState: null,

    // fields that should not be editable
    noEditFields: null,

    // width of the layout that contains this view
    _containerWidth: 0,

    /**
     * Flag indicating if the model for this view contains fields that are locked.
     *
     * @private
     * @type {boolean}
     */
    _hasLockedFields: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        /**
         * @inheritdoc
         * @property {Object} meta
         * @property {boolean} meta.hashSync Set to `true` to update URL
         *   consistently with the view state (`edit` or `detail`)
         */
        options.meta = _.extend({}, app.metadata.getView(null, 'record'), options.meta);
        options.meta.hashSync = _.isUndefined(options.meta.hashSync) ? true : options.meta.hashSync;
        app.view.View.prototype.initialize.call(this, options);
        this.buttons = {};
        //Adding the favorite and follow fields.
        this.context.addFields(this._getDataFields());

        // FIXME: SC-5650 will handle removing these deprecation warnings in 7.10+
        _.each(this.meta.panels, function(panel) {
            _.each(panel.fields, function(field) {
                if (field.label_css_class) {
                    app.logger.warn('Warning: metadata property "label_css_class" found on field with name "' +
                        field.name + '" is deprecated and will be removed in a future release.');
                }
                if (field.cell_css_class) {
                    app.logger.warn('Warning: metadata property "cell_css_class" found on field with name "' +
                        field.name + '" is deprecated and will be removed in a future release.');
                }
            }, this);
        }, this);

        /**
         * An array of the {@link #alerts alert} names in this view.
         *
         * @property {Array}
         * @protected
         */
        this._viewAlerts = [];

        /**
         * A collection of alert messages to be used in this view. The alert methods
         * should be invoked by Function.prototype.call(), passing in an instance of
         * a sidecar view. For example:
         *
         *     // ...
         *     this.alerts.showInvalidModel.call(this);
         *     // ...
         *
         * FIXME: SC-3451 will refactor this `alerts` structure.
         * @property {Object}
         */
        this.alerts = {
            showInvalidModel: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                var name = 'invalid-data';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'error',
                    messages: 'ERR_RESOLVE_ERRORS'
                });
            },
            showNoAccessError: function() {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(), passing in as argument' +
                    'an instance of this view.');
                    return;
                }
                // dismiss the default error
                app.alert.dismiss('data:sync:error');
                // display no access error
                app.alert.show('server-error', {
                    level: 'error',
                    messages: 'ERR_HTTP_404_TEXT_LINE1'
                });
                // discard any changes before redirect
                this.handleCancel();
                // redirect to list view
                var route = app.router.buildRoute(this.module);
                app.router.navigate(route, {trigger: true});
            }
        };
        this.createMode = this.context.get('create') ? true : false;

        this.action = this.context.get('action') || 'detail';

        this.context.on('change:record_label', this.setLabel, this);
        this.context.set('viewed', true);
        this.model.on('duplicate:before', this.setupDuplicateFields, this);
        // displays error msg when required field is missing
        this.model.on('error:validation', this.alerts.showInvalidModel, this);
        this.on('editable:keydown', this.handleKeyDown, this);
        this.on('editable:mousedown', this.handleMouseDown, this);
        this.on('field:error', this.handleFieldError, this);
        this.model.on('acl:change', this.handleAclChange, this);
        this.context.on('field:disabled', this._togglePencil, this);

        //event register for preventing actions
        // when user escapes the page without confirming deleting
        app.routing.before('route', this.beforeRouteDelete, this);
        $(window).on('beforeunload.delete' + this.cid, _.bind(this.warnDeleteOnRefresh, this));

        this.delegateButtonEvents();

        if (this.createMode) {
            this.model.isNotEmpty = true;
        }

        this.noEditFields = [];
        // properly namespace SHOW_MORE_KEY key
        this.MORE_LESS_KEY = app.user.lastState.key(this.MORE_LESS_KEY, this);

        this.adjustHeaderpane = _.bind(_.debounce(this.adjustHeaderpane, 50), this);
        $(window).on('resize.' + this.cid, this.adjustHeaderpane);
        $(window).on('resize.' + this.cid, _.bind(this.overflowTabs, this));

        // initialize tab view after the component is attached to DOM
        this.on('append', function() {
            this.overflowTabs();
            this.handleActiveTab();
        }, this);

        this.on('render', this.registerShortcuts, this);
    },

    /**
     * Handler for when the ACLs change on the model. Toggles the `hide` class
     * on the pencil wrapper for each of the fields on this view that had ACL
     * changes.
     * Hide the wrapper if no access to edit.
     *
     * @param {Object} diff The diff object of fields with ACL changes.
     */
    handleAclChange: function(diff) {
        var editAccess = app.acl.hasAccessToModel('edit', this.model);

        this._setNoEditFields();
        this.setEditableFields();

        var noEditFieldsMap = _.object(this.noEditFields, _.values(this.noEditFields));
        var $pencils = this.$('[data-wrapper=edit]');

        _.each($pencils, function(pencilEl) {
            var $pencilEl = $(pencilEl);
            var field = $pencilEl.data('name');

            if (editAccess && !diff[field]) {
                return;
            }

            var isEditable = _.isUndefined(noEditFieldsMap[field]);
            $pencilEl.toggleClass('hide', !isEditable);

            if (this.action === 'edit') {
                $pencilEl.closest('.record-cell').toggleClass('edit', isEditable);
            }
        }, this);
    },

    /**
     * Shows or hides the edit pencil icon for a field.
     *
     * @param {string} fieldName The field name.
     * @param {boolean} hide `true` to hide the pencil, `false` to show it.
     * @private
     */
    _togglePencil: function(fieldName, hide) {
        var isEditable = !_.contains(this.noEditFields, fieldName) && app.acl.hasAccessToModel('edit', this.model);

        if (!hide && !isEditable) {
            return;
        }

        this.$('span.record-edit-link-wrapper[data-name=' + fieldName + ']').toggleClass('hide', hide);
    },

    /**
     * Go through the field controllers and set the locked states accordingly.
     */
    handleLockedFields: function() {
        var self = this;

        // Reset the locked field state
        this._setLockedFieldFlag(false);

        var lockedFields = this.model.get('locked_fields');

        // Loop and check locked field state of each field
        _.each(this.$('.record-lock-link-wrapper[data-name]'), function(el) {
            var $el = $(el);
            var fieldName = $el.data('name');

            // No field name, nothing to do
            if (fieldName == '') {
                return;
            }

            // Get the field object
            var field = this.getField(fieldName);

            // Is the current field locked?
            var isLocked = _.contains(lockedFields, fieldName);

            // Special handling for fieldsets
            if (field.fields) {
                var hasLockedChildField = false;
                isLocked = true;
                _.each(field.fields, function(fieldSetField) {
                    // Some fieldsets have fields that are only for viewing, like the
                    // `copy` field on alternate addresses. Those should be filtered
                    // out of the fields list.
                    if (_.isUndefined(this.model.get(fieldSetField.name))) {
                        return;
                    }

                    var isChildLocked = _.contains(lockedFields, fieldSetField.name);
                    hasLockedChildField = hasLockedChildField || isChildLocked;

                    // A fieldset is locked when all of its actual fields are locked
                    if (!isChildLocked) {
                        isLocked = false;
                    }
                }, this);
            }

            // Set the flag that says if we have locked fields
            this._setLockedFieldFlag(this.hasLockedFields() || isLocked || hasLockedChildField);

            // Handle toggling the class
            $el.toggleClass('hide', !isLocked);
        }, this);

        // Show the locked field warning if there is one
        if (this.hasLockedFields()) {
            this.warnLockedFields();
        }
    },

    /**
     * Returns the flag that tells whether this object has locked fields or not
     * @return {boolean}
     */
    hasLockedFields: function() {
        return this._hasLockedFields;
    },

    /**
     * Sets the locked field flag
     * @param {boolean} setFlag
     * @private
     */
    _setLockedFieldFlag: function(setFlag) {
        this._hasLockedFields = setFlag;
    },

    /**
     * Alert warning if there are locked fields on the model.
     */
    warnLockedFields: function() {
        if (this.getCurrentButtonState() !== this.STATE.EDIT) {
            return;
        }

        if (this.context.get('lockedFieldsWarning') === false) {
            this.context.set('lockedFieldsWarning', true);
        } else {
            app.alert.show('record_locked_field_warning', {
                level: 'warning',
                messages: 'LBL_LOCKED_FIELD_RECORD_VIEW_WARNING',
                autoClose: true,
                autoCloseDelay: 5000
            });
        }
    },

    /**
     * Compare with last fetched data and return true if model contains changes.
     *
     * Check changes for fields that are editable only.
     *
     * {@link app.plugins.view.editable}
     *
     * @return {Boolean} `true` if current model contains unsaved changes, otherwise `false`.
     */
    hasUnsavedChanges: function() {
        var changedAttributes,
            editableFieldNames = [],
            unsavedFields,
            self = this,
            setAsEditable = function(fieldName) {
                if (fieldName && _.indexOf(self.noEditFields, fieldName) === -1) {
                    editableFieldNames.push(fieldName);
                }
            };

        if (this.resavingAfterMetadataSync)
            return false;

        changedAttributes = this.model.changedAttributes(this.model.getSynced());

        if (_.isEmpty(changedAttributes)) {
            return false;
        }

        // get names of all editable fields on the page including fields in a fieldset
        _.each(this.meta.panels, function(panel) {
            _.each(panel.fields, function(field) {
                if (!field.readonly) {
                    setAsEditable(field.name);
                    if (field.fields && _.isArray(field.fields)) {
                        _.each(field.fields, function(field) {
                            setAsEditable(field.name);
                        });
                    }
                }
            });
        });

        // check whether the changed attributes are among the editable fields
        unsavedFields = _.intersection(_.keys(changedAttributes), editableFieldNames);

        return !_.isEmpty(unsavedFields);
    },

    /**
     * Called when current record is being duplicated to allow customization of
     * fields that will be copied into new record.
     *
     * Override to setup the fields on this bean prior to being displayed in
     * Create dialog.
     *
     * @param {Object} prefill Bean that will be used for new record.
     * @template
     */
    setupDuplicateFields: function(prefill) {
    },

    setLabel: function(context, value) {
        this.$('.record-label[data-name="' + value.field + '"]').text(value.label);
    },

    /**
     * Called each time a validation pass is completed on the model.
     *
     * Enables the action button and calls {@link #handleSave} if the model is
     * valid.
     *
     * @param {boolean} isValid TRUE if model is valid.
     */
    validationComplete: function(isValid) {
        this.toggleButtons(true);
        if (isValid) {
            this.handleSave();
        }
    },

    delegateButtonEvents: function() {
        this.context.on('button:edit_button:click', this.editClicked, this);
        this.context.on('button:save_button:click', this.saveClicked, this);
        this.context.on('button:delete_button:click', this.deleteClicked, this);
        this.context.on('button:duplicate_button:click', this.duplicateClicked, this);
        this.context.on('button:cancel_button:click', this.cancelClicked, this);
    },

    _render: function() {
        this._buildGridsFromPanelsMetadata(this.meta.panels);
        if (this.meta && this.meta.panels) {
            this._initTabsAndPanels();
        }

        app.view.View.prototype._render.call(this);

        if (this.context.get('record_label')) {
            this.setLabel(this.context, this.context.get('record_label'));
        }

        // Field labels in headerpane should be hidden on view but displayed in edit and create
        _.each(this.fields, function(field) {
            // some fields like 'favorite' is readonly by default, so we need to remove edit-link-wrapper
            if (field.def.readonly && field.name && -1 == _.indexOf(this.noEditFields, field.name)) {
                this.$('.record-edit-link-wrapper[data-name=' + field.name + ']').remove();
            }
        }, this);

        if (this.action === 'edit') {
            this.setButtonStates(this.STATE.EDIT);
            this.toggleEdit(true);
        } else {
            this.setButtonStates(this.STATE.VIEW);
            if (this.createMode) {
                this.toggleEdit(true);
            }
        }

        // initialize tab view only if the component is attached to DOM,
        // otherwise it's initialized partially and cannot be properly
        // re-initialized after the component is attached to DOM
        if ($.contains(document.documentElement, this.$el[0])) {
            this.handleActiveTab();
            this.overflowTabs();
        }
    },

    _renderField: function(field, $fieldEl) {
        // When we render the view, we need to enforce `action`
        // to be 'detail' if the field is non editable.
        // This is due to how View.Field#_loadTemplate currently works.
        // FIXME SC-6037: Will remove this hack.
        if (!_.contains(this.editableFields, field)) {
            field.action = 'detail';
            // Set viewName to `detail` if it was set to `edit` (because the field is non-editable)
            // but if it is not `edit` (hardcoded e.g. preview template), we want to keep it as it was.
            if (field.options.viewName === 'edit') {
                field.options.viewName = 'detail';
            }
        }

        this._super('_renderField', [field, $fieldEl]);
    },

    /**
     * Handles initiation of Tabs and Panels view upon render
     * @private
     */
    _initTabsAndPanels: function() {
        this.meta.firstPanelIsTab = this.checkFirstPanel();
        this.meta.lastPanelIndex = this.meta.panels.length - 1;

        _.each(this.meta.panels, function(panel, i) {
            if (panel.header) {
                this.meta.firstNonHeaderPanelIndex = (i + 1);
            }
        }, this);

        // Tell the view to use Tabs and Panels view if either there exists a tab or if the number of panels isn't
        // equivalent to the amount expected for Business Card view (2 panels + possibly 1 if header exists)
        var headerExists = 0;
        if (_.first(this.meta.panels).header) {
            headerExists = 1;
        }

        this.meta.useTabsAndPanels = false;

        //Check if there are any newTabs
        for (i = headerExists; i < this.meta.panels.length; i++) {
            if (this.meta.panels[i].newTab) {
                this.meta.useTabsAndPanels = true;
            }
        }

        //Check for panel number
        if (this.meta.panels.length > (2 + headerExists)) {
            this.meta.useTabsAndPanels = true;
        }

        // set states
        _.each(this.meta.panels, function(panel){
            var panelKey = app.user.lastState.key(panel.name+':tabState', this);
            var panelState = app.user.lastState.get(panelKey);
            panel.panelState = panelState || panel.panelDefault;
        }, this);
    },
    /**
     * handles setting active tab
     */
    handleActiveTab: function() {
        var activeTabHref = this.getActiveTab(),
            activeTab = this.$('#recordTab > .tab > a[href="'+activeTabHref+'"]');

        // Always show first tab if we're on the create view
        if (this.createMode) {
            this.$('#recordTab a:first').tab('show');
            return;
        }

        if (activeTabHref && activeTab) {
            activeTab.tab('show');
        } else if (this.meta.useTabsAndPanels && this.checkFirstPanel()) {
            // If tabs and no last state set, show first tab on render
            this.$('#recordTab a:first').tab('show');
        }
    },
    /**
     * Gets the active tab in the user last state
     * @return {String} The active tab id in the user's last state.
     */
    getActiveTab: function() {
        var activeTabHref = app.user.lastState.get(app.user.lastState.key('activeTab', this));

        // Set to first tab by default
        if (!activeTabHref) {
            activeTabHref = this.$('#recordTab > .tab:first-child > a').attr('href') || '';
            app.user.lastState.set(
                app.user.lastState.key('activeTab', this),
                activeTabHref.substring(0, activeTabHref.indexOf(this.cid))
            );
        }
        else {
            activeTabHref += this.cid;
        }
        return activeTabHref;
    },
    /**
     * sets active tab in user last state
     * @param {Event} event
     */
    setActiveTab: function(event) {
        if (this.createMode) {
            return;
        }
        var tabTarget = this.$(event.currentTarget).attr('href'),
            tabKey = app.user.lastState.key('activeTab', this),
            cidIndex = tabTarget.indexOf(this.cid);

        tabTarget = tabTarget.substring(0, cidIndex);
        app.user.lastState.set(tabKey, tabTarget);
    },
    /**
     * saves panel state in user last state
     * @param {String} panelID
     * @param {String} state
     */
    savePanelState: function(panelID, state) {
        if (this.createMode) {
            return;
        }
        var panelKey = app.user.lastState.key(panelID+':tabState', this);
        app.user.lastState.set(panelKey, state);
    },

    /**
     * Parses through an array of panels metadata and sets some of them
     * as no edit fields.
     *
     * @param {Object[]} [panels=this.meta.panels] The panels to parse.
     * @private
     */
    _setNoEditFields: function(panels) {
        var self = this;
        panels = panels || this.meta.panels;

        delete this.noEditFields;
        this.noEditFields = [];

        _.each(panels, function(panel) {
            _.each(panel.fields, function(field, index) {
                var keys = _.keys(field);
                // Make filler fields readonly
                if (keys.length === 1 && keys[0] === 'span') {
                    field.readonly = true;
                }

                /* Disable the pencil icon if the user doesn't have ACLs.
                   Collection fields may have the "fields" property, but it corresponds to fields
                   on models in the related collection, not the model itself. */
                var isCollectionField = this.model.fields[field.name] &&
                    (this.model.fields[field.name].type === 'collection');
                if (field.fields && !isCollectionField) {
                    // Some fieldsets have fields that are only for viewing, like the
                    // `copy` field on alternate addresses. Those should be filtered
                    // out of the fields list.
                    var fieldSetFields = _.filter(field.fields, function(fieldSetField) {
                        return !_.isUndefined(self.model.get(fieldSetField.name));
                    });

                    if (field.readonly || _.every(fieldSetFields, function(f) {
                        return !app.acl.hasAccessToModel('edit', this.model, f.name);
                    }, this)) {
                        this.noEditFields.push(field.name);
                    }
                } else if (field.readonly || !app.acl.hasAccessToModel('edit', this.model, field.name)) {
                    this.noEditFields.push(field.name);
                }
            }, this);
        }, this);
    },

    /**
     * Returns a list of fields that are not buttons of the view.
     *
     * @private
     */
    _getNonButtonFields: function() {
        return _.filter(this.fields, _.bind(function(field) {
            if (field.name) {
                return !this.buttons[field.name];
            }

            return true;
        }, this));
    },

    /**
     * Uses {@link app.plugins.Editable} to
     * set the internal property of {@link #editableFields}.
     */
    setEditableFields: function() {
        this.editableFields = this.getEditableFields(this._getNonButtonFields(), this.noEditFields);
    },

    /**
     * Registers fields as buttons.
     *
     * @deprecated Since 7.10.
     */
    initButtons: function() {
        app.logger.warn('`BaseRecordView#initButtons` is deprecated since 7.10 and will be ' +
            'removed in a future release.');
        if (this.options.meta && this.options.meta.buttons) {
            _.each(this.options.meta.buttons, function(button) {
                this.registerFieldAsButton(button.name);
            }, this);
        }
    },

    /**
     * Registers fields as buttons.
     *
     * @protected
     */
    _initButtons: function() {
        buttons = this.meta.buttons;
        _.each(buttons, function(button) {
            this.registerFieldAsButton(button.name);
        }, this);
    },

    showPreviousNextBtnGroup: function() {
        var listCollection = this.context.get('listCollection') || new app.data.createBeanCollection(this.module);
        var recordIndex = listCollection.indexOf(listCollection.get(this.model.id));
        if (listCollection && listCollection.models && listCollection.models.length <= 1) {
            this.showPrevNextBtnGroup = false;
        } else {
            this.showPrevNextBtnGroup = true;
        }
        if (this.collection && listCollection.length !== 0) {
            this.showPrevious = listCollection.hasPreviousModel(this.model);
            this.showNext = listCollection.hasNextModel(this.model);
        }
    },

    registerFieldAsButton: function(buttonName) {
        var button = this.getField(buttonName);
        if (button) {
            this.buttons[buttonName] = button;
        }
    },

    _renderHtml: function() {
        this.showPreviousNextBtnGroup();
        app.view.View.prototype._renderHtml.call(this);
        this._initButtons();
        this.setEditableFields();
        this.adjustHeaderpane();
    },

    bindDataChange: function() {
        // Handle locked field changes
        this.model.on('change:locked_fields', this.handleLockedFields, this);
        this.model.on('change', function() {
            if (this.inlineEditMode) {
                this.setButtonStates(this.STATE.EDIT);
            }
        }, this);
    },

    /**
     * Enables or disables the action buttons that are currently shown on the
     * page. Toggles the `.disabled` class by default.
     *
     * @param {boolean} [enable=false] Whether to enable or disable the action
     *   buttons. Defaults to `false`.
     */
    toggleButtons: function(enable) {
        var state = !_.isUndefined(enable) ? !enable : false;

        _.each(this.buttons, function(button) {
            var showOn = button.def.showOn;
            if (_.isUndefined(showOn) || this.currentState === showOn) {
                button.setDisabled(state);
            }
        }, this);
    },

    duplicateClicked: function() {
        var self = this,
            prefill = app.data.createBean(this.model.module);

        prefill.copy(this.model);
        this._copyNestedCollections(this.model, prefill);
        self.model.trigger('duplicate:before', prefill);
        prefill.unset('id');
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                model: prefill,
                copiedFromModelId: this.model.get('id')
            }
        }, function(context, newModel) {
            if (newModel && newModel.id) {
                app.router.navigate(self.model.module + '/' + newModel.id, {trigger: true});
            }
        });

        prefill.trigger('duplicate:field', self.model);
    },

    /**
     * Clones the attributes that are collections by way of the
     * {@link VirtualCollection} plugin.
     *
     * This guarantees that all related models in nested collection are copied
     * instead of only the ones that have already been fetched.
     *
     * All models of the collection on the source model are fetched
     * asynchronously and then added to the same collection on the target model
     * once there are no more models to retrieve. Note that this leaves open
     * the possibility for a race condition where the user clicks the Save
     * button on the Create View before all models have been received.
     *
     * @param {Data.Bean} source
     * @param {Data.Bean} target
     * @private
     */
    _copyNestedCollections: function(source, target) {
        var collections, view;

        // only model's that utilize the VirtualCollection plugin support this
        // functionality
        if (!_.isFunction(source.getCollectionFieldNames)) {
            return;
        }

        // avoid using the ambiguous `this` since there are references to many
        // objects in this method: view, field, model, collection, source,
        // target, etc.
        view = this;

        /**
         * Removes the `_action` attribute from a model when cloning it.
         *
         * @param {Data.Bean} model
         * @return {Data.Bean}
         */
        function cloneModel(model) {
            var attributes = _.chain(model.attributes).clone().omit('_action').value();
            return app.data.createBean(model.module, attributes);
        }

        /**
         * Copies all of the models from a collection to the same collection on
         * the target model.
         *
         * @param collection
         */
        function copyCollection(collection) {
            var field, relatedFields, options;

            /**
             * Adds all of the records from the source collection to the same
             * collection on the target model.
             *
             * @param {VirtualCollection} sourceCollection
             * @param {Object} [options]
             */
            function done(sourceCollection, options) {
                var targetCollection = target.get(collection.fieldName);

                if (!targetCollection) {
                    return;
                }

                targetCollection.add(sourceCollection.map(cloneModel));
            }

            field = view.getField(collection.fieldName, source);
            relatedFields = [];

            if (field.def.fields) {
                relatedFields = _.map(field.def.fields, function(def) {
                    return _.isObject(def) ? def.name : def;
                });
            }

            options = {success: done};

            // request the related fields from the field definition if possible
            if (relatedFields.length > 0) {
                options.fields = relatedFields;
            }

            collection.fetchAll(options);
        }

        // get all attributes from the source model that are collections
        collections = _.intersection(source.getCollectionFieldNames(), _.keys(source.attributes));

        _.each(collections, function(name) {
            copyCollection(source.get(name));
        });
    },

    editClicked: function() {
        this.setButtonStates(this.STATE.EDIT);
        this.action = 'edit';
        this.toggleEdit(true);
        this.setRoute('edit');
    },

    saveClicked: function() {
        // Disable the action buttons.
        this.toggleButtons(false);
        var allFields = this.getFields(this.module, this.model);
        var fieldsToValidate = {};
        var erasedFields = this.model.get('_erased_fields');
        for (var fieldKey in allFields) {
            if (app.acl.hasAccessToModel('edit', this.model, fieldKey) &&
                (!_.contains(erasedFields, fieldKey) || this.model.get(fieldKey) || allFields[fieldKey].id_name)) {
                _.extend(fieldsToValidate, _.pick(allFields, fieldKey));
            }
        }
        this.model.doValidate(fieldsToValidate, _.bind(this.validationComplete, this));
    },

    /**
     * Handles when the cancel_button view event is triggered.
     *
     * FIXME: This method will be removed as part of BR-3945
     *
     * @private
     *
     * @deprecated Since 7.7. Will be removed in 7.9.
     *   Use the `MetadataEventDriven` plugin events from the
     *   `record.php` button metadata instead.
     */
    _deprecatedCancelClicked: function() {
        var cancelBtn = this.getField('cancel_button');
        if (!cancelBtn || !cancelBtn.def || !cancelBtn.def.events) {
            app.logger.warn(this.module + ': Invoking the cancel_button from `this.events` has been deprecated' +
                ' since 7.7. This handler will be removed in 7.9. Please use the `MetadataEventDriven` plugin' +
                ' events from the \'record.php\' button metadata instead.');
            this.cancelClicked.apply(this, arguments);
        }
    },

    cancelClicked: function() {
        this.setButtonStates(this.STATE.VIEW);
        this.action = 'detail';
        this.handleCancel();
        this.clearValidationErrors(this.editableFields);
        this.setRoute();
        this.unsetContextAction();
    },

    deleteClicked: function(model) {
        this.warnDelete(model);
    },

    /**
     * Render fields into either edit or view mode.
     *
     * @param {Boolean} isEdit `true` to set the field in edit mode, `false`
     *   otherwise.
     */
    toggleEdit: function(isEdit) {
        var self = this;
        this.$('.record-lock-link').toggleClass('record-lock-link-on', isEdit);
        if (this.hasLockedFields()) {
            this.warnLockedFields();
        }
        this.toggleFields(this.editableFields, isEdit, function() {
            self.toggleViewButtons(isEdit);
            self.adjustHeaderpaneFields();
        });
    },

    /**
     * Handler for intent to edit. This handler is called both as a callback
     * from click events, and also triggered as part of tab focus event.
     *
     * @param {Event} e Event object (should be click event).
     * @param {jQuery} cell A jQuery node cell of the target node to edit.
     */
    handleEdit: function(e, cell) {
        var target,
            cellData,
            field;

        if (e) { // If result of click event, extract target and cell.
            target = this.$(e.target);
            cell = target.parents('.record-cell');
        }

        cellData = cell.data();
        field = this.getField(cellData.name);

        // Set Editing mode to on.
        this.inlineEditMode = true;

        this.setButtonStates(this.STATE.EDIT);

        this.toggleField(field);

        if (cell.closest('.headerpane').length > 0) {
            this.toggleViewButtons(true);
            this.adjustHeaderpaneFields();
        }
    },

    /**
     * Hide view specific button during edit.
     *
     * @param {Boolean} isEdit `true` to hide some specific buttons, `false`
     *   otherwise.
     *
     * FIXME this should be done in a more generic way (field or metadata
     * property).
     */
    toggleViewButtons: function(isEdit) {
        this.$('.headerpane .btn-group-previous-next').toggleClass('hide', isEdit);
    },

    handleSave: function() {
        if (this.disposed) {
            return;
        }
        this._saveModel();
        this.$('.record-save-prompt').hide();

        if (!this.disposed) {
            this.setButtonStates(this.STATE.VIEW);
            this.action = 'detail';
            this.setRoute();
            this.unsetContextAction();
            this.toggleEdit(false);
            this.inlineEditMode = false;
        }
    },

    /**
     * Checks if the given field, represents a temporary file type.
     *
     * @param {string} key A field name.
     * @return {boolean} True if the field is of a temporary file type.
     */
    isTemporaryFileType: function(key) {
        return this.model.fields[key] && this.model.fields[key].type === 'file_temp';
    },

    /**
     * Clears a model of any temporary file type field values in order to
     * avoid sending the same value again with another, successive update.
     */
    resetTemporaryFileFields: function() {
        _.each(Object.keys(this.model.attributes), function(key) {
            if (this.isTemporaryFileType(key)) {
                delete this.model.attributes[key];
            }
        }, this);
    },

    _saveModel: function() {
        var options,
            successCallback = _.bind(function() {
                this.resetTemporaryFileFields();
                // Loop through the visible subpanels and have them sync. This is to update any related
                // fields to the record that may have been changed on the server on save.
                _.each(this.context.children, function(child) {
                    if (child.get('isSubpanel') && !child.get('hidden')) {
                        if (child.get('collapsed')) {
                            child.resetLoadFlag({recursive: false});
                        } else {
                            child.reloadData({recursive: false});
                        }
                    }
                });
                if (this.createMode) {
                    app.navigate(this.context, this.model);
                } else if (!this.disposed && !app.acl.hasAccessToModel('edit', this.model)) {
                    //re-render the view if the user does not have edit access after save.
                    this.render();
                }
            }, this);

        //Call editable to turn off key and mouse events before fields are disposed (SP-1873)
        this.turnOffEvents(this.fields);

        options = {
            showAlerts: true,
            success: successCallback,
            error: _.bind(function(model, error) {
                if (error.status === 412 && !error.request.metadataRetry) {
                    this.handleMetadataSyncError(error);
                } else if (error.status === 409) {
                    app.utils.resolve409Conflict(error, this.model, _.bind(function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                successCallback();
                            } else {
                                this._saveModel();
                            }
                        }
                    }, this));
                } else if (error.status === 403 || error.status === 404) {
                    this.alerts.showNoAccessError.call(this);
                } else {
                    this.editClicked();
                }
            }, this),
            lastModified: this.model.get('date_modified'),
            viewed: true
        };

        // ensure view and field are sent as params so collection-type fields come back in the response to PUT requests
        // (they're not sent unless specifically requested)
        options.params = options.params || {};
        if (this.context.has('dataView') && _.isString(this.context.get('dataView'))) {
            options.params.view = this.context.get('dataView');
        }

        if (this.context.has('fields')) {
            options.params.fields = this.context.get('fields').join(',');
        }

        options = _.extend({}, options, this.getCustomSaveOptions(options));

        this.model.save({}, options);
    },

    handleMetadataSyncError: function(error) {
        var self = this;
        //On a metadata sync error, retry the save after the app is synced
        self.resavingAfterMetadataSync = true;
        app.once('app:sync:complete', function() {
            error.request.metadataRetry = true;
            self.model.once('sync', function() {
                self.resavingAfterMetadataSync = false;
                //self.model.changed = {};
                app.router.refresh();
            });
            //add a new success callback to refresh the page after the save completes
            error.request.execute(null, app.api.getMetadataHash());
        });
    },

    getCustomSaveOptions: function(options) {
        return {};
    },

    handleCancel: function() {
        this.inlineEditMode = false;
        this.model.revertAttributes();
        this.toggleEdit(false);
        this._dismissAllAlerts();
    },

    /**
     * Pre-event handler before current router is changed.
     *
     * @return {Boolean} `true` to continue routing, `false` otherwise.
     */
    beforeRouteDelete: function() {
        if (this._modelToDelete) {
            this.warnDelete(this._modelToDelete);
            return false;
        }
        return true;
    },

    /**
     * Formats the messages to display in the alerts when deleting a record.
     *
     * @return {Object} The list of messages.
     * @return {string} return.confirmation Confirmation message.
     * @return {string} return.success Success message.
     */
    getDeleteMessages: function() {
        var messages = {};
        var model = this.model;
        var name = Handlebars.Utils.escapeExpression(this._getNameForMessage(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' "' + name + '"';

        messages.confirmation = app.utils.formatString(
            app.lang.get('NTC_DELETE_CONFIRMATION_FORMATTED', this.module),
            [context]
        );
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    },

    /**
     * Retrieves the name of a record
     *
     * @param {Data.Bean} model The model concerned.
     * @return {string} name of the record.
     */
    _getNameForMessage: function(model) {
        return app.utils.getRecordName(model);
    },

    /**
     * Popup dialog message to confirm delete action
     */
    warnDelete: function(model) {
        var self = this;
        this._modelToDelete = model;

        self._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (self._targetUrl !== self._currentUrl) {
            app.router.navigate(self._currentUrl, {trigger: false, replace: true});
        }

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: self.getDeleteMessages().confirmation,
            onConfirm: _.bind(self.deleteModel, self),
            onCancel: function() {
                self._modelToDelete = false;
            }
        });
    },

    /**
     * Popup browser dialog message to confirm delete action
     *
     * @return {String} The message to be displayed in the browser dialog.
     */
    warnDeleteOnRefresh: function() {
        if (this._modelToDelete) {
            return this.getDeleteMessages().confirmation;
        }
    },

    /**
     * Delete the model once the user confirms the action
     */
    deleteModel: function() {
        var self = this;

        self.model.destroy({
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: self.getDeleteMessages().success
                }
            },
            success: function() {
                var redirect = self._targetUrl !== self._currentUrl;

                self.context.trigger('record:deleted', self._modelToDelete);

                self._modelToDelete = false;

                if (redirect) {
                    self.unbindBeforeRouteDelete();
                    //Replace the url hash back to the current staying page
                    app.router.navigate(self._targetUrl, {trigger: true});
                    return;
                }

                app.router.navigate(self.module, {trigger: true});
            }
        });

    },

    /**
     * Key handlers for inline edit mode.
     *
     * Jump into the next or prev target field if `tab` key is pressed.
     * Calls {@link app.plugins.Editable#nextField} to go to next/prev field.
     *
     * @param {Event} e Event object.
     * @param {View.Field} field Current focused field (field in inline-edit mode).
     */
    handleKeyDown: function(e, field) {
        var whichField = e.shiftKey ? 'prevField' : 'nextField';

        if (e.which === 9) { // If tab
            e.preventDefault();
            this.nextField(field, whichField);
            if (field.$el.closest('.headerpane').length > 0) {
                this.toggleViewButtons(false);
                this.adjustHeaderpaneFields();
            }
            if (field[whichField] && field[whichField].$el.closest('.headerpane').length > 0) {
                this.toggleViewButtons(true);
                this.adjustHeaderpaneFields();
            }
        }
    },

    /**
     * Adjust headerpane fields when they change to view mode
     */
    handleMouseDown: function() {
        this.toggleViewButtons(false);
        this.adjustHeaderpaneFields();
    },

    /**
     * Handles a field validation error for record views.
     * @param field
     * @param {Boolean} hasError True if a field has an error, false if the field is clearing it's error state
     */
    handleFieldError: function(field, hasError) {
        if(!hasError) {
            return;
        }

        var tabLink,
            fieldTab   = field.$el.closest('.tab-pane'),
            fieldPanel = field.$el.closest('.record-panel-content');

        if (field.view.meta && field.view.meta.useTabsAndPanels) {
            // If field's panel is a tab, switch to the tab that contains the field with the error
            if (fieldTab.length > 0) {
                tabLink = this.$('[href="#' + fieldTab.attr('id') + '"][data-toggle="tab"]');
                tabLink.tab('show');
                // Put a ! next to the tab if one doesn't already exist
                if (tabLink.find('.fa-exclamation-circle').length === 0) {
                    tabLink.append(' <i class="fa fa-exclamation-circle tab-warning"></i>');
                }
            }

            // If field's panel is a panel that is closed, open it and change arrow
            if (fieldPanel && fieldPanel.is(':hidden')) {
                fieldPanel.toggle();
                var fieldPanelArrow = fieldPanel.prev().find('i');
                fieldPanelArrow.toggleClass('fa-chevron-up fa-chevron-down');
            }
        } else if (field.$el.is(':hidden')) {
            this.$('.more[data-moreless]').trigger('click');
            app.user.lastState.set(this.SHOW_MORE_KEY, this.$('.less[data-moreless]'));
        }
        else if (field.$el.closest('.panel_hidden.hide').length > 0) {
            this.toggleMoreLess(this.MORE_LESS_STATUS.MORE, true);
        }
    },

    /**
     * Show/hide buttons depending on the state defined for each buttons in the
     * metadata.
     *
     * @param {String} state The {@link #STATE} of the current view.
     */
    setButtonStates: function(state) {
        this.currentState = state;

        _.each(this.buttons, function(field) {
            var showOn = field.def.showOn;
            if (_.isUndefined(showOn) || (showOn === state)) {
                field.show();
            } else {
                field.hide();
            }
        });

        this.toggleButtons(true);
    },

    /**
     * Get the current button state.
     * @return {string} The current button state
     */
    getCurrentButtonState: function() {
        return this.currentState;
    },

    /**
     * Set the title in the header pane.
     *
     * @param {String} title The new title to set on the headerpane.
     *
     * FIXME this should be done with the header pane view + re-render it.
     */
    setTitle: function(title) {
        var $title = this.$('.headerpane .module-title');
        if ($title.length > 0) {
            $title.text(title);
        } else {
            this.$('.headerpane h1').prepend('<div class="record-cell"><span class="module-title">' + title + '</span></div>');
        }
    },

    /**
     * Detach the event handlers for warning delete
     */
    unbindBeforeRouteDelete: function() {
        app.routing.offBefore('route', this.beforeRouteDelete, this);
        $(window).off('beforeunload.delete' + this.cid);
    },

    _dispose: function() {
        this.unbindBeforeRouteDelete();
        _.each(this.editableFields, function(field) {
            field.nextField = null;
            field.prevField = null;
        });
        this.buttons = null;
        this.editableFields = null;
        this.off('editable:keydown', this.handleKeyDown, this);
        $(window).off('resize.' + this.cid);
        app.view.View.prototype._dispose.call(this);
    },

    _buildGridsFromPanelsMetadata: function(panels) {
        var lastTabIndex = 0;
        this.noEditFields = [];

        _.each(panels, function(panel) {
            // it is assumed that a field is an object but it can also be a string
            // while working with the fields, might as well take the opportunity to check the user's ACLs for the field
            _.each(panel.fields, function(field, index) {
                if (_.isString(field)) {
                    panel.fields[index] = field = {name: field};
                }

                var keys = _.keys(field);

                // Make filler fields readonly
                if (keys.length === 1 && keys[0] === 'span') {
                    field.readonly = true;
                }

                // disable the pencil icon if the user doesn't have ACLs
                if (field.fields && _.isArray(field.fields)) {
                    if (field.readonly || _.every(field.fields, function(field) {
                        return !app.acl.hasAccessToModel('edit', this.model, field.name);
                    }, this)) {
                        this.noEditFields.push(field.name);
                    }
                } else if (field.readonly || !app.acl.hasAccessToModel('edit', this.model, field.name)) {
                    this.noEditFields.push(field.name);
                }
            }, this);

            // Set flag so that show more link can be displayed to show hidden panel.
            if (panel.hide) {
                this.hiddenPanelExists = true;
            }

            // labels: visibility for the label
            if (_.isUndefined(panel.labels)) {
                panel.labels = true;
            }

            if (_.isFunction(this.getGridBuilder)) {
                var options = {
                        fields: panel.fields,
                        columns: panel.columns,
                        labels: panel.labels,
                        labelsOnTop: panel.labelsOnTop,
                        tabIndex: lastTabIndex
                    },
                    gridResults = this.getGridBuilder(options).build();

                panel.grid = gridResults.grid;
                lastTabIndex = gridResults.lastTabIndex;
            }
        }, this);
    },

    /**
     * Handles click event on next/previous button of record.
     * @param {Event} evt
     */
    paginateRecord: function(evt) {
        var el = $(evt.currentTarget),
            data = el.data();
        if (data.id) {
            var list = this.context.get('listCollection'),
                model = list.get(data.id);
            this._doPaginate(model, data.actionType);
        }
    },
    /**
     * paginates record view depeding on direction and model
     * @param {Object} model
     * @param {String} actionType
     * @private
     */
    _doPaginate: function(model, actionType) {
        var list = this.context.get('listCollection');
        switch (actionType) {
            case 'next':
                list.getNext(model, this.navigateModel);
                break;
            case 'prev':
                list.getPrev(model, this.navigateModel);
                break;
            default:
                this._disablePagination(el);
        }
    },
    /**
     * Callback for navigate to new model.
     *
     * @param {Data.Bean} model model New model to navigate.
     * @param {String} actionType actionType Side of navigation (prev/next).
     */
    navigateModel: function(model, actionType) {
        if (model && model.id) {
            if (app.acl.hasAccessToModel('view', model)) {
                app.router.navigate(app.router.buildRoute(this.module, model.id), {trigger: true});
            } else {
                this._doPaginate(model, actionType);
            }
        } else {
            var el = this.$el.find('[data-action=scroll][data-action-type=' + actionType + ']');
            this._disablePagination(el);
        }
    },

    /**
     * Updates url without triggering the router.
     *
     * @param {string} action Action to pass when building the route
     *   with {@link Core.Router#buildRoute}.
     */
    setRoute: function(action) {
        if (!this.meta.hashSync) {
            return;
        }
        app.router.navigate(app.router.buildRoute(this.module, this.model.id, action), {trigger: false});
    },

    /**
     * Unsets the `action` attribute from the current context.
     *
     * Once 'action' is unset, the action is 'detail' and the view will render
     * next in detail mode.
     */
    unsetContextAction: function() {
            this.context.unset('action');
    },

    /**
     * Disabling pagination if we can't paginate.
     * @param {Object} el Element to disable pagination on.
     */
    _disablePagination: function(el) {
        app.logger.error('Wrong data for record pagination. Pagination is disabled.');
        el.addClass('disabled');
        el.data('id', '');
    },

    /**
     * Adjust headerpane such that certain fields can be shown with ellipsis
     */
    adjustHeaderpane: function() {
        if (this.disposed) {
            return;
        }
        this.setContainerWidth();
        this.adjustHeaderpaneFields();
    },

    /**
     * Get the width of the layout container
     */
    getContainerWidth: function() {
        return this._containerWidth;
    },

    /**
     * Set the width of the layout container
     */
    setContainerWidth: function() {
        this._containerWidth = this._getParentLayoutWidth(this.layout);
    },

    /**
     * Get the width of the parent layout that contains `getPaneWidth()`
     * method.
     *
     * @param {View.Layout} layout The parent layout.
     * @return {Number} The parent layout width.
     * @private
     */
    _getParentLayoutWidth: function(layout) {
        if (!layout) {
            return 0;
        } else if (_.isFunction(layout.getPaneWidth)) {
            return layout.getPaneWidth(this);
        }

        return this._getParentLayoutWidth(layout.layout);
    },

    /**
     * Adjust headerpane fields such that the first field is ellipsified and the last field
     * is set to 100% on view.  On edit, the first field is set to 100%.
     */
    adjustHeaderpaneFields: function() {
        var $ellipsisCell,
            ellipsisCellWidth,
            $recordCells;

        if (this.disposed) {
            return;
        }

        $recordCells = this.$('.headerpane h1').children('.record-cell, .btn-toolbar');

        if (($recordCells.length > 0) && (this.getContainerWidth() > 0)) {
            $ellipsisCell = $(this._getCellToEllipsify($recordCells));

            if ($ellipsisCell.length > 0) {
                if ($ellipsisCell.hasClass('edit')) {
                    // make the ellipsis cell widen to 100% on edit
                    $ellipsisCell.css({'width': '100%'});
                } else {
                    ellipsisCellWidth = this._calculateEllipsifiedCellWidth($recordCells, $ellipsisCell);
                    this._setMaxWidthForEllipsifiedCell($ellipsisCell, ellipsisCellWidth);
                }
            }
        }

        if (this.layout) {
            this.layout.trigger('headerpane:adjust_fields');
        }
    },

    /**
     * Get the first cell for the field that can be ellipsified.
     * @param {jQuery} $cells
     * @return {jQuery}
     * @private
     */
    _getCellToEllipsify: function($cells) {
        var fieldTypesToEllipsify = ['fullname', 'name', 'text', 'base', 'enum', 'url', 'dashboardtitle'];

        return _.find($cells, function(cell) {
            return (_.indexOf(fieldTypesToEllipsify, $(cell).data('type')) !== -1);
        });
    },

    /**
     * Calculate the width for the cell that needs to be ellipsified.
     * @param {jQuery} $cells
     * @param {jQuery} $ellipsisCell
     * @return {Number}
     * @private
     */
    _calculateEllipsifiedCellWidth: function($cells, $ellipsisCell) {
        var width = this.getContainerWidth();

        _.each($cells, function(cell) {
            var $cell = $(cell);

            if ($cell.is($ellipsisCell)) {
                width -= (parseInt($ellipsisCell.css('padding-left'), 10) +
                         parseInt($ellipsisCell.css('padding-right'), 10));
            } else if ($cell.is(':visible')) {
                $cell.css({'width': 'auto'});
                width -= $cell.outerWidth();
            }
            $cell.css({'width': ''});
        });

        return width;
    },

    /**
     * Set the max-width for the specified cell.
     * @param {jQuery} $ellipsisCell
     * @param {number} width
     * @private
     */
    _setMaxWidthForEllipsifiedCell: function($ellipsisCell, width) {
        var ellipsifiedCell,
            fieldType = $ellipsisCell.data('type');
        if (fieldType === 'fullname' || fieldType === 'dashboardtitle') {
            ellipsifiedCell = this.getField($ellipsisCell.data('name'));
            width -= ellipsifiedCell.getCellPadding();
            ellipsifiedCell.setMaxWidth(width);
        } else {
            $ellipsisCell.css({'width': width}).children().css({'max-width': (width - 2) + 'px'});
        }
    },

    /**
     * Returns some fields to be used with app.view.View.getFieldNames() if their corresponding
     * meta attribute is true
     *
     * @private
     */
    _getDataFields: function() {
        var fields = [];

        var favorite = _.find(this.meta.panels, function(panel) {
            return _.find(panel.fields, function(field) {
                return field.type === 'favorite';
            });
        });

        var follow = _.find(this.meta.panels, function(panel) {
            return _.find(panel.fields, function(field) {
                return field.type === 'follow';
            });
        });

        if (favorite) {
            fields.push('my_favorite');
        }

        if (follow) {
            fields.push('following');
        }

        return fields;
    },

    /**
     * Extracts the field names from the metadata for directly related views/panels.
     * @param {string} [module] Module name.
     */
    getFieldNames: function(module) {
        return _.union(this._super('getFieldNames', arguments), this._getDataFields());
    },

    /**
     * Hide or show panel based on click to the panel header
     * @param {Event} e
     */
    togglePanel: function(e) {
        var $panelHeader = this.$(e.currentTarget);
        if ($panelHeader && $panelHeader.next()) {
            $panelHeader.next().toggle();
            $panelHeader.toggleClass('panel-inactive panel-active');
        }
        if ($panelHeader && $panelHeader.find('i')) {
            $panelHeader.find('i').toggleClass('fa-chevron-up fa-chevron-down');
        }
        var panelName = this.$(e.currentTarget).parent().data('panelname');
        var state = 'collapsed';
        if (this.$(e.currentTarget).next().is(":visible")) {
            state = 'expanded';
        }
        this.savePanelState(panelName, state);
    },

    /**
     * Returns true if the first non-header panel has useTabs set to true
     */
    checkFirstPanel: function() {
        if (this.meta && this.meta.panels) {
            if (this.meta.panels[0] && this.meta.panels[0].newTab && !this.meta.panels[0].header) {
                return true;
            }
            if (this.meta.panels[1] && this.meta.panels[1].newTab) {
                return true;
            }
        }
        return false;
    },

    /**
     * Moves overflowing tabs into a dropdown
     */
    overflowTabs: function() {
        if (this.disposed) {
            return;
        }
        var $tabs = this.$('#recordTab > .tab:not(.dropdown)'),
            $dropdownList = this.$('#recordTab .dropdown'),
            $dropdownTabs = this.$('#recordTab .dropdown-menu li'),
            navWidth = this.$('#recordTab').width(),
            activeTabHref = this.getActiveTab(),
            $activeTab = this.$('#recordTab > .tab > a[href="'+activeTabHref+'"]').parent(),
            // Calculate available width for items in navbar
            // Includes the activetab to ensure it is displayed
            width = $activeTab.outerWidth() + $dropdownList.outerWidth();

        $tabs.each(_.bind(function (index, elem) {
            var $tab = $(elem),
                overflow;

            // Always include the active tab
            if ($tab.hasClass('active')) {
                overflow = false;
            }
            else {
                width += $tab.outerWidth();
                // Check if the tab fits in the navbar
                overflow = width >= navWidth;
            }

            // Toggle tabs in the navbar
            $tab.toggleClass('hidden', overflow);
            // Toggle items in the dropdown
            this.$($dropdownTabs[index]).toggleClass('hidden', !overflow);
        }, this));
        // Toggle the dropdown arrow
        $dropdownList.toggleClass('hidden', !$tabs.is(':hidden'));
    },

    /**
     * Takes a tab dropdown link and triggers the corresponding tab
     * @param {Event} e
     */
    triggerNavTab: function(e) {
        var tabTarget = e.currentTarget.hash,
            activeTab = this.$('#recordTab > .tab > a[href="'+tabTarget+'"]');

        e.preventDefault();
        activeTab.trigger('click');
        this.overflowTabs();
    },

    /**
     * Register keyboard shortcuts.
     */
    registerShortcuts: function() {
        app.shortcuts.register({
            id: 'Record:Edit',
            keys: ['e','mod+alt+i'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_EDIT',
            handler: function() {
                var $editButton = this.$('.headerpane [name=edit_button]');
                if ($editButton.is(':visible') && !$editButton.hasClass('disabled')) {
                    $editButton.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Record:Delete',
            keys: ['d','mod+alt+d'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_DELETE',
            handler: function() {
                this.$('.headerpane [data-toggle=dropdown]:visible').click().blur();
                this.$('.headerpane [name=delete_button]:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'Record:Save',
            keys: ['mod+s','mod+alt+a'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_SAVE',
            callOnFocus: true,
            handler: function() {
                var $saveButton = this.$('a[name=save_button]');
                if ($saveButton.is(':visible') && !$saveButton.hasClass('disabled')) {
                    $saveButton.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Record:Cancel',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_RECORD_CANCEL',
            callOnFocus: true,
            handler: function() {
                var $cancelButton = this.$('a[name=cancel_button]');
                if ($cancelButton.is(':visible') && !$cancelButton.hasClass('disabled')) {
                    $cancelButton.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Record:Previous',
            keys: 'h',
            component: this,
            description: 'LBL_SHORTCUT_RECORD_PREVIOUS',
            handler: function() {
                var $previous = this.$('.btn.previous-row');
                if ($previous.is(':visible') && !$previous.hasClass('disabled')) {
                    $previous.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Record:Next',
            keys: 'l',
            component: this,
            description: 'LBL_SHORTCUT_RECORD_NEXT',
            handler: function() {
                var $next = this.$('.btn.next-row');
                if ($next.is(':visible') && !$next.hasClass('disabled')) {
                    $next.click();
                }
            }
        });

        app.shortcuts.register({
            id: 'Record:Favorite',
            keys: 'f a',
            component: this,
            description: 'LBL_SHORTCUT_FAVORITE_RECORD',
            handler: function() {
                this.$('.headerpane .fa-favorite:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'Record:Follow',
            keys: 'f o',
            component: this,
            description: 'LBL_SHORTCUT_FOLLOW_RECORD',
            handler: function() {
                this.$('.headerpane [name=follow]:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'Record:Copy',
            keys: ['shift+c','mod+alt+u'],
            component: this,
            description: 'LBL_SHORTCUT_COPY_RECORD',
            handler: function() {
                this.$('.headerpane [data-toggle=dropdown]:visible').click().blur();
                this.$('.headerpane [name=duplicate_button]:visible').click();
            }
        });

        app.shortcuts.register({
            id: 'Record:Action:More',
            keys: 'm',
            component: this,
            description: 'LBL_SHORTCUT_OPEN_MORE_ACTION',
            handler: function() {
                var $primaryDropdown = this.$('.headerpane .btn-primary[data-toggle=dropdown]:visible');
                if (($primaryDropdown.length > 0) && !$primaryDropdown.hasClass('disabled')) {
                    $primaryDropdown.click();
                }
            }
        });
    },

    /**
     * Dismisses all {@link #_viewAlerts alerts} defined in this view.
     *
     * @protected
     */
    _dismissAllAlerts: function() {
        if (_.isEmpty(this._viewAlerts)) {
            return;
        }
        _.each(_.uniq(this._viewAlerts), function(alert) {
            app.alert.dismiss(alert);
        });
        this._viewAlerts = [];
    }
}) },
"language-actions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.LanguageActionsView
 * @alias SUGAR.App.view.views.BaseLanguageActionsView
 * @extends View.View
 */
({
	// Language-actions View (base) 

    events: {
        'click [data-action=languageList] .dropdown-menu a' : 'setLanguage'
    },
    tagName: "span",
    plugins: ['Dropdown'],
    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        app.events.on("app:sync:complete", this.render, this);
        app.events.on("app:login:success", this.render, this);
        app.events.on("app:logout", this.render, this);
        app.view.View.prototype.initialize.call(this, options);
        $(window).on('resize', _.debounce(_.bind(this.adjustMenuHeight, this), 100));
    },
    /**
     * @override
     * @private
     */
    _renderHtml: function() {
        this.isAuthenticated = app.api.isAuthenticated();
        this.currentLang = app.lang.getLanguage() || "en_us";
        this.languageList = this.formatLanguageList();
        app.view.View.prototype._renderHtml.call(this);
        this.$('[data-toggle="dropdown"]').dropdown();
        this.adjustMenuHeight();
    },
    /**
     * When a user selects a language in the dropdown, set this language.
     * Note that on login, user's preferred language will be updated to this language
     *
     * @param {Event} e
     */
    setLanguage: function(e) {
        var $li = this.$(e.currentTarget),
            langKey = $li.data("lang-key");
        app.alert.show('language', {level: 'warning', title: app.lang.get('LBL_LOADING_LANGUAGE'), autoclose: false});
        app.lang.setLanguage(langKey, function() {
            app.alert.dismiss('language');
        });
    },
    adjustMenuHeight: function(){
        if (this.$('[data-action=languageList]').length === 0) {
            return;
        }
        var linkButton = this.$('[data-action=languageList]'),
            dropupMenu = this.$('[data-action=languageList] .dropdown-menu.bottom-up'),
            linkBottomPosition = parseInt($('footer').height() - linkButton.height() - linkButton.position().top, 10),
            dropupOffset = parseInt(dropupMenu.css('bottom'), 10),
            borderTop = parseInt(dropupMenu.css('border-top-width'), 10),
            menuHeight = Math.round($(window).height() - borderTop - dropupOffset - linkBottomPosition);
        dropupMenu.css('max-height', menuHeight);
    },
    /**
     * Formats the language list for the template
     *
     * @return {Array} of languages
     */
    formatLanguageList: function() {
        // Format the list of languages for the template
        var list = [],
            languages = app.lang.getAppListStrings('available_language_dom');

        _.each(languages, function(label, key) {
            if (key !== '') {
                list.push({ key: key, value: label });
            }
        });
        return list;
    },
    /**
     * @inheritdoc
     */
    _dispose: function() {
        $(window).off('resize');
        app.view.View.prototype._dispose.call(this);
    }
}) },
"selection-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SelectionHeaderpaneView
 * @alias SUGAR.App.view.views.BaseSelectionHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Selection-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    initialize: function(options) {
        this._super('initialize', [options]);

        var moduleMeta = app.metadata.getModule(options.module),
            isBwcEnabled = (moduleMeta && moduleMeta.isBwcEnabled),
            multiSelect = options.context.get('isMultiSelect'),
            buttonsToRemove = [],
            additionalEvents = {};

        this.isMultiLink = options.context.has('recLink');
        var createButtonAcl = _.chain(this.meta.buttons)
            .findWhere({name: 'main_dropdown'}).result('buttons')
            .findWhere({name: 'create_button'}).result('acl_action').value();

        if (isBwcEnabled || multiSelect || this.isMultiLink || !app.acl.hasAccess(createButtonAcl, options.module)) {
            buttonsToRemove.push('create_button');
        } else {
            additionalEvents['click [name=create_button]'] = 'createAndSelect';
            this.events = _.extend({}, this.events, additionalEvents);
        }


        if (this.isMultiLink) {
            //FIXME: This will be removed with SC-4073.
            var linkTitleLabel = _.find(this.meta.fields, function(field) {
                return field.name === 'title';
            }, this);
            linkTitleLabel.default_value = 'TPL_SEARCH_AND_ADD';
        } else {
            buttonsToRemove.push('link_button');
        }

        if (!multiSelect) {
            buttonsToRemove.push('select_button');
        }

        this._removeButtons(buttonsToRemove);
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this._super('_renderHtml');

        this.layout.on('selection:closedrawer:fire', _.once(_.bind(function() {
            this.$el.off();
            app.drawer.close();
        }, this)));

        if (this.isMultiLink) {
            this.layout.on('selection:link:fire', function() {
                this.context.trigger('selection-list:link:multi');
            });
        }
    },

    /**
     * @inheritdoc
     */
    _formatTitle: function(title) {
        var moduleName = app.lang.get('LBL_MODULE_NAME', this.module);
        return app.lang.get(title, this.module, {module: moduleName});
    },

    /**
     * Open create inline modal with no dupe check
     * On save, set the selection model which will close the selection-list inline modal
     */
    createAndSelect: function() {
        app.drawer.open({
            layout: 'create-nodupecheck',
            context: {
                module: this.module,
                create: true
            }
        }, _.bind(function(context, model) {
            if (model) {
                this.context.trigger('selection-list:select', context, model);
            }
        }, this));
    },

    /**
     * Removes buttons from main_dropdown
     *
     * @param {Array} buttons The names of the buttons to remove.
     * @private
     */
    _removeButtons: function(buttons) {
        if (!buttons.length) {
            return;
        }

        var mainDropdown = _.find(this.meta.buttons, function(button) {
            return button.name === 'main_dropdown';
        });

        if (!mainDropdown) {
            return;
        }

        mainDropdown.buttons = _.filter(mainDropdown.buttons, function(button) {
            return !_.contains(buttons, button.name);
        });
    }
}) },
"list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View that displays a list of models pulled from the context's collection.
 *
 * @class View.Views.Base.ListView
 * @alias SUGAR.App.view.views.BaseListView
 * @extends View.View
 */
({
	// List View (base) 

    className: 'list-view',

    plugins: ['Pagination'],

    events: {
        'click [class*="orderBy"]':'setOrderBy'
    },

    defaultLayoutEvents: {
        "list:search:fire": "fireSearch",
        "list:filter:toggled": "filterToggled",
        "list:alert:show": "showAlert",
        "list:alert:hide": "hideAlert",
        "list:sort:fire": "sort"
    },

    /**
     * @inheritdoc
     */
    dataView: 'list',

    defaultContextEvents: {},

    // Model being previewed (if any)
    _previewed: null,
    //Store left column fields
    _leftActions: [],
    //Store right column fields
    _rowActions: [],
    //Store default and available(+visible) field names
    _fields: {},

    initialize: function(options) {
        //Grab the list of fields to display from the main list view (assuming initialize is being called from a subclass)
        var listViewMeta = app.metadata.getView(options.module, 'list') || {};
        //Extend from an empty object to prevent polution of the base metadata
        options.meta = _.extend({}, listViewMeta, options.meta || {});
        // FIXME: SC-5622 we shouldn't manipulate metadata this way.
        options.meta.type = options.meta.type || 'list';
        options.meta.action = 'list';
        options = this.parseFieldMetadata(options);

        app.view.View.prototype.initialize.call(this, options);

        this.viewName = 'list';

        /**
         * View name that corresponds to the list of fields API should retrieve.
         * @property {string} dataViewName
         * @deprecated Use {@link #dataView} instead
         */
        if (this.dataViewName) {
            app.logger.warn('`dataViewName` is deprecated, please use `dataView`.');
            this.context.set('dataView', this.dataViewName);
        }

        this.attachEvents();
        this.orderByLastStateKey = app.user.lastState.key('order-by', this);
        this.orderBy = this._initOrderBy();
        if(this.collection) {
            this.collection.orderBy = this.orderBy;
        }
        // Dashboard layout injects shared context with limit: 5.
        // Otherwise, we don't set so fetches will use max query in config.
        this.limit = this.context.has('limit') ? this.context.get('limit') : null;
        this.metaFields = this.meta.panels ? _.first(this.meta.panels).fields : [];

        this.registerShortcuts();
    },

    /**
     * Initializes the {@link #orderBy} property.
     *
     * Retrieves the last state from the local storage and verifies the field
     * is still sortable.
     *
     * @return {Object}
     * @return {string} return.field The field name to sort by.
     * @return {string} return.direction The direction to sort by (either `asc`
     *   or `desc`).
     * @protected
     */
    _initOrderBy: function() {
        var lastStateOrderBy = app.user.lastState.get(this.orderByLastStateKey) || {},
            lastOrderedFieldMeta = this.getFieldMeta(lastStateOrderBy.field);

        if (_.isEmpty(lastOrderedFieldMeta) || !app.utils.isSortable(this.module, lastOrderedFieldMeta)) {
            lastStateOrderBy = {};
        }

        // if no access to the field, don't use it
        if (!_.isEmpty(lastStateOrderBy.field) && !app.acl.hasAccess('read', this.module, app.user.get('id'), lastStateOrderBy.field)) {
            lastStateOrderBy = {};
        }

        return _.extend({
                field : '',
                direction : 'desc'
            },
            this.meta.orderBy,
            lastStateOrderBy
        );
    },

    /**
     * @override
     * @private
     */
    _render: function () {
        app.view.View.prototype._render.call(this);
        //If user has no `list` access, render `noaccess.hbs` template
        if (!app.acl.hasAccessToModel(this.action, this.model)) {
            this._noAccessTemplate = this._noAccessTemplate || app.template.get("list.noaccess");
            this.$el.html(this._noAccessTemplate());
        }
    },

    /**
     * Parses the field's metadata to make sure that the following attributes
     * respect specific standards:
     *
     *  - `align`: accepted values are `left`, `center` and `right`.
     *  - `width`: the value can be a default width (e.g. `small` or `large`) or
     *  a number in pixels. Percentage widths are ignored.
     *
     * The method will add (or append to) two properties to each field's
     * metadata:
     *
     * - `classes`: css classes that should be set on the column header.
     * - `styles`: inline style that should be set on the column header.
     *
     * To render properly, make sure that the template sets them on the
     * column headers.
     *
     * @param {Object} options The `options` object passed in
     *   {@link #initialize}.
     * @param {Object} options.meta The metadata that we want to parse.
     * @return {Object} The `options` object with the metadata parsed and
     *   patched.
     */
    parseFieldMetadata: function(options) {
        // standardize the align and width param in the defs if they exist
        _.each(options.meta.panels, function(panel, panelIdx) {
            _.each(panel.fields, function(field, fieldIdx) {
                var fieldFromMeta = options.meta.panels[panelIdx].fields[fieldIdx];
                // FIXME align should be handled by the field directly - SC-3588
                if (!_.isUndefined(field.align)) {
                    if (_.contains(['left', 'center', 'right'], field.align)) {
                        fieldFromMeta.align = 't' + field.align;
                    } else {
                        delete fieldFromMeta.align;
                    }
                }

                // The width field in Studio is defined as a percentage which is
                // deprecated for Sugar7 modules. Check to see if module list
                // view metadata has been defined as percentage and if so,
                // ignore.
                if (!_.isUndefined(field.width)) {
                    // check to see if it's a percentage
                    // match beginning, decimal of 0 to 3 places, percent sign, end
                    var percent = field.width.toString().match(/^(\d{0,3})\%$/);
                    // ignore if defined as percent
                    if (!percent && !_.isEmpty(field.width+'')) {
                        var width = parseInt(field.width, 10);
                        if (!_.isNaN(width) && _.isNumber(width)) {
                            var styles = 'max-width:' + width + 'px;min-width:' + width + 'px';
                            fieldFromMeta.styles = styles;
                            fieldFromMeta.expectedWidth = width;
                        } else {
                            fieldFromMeta.widthClass = 'cell-' + field.width;
                            fieldFromMeta.expectedWidth = field.width;
                        }
                    }
                }
            }, this);
        }, this);

        return options;
    },

    /**
     * Takes the defaultListEventMap and listEventMap and binds the events. This is to allow views that
     * extend ListView to specify their own events.
     */
    attachEvents: function() {
        this.layoutEventsMap = _.extend(this.defaultLayoutEvents, this.layoutEvents); // If undefined nothing will be added.
        this.contextEventsMap = _.extend(this.defaultContextEvents, this.contextEvents);

        if (this.layout) {
            _.each(this.layoutEventsMap, function(callback, event) {
                this.layout.on(event, this[callback], this);
            }, this);
        }

        if (this.context) {
            _.each(this.contextEventsMap, function(callback, event) {
                this.context.on(event, this[callback], this);
            }, this);
        }
    },

    sort: function() {
        //When sorting the list view, we need to close the preview panel
        app.events.trigger("preview:close");
    },

    showAlert: function(message) {
        this.$("[data-target=alert]").html(message);
        this.$("[data-target=alert-container]").removeClass("hide");
    },

    hideAlert: function() {
        this.$("[data-target=alert-container]").addClass("hide");
        this.$("[data-target=alert]").empty();
    },
    filterToggled:function (isOpened) {
        this.filterOpened = isOpened;
    },
    fireSearch:function (term) {
        term = term || "";
        var options = {
            limit: this.limit || null,
            query: term
        };
        this.context.get("collection").resetPagination();
        this.context.resetLoadFlag({recursive: false});
        this.context.set('skipFetch', false);
        this.context.loadData(options);
    },

    /**
     * Sets order by on collection and view.
     *
     * The event is canceled if an element being dragged is found.
     *
     * @param {Event} event jQuery event object.
     */
    setOrderBy: function(event) {
        if ($(event.currentTarget).find('ui-draggable-dragging').length) {
            return;
        }
        var collection, options, eventTarget, orderBy;
        var self = this;

        collection = self.collection;
        eventTarget = self.$(event.currentTarget);

        // first check if alternate orderby is set for column
        orderBy = eventTarget.data('orderby');
        // if no alternate orderby, use the field name
        if (!orderBy) {
            orderBy = eventTarget.data('fieldname');
        }
        if (!_.isEmpty(orderBy) && !app.acl.hasAccess('read', this.module, app.user.get('id'), orderBy)) {
            // no read access to the orderBy field, don't bother to reload data
            return;
        }

        // if same field just flip
        if (orderBy === self.orderBy.field) {
            self.orderBy.direction = self.orderBy.direction === 'desc' ? 'asc' : 'desc';
        } else {
            self.orderBy.field = orderBy;
            self.orderBy.direction = 'desc';
        }

        collection.orderBy = self.orderBy;

        collection.resetPagination();

        options = self.getSortOptions(collection);

        if(this.triggerBefore('list:orderby', options)) {
            self._setOrderBy(options);
        }
    },

    /**
     * Run the order by on the collection
     *
     * @param {Object} options
     * @private
     */
    _setOrderBy: function(options) {
        if(this.orderByLastStateKey) {
            app.user.lastState.set(this.orderByLastStateKey, this.orderBy);
        }
        // refetch the collection
        this.context.resetLoadFlag({recursive: false});
        this.context.set('skipFetch', false);
        this.context.loadData(options);
    },
    /**
     * Gets options for fetch call for list sorting
     * @param collection
     * @return {Object}
     */
    getSortOptions: function(collection) {
        var self = this, options = {};
        // Treat as a "sorted search" if the filter is toggled open
        options = self.filterOpened ? self.getSearchOptions() : {};

        //Show alerts for this request
        options.showAlerts = true;

        // If injected context with a limit (dashboard) then fetch only that
        // amount. Also, add true will make it append to already loaded records.
        options.limit = self.limit || null;
        options.success = function (collection, response, options) {
            self.layout.trigger("list:sort:fire", collection, self);
        };

        // if we have a bunch of models already fetch at least that many
        if (collection.offset) {
            options.limit = collection.offset;
            options.offset = 0;
        }

        return options;
    },
    getSearchOptions:function () {
        var collection, options, previousTerms, term = '';
        collection = this.context.get('collection');

        // If we've made a previous search for this module grab from cache
        if (app.cache.has('previousTerms')) {
            previousTerms = app.cache.get('previousTerms');
            if (previousTerms) {
                term = previousTerms[this.module];
            }
        }
        // build search-specific options and return
        options = {
            params:{},
            fields:collection.fields ? collection.fields : this.collection
        };
        if (term) {
            options.params.q = term;
        }
        if (this.context.get('link')) {
            options.relate = true;
        }
        return options;
    },
    bindDataChange:function () {
        if (this.collection) {
            this.collection.on("reset", this.render, this);
        }
    },

    _dispose: function() {
        this._fields = null;
        app.view.View.prototype._dispose.call(this);
    },

    /**
     * Select next or previous row.
     * @param {Boolean} down
     */
    selectRow: function(down) {
        var $rows = this.$('.dataTable tbody tr'),
            $selected,
            $next;

        if ($rows.hasClass('selected')) {
            $selected = $rows.filter('.selected');
            $next = down ? $selected.next() : $selected.prev();
            if($next.length > 0) {
                $selected.removeClass('selected');
                $next.addClass('selected');
                this.makeRowVisible($next);
            }
        } else {
            $rows.first().addClass('selected');
            this.makeRowVisible();
        }
    },

    /**
     * Scroll list view such that the selected row is visible.
     * @param {jQuery} $selected
     */
    makeRowVisible: function($selected) {
        var $mainpane = this.$el.closest('.main-pane'),
            mainpaneHeight,
            selectedHeight,
            selectedTopPosition,
            selectedOffsetParent;

        if (_.isUndefined($selected)) {
            $mainpane.scrollTop(0);
            return;
        }

        mainpaneHeight = $mainpane.height();
        selectedHeight = $selected.height();
        selectedOffsetParent = $selected.offsetParent();
        selectedTopPosition = $selected.position().top + selectedOffsetParent.position().top;

        if ((selectedTopPosition + selectedHeight) > mainpaneHeight) {
            $mainpane.scrollTop($mainpane.scrollTop() + mainpaneHeight/2);
        }

        if (selectedTopPosition < 0) {
            $mainpane.scrollTop($mainpane.scrollTop() - mainpaneHeight/2);
        }
    },

    /**
     * Scroll list view either right or left.
     * @param {Boolean} right
     */
    scrollHorizontally: function(right) {
        var $scrollableDiv = this.$('.flex-list-view-content'),
            scrollEnabled = this.$el.hasClass('scroll-width'),
            nextScrollPosition,
            increment = 60;

        if (scrollEnabled) {
            if (right) {
                nextScrollPosition = $scrollableDiv.scrollLeft() + increment;
            } else {
                nextScrollPosition = $scrollableDiv.scrollLeft() - increment;
            }

            $scrollableDiv.scrollLeft(nextScrollPosition);
        }
    },

    /**
     * Register shortcut keys.
     */
    registerShortcuts: function() {
        app.shortcuts.register({
            id: 'List:Select:Down',
            keys: 'j',
            component: this,
            description: 'LBL_SHORTCUT_NAVIGATE_DOWN',
            handler: function() {
                this.selectRow(true);
            }
        });

        app.shortcuts.register({
            id: 'List:Select:Up',
            keys: 'k',
            component: this,
            description: 'LBL_SHORTCUT_NAVIGATE_UP',
            handler: function() {
                this.selectRow(false);
            }
        });

        app.shortcuts.register({
            id: 'List:Scroll:Left',
            keys: 'h',
            component: this,
            description: 'LBL_SHORTCUT_SCROLL_LEFT',
            handler: function() {
                this.scrollHorizontally(false);
            }
        });

        app.shortcuts.register({
            id: 'List:Scroll:Right',
            keys: 'l',
            component: this,
            description: 'LBL_SHORTCUT_SCROLL_RIGHT',
            handler: function() {
                this.scrollHorizontally(true);
            }
        });

        app.shortcuts.register({
            id: 'List:Select:Open',
            keys: 'o',
            component: this,
            description: 'LBL_SHORTCUT_OPEN',
            handler: function() {
                if (this.$('.selected [data-type=name] a:visible').length > 0) {
                    this.$('.selected [data-type=name] a:visible').get(0).click();
                } else if (this.$('.selected [data-type=fullname] a:visible').length > 0) {
                    this.$('.selected [data-type=fullname] a:visible').get(0).click();
                }
            }
        });
    }
}) },
"error": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ErrorView
 * @alias SUGAR.App.view.views.BaseErrorView
 * @extends View.View
 */
({
	// Error View (base) 

    className: 'error-page',

    cubeOptions: {spin: false},

    events: {
        'click .sugar-cube': 'spinCube'
    },

    initialize: function(options) {
        // Adds the metadata for the Error module
        app.metadata.set(this._metadata);
        app.data.declareModels();

        // Reprepare the context because it was initially prepared without metadata
        app.controller.context.prepare(true);

        // Attach the metadata to the view
        options.meta = this._metadata.modules[options.module].views[options.type].meta;
        this._super('initialize', [options]);
    },
    _render: function() {
        if(this.context.get('errorType')) {
            var attributes = this.getErrorAttributes();
            this.model.set(attributes);
        }
        app.view.View.prototype._render.call(this);
    },
    getErrorAttributes: function() {
        var errorType = this.context.get('errorType'),
            attributes;

        switch (errorType) {
            case '400':
                attributes = {
                    title: 'ERR_HTTP_400_TITLE',
                    type: 'ERR_HTTP_400_TYPE',
                    messages: ['ERR_HTTP_400_TEXT_LINE1', 'ERR_HTTP_400_TEXT_LINE2'],
                    linkText: app.lang.get('ERR_HTTP_400_ACTION')
                };
                break;
            case '404':
                attributes = {
                    title: 'ERR_HTTP_404_TITLE',
                    type: 'ERR_HTTP_404_TYPE',
                    messages: ['ERR_HTTP_404_TEXT_LINE1', 'ERR_HTTP_404_TEXT_LINE2'],
                    linkText: app.lang.get('ERR_HTTP_404_ACTION')
                };
                break;
            case '422':
                attributes = {
                    title: 'ERR_HTTP_DEFAULT_TEXT',
                    type: error.status || 'ERR_HTTP_DEFAULT_TYPE',
                    messages: ['ERR_CONTACT_TECH_SUPPORT'],
                    linkText: app.lang.get('ERR_HTTP_DEFAULT_ACTION')
                };
                break;
            case '500':
                attributes = {
                    title: 'ERR_HTTP_500_TITLE',
                    type: 'ERR_HTTP_500_TYPE',
                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2'],
                    linkText: app.lang.get('ERR_HTTP_500_ACTION')
                };
                break;
            case '502':
                attributes = {
                    title: 'ERR_HTTP_502_TITLE',
                    type: 'ERR_HTTP_502_TYPE',
                    messages: ['ERR_HTTP_502_TEXT_LINE1', 'ERR_HTTP_502_TEXT_LINE2']
                };
                break;
            case '503':
                attributes = {
                    title: 'ERR_HTTP_503_TITLE',
                    type: 'ERR_HTTP_503_TYPE',
                    messages: ['ERR_HTTP_503_TEXT_LINE1', 'ERR_HTTP_503_TEXT_LINE2']
                };
                break;
            default:
                var error = this.context.get('error') || {};
                var title = null;
                if (error.status && error.errorThrown) {
                    title = 'HTTP: ' + error.status + ' ' + error.errorThrown;
                }
                attributes = {
                    title: title || 'ERR_HTTP_DEFAULT_TITLE',
                    type: error.status || 'ERR_HTTP_DEFAULT_TYPE',
                    messages: [error.message || 'ERR_HTTP_DEFAULT_TEXT']
                };
                break;
        }
        return attributes;
    },

    _metadata : {
        "modules": {
            "Error": {
                "views": {
                    "error": {
                        "meta": {}
                    }
                },
                "layouts": {
                    "error": {
                        "meta": {
                            "type": "simple",
                            "components": [
                                {view: "error"}
                            ]
                        }
                    }
                }
            }
        },
        'module_tab_map': {
            'Error': ''
        }
    },

    spinCube: function() {
        this.cubeOptions.spin = !this.cubeOptions.spin;
        this.render();
    }
}) },
"filtered-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.FilteredListView
 * @alias SUGAR.App.view.views.BaseFilteredListView
 * @extends View.Views.Base.ListView
 */
({
	// Filtered-list View (base) 

    extendsFrom: 'ListView',

    /**
     * Filtered and sorted collection set.
     * @property
     */
    filteredCollection: [],

    /**
     * Typed search keyword.
     * @property
     */
    searchTerm: '',

    /**
     * Convert the available filter to the regular expression.
     * @property
     */
    _patternToReg: {
        startsWith: '^(term)',
        endsWith: '(term)$',
        contains: '(term)'
    },

    /**
     * Filter the metadata in order to initiate the searchable fields.
     * @protected
     */
    _initFilter: function() {
        var filter = this._filter || _.chain(this.getFields())
            .filter(function(field) {
                return field.filter;
            })
            .map(function(field) {
                return {
                    name: field.name,
                    label: app.lang.get(field.label, this.module),
                    filter: field.filter
                };
            }, this)
            .value();
        this.context.trigger('filteredlist:filter:set', _.pluck(filter, 'label'));

        if (_.isEmpty(filter)) {
            return;
        }
        this._filter = filter;
    },

    /**
     * Filtering collection that matches with search term.
     * In order to activate filtering on the field,
     * the filter term should be defined in the metadata.
     * There are three type of filter type (startsWith, contains, endsWith).
     *
     * Examples:
     *
     * <pre><code>
     * array(
     *     'type' => 'base',
     *     'name' => 'field_name',
     *     'filter' => 'startsWith',
     *     ),
     * array(
     *     'type' => 'base',
     *     'name' => 'before_field_value',
     *     'filter' => 'contains',
     *     ),
     * array(
     *     'type' => 'base',
     *     'name' => 'datetime',
     *     'filter' => 'endsWith',
     *     ),
     * </code></pre>
     */
    filterCollection: function() {
        var term = this.searchTerm,
            filter = this._filter;

        if (!_.isEmpty(term) && _.isString(term)) {
            this.filteredCollection = this.collection.filter(function(model) {
                return _.some(filter, function(params) {
                    var pattern = this._patternToReg[params.filter].replace('term', term),
                        tester = new RegExp(pattern, 'i');
                    return tester.test(model.get(params.name));
                }, this);
            }, this);
        }
    },

    /**
     * Set the current search term and then reload the table.
     * @param {String} term Search term.
     */
    setSearchTerm: function(term) {
        this.searchTerm = term;
        this._renderData();
    },

    /**
     * @inheritdoc
     *
     * Sort the collection based on user input.
     * In order to activate sorting on the field,
     * 'sortable' should be defined in the metadata.
     *
     * <pre><code>
     * array(
     *     'type' => 'base',
     *     'name' => 'field_name',
     *     'sortable' => true,
     *     ),
     * </code></pre>
     */
    setOrderBy: function(event) {
        this._super('setOrderBy', [event]);
        this.collection.comparator = function(model) {
            return model.get(this.orderBy.field);
        };
        if (this.orderBy.direction === 'desc') {
            this.collection.sort({silent: true});
            this.collection.models.reverse();
            this.collection.trigger('sort', this.collection);
        } else {
            this.collection.sort();
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.on('render', this._initFilter, this);
        if (this.collection) {
            this.collection.on('reset sort', this._renderData, this);
        }
        this.context.on('filteredlist:search:fired', this.setSearchTerm, this);
    },

    /**
     * Refresh the filtered collection and then refresh the html.
     * @protected
     */
    _renderData: function() {
        this.filteredCollection = this.collection.models;
        this.filterCollection();
        this.render();
    }
}) },
"history-summary-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.HistorySummaryHeaderpaneView
 * @alias SUGAR.App.view.views.BaseHistorySummaryHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// History-summary-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=cancel_button]': 'cancel'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.model = this.context.parent && this.context.parent.get('model') || this.model;
    },

    /**
     * @override
     */
    _formatTitle: function(title) {
        var parent = this._getParentModel();
        var recordName = app.utils.getRecordName(parent);
        if (recordName) {
            return app.lang.get('TPL_HISTORICAL_SUMMARY', parent.module, {name: recordName});
        } else if (title) {
            return app.lang.get(title, this.module);
        } else {
            return '';
        }
    },

    /**
     * Gets the parent model of this historical summary view.
     *
     * @return {Data.Bean} The parent model.
     * @private
     */
    _getParentModel: function() {
        return this.context.parent.get('model');
    },

    /**
     * Gets the name of the parent model.
     *
     * @return {string} The parent model name.
     * @protected
     * @deprecated Deprecated since 8.0. Please use App.utils.getRecordName(parent)
     */
    _getParentModelName: function() {
        app.logger.warn('The function ' +
            '`View.Views.Base.HistorySummaryHeaderpaneView._getParentModelName`' +
            ' is deprecated since 8.0 and will be removed in the near future.' +
            'Please use `App.utils.getRecordName` instead.');

        var parent = this._getParentModel();
        return app.utils.formatNameModel(parent.module, parent.attributes) || parent.get('name');
    },

    /**
     * Cancel and close the drawer
     */
    cancel: function() {
        app.drawer.close();
    }
}) },
"dashletselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * "Add a dashlet" view.
 * Displays a list of dashlets filtered according to current module and layout.
 *
 * @class View.Views.Base.DashletselectView
 * @alias SUGAR.App.view.views.DashletselectView
 * @extends View.Views.Base.FilteredListView
 */
({
	// Dashletselect View (base) 

    extendsFrom: 'FilteredListView',

    /**
     * @inheritdoc
     *
     * Displays a filtered list of dashlets.
     * Uses client-generated collection with disabled load state, custom
     * preview and select actions.
     */
    initialize: function(options) {
        var meta = app.metadata.getView(null, 'dashletselect') || {};
        options.meta = _.extend({}, meta, options.meta || {});

        this._super('initialize', [options]);

        // To avoid reset while sorting.
        this.context = _.extend(_.clone(this.context), {
            resetLoadFlag: function() {
                return;
            }
        });

        this.context.on('dashletlist:select-and-edit', function(model) {
            this.selectDashlet(model.get('metadata'));
        }, this);

        this.context.on('dashletlist:preview:fire', function(model) {
            this.previewDashlet(model.get('metadata'));
        }, this);
    },

    /**
     * Load dashlet preview by passing preview metadata
     *
     * @param {Object} metadata Preview metadata.
     */
    previewDashlet: function(metadata) {
        var layout = this.layout,
            previewLayout;
        while (layout) {
            if (layout.getComponent('preview-pane')) {
                previewLayout = layout.getComponent('preview-pane').getComponent('dashlet-preview');
                previewLayout.showPreviewPanel();
                break;
            }
            layout = layout.layout;
        }

        if (previewLayout) {
            // If there is no preview property, use the config property
            if (!metadata.preview) {
                metadata.preview = metadata.config;
            }
            var previousComponent = _.last(previewLayout._components);
            if (previousComponent.name !== 'dashlet-preview') {
                var index = previewLayout._components.length - 1;
                previewLayout._components[index].dispose();
                previewLayout.removeComponent(index);
            }

            var contextDef,
                component = {
                    label: app.lang.get(metadata.label, metadata.preview.module),
                    type: metadata.type,
                    preview: true
                };
            if (metadata.preview.module || metadata.preview.link) {
                contextDef = {
                    skipFetch: false,
                    forceNew: true,
                    module: metadata.preview.module,
                    link: metadata.preview.link
                };
            } else if (metadata.module) {
                contextDef = {
                    module: metadata.module
                };
            }

            component.view = _.extend({module: metadata.module}, metadata.preview, component);
            if (contextDef) {
                component.context = contextDef;
            }

            previewLayout.initComponents([
                {
                    layout: {
                        type: 'dashlet',
                        label: app.lang.get(metadata.preview.label || metadata.label, metadata.preview.module),
                        preview: true,
                        components: [
                            component
                        ]
                    }
                }
            ], this.context);
            previewLayout.loadData();
            previewLayout.render();
        }
    },

    /**
     * Load dashlet configuration view by passing configuration metadata
     *
     * @param {Object} metadata Configuration metadata.
     */
    selectDashlet: function(metadata) {
        var model = new app.Bean();

        app.drawer.load({
            layout: {
                type: 'dashletconfiguration',
                components: [
                    {
                        view: _.extend({}, metadata.config, {
                            label: app.lang.get(metadata.label, metadata.config.module),
                            type: metadata.type,
                            config: true,
                            module: metadata.config.module || metadata.module
                        })
                    }
                ]
            },
            context: {
                module: metadata.config.module || metadata.module,
                model: model,
                forceNew: true,
                skipFetch: true
            }
        });
    },

    /**
     * Filtering the available dashlets with the current page's module and
     * layout view.
     *
     * @param {Array} dashlets A list of dashlet components.
     * @return {Array} A list of filtered dashlet set.
     */
    getFilteredList: function(dashlets) {
        var parentModule = app.controller.context.get('module');
        var parentView = app.controller.context.get('layout');

        return _.chain(dashlets)
            .filter(function(dashlet) {
                var filter = dashlet.filter;
                // if there is no filter for this dashlet, include it
                if (_.isUndefined(filter)) {
                    return true;
                }

                var filterModules = filter.module || [parentModule];
                var filterViews = filter.view || [parentView];

                if (_.isString(filterModules)) {
                    filterModules = [filterModules];
                }
                if (_.isString(filterViews)) {
                    filterViews = [filterViews];
                }

                //if the filter is matched, then it returns true
                return _.contains(filterModules, parentModule) &&
                    _.contains(filterViews, parentView);
            })
            .value();
    },

    /**
     * Iterates dashlets metadata and extract the dashlet components among them.
     *
     * @param {String} type The component type (layout|view).
     * @param {String} name The component name.
     * @param {String} module The module name.
     * @param {Object} meta The metadata.
     * @return {Array} list of available dashlets.
     * @private
     */
    _getDashlets: function(type, name, module, meta) {
        var dashlets = [],
            hadDashlet = meta && meta.dashlets &&
                app.view.componentHasPlugin({
                    type: type,
                    name: name,
                    module: module,
                    plugin: 'Dashlet'
                });
        if (!hadDashlet) {
            return dashlets;
        }
        _.each(meta.dashlets, function(dashlet) {
            if (!dashlet.config) {
                return;
            }
            var description = app.lang.get(dashlet.description, dashlet.config.module);
            if (!app.acl.hasAccess('access', module || dashlet.config.module)) {
                return;
            }
            dashlets.push({
                type: name,
                filter: dashlet.filter,
                metadata: _.extend({
                    component: name,
                    module: module,
                    type: name
                }, dashlet),
                title: app.lang.get(dashlet.label, dashlet.config.module),
                description: description
            });
        }, this);
        return dashlets;
    },

    /**
     * Retrieves all base view's metadata.
     *
     * @return {Array} All base view's metadata.
     * @private
     */
    _addBaseViews: function() {
        var components = [];
        _.each(app.metadata.getView(), function(view, name) {
            var dashlets = this._getDashlets('view', name, null, view.meta);
            if (!_.isEmpty(dashlets)) {
                components = _.union(components, dashlets);
            }
        }, this);
        return components;
    },

    /**
     * Retrieves all module view's metadata.
     *
     * @return {Array} The module view's metadata.
     * @private
     */
    _addModuleViews: function() {
        var components = [];
        _.each(app.metadata.getModuleNames({filter: 'visible'}), function(module) {
            _.each(app.metadata.getView(module), function(view, name) {
                var dashlets = this._getDashlets('view', name, module, view.meta);
                if (!_.isEmpty(dashlets)) {
                    components = _.union(components, dashlets);
                }
            }, this);
        }, this);
        return components;
    },

    /**
     * @inheritdoc
     *
     * Instead of fetching context, it will retrieve all dashable components
     * based on metadata. Sorts the components by `title` alphabetically.
     */
    loadData: function() {
        if (this.collection.length) {
            this.filteredCollection = this.collection.models;
            return;
        }

        var dashletCollection = _.union(this._addBaseViews(), this._addModuleViews()),
            filteredDashletCollection = this.getFilteredList(dashletCollection);

        this.collection.comparator = function(model) {
            return model.get('title');
        };

        this.collection.add(filteredDashletCollection);
        this.collection.dataFetched = true;
        this._renderData();
    },

    /**
     * @inheritdoc
     *
     * DashletSelect isn't a read module, no need to compare fields with defs.
     */
    getFields: function() {
        return _.flatten(_.pluck(this.meta.panels, 'fields'));
    }

}) },
"selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The SelectionListView provides an easy way to select a record from a list.
 * It's designed to be used in a drawer. The model attributes of the selected
 * record will be passed to the drawer callback.
 *
 * The SelectionListView has a generic implementation and can be overriden for
 * particular uses.
 *
 * It has to be opened passing the following data in the drawer's context:
 *
 * - `module` {String} The module the list is related to.
 * - `fields` {Array} The fields to be displayed.
 * - `filterOptions` {Object} the filter options for the list view.
 *
 *  Example of usage:
 *
 *     app.drawer.open({
	// Selection-list View (base) 

 *              layout: 'selection-list',
 *               context: {
 *                   module: this.getSearchModule(),
 *                   fields: this.getSearchFields(),
 *                   filterOptions: this.getFilterOptions(),
 *               }
 *           }, _.bind(this.setValue, this));
 *     },
 *
 * @class View.Views.Base.SelectionListView
 * @alias SUGAR.App.view.views.BaseSelectionListView
 * @extends View.Views.Base.FlexListView
 */
({
    extendsFrom: 'FlexListView',

    dataView: 'selection-list',

    initialize: function(options) {
        // Since list.js only fetches list view metadata, we need to build our
        // own metadata to send to the parent.
        var viewMeta = app.metadata.getView(options.module, options.name) ||
                       app.metadata.getView(options.module, this.dataView) || {};
        this.plugins = _.union(this.plugins, ['ListColumnEllipsis', 'ListRemoveLinks']);
        //setting skipFetch to true so that loadData will not run on initial load and the filter load the view.
        options.context.set('skipFetch', true);
        options.meta = _.extend(viewMeta, options.meta || {});
        this.setSelectionMeta(options);
        this._super('initialize', [options]);

        // set list back to flex-list
        this.tplName = 'flex-list';

        this.events = _.extend({}, this.events, {
            'click .search-and-select .single': 'triggerCheck'
        });
        this.initializeEvents();
    },

    /**
     * Sets metadata proper to selection-list.
     *
     * @param {Object} options
     *
     * FIXME: SC-4075 will remove this method.
     */
    setSelectionMeta: function(options) {
        options.meta.selection = {
            type: 'single',
            label: 'LBL_LINK_SELECT',
            isSearchAndSelectAction: true
        };
    },

    /**
     * Checks the `[data-check=one]` element when the row is clicked.
     *
     * @param {Event} event The `click` event.
     */
    triggerCheck: function(event) {
        //Ignore inputs and links/icons, because those already have defined effects
        if (!($(event.target).is('a,i,input'))) {
            var checkbox = $(event.currentTarget).find('[data-check=one]');
            checkbox[0].click();
        }
    },

    /**
     * Sets up events.
     */
    initializeEvents: function() {
        this.context.on('change:selection_model selection-list:select', this._selectAndClose, this);
    },

    /**
     * Closes the drawer passing the selected model attributes to the callback.
     *
     * @param {object} context
     * @param {Data.Bean} selectedModel The selected record.
     *
     * @protected
     */
    _selectAndClose: function(context, selectedModel) {
        if (selectedModel) {
            this.context.unset('selection_model', {silent: true});
            app.drawer.close(this._getModelAttributes(selectedModel));
        }
    },

    /**
     * Returns attributes given a model with ACL check.
     *
     * @param {Data.bean} model
     * @return {object} attributes
     *
     * @private
     */
    _getModelAttributes: function(model) {
        var attributes = {
            id: model.id,
            value: model.get('name')
        };

        //only pass attributes if the user has view access
        _.each(model.attributes, function(value, field) {
            if (app.acl.hasAccessToModel('view', model, field)) {
                attributes[field] = attributes[field] || model.get(field);
            }
        }, this);

        return attributes;
    },

    /**
     * Adds Preview button on the actions column on the right.
     */
    addActions: function() {
        this._super('addActions');
        if (this.meta.showPreview !== false) {
            this.rightColumns.push({
                type: 'preview-button',
                css_class: 'btn',
                tooltip: 'LBL_PREVIEW',
                event: 'list:preview:fire',
                icon: 'fa-eye',
                acl_action: 'view'
            });
        } else {
            this.rightColumns.push({});
        }
    }
}) },
"merge-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for merge duplicates.
 *
 * @class View.Views.Base.MergeDuplicatesView
 * @alias SUGAR.App.view.views.BaseMergeDuplicatesView
 * @extends View.Views.Base.ListView
 */
({
	// Merge-duplicates View (base) 

    extendsFrom: 'ListView',

    plugins: ['Editable', 'ErrorDecoration', 'MergeDuplicates'],

    events: {
        'click [data-mode=preview]' : 'togglePreview',
        'click [data-action=copy]' : 'triggerCopy',
        'click [data-action=delete]' : 'triggerDelete'
    },

    dataView: '',

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} merge_relate_fetch_concurrency Determining how many worker
     *   functions should be run in parallel for fetch.
     * - {Number} merge_relate_fetch_timeout Timeout for fetch related records
     *   call (milliseconds).
     * - {Number} merge_relate_fetch_limit Max number of records to fetch
     *   for related collection at a time.
     * - {Number} merge_relate_update_concurrency Determining how many worker
     *   functions should be run in parallel for update beans.
     * - {Number} merge_relate_update_timeout Timeout for update
     *   beans (milliseconds).
     * - {Number} merge_relate_max_attempt Max number of attemps for
     *   merge related.
     *
     * Example:
     * <pre><code>
     * // ...
     * 'settings' => array(
     *      'merge_relate_fetch_concurrency' => 2,
     *      'merge_relate_fetch_timeout' => 90000,
     *      'merge_relate_fetch_limit' => 20,
     *      'merge_relate_update_concurrency' => 4,
     *      'merge_relate_update_timeout' => 90000,
     *      'merge_relate_max_attempt' => 3,
     *      //...
     * ),
     * // ...
     * </code></pre>
     *
     * @property {Object}
     * @protected
     */
    _defaultSettings: {
        merge_relate_fetch_concurrency: 2,
        merge_relate_fetch_timeout: 90000,
        merge_relate_fetch_limit: 20,
        merge_relate_update_concurrency: 4,
        merge_relate_update_timeout: 90000,
        merge_relate_max_attempt: 3
    },

    /**
     * List of fields to generate the metadata on the fly.
     *
     * @property {Array} mergeFields
     */
    mergeFields: [],

    /**
     * @property {Object} rowFields
     */
    rowFields: {},

    /**
     * @property {Data.Bean} primaryRecord
     */
    primaryRecord: {},

    /**
     * @property {Boolean} [toggled=false]
     */
    toggled: false,

    /**
     * @property {Boolean} [isPreviewOpen=false]
     */
    isPreviewOpen: false,

    /**
     * Array of field defs keys that contain fields to populate.
     *
     * For some types of field we should populate additional fields
     * that can be determined from fields defs. E.g.
     * 1. if field type is 'relate' and 'parent'
     *     - def.id_name contains field name for id of related
     * 2. if field type is 'parent'
     *     - def.type_name contains field name for type of related
     *
     * @property {Array} relatedFieldsMap
     */
    relatedFieldsMap: ['id_name', 'type_name'],

    /**
     * Field names won't be mergeable.
     *
     * @property {Array} fieldNameBlacklist
     */
    fieldNameBlacklist: [
        'date_entered', 'date_modified', 'modified_user_id', 'created_by', 'deleted'
    ],

    /**
     * Field types won't be mergeable.
     *
     * @property {Array} fieldTypesBlacklist
     *
     * TODO: remove types that have properly implementation for merge interface
     */
    fieldTypesBlacklist: ['team_list', 'link', 'id', 'password'],

    /**
     * Links names won't be mergeable.
     * Those links will be not used in merge related records.
     *
     * @property {Array} relatesBlacklist
     */
    relatesBlacklist: [
        'assigned_user_link', 'modified_user_link', 'created_by_link',
        'teams', 'team_link', 'team_count_link',
        'archived_emails', 'email_addresses', 'email_addresses_primary',
        'forecastworksheets',
        'currencies'
    ],

    /**
     * Links names for certain module won't be mergeable.
     * Those links will be not used in merge related records for certain module.
     *
     * @property {Object} relatesBlacklistForModule
     */
    relatesBlacklistForModule: {
        Accounts: ['revenuelineitems'],
        Opportunities: ['accounts'],
        Leads: ['meetings_parent', 'calls_parent'],
        Prospects: ['tasks'],
        Bugs: ['project'],
        RevenueLineItems: ['campaign_revenuelineitems']
    },

    /**
     * @property {Object} mergeStat Contains stat after merging.
     */
    mergeStat: null,

    /**
     * Object used as context for merge duplicates view.
     *
     * {Backbone.Model} mergeProgressModel
     */
    mergeProgressModel: null,

    /**
     * @property {Backbone.Model} mergeRelatedCollection Contains related records to merge.
     */
    mergeRelatedCollection: null,

    /**
     * Attribute combos allowed to merge.
     *
     * @property {Array} validArrayAttributes
     */
    validArrayAttributes: [
        { type: 'datetimecombo', source: 'db' },
        { type: 'datetime', source: 'db' },
        { type: 'varchar', source: 'db' },
        { type: 'enum', source: 'db' },
        { type: 'multienum', source: 'db' },
        { type: 'text', source: 'db' },
        { type: 'date', source: 'db' },
        { type: 'time', source: 'db' },
        { type: 'currency', source: 'db', calculated: false },
        { type: 'int', source: 'db' },
        { type: 'long', source: 'db' },
        { type: 'double', source: 'db' },
        { type: 'float', source: 'db' },
        { type: 'short', source: 'db' },
        { dbType: 'varchar', source: 'db' },
        { dbType: 'double', source: 'db' },
        { type: 'relate' },
        { type: 'parent' },
        { type: 'image' },
        { type: 'teamset' },
        { type: 'email' },
        { type: 'tag' }
    ],

    /**
     * Types of fields that can be processed
     * in {@link View.Views.BaseMergeDuplicatesView#flattenFieldsets}.
     * @property {Array} flattenFieldTypes
     */
    flattenFieldTypes: ['fieldset', 'fullname'],

    /**
     * Variable to store generated values for some types of fields (e.g. teamset).
     * @property {Object} generatedValues
     */
    generatedValues: null,

    /**
     * Variable to store a copy of primary record's model for showing it
     * on preview panel
     * @property {Backbone.Model} previewModel Contains copy of primary record.
     */
    previewModel: {},

    /**
     * @inheritdoc
     *
     * Initialize merge collection as collection of selected records and
     * initialise fields that can be used in merge.
     */
    initialize: function(options) {
        this._initializeMergeFields(options.module);
        this._super('initialize', [options]);
        this._initSettings();
        this._initializeMergeCollection(this._prepareRecords());

        this.action = 'list';
        this._delegateEvents();
    },

    /**
     * Add event listeners
     *
     * @private
     */
    _delegateEvents: function() {
        this.layout.on('mergeduplicates:save:fire', this.triggerSave, this);

        app.events.on('preview:open', _.bind(this._onPreviewToggle, this, true), this);
        app.events.on('preview:close', _.bind(this._onPreviewToggle, this, false), this);
        this.on('render', this._showAlertIfIdentical, this);
    },

    /**
     * Initialize settings, default settings are used when none are supplied
     * through metadata.
     *
     * @return {View.Views.BaseMergeDuplicatesView} Instance of this view.
     * @protected
     */
    _initSettings: function() {

        var configSettings = app.config.mergeDuplicates && {
            merge_relate_fetch_concurrency: app.config.mergeDuplicates.mergeRelateFetchConcurrency,
            merge_relate_fetch_timeout: app.config.mergeDuplicates.mergeRelateFetchTimeout,
            merge_relate_fetch_limit: app.config.mergeDuplicates.mergeRelateFetchLimit,
            merge_relate_update_concurrency: app.config.mergeDuplicates.mergeRelateUpdateConcurrency,
            merge_relate_update_timeout: app.config.mergeDuplicates.mergeRelateUpdateTimeout,
            merge_relate_max_attempt: app.config.mergeDuplicates.mergeRelateMaxAttempt
        };

        this._settings = _.extend(
            this._defaultSettings,
            configSettings,
            this.meta && this.meta.settings || {}
        );
        return this;
    },

    /**
     * Standardize primary record from list of records.
     *
     * Put primary at the beginning of records.
     * This is useful primarily to know which record will be the primary
     * in the collection to be pulled later. We do not use the input models.
     *
     * @return {Array} records.
     * @private
     */
    _prepareRecords: function() {
        var records = this._validateModelsForMerge(this.context.get('selectedDuplicates'));

        this.setPrimaryRecord(this._findPrimary(records));
        return records;
    },

    /**
     * Find primary model from models chosen for merge.
     *
     * If primary model has no access to edit it finds first model that can
     * be edited and sets it as primary.
     *
     * @param {Data.Bean[]} models Set of models to merge.
     * @return {Data.Bean} Primary model
     * @protected
     */
    _findPrimary: function(models) {
        var primary = this.context.has('primaryRecord') &&
            _.findWhere(models, {id: this.context.get('primaryRecord').id});

        return primary || _.find(models, function(model) {
            return app.acl.hasAccessToModel('edit', model);
        });
    },

    /**
     * Initialize fields for merge.
     *
     * Creates filtered set of model's fields that can be merged.
     *
     * @param {string} module Module to retrieve metadata from.
     * @protected
     */
    _initializeMergeFields: function(module) {
        var meta = app.metadata.getView(module, 'record');
        var fieldDefs = app.metadata.getModule(module).fields;

        this.mergeFields = _.chain(meta.panels)
            .map(function(panel) {
                return this.flattenFieldsets(panel.fields);
            }, this)
            .flatten()
            .filter(function(field) {
                return field.name && this.validMergeField(fieldDefs[field.name]);
            }, this)
            .value();
    },

    /**
     * Initialize collection for merge.
     *
     * Enforce the order of the ids so that primaryRecord always appears first
     * and only retrieve the records specified.
     * @param {Array} records
     * @private
     */
    _initializeMergeCollection: function(records) {
        var ids = (_.pluck(records, 'id'));

        if (this.collection) {
            this.collection.filterDef = [];
            this.collection.filterDef.push({ 'id': { '$in' : ids}});
            this.collection.comparator = function(model) {
                return _.indexOf(ids, model.get('id'));
            };
        }
    },

    /**
     * Handler for save merged records event.
     *
     * Shows confirmation message and calls
     * {@link View.Views.BaseMergeDuplicatesView#_savePrimary} on confirm.
     */
    triggerSave: function() {
        var self = this,
            alternativeModels = _.without(this.collection.models, this.primaryRecord),
            alternativeModelNames = [];

        _.each(alternativeModels, function(model) {
            alternativeModelNames.push(app.utils.getRecordName(model));
        }, this);

        this.clearValidationErrors(this.getFieldNames());

        app.alert.show('merge_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_MERGE_DUPLICATES_CONFIRM') + ' ' +
                // FIXME needs to be removed on SC-4494.
                Handlebars.Utils.escapeExpression(alternativeModelNames.join(', ')) + '. ' +
                app.lang.get('LBL_MERGE_DUPLICATES_PROCEED'),
            onConfirm: _.bind(this._savePrimary, this)
        });
    },

    /**
     * Saves primary record and triggers `mergeduplicates:primary:saved` event on success.
     * Before saving triggers also `duplicate:unformat:field` event.
     *
     * @private
     */
    _savePrimary: function() {
        var self = this;
        var fields = this.getFieldNames().filter(function(field) {
            return app.acl.hasAccessToModel('edit', this.primaryRecord, field);
        }, this);
        var headerpaneView = this.layout.getComponent('merge-duplicates-headerpane');

        headerpaneView.getField('cancel_button').setDisabled(true);

        this.primaryRecord.trigger('duplicate:unformat:field');

        this.primaryRecord.save({}, {
            fieldsToValidate: fields,
            success: function() {
                // Trigger format fields again, because they can come different
                // from the server (e.g: only teams checked will be in the
                // response, and we still want to display unchecked teams on the
                // view)
                self.primaryRecord.trigger('duplicate:format:field');
                self.primaryRecord.trigger('mergeduplicates:primary:saved');
            },
            error: function(model, error) {
                if (error.status === 409) {
                    app.utils.resolve409Conflict(error, self.primaryRecord, function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                self.resetRadioSelection(model.id);
                                headerpaneView.getField('cancel_button').setDisabled(false);
                            } else {
                                self._savePrimary();
                            }
                        }
                    });
                } else {
                    headerpaneView.getField('cancel_button').setDisabled(false);
                }
            },
            lastModified: this.primaryRecord.get('date_modified'),
            showAlerts: true,
            viewed: true
        });
    },

    /**
     * Removes merged models and triggers `mergeduplicates:primary:merged` on success.
     *
     * We need to wait until all models are removed from server
     * to properly reload records view. Runs destroy methods in parallel
     * and triggers event after all requests have finished.
     *
     * @private
     */
    _removeMerged: function() {
        var self = this,
            models = _.without(this.collection.models, this.primaryRecord);

        async.forEach(models, function(model, callback) {
            self.collection.remove(model);
            model.destroy({success: function() {
                callback.call();
            }});
        }, function() {
            self.primaryRecord.trigger('mergeduplicates:primary:merged');
            self.hideMainPreviewPanel();
        });
    },

    /**
     * Hide the preview panel, from the main drawer
     */
    hideMainPreviewPanel: function() {
        //Get main drawer
        var $main_drawer = app.$contentEl.children().first();
        if (!_.isUndefined($main_drawer) && $main_drawer.hasClass('drawer inactive')) {
            var layout = $main_drawer.find('.sidebar-content');
            layout.find('.side-pane').addClass('active');
            layout.find('.dashboard-pane').show();
            layout.find('.preview-pane').removeClass('active');
        }
    },
    /**
     * @inheritdoc
     *
     * Override fetching fields names. Use fields that are allowed to merge only.
     *
     * Add additional fields for cases:
     * 1. field type is 'relate' and 'parent' (def.id_name)
     *     - def.id_name contains field name for id of related
     * 2. field type is 'parent' (def.type_name)
     *     - def.type_name contains field name for type of related
     *
     * @return {Array} array of field names.
     */
    getFieldNames: function() {
        var fields = [],
            fieldDefs = app.metadata.getModule(this.module).fields;

        _.each(this.mergeFields, function(mergeField) {
            var def = fieldDefs[mergeField.name];
            _.each(this.relatedFieldsMap, function(relatedField) {
                if (!_.isUndefined(def[relatedField]) && !_.isUndefined((fieldDefs[def[relatedField]].name))) {
                    fields.push(fieldDefs[def[relatedField]].name);
                }
            });
            var related_fields = mergeField.related_fields || def.related_fields || undefined;
            if (!_.isUndefined(related_fields) && _.isArray(related_fields)) {
                _.each(related_fields, function(rField) {
                    fields.push(rField);
                });
            }
            fields.push(def.name);
        }, this);
        return _.unique(fields);
    },

    /**
     * Create metadata for panels.
     *
     * Team sets will have a special metadata setup to match the height in all
     * records shown (match height).
     *
     * The fields are sorted by difference of values, showing first the ones
     * that are different among all records and then the ones that are equal.
     *
     * @param {Array} fields The list of fields for the module.
     * @return {Object} The metadata for the view template.
     * @private
     */
    _generateMetadata: function(fields) {
        this.generatedValues = {
            teamsets: []
        };

        _.each(fields, function(field) {
            if (field.type === 'teamset') {

                var teams = {};
                this.collection.each(function(model) {
                    _.each(model.get(field.name), function(team) {
                        teams[team.id] = team;
                    });
                });

                this.generatedValues.teamsets[field.name] = _.values(teams);
                field.maxHeight = _.size(teams);
                field.noRadioBox = true;
            }
        }, this);

        var models = this.collection.without(this.primaryRecord);
        fields = _.sortBy(fields, function(field) {
            return _.every(models, function(model) {
                return _.isEqual(this.primaryRecord.get(field.name), model.get(field.name));
            }, this);
        }, this);

        return {
            type: 'list',
            panels: [
                {
                    fields: fields
                }
            ]
        };
    },

    /**
     * Checks if all values are the same among all models.
     *
     * Compares the field value from primary model with values from other
     * models and returns `false` if it finds 1 field that isn't equal across
     * all models.
     *
     * @param {Data.Bean} primary The model chosen as primary.
     * @param {Data.Bean[]} models The array of models to compare with.
     * @return {Boolean} Is field value the same among all models.
     *
     * @private
     */
    _isSimilar: function(primary, models) {
        return _.every(models, function(model) {
            var modelFields = this.rowFields[model.id],
                primaryFields = this.rowFields[primary.id];

            return _.every(modelFields, function(field, index) {
                return field.equals(primaryFields[index]);
            }, this);
        }, this);
    },

    /**
     * Utility method for determining if a field is mergeable from its def.
     *
     * @param {Object} fieldDef Defs of validated field.
     * @return {Boolean} Is this field a valid field to merge?
     */
    validMergeField: function(fieldDef) {

        if (!fieldDef ||
            fieldDef.auto_increment === true ||
            !this._validMergeFieldName(fieldDef) ||
            !this._validMergeFieldType(fieldDef) ||
            this._isDuplicateMergeDisabled(fieldDef)
        ) {
            return false;
        }

        if (this._isDuplicateMergeEnabled(fieldDef)) {
            return true;
        }

        return this._validMergeFieldAttributes(fieldDef);
    },

    /**
     * Validate field to merge by name.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _validMergeFieldName: function(defs) {
        return !_.contains(this.fieldNameBlacklist, defs.name);
    },

    /**
     * Validate field to merge by type.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _validMergeFieldType: function(defs) {
        return !_.contains(this.fieldTypesBlacklist, defs.type);
    },

    /**
     * Checks if duplicate_merge is disabled in field's defs.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _isDuplicateMergeDisabled: function(defs) {
        if (!_.isUndefined(defs.duplicate_merge) &&
            (defs.duplicate_merge === 'disabled' ||
                defs.duplicate_merge === false)
        ) {
            return true;
        }
        return false;
    },

    /**
     * Checks if duplicate_merge is enabled in field's defs.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _isDuplicateMergeEnabled: function(defs) {
        if (!_.isUndefined(defs.duplicate_merge) &&
            (defs.duplicate_merge === 'enabled' ||
                defs.duplicate_merge === true)
        ) {
            return true;
        }
        return false;
    },

    /**
     * Validate field to merge by attributes.
     *
     * Uses `this.validArrayAttributes` hash to validate attributes.
     * Also checks if field is calculated and if it is returns `false`.
     *
     * @param {Object} defs Defs of validated field.
     * @return {Boolean}
     * @private
     */
    _validMergeFieldAttributes: function(defs) {
        // normalize fields that might not be there
        defs.dbType = defs.dbType || defs.type;
        defs.source = defs.source || 'db';
        defs.calculated = defs.calculated || false;

        if (defs.calculated !== false) {
            return false;
        }

        // compare to values in the list of acceptable attributes
        return _.some(this.validArrayAttributes, function(o) {
            return _.chain(o)
                .keys()
                .every(function(key) {
                    return o[key] === defs[key];
                })
                .value();
        });
    },

    /**
     * Utility method for taking a fieldlist with possible nested fields,
     * and returning a flat array of fields.
     *
     * @param {Array} defs Unprocessed list of fields from metadata.
     * @return {Array} Fields flat list of fields.
     */
    flattenFieldsets: function(defs) {
        var fieldsetFilter = function(field) {
                return (field.type &&
                    _.isArray(field.fields) &&
                    _.contains(this.flattenFieldTypes, field.type));
            },
            fields = _.reject(defs, fieldsetFilter, this),
            fieldsets = _.filter(defs, fieldsetFilter, this),
            sort = _.chain(defs).pluck('name').value() || [],
            sortTemp = [];

        while (fieldsets.length) {
            //collect fields' names from fieldset
            var fieldsNames = _.chain(fieldsets)
                .pluck('fields')
                .flatten()
                .pluck('name')
                .value();
            sortTemp = [];
            // create new sort sequence
            _.each(sort, function(value) {
                if (value === _.first(fieldsets).name) {
                    sortTemp = sortTemp.concat(fieldsNames);
                } else {
                    sortTemp = sortTemp.concat(value);
                }
            }, this);
            sort = sortTemp;
            // fieldsets need to be broken into component fields
            fieldsets = _.chain(fieldsets)
                .pluck('fields')
                .flatten()
                .value();

            // now collect the raw fields from the press
            fields = fields.concat(_.reject(fieldsets, fieldsetFilter));

            // do we have any more fieldsets to squash?
            fieldsets = _.filter(fieldsets, fieldsetFilter);
        }
        // sorting fields acording to sequence
        fields = _.sortBy(fields, function(value, index) {
            var result = index,
                name = value;
            if (!_.isUndefined(value.name)) {
                name = value.name;
                _.each(sort, function(valueSort, indexSort) {
                    if (valueSort == name) {
                        result = indexSort;
                    }
                });
            }
            return result;
        });
        return fields;
    },

    /**
     * Event handler for `preview:open` and `preview:close` events.
     *
     * @param {boolean} open Flag indicating the desired state of the preview
     * @deprecated Since 7.8. Will be removed in 7.9.
     */
    onPreviewToggle: function(open) {
        app.logger.warn('`View.Views.Base.MergeDuplicatesView#onPreviewToggle` has been deprecated since 7.8 and' +
            ' will be removed in 7.9.');
        this.isPreviewOpen = open;
        this.$('[data-mode=preview]').toggleClass('on', open);
    },

    /**
     * Event handler for `preview:open` and `preview:close` events.
     *
     * @param {boolean} open Flag indicating the desired state of the preview
     * @deprecated Since 7.8. Will be removed in 7.9.
     * @private
     */
    _onPreviewToggle: function(open) {
        this.isPreviewOpen = open;
        this.$('[data-mode=preview]').toggleClass('on', open);
    },

    /**
     * Toggles a Preview for the primary record.
     *
     * @param {Event} evt Mouse click event.
     */
    togglePreview: function(evt) {
        if (this.isPreviewOpen) {
            app.events.trigger('preview:close');
        } else {
            this.updatePreviewRecord(this.primaryRecord);
        }
    },

    /**
     * Creates the preview panel for the model in question.
     *
     * @param {Data.Bean} model Model to preview.
     */
    updatePreviewRecord: function(model) {
        var module = model.module || model.get('module');
        var previewCollection;

        // FIXME PX-15: Hack-fix for re-enabling sync on preview panel launch
        // We had to get the delta for primary record from current state until
        // now and reapply all of them after preview is synced
        if (_.isEmpty(this.previewModel) || this.previewModel.get('id') !== model.get('id')) {
            this.previewModel = app.data.createBean(module, model.toJSON());
            previewCollection = app.data.createBeanCollection(module, [this.previewModel]);

            this.previewModel.setOption({
                success: function(changedModel) {
                    var changedAttributes = model.changedAttributes(model.getSynced());
                    changedModel.set(_.mapObject(changedAttributes, function(value, fieldName) {
                        return model.get(fieldName);
                    }, this));
                }
            });
        }

        app.events.trigger('preview:render', this.previewModel, previewCollection, false);
        app.events.trigger('preview:open', true);
    },

    /**
     * Updates the view's title.
     *
     * @param {String} title
     */
    updatePrimaryTitle: function(title) {
        this.$('[data-container=primary-title]').text(title);
    },

    /**
     * @inheritdoc
     *
     * Add additional fields for specific types like 'parent' and 'relate'.
     * Setup primary model editable.
     * Setup drag-n-drop functionality.
     */
    _renderHtml: function() {
        this.meta = this._generateMetadata(this.mergeFields);

        this._super("_renderHtml");

        this.rowFields = {};
        _.each(this.fields, function(field) {
            if (field.model.id && _.isUndefined(field.parent)) {
                this.rowFields[field.model.id] = this.rowFields[field.model.id] || [];
                this.rowFields[field.model.id].push(field);
            }
        }, this);
        this.setPrimaryEditable(this.primaryRecord.id);
        this.setDraggable();
    },

    /**
     * Shows confirmation message if records are identical.
     * @protected
     */
    _showAlertIfIdentical: function() {
        if (!this.collection.length) {
            return;
        }

        var self = this,
            alternatives = this.collection.without(this.primaryRecord);

        if (this._isSimilar(this.primaryRecord, alternatives)) {
            app.alert.show('merge_confirmation_identical', {
                level: 'confirmation',
                messages: app.lang.get('TPL_MERGE_DUPLICATES_IDENTICAL', this.module),
                onConfirm: function() {
                    self.layout.trigger('mergeduplicates:save:fire');
                }
            });
        }
    },

    /**
     * Set ups label of primary record as draggable using jQuery UI Sortable plugin.
     */
    setDraggable: function() {
        var self = this,
        mergeContainer = this.$('[data-container=merge-container]');
        mergeContainer.find('[data-container=primary-label]').sortable({
            connectWith: self.$('[data-container=primary-label]'),
            appendTo: mergeContainer,
            axis: 'x',
            disableSelection: true,
            cursor: 'move',
            placeholder: 'primary-lbl-placeholder-span',
            start: function(event, ui) {
                self.$('[data-container=primary-label]').addClass('primary-lbl-placeholder');
            },
            stop: _.bind(self._onStopSorting, self)
        });

        mergeContainer.find('[data-container=primary-label].disabled').sortable(
            'option', 'disabled', true
        );
    },

    /**
     * Handler for jQuery UI Sortable plugin event triggered when sorting has stopped.
     *
     * Set ups choosed record as primary and make it editable.
     * If old primary record is changed shows confirmation message to confirm action.
     *
     * @param {Event} event
     * @param {Object} ui
     */
    _onStopSorting: function(event, ui) {
        var self = this,
            droppedTo = ui.item.parents('[data-record-id]');

        self.$('[data-container=primary-label]').removeClass('primary-lbl-placeholder');
        // short circuit if we didn't land on anything
        if (droppedTo.length === 0) {
            self.$('[data-container=primary-label]').sortable('cancel');
            return;
        }

        if (self.primaryRecord && self.primaryRecord.id !== droppedTo.data('record-id')) {
            var changedAttributes = self.primaryRecord.changedAttributes(
                self.primaryRecord.getSynced()
            );
            if (!_.isEmpty(changedAttributes)) {
                app.alert.show('change_primary_confirmation', {
                    level: 'confirmation',
                    messages: app.lang.get('LBL_MERGE_UNSAVED_CHANGES'),
                    onConfirm: function() {
                        self.primaryRecord.revertAttributes();
                        self.setPrimaryEditable(droppedTo.data('record-id'));
                    },
                    onCancel: function() {
                        self.$('[data-record-id=' + self.primaryRecord.get('id') + '] ' +
                            '[data-container=primary-label]').sortable('cancel');
                    }
                });
                return;
            }
            self.setPrimaryEditable(droppedTo.data('record-id'));
        }
    },

    /**
     * Enable/disable radio buttons according to ACL access to fields for all models.
     */
    checkCopyRadioButtons: function() {
        if (!this.primaryRecord) {
            return;
        }
        _.each(this.mergeFields, function(field) {
            var model = this.primaryRecord,
                element = this.$('[data-field-name=' + field.name + '][data-record-id=' + model.id + ']'),
                others = this.$('[data-field-name=' + field.name + '][data-record-id!=' + model.id + ']'),
                editAccess = app.acl.hasAccessToModel('edit', model, field.name);

            element.prop('disabled', !editAccess || field.readonly);

            if (!editAccess || field.readonly) {
                others.prop('disabled', true);
                return;
            }

            _.each(others, function(domElement) {
                var el = $(domElement),
                    readAccess = app.acl.hasAccessToModel(
                        'read',
                        this.collection.get(el.data('record-id')),
                        field.name
                    );
                el.prop('disabled', !readAccess);
            }, this);
        }, this);
    },

    /**
     * Prepare primary record for edit mode.
     *
     * Toggle primary record in edit mode, setup panel title and
     * update preview panel if it is opened. Make sure we get the model in
     * the collection, with all fields in it. If id parameter is provided
     * switch primary record to new model before and revert old primary record
     * to standard record. If new model is same as primary no action is taken.
     * Triggers `duplicate:format:field` before toggle fields.
     *
     * @param {String} [id] The record representing the new primary model.
     */
    setPrimaryEditable: function(id) {

        var oldPrimaryRecord = this.primaryRecord,
            newPrimaryRecord = this.collection.get(id || null);

        if (!_.isUndefined(newPrimaryRecord) && newPrimaryRecord !== oldPrimaryRecord) {
            this.setPrimaryRecord(newPrimaryRecord);
        }

        if (!this.primaryRecord) {
            return;
        }

        if (oldPrimaryRecord && oldPrimaryRecord !== this.primaryRecord) {
            this.toggleFields(this.rowFields[oldPrimaryRecord.id], false);
        }

        this.primaryRecord.trigger('duplicate:format:field');

        this.toggleFields(this.rowFields[this.primaryRecord.id], true);
        this.updatePrimaryTitle(app.utils.getRecordName(this.primaryRecord));
        if (this.isPreviewOpen) {
            this.updatePreviewRecord(this.primaryRecord);
        }
        this.$('.primary-edit-mode').removeClass('primary-edit-mode');
        this.$('[data-record-id=' + this.primaryRecord.id + ']').addClass('primary-edit-mode');
        this.resetRadioSelection(this.primaryRecord.id);
        this.checkCopyRadioButtons();
        this._disableRemovePrimary();

        if (this.collection.length <= 2) {
            this.$('[data-action=delete]').css('visibility', 'hidden');
        }
    },

    /**
     * Checks can primary record be removed or not and if not hides remove control.
     *
     * Primary record cannot be removed is there is not other model with edit access.
     *
     * @protected
     */
    _disableRemovePrimary: function() {
        var disableRemovePrimary = !_.some(this.collection.models, function(model) {
            return model !== this.primaryRecord && app.acl.hasAccessToModel('edit', model);
        }, this);

        this.$('[data-record-id=' + this.primaryRecord.get('id') + ']')
            .find('[data-action=delete]')
            .css('visibility', (disableRemovePrimary ? 'hidden' : 'visible'));
    },

    resetRadioSelection: function(modelId) {
        this.$('[data-record-id=' + modelId + '] input[type=radio]').attr('checked', true);
    },

    /**
     * Set a given model as primary.
     *
     * If the given module is already the primary record no action will be taken.
     * This will toggle off all the events of the old primary record and
     * setup the events for the new model. It will also setup primary record
     * 'change' event handler to updates title of panel,
     * 'mergeduplicates:primary:saved' to remove others models and
     * 'mergeduplicates:primary:merged' event handler to close drawer.
     *
     * @param {Data.Bean} model Primary model.
     */
    setPrimaryRecord: function(model) {
        if (this.primaryRecord === model) {
            return;
        }

        if (this.primaryRecord instanceof Backbone.Model) {
            this.primaryRecord.off(null, null, this);
        }

        this.primaryRecord = model;

        this.primaryRecord.on('change', function(model) {
            // Reapply every change on preview model
            if (!_.isEmpty(this.previewModel)) {
                var changedAttributes = this.primaryRecord.changedAttributes();

                this.previewModel.set(_.mapObject(changedAttributes, function(value, fieldName) {
                    return this.primaryRecord.get(fieldName);
                }, this));
            }

            this.updatePrimaryTitle(app.utils.getRecordName(this.primaryRecord));
        }, this);

        this.primaryRecord.on('mergeduplicates:primary:saved', function() {
            this._mergeRelatedRecords();
        }, this);

        this.primaryRecord.on('mergeduplicates:related:merged', function() {
            this._onRelatedMerged();
        }, this);

        this.primaryRecord.on('mergeduplicates:primary:merged', function() {
            app.alert.dismiss('mergeduplicates_merging');
            this._showSuccessMessage();
            app.drawer.close(true, this.primaryRecord);
        }, this);

        this.primaryRecord.on('validation:complete', function(isValid) {
            if (!isValid) {
                var headerpaneView = this.layout.getComponent('merge-duplicates-headerpane');
                headerpaneView.getField('cancel_button').setDisabled(false);
            }
        }, this);
    },

    /**
     * Event handler for radio box controls.
     *
     * Before copy value from model or restore value
     * triggers `before duplicate:field` event.
     *
     * @param {Event} evt Mouse click event.
     */
    triggerCopy: function(evt) {
        var currentTarget = this.$(evt.currentTarget),
            recordId = currentTarget.data('record-id'),
            fieldName = currentTarget.data('field-name'),
            fieldDefs = app.metadata.getModule(this.module).fields,
            model;

        if (_.isUndefined(this.primaryRecord) ||
            _.isUndefined(this.primaryRecord.id) ||
            _.isUndefined(recordId) ||
            _.isUndefined(fieldName) ||
            _.isUndefined(fieldDefs[fieldName])
        ) {
            return;
        }

        model = this.collection.get(recordId);
        if (_.isUndefined(model)) {
            return;
        }

        if (!app.acl.hasAccessToModel('edit', this.primaryRecord, fieldName) ||
            !app.acl.hasAccessToModel('read', model, fieldName)) {
            return;
        }

        var data = currentTarget.data();
        // Unlike data(), attr() doesn't perform type conversions if possible.
        // This is good because recordItemId can sometimes be numeric but must be type of string always.
        data.recordItemId = currentTarget.attr('data-record-item-id');
        data = _.extend({}, data, {
            checked: currentTarget.prop('type') === 'checkbox' ?
                currentTarget.prop('checked') : true
        });
        if (this.triggerBefore('duplicate:field', {model: model, data: data}) === false) {
            return;
        }

        if (model === this.primaryRecord) {
            this.revert(fieldName);
        } else {
            this.copy(fieldName, model);
        }
    },

    /**
     * Copy value from selected field to primary record.
     *
     * Setups new value current field and additional fields.
     * Also triggers `duplicate:field` event on the primary model.
     *
     * @param {String} fieldName Name of field to copy.
     * @param {Data.Bean} model Model to copy from.
     */
    copy: function(fieldName, model) {
        this._setRelatedFields(fieldName, model);
        this.primaryRecord.set(fieldName, model.get(fieldName));

        this.primaryRecord.trigger(
            'duplicate:field:' + fieldName,
            model !== this.primaryRecord ? model : null,
            model !== this.primaryRecord ? model.get(fieldName) : null
        );
    },

    /**
     * Revert value of field to latest sync state.
     *
     * Revert original values.
     * Also triggers `duplicate:field` event on the primary model.
     *
     * @param {String} fieldName Name of field to revert.
     */
    revert: function(fieldName) {
        var syncedAttributes = this.primaryRecord.getSynced();

        this._setRelatedFields(fieldName, this.primaryRecord, true);
        this.primaryRecord.set(
            fieldName,
            !_.isUndefined(syncedAttributes[fieldName]) ?
                syncedAttributes[fieldName] :
                this.primaryRecord.get(fieldName)
        );

        this.primaryRecord.trigger(
            'duplicate:field:' + fieldName,
            this.primaryRecord,
            this.primaryRecord.get(fieldName)
        );
    },

    /**
     * Event handler for model delete button.
     *
     * Shows alert message to confirm model removing.
     *
     * @param {Event} evt Mouse click event.
     */
    triggerDelete: function(evt) {
        var recordId = this.$(evt.currentTarget).closest('[data-record-id]').data('recordId'),
            model = this.collection.get(recordId),
            self = this;
        if (this.collection.length <= 2 || !recordId || !model) {
            return;
        }

        if (model === this.primaryRecord) {
            var allow = _.some(this.collection.models, function(model) {
                return model !== this.primaryRecord && app.acl.hasAccessToModel('edit', model);
            }, this);
            if (!allow) {
                return;
            }
        }
        app.alert.show('record-delete-confirm', {
            level: 'confirmation',
            messages: app.lang.get('LBL_MERGE_DUPLICATES_REMOVE', this.module),
            onConfirm: function() {
                self.deleteFromMerge(model);
                self.$('[data-container="merge-container"]').attr('class', function(){
                    return $(this).attr('class').replace(
                        /\b(num\-cols\-)(\d+)\b/g,
                        '$1' + self.collection.length
                    );
                });
            }
        });
    },

    /**
     * Delete model from collection to merge.
     *
     * If removed model is primary find first model in
     * collection an setup it as primary.
     *
     * @param {Data.Bean} model Model to remove.
     */
    deleteFromMerge: function(model) {

        this.collection.remove(model, {silent: true});

        var selModelEl = '[data-container=merge-record][data-record-id=' + model.get('id') + ']';

        if (model === this.primaryRecord) {
            var primary = this._findPrimary(this.collection.models),
                selNewPrimaryEl = '[data-container=merge-record][data-record-id=' + primary.get('id') + ']',
                primaryEl = this.$(selNewPrimaryEl).find('[data-container=primary-label]'),
                primaryLabel = this.$(selModelEl).find('[data-container=primary-label-span]');

            primaryEl.append(primaryLabel);
            this.setPrimaryEditable(primary.get('id'));

        }

        this.$(selModelEl).remove();

        if (this.collection.length <= 2) {
            this.$('[data-action=delete]').css('visibility', 'hidden');
        }
    },

    /**
     * Copy additional fields to primary model.
     *
     * Cases:
     * 1. field type is 'relate' and 'parent' (def.id_name)
     *     - def.id_name contains field name for id of related.
     * 2. field type is 'parent' (def.type_name)
     *     - def.type_name contains field name for type of related.
     *
     * @param {String} fieldName Name of main field to copy.
     * @param {Data.Bean} model Model from which values should be coped.
     * @param {Boolean} synced Use last synced attributes of model for copy or not.
     * @protected
     */
    _setRelatedFields: function(fieldName, model, synced) {
        synced = synced || false;

        var fieldDefs = app.metadata.getModule(this.module).fields;
            defs = fieldDefs[fieldName],
            syncedAttributes = synced ? model.getSynced() : {},
            fields = _.union(defs.populate_list, defs.related_fields);

        _.each(this.relatedFieldsMap, function(field) {
            if (!_.isUndefined(defs[field]) && !_.isUndefined(fieldDefs[defs[field]].name)) {
                fields.push(fieldDefs[defs[field]].name);
            };
        });

        // FIXME: populate_list is only available on related fields plus
        // related_fields is only available on fieldsets, so this logic should
        // be implemented on field side thus calling a method like
        // this.fields[fieldName].revertTo(model); here SC-3467
        _.each(fields, function(relatedField) {
            if (_.isUndefined(fieldDefs[relatedField])) {
                return;
            }

            this.primaryRecord.set(
                relatedField,
                !_.isUndefined(syncedAttributes[relatedField]) ?
                    syncedAttributes[relatedField] :
                    model.get(relatedField)
            );
        }, this);
    },

    /**
     * Returns defs of bean fields that are valid link for merge related records.
     *
     * @return {Object[]} Defs of fields.
     * @protected
     */
    _getRelatedLinks: function() {
        var fieldDefs = app.metadata.getModule(this.module).fields,
            excludedLinks = this._getExcludedRelatedLinks();

        return _.filter(fieldDefs, function(field) {
            return !_.isUndefined(field.type) && field.type === 'link' &&
                !_.contains(excludedLinks, field.name) &&
                this._isValidRelateLink(field) &&
                this._isValidRelateLinkType(field);
        }, this);
    },

    /**
     * Returns names of links that has been processed using `relate` fields on UI.
     *
     * @return {String[]} Names of links.
     * @protected
     */
    _getExcludedRelatedLinks: function() {
        var excludedLinks = [],
            fieldDefs = app.metadata.getModule(this.module).fields;

        _.each(this.mergeFields, function(mergeField) {
            var def = fieldDefs[mergeField.name];
            if (def.type === 'relate' && !_.isUndefined(def.link)) {
                excludedLinks.push(def.link);
            }
        }, this);

        return excludedLinks;
    },

    /**
     * Check is certain link valid for merge related records.
     *
     * Returns false in cases:
     * 1. link name isn't defined
     * 2. link module doesn't exist in our metadata
     * 3. link is in global black list
     * 4. link is in black list for current module
     * 5. merge is disabled in link defs
     *
     * @param {Object} link Defenition of link field.
     * @return {boolean} Is link valid for merge related.
     *
     * @protected
     */
    _isValidRelateLink: function(link) {
        if (!link || !link.name) {
            return false;
        }

        var module = app.data.getRelatedModule(this.module, link.name);
        if (_.isEmpty(app.metadata.getModule(module))) {
            return false;
        }

        if (_.contains(this.relatesBlacklist, link.name)) {
            return false;
        }

        if (!_.isUndefined(this.relatesBlacklistForModule[this.module]) &&
            _.contains(this.relatesBlacklistForModule[this.module], link.name)
        ) {
            return false;
        }

        if (!_.isUndefined(link.duplicate_merge) &&
            (link.duplicate_merge === 'disabled' ||
                link.duplicate_merge === 'false' ||
                link.duplicate_merge === false)
        ) {
            return false;
        }

        return true;
    },

    /**
     * Check is certain link valid for merge related records by link type.
     *
     * Returns false for cases:
     * 1. type of link is `one`
     *
     * @param {Object} link Defenition of link field.
     * @return {boolean} Is link valid for merge related by link type.
     * @protected
     */
    _isValidRelateLinkType: function(link) {
        if (!_.isUndefined(link.link_type) && link.link_type === 'one') {
            return false;
        }
        return true;
    },

    /**
     * Merge related records using queue.
     * Triggers `mergeduplicates:related:merged` event on finish.
     * @protected
     */
    _mergeRelatedRecords: function() {
        var self = this,
            alternativeModels = _.without(this.collection.models, this.primaryRecord),
            relatedLinks = _.pluck(this._getRelatedLinks(), 'name'),
            progressView,
            queue,
            tasks = [];

        this.mergeStat = {
            records: this.collection.models.length,
            total: 0, total_errors: 0, total_fetch_errors: 0
        };

        this.mergeProgressModel = new Backbone.Model({
            isStopped: false
        });

        this.mergeRelatedCollection = this.getMergeRelatedCollection();

        if (!alternativeModels || !alternativeModels.length) {
            self.primaryRecord.trigger('mergeduplicates:related:merged');
            return;
        }

        if (!relatedLinks || !_.isArray(relatedLinks) || !relatedLinks.length) {
            self.primaryRecord.trigger('mergeduplicates:related:merged');
            return;
        }

        progressView = this._getProgressView();
        progressView.reset();
        progressView.setTotalRecords(alternativeModels.length * relatedLinks.length);

        this.mergeProgressModel.trigger('massupdate:start');

        _.each(relatedLinks, function(link) {
            _.each(alternativeModels, function(model) {
                tasks.push({
                    collection: self._createRelatedCollection(model, link)
                });
            });
        });
        queue = async.queue(function(task, callback) {
            if (self.mergeProgressModel.get('isStopped')) {
                callback.call();
                return;
            }
            self._mergeRelatedCollection(task.collection, callback);
        }, this._settings.merge_relate_fetch_concurrency);
        queue.drain = function() {
            var finishMerge = function() {
                self.mergeProgressModel.trigger('massupdate:end');
                if (!self.mergeProgressModel.get('isStopped')) {
                    self.primaryRecord.trigger('mergeduplicates:related:merged');
                }

                if (self.mergeStat.total_fetch_errors > 0 || self.mergeStat.total_errors > 0) {
                    var headerpaneView = self.layout.getComponent('merge-duplicates-headerpane');
                    headerpaneView.getField('cancel_button').setDisabled(false);
                }
            };
            // Wait until all related records be merged or finish merge.
            self.mergeRelatedCollection.queue.running() ?
                self.mergeRelatedCollection.queue.drain = finishMerge :
                finishMerge();
        };
        queue.push(tasks, function(err) {});
    },

    /**
     * Creates collection against the parent model to merge related records.
     *
     * @return {Backbone.Collection} Merge collection.
     */
    getMergeRelatedCollection: function() {
        var constructor = Backbone.Collection.extend({
            method: 'create',
            queue: null,
            view: null,

            /**
             * @property {String} id Primary record's ID.
             */
            id: this.primaryRecord.id,

            /**
             * @property {String} module Primary record's module name.
             */
            module: this.primaryRecord.module,

            /**
             * @property {Number} attempt Current trial attempt number.
             */
            attempt: 0,

            /**
             * @inheritdoc
             *
             * Sync added set of records and clear collection.
             */
            initialize: function(models, options) {
                this.view = options.view;
                this.queue = async.queue(
                    _.bind(function(task, callback) {
                        this.sync('update', this, {
                            chunk: task,
                            queueSuccess: callback
                        });
                    }, this),
                    this.view._settings.merge_relate_update_concurrency
                );
                this.on('add', function(model, options) {
                    this.queue.push(
                        {
                            link_name: model.link.name,
                            ids: _.pluck(this.models, 'id')
                        },
                        function(err) {}
                    );
                    this.reset();
                }, this);
            },

            /**
             * @inheritdoc
             *
             * Overrides default behaviour to use related API and send related
             * records into chunks.
             */
            sync: function(method, model, options) {
                var apiMethod = options.method || this.method,
                    url = app.api.buildURL(this.module, method, {link: true, id: this.id}, options.params),
                    callbacks = {
                        success: function(data, response) {
                            model.view.mergeStat.total = model.view.mergeStat.total + options.chunk.ids.length;
                            options.queueSuccess();
                            if (_.isFunction(options.success)) {
                                options.success(data);
                            }
                        },
                        error: function(xhr) {
                            model.attempt = model.attempt + 1;
                            model.view.mergeProgressModel.trigger('massupdate:item:attempt', model);
                            if (model.attempt <= (model.view._settings.merge_relate_max_attempt)) {
                                app.api.call(apiMethod, url, options.chunk, callbacks);
                            } else {
                                model.attempt = 0;
                                model.view.mergeStat.total_errors = model.view.mergeStat.total_errors + 1;
                                model.view.mergeProgressModel.trigger('massupdate:item:fail', model);
                            }
                        },
                        complete: function(xhr) {
                            if (_.isFunction(options.complete)) {
                                options.complete(xhr);
                            }
                        }
                    };
                app.api.call(apiMethod, url, options.chunk, callbacks);
            }
        }),
        collection = new constructor([], {view: this});
        return collection;
    },

    /**
     * Called when merge related records process is finished.
     *
     * @protected
     */
    _onRelatedMerged: function() {
        var self = this;

        if (this.mergeStat.total_fetch_errors > 0 ||
            this.mergeStat.total_errors > 0
        ) {
            app.alert.show('final_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_MERGE_DUPLICATES_FAIL_PROCESS', this.module),
                onConfirm: function() {
                    self._onMergeRelatedCompleted();
                },
                onCancel: function() {
                    self.mergeProgressModel.trigger('massupdate:end');
                },
                autoClose: false
            });
            return;
        }

        this._onMergeRelatedCompleted();
    },

    /**
     * Starts removing models and shows process message.
     * @protected
     */
    _onMergeRelatedCompleted: function() {
        app.alert.show('mergeduplicates_merging', {
            level: 'process',
            title: app.lang.get('LBL_SAVING', this.module)
        });
        this._removeMerged();
    },

    /**
     * Creates related collection.
     * Setup additional parameters for merge process.
     *
     * @param {Data.Bean} model Model to create related collection.
     * @param {String} link Relationship link name.
     * @return {Data.BeanCollection} Created collection.
     * @protected
     */
    _createRelatedCollection: function(model, link) {
        var relatedCollection = app.data.createRelatedCollection(model, link);

        return _.extend(relatedCollection, {
            attempt: 0,
            maxAllowAttempt: this._settings.merge_relate_max_attempt,
            objectName: app.data.getRelatedModule(this.primaryRecord.module, link)
        });
    },

    /**
     * Recursively merge related collection.
     *
     * Recursively fetch data from link collection and creates (links) beans
     * to primary record.
     *
     * @param {Data.BeanCollection} collection Collection to merge.
     * @param {Function} callback Function called on end.
     * @param {Number} offset Offset to fetch data.
     * @protected
     */
    _mergeRelatedCollection: function(collection, callback, offset) {

        if (this.mergeProgressModel.get('isStopped')) {
            callback.call();
            return;
        }

        offset = offset || 0;

        var self = this,
            onCollectionMerged = function() {
                self.mergeProgressModel.trigger('massupdate:item:processed');
                callback.call();
            };

        collection.fetch({
            relate: true,
            limit: this._settings.merge_relate_fetch_limit,
            offset: offset,
            fields: ['id'],
            apiOptions: {
                timeout: this._settings.merge_relate_fetch_timeout,
                skipMetadataHash: true
            },
            success: function(data, response, options) {
                if (!data || !data.models || !data.models.length) {
                    onCollectionMerged.call();
                    return;
                }

                self.mergeRelatedCollection.add(data.models);

                if (!_.isUndefined(data.next_offset) && data.next_offset !== -1) {
                    self._mergeRelatedCollection(collection, callback, data.next_offset);
                } else {
                    onCollectionMerged.call();
                }
            },
            error: function() {
                collection.attempt = collection.attempt + 1;
                self.mergeProgressModel.trigger('massupdate:item:attempt', collection);
                if (collection.attempt <= collection.maxAllowAttempt) {
                    self._mergeRelatedCollection(collection, callback, offset);
                } else {
                    self.mergeStat.total_fetch_errors = self.mergeStat.total_fetch_errors + 1;
                    self.mergeProgressModel.trigger('massupdate:item:fail', collection);
                    onCollectionMerged.call();
                }
            }
        });
    },

    /**
     * Create the Progress view unless it is initialized.
     * Return the progress view component in the same layout.
     *
     * @return {Backbone.View} MergeDuplicatesProgress view component.
     * @protected
     */
    _getProgressView: function() {
        var progressView = this.layout.getComponent('merge-duplicates-progress');
        if (!progressView) {
            progressView = app.view.createView({
                context: this.context,
                type: 'merge-duplicates-progress',
                layout: this.layout,
                model: this.mergeProgressModel
            });
            this.layout._components.push(progressView);
            this.layout.$el.append(progressView.$el);
        }
        progressView.render();
        return progressView;
    },

    /**
     * Displays alert message with last merge related records stat.
     *
     * @protected
     */
    _showSuccessMessage: function() {
        app.alert.show('mergerelated_final_notice', {
            level: 'success',
            messages: app.lang.get('TPL_MERGE_DUPLICATES_STAT', this.module, {
                stat: this.mergeStat
            }),
            autoClose: true,
            autoCloseDelay: 8000
        });
    },

    /**
     * @inheritdoc
     *
     * Override 'reset' event for collection to setup first model ar primary.
     */
    bindDataChange: function() {
        if (!this.collection) {
            return;
        }
        this.collection.on('reset', function(coll) {
            if (coll.length) {
                _.each(coll.models, function(model) {
                    model.readonly = !app.acl.hasAccessToModel('edit', model);
                }, this);
                this.setPrimaryRecord(this._findPrimary(coll.models));
            }
            if (this.disposed) {
                return;
            }
            this.render();
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Off all events on primary model.
     */
    _dispose: function() {
        if (!_.isEmpty(this.primaryRecord)) {
            this.primaryRecord.off(null, null, this);
        }
        this._super('_dispose');
    }
}) },
"merge-duplicates-progress": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MergeDuplicatesProgressView
 * @alias SUGAR.App.view.views.BaseMergeDuplicatesProgressView
 * @extends View.Views.Base.MassupdateProgressView
 */
({
	// Merge-duplicates-progress View (base) 

    extendsFrom: 'MassupdateProgressView',

    plugins: ['editable'],

    /**
     * @inheritdoc
     */
    _labelSet: {
        TITLE: 'LBL_MERGE_DUPLICATES_TITLE',
        PROGRESS_STATUS: 'TPL_MERGE_DUPLICATES_PROGRESS_STATUS',
        FAIL_TO_ATTEMPT: 'TPL_MERGE_DUPLICATES_FAIL_TO_ATTEMPT',
        FAIL: 'TPL_MERGE_DUPLICATES_FAIL'
    },

    /**
     * @property {Number} processedCount Number of processed elements.
     */
    processedCount: 0,

    /**
     * @property {Number} failsCount Number of fails.
     */
    failsCount: 0,

    /**
     * @inheritdoc
     */
    initLabels: function() {
        this.LABELSET = this._labelSet;
    },

    /**
     * Reset view parameters.
     */
    reset: function() {
        this.processedCount = 0;
        this.failsCount = 0;
        this.totalRecord = 0;
    },

    /**
     * @inheritdoc
     *
     * There are no conditions to check.
     */
    checkAvailable: function() {
        return true;
    },

    /**
     * @inheritdoc
     *
     * No estimate used.
     */
    getEstimate: function() {
        return 0;
    },

    /**
     * Set number of total elements for progress.
     *
     * @param {Number} total Number of total records.
     */
    setTotalRecords: function(total) {
        this.totalRecord = total;
    },

    /**
     * @inheritdoc
     */
    getTotalRecords: function() {
        return this.totalRecord;
    },

    /**
     * @inheritdoc
     */
    getRemainder: function() {
        return '';
    },

    /**
     * Setup count of processed elements.
     *
     * @param {Number} count Count of processed elements.
     */
    setProgressSize: function(count) {
        this.processedCount;
    },

    /**
     * Increments count of processed elements.
     */
    incrementProgressSize: function() {
        this.processedCount = this.processedCount + 1;
    },

    /**
     * @inheritdoc
     */
    getProgressSize: function() {
        return this.processedCount;
    },

    /**
     * @inheritdoc
     *
     * @param {Object} context Object to check errors.
     */
    checkError: function(context) {
        if (_.isUndefined(context) || _.isUndefined(context.attempt)) {
            return;
        }

        if (context.attempt === 0 ||
            context.attempt > (context.maxAllowAttempt || 3)
        ) {
            return;
        }

        app.alert.dismiss('check_error_message');
        app.alert.show('check_error_message', {
            level: 'warning',
            messages: app.lang.get(this.LABELSET['FAIL_TO_ATTEMPT'], this.module, {
                objectName: context.objectName || '',
                num: context.attempt,
                total: (context.maxAllowAttempt || 3)
            }),
            autoClose: true,
            autoCloseDelay: 8000
        });
    },

    /**
     * Handler for drawer `reset` event.
     * @return {boolean}
     */
    _onDrawerReset: function() {
        this.showProgress();
        return false;
    },

    /**
     * @inheritdoc
     *
     * Setup handler for drawer to prevent closing it.
     * We need it b/ the operation an be too long and in this time
     * token can be expired.
     */
    showProgress: function() {
        app.drawer.before('reset', this._onDrawerReset, this);
        this._super('showProgress');
    },

    /**
     * Update the progress view when the job is paused.
     * Triggers `massupdate:pause:completed` event on model.
     */
    pauseProgress: function() {
        var stopButton = this.getField('btn-stop');
        if (stopButton) {
            stopButton.setDisabled(true);
        }
        this.$holders.bar.removeClass('active');
        this.model.trigger('massupdate:pause:completed');
    },

    /**
     * Update the progress view when the job is resumed.
     * Triggers `massupdate:resume:completed` event on model.
     */
    resumeProgress: function() {
        var stopButton = this.getField('btn-stop');
        if (stopButton) {
            stopButton.setDisabled(false);
        }
        this.model.trigger('massupdate:resume:completed');
    },

    /**
     * Update the progress view when the job is stopped.
     * Triggers `massupdate:stop:completed` event on model.
     */
    stopProgress: function() {
        this.model.trigger('massupdate:stop:completed');
    },

    /**
     * @inheritdoc
     *
     * Dismiss alerts:
     * 1. `stop_confirmation` - confirmation on pause
     * 2. `check_error_message` - check errors status alert
     * Triggers `massupdate:end:completed` event on model.
     * Removes handler for drawer.
     */
    hideProgress: function() {
        app.drawer.offBefore('reset', this._onDrawerReset, this);
        this.hide();
        app.alert.dismiss('stop_confirmation');
        app.alert.dismiss('check_error_message');
        this.model.trigger('massupdate:end:completed');
    },

    /**
     * Called with new item is processed.
     *
     * Increments number of processed elements and
     * calls {@link View.MergeDuplicatesProgressView#updateProgress}.
     * Triggers `massupdate:item:processed:completed` event on model.
     */
    onItemProcessed: function() {
        this.incrementProgressSize();
        this.updateProgress();
        this.model.trigger('massupdate:item:processed:completed');
    },

    /**
     * Called when item go to next attemp.
     * Triggers `massupdate:item:attempt:completed` event on model.
     *
     * @param {Object} context Object that triggered event.
     */
    onNextAttept: function(context) {
        this.checkError(context);
        this.model.trigger('massupdate:item:attempt:completed');
    },

    /**
     * Called when item cannot be processed after a few attemps.
     *
     * Shows error message.
     * Triggers `massupdate:item:fail:completed` event on model.
     *
     * @param {Object} context Object that triggered event.
     */
    onItemFail: function(context) {
        this.failsCount = this.failsCount + 1;
        this.$holders.bar
            .removeClass('progress-info')
            .addClass('progress-danger');

        app.alert.dismiss('fail_message');
        app.alert.show('fail_message', {
            level: 'error',
            messages: app.lang.get(this.LABELSET['FAIL'], this.module, {
                objectName: context.objectName || ''
            })
        });
        this.model.trigger('massupdate:item:fail:completed');
    },

    /**
     * @inheritdoc
     *
     * Use model to listen events insted of collection.
     */
    bindDataChange: function() {
        if (!this.model) {
            return;
        }
        this.on('render', this.initHolders, this);
        this.before('start', this.checkAvailable, this);
        this.model.on('massupdate:always', this.updateProgress, this);
        this.model.on('massupdate:start', this.showProgress, this);
        this.model.on('massupdate:end', this.hideProgress, this);
        this.model.on('massupdate:fail', this.checkError, this);
        this.model.on('massupdate:resume', this.resumeProgress, this);
        this.model.on('massupdate:pause', this.pauseProgress, this);
        this.model.on('massupdate:stop', this.stopProgress, this);
        this.model.on('massupdate:item:processed', this.onItemProcessed, this);
        this.model.on('massupdate:item:attempt', this.onNextAttept, this);
        this.model.on('massupdate:item:fail', this.onItemFail, this);
    }
}) },
"quicksearch-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.QuicksearchButtonView
 * @alias SUGAR.App.view.fields.BaseQuicksearchButtonView
 * @extends View.View
 */
({
	// Quicksearch-button View (base) 

    className: 'quicksearch-button-wrapper',

    events: {
        'click [data-action=search_icon]' : 'searchIconClickHandler'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        // Listener for `quicksearch:close`.
        this.layout.on('quicksearch:close', function() {
            if (!this.context.get('search')) {
                this.toggleSearchIcon(true);
            }
        }, this);

        /**
         * Used for keyboard up/down arrow navigation between components of `globalsearch` layout
         *
         * @property {boolean}
         */
        this.isFocusable = false;

        /**
         * Used for indicating the state of the button icon.
         *
         * @property {boolean}
         * - `true` means magnifying glass.
         * - `false` means X icon.
         */
        this.searchButtonIcon = true;

        this.layout.on('quicksearch:button:toggle', this.toggleSearchIcon, this);
    },


    /**
     * Toggles the search icon between the magnifying glass and x.
     *
     * @param {boolean} searchButtonIcon Indicates the state of the search button icon
     * - `true` means magnifying glass.
     * - `false` means X icon.
     */
    toggleSearchIcon: function(searchButtonIcon) {
        if (this.searchButtonIcon === searchButtonIcon) {
            return;
        }
        var iconEl = this.$('[data-action=search_icon] .fa').first();
        this.searchButtonIcon = searchButtonIcon;
        if (searchButtonIcon) {
            iconEl.removeClass('fa-times');
            iconEl.addClass('fa-search');
        } else {
            iconEl.removeClass('fa-search');
            iconEl.addClass('fa-times');
        }
    },

    /**
     * Handler for clicks on the search icon (or x, depending on state).
     */
    searchIconClickHandler: function() {
        if (this.searchButtonIcon) {
            if (this.layout.isResponsiveMode) {
                this.layout.trigger('quicksearch:expand');
            } else {
                this.layout.trigger('quicksearch:bar:search');
            }
        } else {
            this.layout.trigger('quicksearch:bar:clear');
            this.layout.trigger('quicksearch:close');
        }
    }
}) },
"quicksearch-modulelist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchModuleListView
 * @alias SUGAR.App.view.views.BaseQuicksearchModuleListView
 * @extends View.View
 */
({
	// Quicksearch-modulelist View (base) 

    className: 'table-cell quicksearch-modulelist-wrapper',
    plugins: ['Dropdown'],
    dropdownItemSelector: '[data-action=select-module], [data-action=select-all]',

    events: {
        'click [data-action=select-all]': 'selectAllModules',
        'click [data-action=select-module]': 'selectModule',
        'keydown [data-action=select-all]': 'allModulesKeydownHandler',
        'keydown [data-action=select-module]': 'moduleKeydownHandler',
        'click [data-toggle=dropdown]': 'moduleDropdownClick'
    },

    // List of modules that should not be included in the module list
    blacklistModules: ['Tags'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.hide();

        this.collection = this.layout.collection || app.data.createMixedBeanCollection();

        /**
         * A collection of the available modules.
         *
         * @type {Backbone.Collection}
         */
        this.searchModuleFilter = new Backbone.Collection(null, {
            //adds models in alphabetical order of model's id's module name translation
            comparator: function(model) {
                return app.lang.getModuleName(model.id, {plural: true});
            }
        });

        /**
         * The lastState key for local storage.
         *
         * @type {String}
         */
        this.stateKey = app.user.lastState.buildKey('quicksearch', 'modulelist', this.name);

        /**
         * Template for the module icons in the search bar.
         *
         * @type {Handlebars.Template}
         * @private
         */
        this._moduleIconTemplate = app.template.getView(this.name + '.module-avatar');

        /**
         * Data structure for the display of the module icons.
         *
         * @type {Object}
         */
        this.moduleIcons = {};

        // When the app is ready, fetch the searchable modules and put them in
        // the module list dropdown. This cannot be in the initialize because
        // when initialize is called, the only module available is login.
        app.events.on('app:sync:complete', function() {
            this.populateModules();
            // If there is a module preference stored in local storage,
            // default selection to those modules.
            var previousModuleSelection = app.user.lastState.get(this.stateKey);
            if (_.isEmpty(previousModuleSelection)) {
                this.searchModuleFilter.allSelected = true;
            } else {
                _.each(previousModuleSelection, function(module) {
                    this.searchModuleFilter.get(module).set('selected', true);
                }, this);
            }
            this._setSelectedModules();
            // Prepare the module icons for display
            var moduleIconObj = this._buildModuleIconList();
            this.moduleIcons = {icon: moduleIconObj};
            this.render();
            this.layout.off('route:search', this.populateModuleSelectionFromContext);
            this.layout.on('route:search', this.populateModuleSelectionFromContext, this);

            // We need to call `populateModuleSelectionFromContext` here to
            // update the module icons if the user navigates directly to the
            // search page from outside Sugar. In this use case,
            // 'quicksearch-modulelist.js' is initialized and needs to update
            // the module icons to be in sync with the ones in the url.
            this.populateModuleSelectionFromContext();
        }, this);

        // On expansion of quicksearch, show the module dropdown & buttons.
        this.layout.on('quicksearch:expanded', this.show, this);

        // On collapse of quicksearch, hide the module dropdown & buttons.
        this.layout.on('quicksearch:collapse', this.hide, this);

        // Whenever anything happens within the quicksearch layout navigation,
        // close the module list dropdown.
        this.layout.on('navigate:next:component navigate:previous:component navigate:to:component', function() {
            this.$el.removeClass('open');
        }, this);
    },

    /**
     * Populate the module selection from the search context.
     */
    populateModuleSelectionFromContext: function() {
        // Reset all the selections
        var previousModuleSelection = this.context.get('module_list');
        this.searchModuleFilter.invoke('set', {selected: false});
        this.$('[data-action=select-module]').removeClass('selected');

        // Handle the 'all selected' case
        if (_.isEmpty(previousModuleSelection)) {
            this.searchModuleFilter.allSelected = true;
            this.$('[data-action=select-all]').addClass('selected');
            // A specific set of modules have been selected.
        } else {
            this.searchModuleFilter.allSelected = false;
            this.$('[data-action=select-all]').removeClass('selected');
            _.each(previousModuleSelection, function(module) {
                var moduleFilter = this.searchModuleFilter.get(module);
                if (moduleFilter) {
                    moduleFilter.set('selected', true);
                    this.$('[data-action=select-module][data-module=' + module + ']').addClass('selected');
                }
            }, this);
        }
        this._setSelectedModules();
        this._updateModuleIcons();
    },

    /**
     * Handle module 'select/unselect' event.
     *
     * @param {Event} event
     */
    selectModule: function(event) {
        // We need to stop propagation for two reasons:
        // 1) Stop scrolling when using the spacebar.
        // 2) Prevent collapse of the `quicksearch` layout. The module list is
        // considered inside the dropdown plugin, and not in the layout. Clicks
        // outside the layout normally collapse the layout.
        event.stopImmediatePropagation();
        var $li = $(event.currentTarget);
        var module = $li.data('module');
        var moduleModel = this.searchModuleFilter.get(module);

        // If all the modules were selected, we unselect all of them first.
        if (this.searchModuleFilter.allSelected) {
            this.$('[data-action=select-all]').removeClass('selected', false);
            this.searchModuleFilter.allSelected = false;
        }

        // Then we select the clicked module.
        var checkModule = !moduleModel.get('selected');
        moduleModel.set('selected', checkModule);
        $li.toggleClass('selected', checkModule);

        // Check to see if all the modules are now all selected or unselected.
        var selectedLength = this.searchModuleFilter.where({'selected': true}).length;

        // All modules are selected, set them all to unselected.
        if (selectedLength === this.searchModuleFilter.length) {
            this.searchModuleFilter.invoke('set', {selected: false});
            selectedLength = 0;
        }

        // If all modules are now unselected, update checkboxes and set the
        // `allSelected` property of the filter.
        if (selectedLength === 0) {
            this.searchModuleFilter.allSelected = true;
            this.$('[data-action=select-all]').addClass('selected');
            this.$('[data-action=select-module]').removeClass('selected');
        }

        this._setSelectedModules();
        this._updateModuleIcons();
    },

    /**
     * Handle clicks on the "Search all" list item.
     * @param {event} event
     */
    selectAllModules: function(event) {
        // We need to stop propagation for two reasons:
        // 1) Stop scrolling when using the spacebar.
        // 2) Prevent collapse of the `quicksearch` layout. The module list is
        // considered inside the dropdown plugin, and not in the layout. Clicks
        // outside the layout normally collapse the layout.
        event.stopImmediatePropagation();

        // Selects all modules.
        this.$('[data-action=select-all]').addClass('selected');
        this.$('[data-action=select-module]').removeClass('selected');
        this.searchModuleFilter.invoke('set', {selected: false});
        this.searchModuleFilter.allSelected = true;

        this._setSelectedModules();
        this._updateModuleIcons();
    },

    /**
     * Handles the keydown events on the "All Modules" checkbox.
     * On spacebar, trigger the same functionality as a click.
     *
     * @param {Event} event The `keydown` event
     */
    allModulesKeydownHandler: function(event) {
        if (event.keyCode === 32) { // space bar
            this.selectAllModules(event);
            event.preventDefault();
        }
    },

    /**
     * Handles the keydown events on the module list items.
     * On spacebar, trigger the same functionality as a click.
     *
     * @param {Event} event The `keydown` event
     */
    moduleKeydownHandler: function(event) {
        if (event.keyCode === 32) { // space bar
            this.selectModule(event);
            event.preventDefault();
        }
    },

    /**
     * Trigger `quicksearch:results:close` when the module dropdown is clicked.
     */
    moduleDropdownClick: function() {
        this.layout.trigger('quicksearch:results:close');
    },

    /**
     * Updates the modules icons in the search bar, based on the currently
     * selected modules.
     *
     * @private
     */
    _updateModuleIcons: function() {
        // Update the module icons in the search bar.
        var $moduleIconContainer = this.$('[data-label=module-icons]');
        $moduleIconContainer.empty();
        var moduleIconObj = this._buildModuleIconList();

        $moduleIconContainer.append(this._moduleIconTemplate({icon: moduleIconObj}));
    },

    /**
     * Builds an array of objects for displaying the module icons.
     * @return {Array}
     * @private
     */
    _buildModuleIconList: function() {
        var moduleIconObj = [];
        // If all modules are selected, display "all" icon.
        if (this.collection.selectedModules.length === 0) {
            moduleIconObj.push({});
            // If 3 or fewer selected, display the module icons that are selected.
        } else if (this.collection.selectedModules.length <= 3) {
            _.each(this.collection.selectedModules, function(module) {
                moduleIconObj.push({module: module});
            }, this);
            // If there are more than 3 modules selected, display the
            // "Multiple Modules" icon
        } else {
            moduleIconObj.push({multiple: true});
        }
        return moduleIconObj;
    },

    /**
     * Populate `this.searchModuleFilter` with the searchable modules, using
     * acls and the metadata attribute `checkGlobalSearchEnabled`.
     */
    populateModules: function() {
        if (this.disposed) {
            return;
        }

        //Reset the collection of module filters so we don't add duplicate
        //elements to the original collection.
        this.searchModuleFilter.reset();
        var modules = app.metadata.getModules() || {};

        //filter the module names out based on global search enabled, has
        //access to acl, and is not a blacklisted module
        _.each(modules, function(meta, module) {
            if (meta.globalSearchEnabled &&
                app.acl.hasAccess.call(app.acl, 'view', module) &&
                !_.contains(this.blacklistModules, module)
            ) {
                var moduleModel = new Backbone.Model({id: module, selected: false});
                this.searchModuleFilter.add(moduleModel);
            }
        }, this);
    },

    /**
     * Store the selected modules on the collection and in local storage.
     *
     * @private
     */
    _setSelectedModules: function() {
        var selectedModules = [];
        if (!this.searchModuleFilter.allSelected) {
            this.searchModuleFilter.each(function(model) {
                if (model.get('selected')) {
                    selectedModules.push(model.id);
                }
            });
        }

        this.collection.selectedModules = selectedModules;
        app.user.lastState.set(this.stateKey, this.collection.selectedModules);
    }
}) }
}}
,
"layouts": {
"base": {
"drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DrawerLayout
 * @alias SUGAR.App.view.layouts.BaseDrawerLayout
 * @extends View.Layout
 */
({
	// Drawer Layout (base) 

    backdropHtml: '<div class="drawer-backdrop"></div>',

    onCloseCallback: null, //callbacks to be called once drawers are closed

    scrollTopPositions: [], //stores scroll positions for main and side pane

    pixelsFromFooter: 69, //how many pixels from the footer the drawer will drop down to

    initialize: function(options) {
        var self = this;

        /**
         * The fragments queue of the open drawers.
         *
         * @property {Array}
         * @private
         */
        this._fragments = [];

        if (!this.$el.is('#drawers')) {
            app.logger.error('Drawer layout can only be included as an Additional Component.');
            return;
        }

        app.drawer = this;
        this.onCloseCallback = [];

        // define the states the drawer can be in
        this.STATES = {
            IDLE: 'idle',
            OPENING: 'opening',
            CLOSING: 'closing'
        };
        // start in the IDLE state; the drawer will be IDLE most of the time
        this._enterState(this.STATES.IDLE);

        //clear out drawers before routing to another page
        this.name = 'drawer';

        app.view.Layout.prototype.initialize.call(this, options);

        // Browser find functionality auto-scrolls even when overflow is set to hidden.
        // Prevent scrolling only when there are active drawers.
        $(window).on('scroll.prevent', function() {
            self._preventScroll($(this));
        });
        app.$contentEl.on('scroll.prevent', function() {
            self._preventScroll($(this));
        });

        app.before('app:view:load', function() {
            return this.reset();
        }, this);
    },

    /**
     * Open the specified layout or view in a drawer.
     *
     * You can pass the current context if you want the context created to be a
     * child of that current context. If you don't pass a `scope`, it will
     * create a child of the main context (`app.controller.context`).
     *
     * @param {Object} def The component definition.
     * @param {Core.Context/Object} [def.context] The context to pass to
     *  the drawer.
     * @param {Core.Context} [def.context.parent] The parent context of
     *  the context to pass to the drawer.
     * @param {Function} [onClose] Callback method when the drawer closes.
     */
    open: function(def, onClose) {
        var component;

        app.shortcuts.saveSession();
        if (!app.triggerBefore('app:view:change')) {
            return;
        }

        this._enterState(this.STATES.OPENING);

        //store the callback function to be called later
        if (_.isUndefined(onClose)) {
            this.onCloseCallback.push(function(){});
        } else {
            this.onCloseCallback.push(onClose);
        }

        //initialize layout definition components
        this._initializeComponentsFromDefinition(def);

        component = _.last(this._components);

        this._updateFragments();

        //scroll both main and sidebar to the top
        this._scrollToTop();

        //open the drawer
        this._animateOpenDrawer(_.bind(function() {
            this._afterOpenActions();
        }, this));

        //load and render new layout in drawer
        component.loadData();
        component.render();
    },

    /**
     * Closes the top-most drawer.
     *
     * @param any parameters passed into the close method will be passed to the
     * callback.
     */
    close: function() {
        var self = this,
            args = Array.prototype.slice.call(arguments, 0);

        this._updateFragments(true);

        if (!Modernizr.csstransitions) {
            this.closeImmediately.apply(this, args);
            return;
        }

        if (this._components.length > 0) {
            if (!app.triggerBefore('app:view:change')) {
                return;
            }

            this._enterState(this.STATES.CLOSING);

            //close the drawer
            this._animateCloseDrawer(function() {
                self._afterCloseActions(args);
            });
        }
    },

    /**
     * Updates the fragments array according to the passed parameter.
     *   - Adds the current fragment to the fragments queue if no
     *   argument or `false` is passed.
     *   - Navigates back to the previous fragment if `true` is passed.
     *
     * @param {boolean} goBack `true` to navigate back to the previous fragment.
     *   No argument or `false` to add the current fragment to the queue.
     * @private
     */
    _updateFragments: function(goBack) {
        var component = _.last(this._components);
        if (!component.context.get('fromRouter')) {
            return;
        }
        if (goBack) {
            this._fragments.pop();
            app.router.navigate(_.last(this._fragments));
            if (this.count() === 1) {
                this._fragments = [];
            }
        } else {
            if (this.count() === 1) {
                this._fragments = [app.router.getPreviousFragment(), app.router.getFragment()];
            } else {
                this._fragments.push(app.router.getFragment());
            }
        }
    },

    /**
     * Close the top-most drawer immediately without transitions.
     *
     * @param any parameters passed into the close method will be passed to the
     * callback
     */
    closeImmediately: function() {
        if (this._components.length > 0) {
            var args = Array.prototype.slice.call(arguments, 0),
                drawers = this._getDrawers(false),
                drawerHeight = this._determineDrawerHeight();

            if (!app.triggerBefore('app:view:change')) {
                return;
            }

            this._enterState(this.STATES.CLOSING);

            //move the bottom drawer to the top and the next drawer to be viewed on the bottom.
            drawers.$bottom.css('top','');
            if (drawers.$next) {
                drawers.$next.css('top', this._isMainAppContent(drawers.$next) ? drawerHeight : drawers.$next.offset().top - drawerHeight);
            }

            this._removeTabAndBackdrop(drawers.$bottom);
            this._cleanUpAfterClose(drawers);
            this._afterCloseActions(args);
        }
    },

    /**
     * Reload the current drawer with a new layout or view.
     *
     * @param def The layout or view definition.
     */
    load: function(def) {
        var comp = this._components.pop(),
            top = comp.$el.css('top'),
            height = comp.$el.css('height'),
            drawers;

        comp.dispose();

        if (!app.triggerBefore('app:view:change')) {
            return;
        }

        this._enterState(this.STATES.OPENING);

        this._initializeComponentsFromDefinition(def);

        drawers = this._getDrawers(true);
        drawers.$next
            .addClass('drawer active')
            .css({
                top: top,
                height: height
            });

        //refresh tab and backdrop
        this._removeTabAndBackdrop(drawers.$top);
        this._createTabAndBackdrop(drawers.$next, drawers.$top);

        comp = _.last(this._components);
        comp.loadData();
        comp.render();

        this._enterState(this.STATES.IDLE);
    },

    /**
     * Retrieves the number of drawers in the stack.
     *
     * @return {Number}
     */
    count: function() {
        return this._components.length;
    },

    /**
     * Test if element is part of active drawer.  Always returns true if there's no inactive components on page.
     * @param el DOM element to test if it is in the active drawer
     * @return boolean
     */
    isActive: function(el) {
        return ((this.count() === 0) || ($(el).parents('.drawer.active').length > 0));
    },

    /**
     * Gets the active drawer.
     *
     * @return {View.Component} The active drawer's component. `undefined` if
     *   no drawer is open.
     */
    getActive: function() {
        return _.last(this._components);
    },

    /**
     * Get currently active drawer layout.
     *
     * @return {View.Layout}
     * @deprecated Since 7.7. Will be removed in 7.9.
     */
    getActiveDrawerLayout: function() {
        app.logger.warn('Drawer\'s `getActiveDrawerLayout` is deprecated and will be removed in 7.9,' +
            'please use `getActive` instead.');
        return this.count() ? this.getActive() : app.controller.layout;
    },

    /**
     * Remove all drawers and reset
     * @param trigger Indicates whether to triggerBefore (defaults to true if anything other than `false`)
     */
    reset: function(triggerBefore) {
        triggerBefore = triggerBefore === false ? false : true;
        if (triggerBefore && !this.triggerBefore("reset", {drawer: this})) {
            return false;
        }

        var $main = app.$contentEl.children().first();

        this._enterState(this.STATES.CLOSING);

        _.each(this._components, function(component) {
            component.dispose();
        }, this);

        this._components = [];
        this.onCloseCallback = [];

        if ($main.hasClass('drawer')) {
            $main
                .removeClass('drawer inactive')
                .removeAttr('aria-hidden')
                .css('top','');
            this._removeTabAndBackdrop($main);
        }

        $('body').removeClass('noscroll');
        app.$contentEl.removeClass('noscroll');

        this._enterState(this.STATES.IDLE);
    },

    /**
     * Force to create a new context and create components from the layout/view
     * definition. If the parent context is defined, make the new context as a
     * child of the parent context.
     *
     * @param {Object} def The layout or view definition.
     * @private
     */
    _initializeComponentsFromDefinition: function(def) {
        var parentContext;

        if (_.isUndefined(def.context)) {
            def.context = {};
        }

        if (_.isUndefined(def.context.forceNew)) {
            def.context.forceNew = true;
        }

        if (!(def.context instanceof app.Context) && def.context.parent instanceof app.Context) {
            parentContext = def.context.parent;
            // Remove the `parent` property to not mess up with the context
            // attributes.
            delete def.context.parent;
        }

        this.initComponents([def], parentContext);
    },

    /**
     * Animate opening of a new drawer.
     *
     * @private
     * @param {Function} callback Called when open animation is finished.
     */
    _animateOpenDrawer: function(callback) {
        if (this._components.length === 0) {
            this._enterState(this.STATES.IDLE);
            return;
        }

        var drawers = this._getDrawers(true),
            drawerHeight = this._determineDrawerHeight(),
            topDrawerCurrentTopPos = drawers.$top.offset().top,
            aboveWindowTopPos = topDrawerCurrentTopPos - drawerHeight, //top position above the browser window
            bottomDrawerTopPos = this._isMainAppContent(drawers.$top) ? drawerHeight : topDrawerCurrentTopPos + drawerHeight,
            belowWindowTopPos; //top position below the browser window

        if (drawers.$bottom) {
            belowWindowTopPos = drawers.$bottom.offset().top + drawerHeight
        }

        if (this._isMainAppContent(drawers.$top)) {
            //make sure that the main application content is set as a drawer
            drawers.$top.addClass('drawer');
            $('body').addClass('noscroll');
            app.$contentEl.addClass('noscroll');
        }

        //add the expand tab and the backdrop to the top drawer
        this._createTabAndBackdrop(drawers.$next, drawers.$top);

        //indicate that it's an active drawer
        drawers.$next.addClass('drawer active');
        //set the height of the new drawer
        drawers.$next.css('height', drawerHeight);
        //set the animation starting point for the new drawer
        drawers.$next.css('top', aboveWindowTopPos);
        //mark the top drawer as inactive
        drawers.$top
            .addClass('inactive')
            .removeClass('active')
            .attr('aria-hidden', true); //accessibility
        //prevent scrolling on drawer
        drawers.$top.on('scroll.prevent', _.bind(function() {
            this._preventScroll(drawers.$top);
        }, this));

        // Need to do a defer so that transition can be applied when the drawer is coming down
        // but not when it's being setup above browser window.
        _.defer(_.bind(function() {
            this._setTransition(drawers);
            this._onTransitionEnd(drawers.$next, function() {
                this._removeTransition(drawers);
                if (_.isFunction(callback)) {
                    callback();
                }
                this.trigger('drawer:resize', drawerHeight);
            });

            //start animation to open the drawer
            drawers.$next.css('top','');
            drawers.$top.css('top', bottomDrawerTopPos);
            if (drawers.$bottom) {
                drawers.$bottom.css('top', belowWindowTopPos);
            }

            //resize the visible drawer when the browser resizes
            if (this._components.length === 1) {
                $(window).on('resize.drawer', _.bind(this._resizeDrawer, this));
            }
        }, this));
    },

    /**
     * Animate closing of the top-most drawer.
     *
     * @param {Function} callback Function to be called after drawer has been
     * closed.
     * @private
     */
    _animateCloseDrawer: function(callback) {
        if (this._components.length === 0) {
            this._enterState(this.STATES.IDLE);
            return;
        }

        var drawers = this._getDrawers(false),
            drawerHeight = this._determineDrawerHeight(),
            aboveWindowTopPos = drawers.$top.offset().top - drawerHeight, //top position above the browser window
            bottomDrawerTopPos; //top position of the bottom drawer

        if (drawers.$next) {
            bottomDrawerTopPos = this._isMainAppContent(drawers.$next) ? drawerHeight : drawers.$next.offset().top - drawerHeight;
        }

        this._setTransition(drawers);
        this._onTransitionEnd(drawers.$bottom, function() {
            this._removeTransition(drawers);
            this._cleanUpAfterClose(drawers);
            if (_.isFunction(callback)) {
                callback();
            }
        });

        //start the animation to close the drawer
        drawers.$top.css('top', aboveWindowTopPos);
        drawers.$bottom.css('top','');
        if (drawers.$next) {
            drawers.$next.css('top', bottomDrawerTopPos);
        }

        this._removeTabAndBackdrop(drawers.$bottom);
    },

    /**
     * Get all (top, bottom, next) drawers layouts depending upon whether or not
     * a drawer is being opened or closed.
     *
     * @param {boolean} open `true` if the drawer is being opened.
     * @return {Object}
     * @private
     */
    _getDrawers: function(open) {
        var $main = app.$contentEl.children().first(),
            $nextDrawer, $topDrawer, $bottomDrawer,
            open = _.isUndefined(open) ? true : open,
            drawerCount = this._components.length;

        switch (drawerCount) {
            case 0: //no drawers
                break;
            case 1: //only one drawer
                $nextDrawer = open ? this._components[drawerCount-1].$el : undefined;
                $topDrawer = open ? $main : this._components[drawerCount-1].$el;
                $bottomDrawer = open? undefined : $main;
                break;
            case 2: //two drawers
                $nextDrawer = open ? this._components[drawerCount-1].$el : $main;
                $topDrawer = open ? this._components[drawerCount-2].$el : this._components[drawerCount-1].$el;
                $bottomDrawer = open? $main : this._components[drawerCount-2].$el;
                break;
            default: //more than two drawers
                $nextDrawer = open ? this._components[drawerCount-1].$el : this._components[drawerCount-3].$el;
                $topDrawer = open ? this._components[drawerCount-2].$el : this._components[drawerCount-1].$el;
                $bottomDrawer = open? this._components[drawerCount-3].$el : this._components[drawerCount-2].$el;
        }

        return {
            $next: $nextDrawer,
            $top: $topDrawer,
            $bottom: $bottomDrawer
        };
    },

    /**
     * Is this drawer the main application content area?
     * @param $layout
     * @return {Boolean}
     * @private
     */
    _isMainAppContent: function($layout) {
        return !$layout.parent().is(this.$el);
    },

    /**
     * Calculate how far down the drawer should drop down, i.e. the height of the drawer
     * @param $mainContent
     * @return {Number}
     * @private
     */
    _determineDrawerHeight: function() {
        var windowHeight = $(window).height(),
            headerHeight = $('#header .navbar').outerHeight(),
            footerHeight = $('footer').outerHeight();

        return windowHeight - headerHeight - footerHeight - this.pixelsFromFooter;
    },

    /**
     * Calculate how much to collapse the drawer
     * @return {Number}
     * @private
     */
    _determineCollapsedHeight: function() {
        return $(window).height()/2; //middle of the window
    },

    /**
     * Create tab and the backdrop. Add the ability to expand and collapse the drawer when the tab is clicked
     * @param $top
     * @param $bottom
     * @private
     */
    _createTabAndBackdrop: function($top, $bottom) {
        var $drawerTab;

        //add the expand tab and the backdrop to the top drawer
        this.expandTpl = app.template.getLayout(this.name + '.expand');
        this.expandTabHtml = this.expandTpl();

        $bottom
            .append(this.expandTabHtml)
            .append(this.backdropHtml);

        //add tooltip
        $drawerTab = $bottom.find('.drawer-tab');

        //add expand/collapse tab behavior
        $drawerTab.on('click', _.bind(function(event) {
            if ($('i', event.currentTarget).hasClass('fa-chevron-up')) {
                this._collapseDrawer($top, $bottom);
            } else {
                this._expandDrawer($top, $bottom);
            }
            return false;
        }, this));
        app.accessibility.run($drawerTab, 'click');
    },

    /**
     * Remove the tab and the backdrop and the event listener that handles the ability to expand and collapse the drawer.
     * @param $drawer
     * @private
     */
    _removeTabAndBackdrop: function($drawer) {
        //remove drawer tab
        var $drawerTab = $drawer.find('.drawer-tab')
            .off('click')
            .remove();

        //remove backdrop
        $drawer.find('.drawer-backdrop')
            .remove();
    },

    /**
     * Process clean up after the drawer has been closed.
     * @param {Object} drawers Object of drawers ({@link #_getDrawers})
     * @private
     */
    _cleanUpAfterClose: function(drawers) {
        drawers.$top.removeClass('active');

        drawers.$bottom
            .removeClass('inactive')
            .addClass('active')
            .removeAttr('aria-hidden') //accessibility
            .off('scroll.prevent'); //remove event handler that prevents scrolling

        if (this._isMainAppContent(drawers.$bottom)) {
            drawers.$bottom.removeClass('drawer active');
            $('body').removeClass('noscroll');
            app.$contentEl.removeClass('noscroll');
        } else {
            //refresh drawer position and height for collapsed or resized drawers
            this._expandDrawer(drawers.$bottom, drawers.$next);
        }

        //set scrollable elements back its original position
        this._scrollBackToOriginal(drawers.$bottom);

        //remove resize handler
        if (this._components.length === 1) {
            $(window).off('resize.drawer');
        }
    },

    /**
     * Trigger view change event and return to idle state.
     *
     * @private
     */
    _afterOpenActions: function() {
        var layout = _.last(this._components);

        // Forecasts config route uses the drawer but if user
        // does not have access, initialize is never called so the
        // context on the layout never gets set. Adding check to make
        // sure there actually is a context to use on the layout
        if (layout.context) {
            app.trigger('app:view:change', layout.options.type, _.extend(layout.context.attributes, {drawer: true}));
        }

        this._enterState(this.STATES.IDLE);
    },

    /**
     * Trigger view change event and restore shortcuts session.
     * @param {array} callbackArgs Arguments that will be passed to the callback
     * @private
     */
    _afterCloseActions: function(callbackArgs) {
        var layout;
        var topDrawer;
        var closeCallback;

        topDrawer = this._components.pop();
        if (topDrawer) {
            topDrawer.dispose(); //dispose top-most drawer
        }

        layout = _.last(this._components);
        if (layout) { // still have layouts in the drawer
            app.trigger('app:view:change', layout.options.type, layout.context.attributes);
        } else { //we've returned to base layout
            app.trigger('app:view:change', app.controller.context.get('layout'),
                _.extend(app.controller.context.attributes, {drawer: true}));
        }

        this._enterState(this.STATES.IDLE);

        app.shortcuts.restoreSession();

        closeCallback = this.onCloseCallback.pop();
        if (closeCallback) {
            closeCallback.apply(window, callbackArgs); //execute callback
        }
    },

    /**
     * Expand the drawer.
     * @param {jQuery} $top The top drawer
     * @param {jQuery} $bottom The bottom drawer
     * @private
     */
    _expandDrawer: function($top, $bottom) {
        var expandHeight = this._determineDrawerHeight();
        $top.css('height', expandHeight);

        if (this._isMainAppContent($bottom)) {
            $bottom.css('top', expandHeight);
        } else {
            $bottom.css('top', expandHeight + $top.offset().top);
        }

        $bottom
            .find('.drawer-tab i')
            .removeClass('fa-chevron-down')
            .addClass('fa-chevron-up');

        this.trigger('drawer:resize', expandHeight);
    },

    /**
     * Collapse the drawer.
     * @param {jQuery} $top The top drawer
     * @param {jQuery} $bottom The bottom drawer
     * @private
     */
    _collapseDrawer: function($top, $bottom) {
        var collapseHeight = this._determineCollapsedHeight();
        $top.css('height', collapseHeight);

        if (this._isMainAppContent($bottom)) {
            $bottom.css('top', collapseHeight);
        } else {
            $bottom.css('top', collapseHeight + $top.offset().top);
        }

        $bottom
            .find('.drawer-tab i')
            .removeClass('fa-chevron-up')
            .addClass('fa-chevron-down');

        this.trigger('drawer:resize', collapseHeight);
    },

    /**
     * Add transition to the drawers.
     * @param {Object} drawers Object of drawers ({@link #_getDrawers})
     * @private
     */
    _setTransition: function(drawers) {
        drawers.$top.addClass('transition');

        if (drawers.$next) {
            drawers.$next.addClass('transition');
        }

        if (drawers.$bottom) {
            drawers.$bottom.addClass('transition');
        }
    },

    /**
     * Remove transition from the drawers.
     * @param {Object} drawers Object of drawers ({@link #_getDrawers})
     * @private
     */
    _removeTransition: function(drawers) {
        drawers.$top.removeClass('transition');

        if (drawers.$next) {
            drawers.$next.removeClass('transition');
        }

        if (drawers.$bottom) {
            drawers.$bottom.removeClass('transition');
        }
    },

    /**
     * Is the drawer in a middle of a transition?
     * @param {jQuery} drawer top, bottom, or next drawer layout
     * @return {boolean}
     * @private
     */
    _isInTransition: function(drawer) {
        return drawer.hasClass('transition');
    },

    /**
     * Attach transition end event handler for a given drawer.
     * @param {jQuery} $drawer Drawer to attach the event
     * @param {Function} callback Event handler
     * @private
     */
    _onTransitionEnd: function($drawer, callback) {
        var self = this,
            transitionEndEvents = 'webkitTransitionEnd oTransitionEnd otransitionend transitionend msTransitionEnd';

        //once the animation is done, reset to original state and execute callback parameter
        $drawer.one(transitionEndEvents, function() {
            $drawer.off(transitionEndEvents); //some browsers fire multiple transitionend events
            callback.call(self);
        });

        //this is a failsafe to ensure that drawer will always close
        //in Chrome the css change to 'top' sometimes (randomly) doesn't actually change the css value
        _.delay(function() {
            $drawer.trigger('transitionend');
        }, 400);
    },

    /**
     * Scroll the scrollable divs to the top and save its position.
     * Content needs to be scrolled as well because in small width screens,
     * the responsive layout changes the #content div to be a scrollable container
     * @private
     */
    _scrollToTop: function() {
        var drawers = this._getDrawers(true),
            $mainpane = drawers.$top.find('.main-pane'),
            $sidepane = drawers.$top.find('.sidebar-content'),
            $content = app.$contentEl;

        this.scrollTopPositions.push({
            main: $mainpane.scrollTop(),
            side: $sidepane.scrollTop(),
            drawer: drawers.$top.scrollTop(),
            content: $content.scrollTop()
        });

        drawers.$top.scrollTop(0);
        $mainpane.scrollTop(0);
        $sidepane.scrollTop(0);
        $content.scrollTop(0);
    },

    /**
     * Scroll the scrollable elements back to its original position.
     * @param {jQuery} [$drawer] Drawer to scroll back
     * @private
     */
    _scrollBackToOriginal: function($drawer) {
        var scrollPositions = this.scrollTopPositions.pop();

        if (!scrollPositions || !scrollPositions.length) {
            return;
        }

        if ($drawer) {
            $drawer.scrollTop(scrollPositions.drawer);
        } else {
            $drawer = app.$contentEl;
        }

        $drawer.find('.main-pane').scrollTop(scrollPositions.main);
        $drawer.find('.sidebar-content').scrollTop(scrollPositions.side);
        app.$contentEl.scrollTop(scrollPositions.content);
    },

    /**
     * Get the current height of the active drawer
     * @return {Number}
     */
    getHeight: function(){
        if (_.isEmpty(this._components)) {
            return 0; // No drawers on page
        }
        var $top = this._getDrawers(false).$top;
        return $top.height();
    },

    /**
     * Prevent scrolling when drawer is open.  This feature is needed because browsers
     * automatically scroll when the Find feature is used (Ctrl+F) even when the scrollable
     * elements have been set with hidden overflow.
     * @param {jQuery} $scrollable Scrollable element that needs to be prevented from scrolling
     * @private
     */
    _preventScroll: function($scrollable) {
        // Preventing scrolls in iOS 7 causes AJAX calls to be paused (MAR-2768). No problems in iOS 8.
        if (!Modernizr.touch && (app.drawer.count() > 0)) {
            $scrollable.scrollTop(0);
        }
    },

    _dispose: function() {
        this.reset();
        app.offBefore(null, null, this);
        $(window).off('resize.drawer');
        $(window).off('scroll.prevent');
        app.$contentEl.on('scroll.prevent');
        this._super('_dispose');
    },

    /**
     * Resize the height of the drawer by expanding.
     */
    _resizeDrawer: _.throttle(function() {
        var drawers = this._getDrawers(false);
        // Do not resize the drawer when the drawer is opening or closing.
        if (drawers.$top && !this.isOpening() && !this.isClosing()) {
            this._expandDrawer(drawers.$top, drawers.$bottom);
        }
    }, 300),

    /**
     * Enter the drawer into one of the allowed states.
     *
     * @param {string} state
     * @return {string} If the returned state is the same as the previous
     * state, then the parameter was not a valid state.
     * @private
     */
    _enterState: function(state) {
        if (_.contains(this.STATES, state)) {
            this.state = state;
        }

        return this.state;
    },

    /**
     * Confirms or denies that the current state of the drawer is the expected
     * state.
     *
     * @param state
     * @return {boolean}
     */
    isInState: function(state) {
        return state === this.state;
    },

    /**
     * Is the drawer currently in the idle state?
     *
     * The drawer will be in the IDLE state unless a drawer is currently
     * opening or closing.
     *
     * @return {boolean}
     */
    isIdle: function() {
        return this.isInState(this.STATES.IDLE);
    },

    /**
     * Is the drawer currently opening?
     *
     * The drawer will be in the OPENING state while a drawer is opening. Once
     * the open animation has completed, the drawer state is returned to IDLE.
     *
     * @return {boolean}
     */
    isOpening: function() {
        return this.isInState(this.STATES.OPENING);
    },

    /**
     * Is the drawer currently closing?
     *
     * The drawer will be in the CLOSING state while a drawer is closing. Once
     * the close animation has completed, the drawer state is returned to IDLE.
     *
     * @return {boolean}
     */
    isClosing: function() {
        return this.isInState(this.STATES.CLOSING);
    }
}) },
"dupecheck-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DupecheckFilterLayout
 * @alias SUGAR.App.view.layouts.BaseDupecheckFilterLayout
 * @extends View.Layouts.Base.Filter
 */
({
	// Dupecheck-filter Layout (base) 

    extendsFrom: 'FilterLayout',
    initialFilter: 'all_records',

    initialize: function(options) {
        this._super('initialize', [options]);
        this.name = 'filter';

        //initialize the last filter to show all duplicates before allowing user to change the filter
        this.setLastFilter(this.module, this.layoutType, this.initialFilter);
    },

    /**
     * @inheritdoc
     *
     * Override getting relevant context logic in order to filter on current
     * context.
     */
    getRelevantContextList: function() {
        return [this.context];
    },

    /**
     * @inheritdoc
     *
     * Override getting last filter in order to retrieve found duplicates for
     * initial set.
     */
    getLastFilter: function() {
        var lastFilter = this._super('getLastFilter', arguments);
        return (_.isUndefined(lastFilter)) ? this.initialFilter : lastFilter;
    }
}) },
"dashboard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The outer layout of the dashboard.
 *
 * This layout contains the header view and wraps the daslet-main layout.
 * The layouts for each dashboard are stored in the server.
 *
 * @class View.Layouts.Base.DashboardLayout
 * @alias SUGAR.App.view.layouts.BaseDashboardLayout
 * @extends View.Layout
 * @deprecated 7.9 It will be removed in 7.11.
 *   Please use {@link View.Layouts.Dashboards.DashboardLayout} instead.
 */
({
	// Dashboard Layout (base) 

    className: 'row-fluid',
    //FIXME We need to remove this. TY-1132 will address it.
    dashboardLayouts: {
        'record': 'record-dashboard',
        'records': 'list-dashboard',
        'search': 'search-dashboard'
    },
    events: {
        'click [data-action=create]': 'createClicked'
    },
    error: {
        //Dashboard is a special case where a 404 here shouldn't break the page,
        //it should just send us back to the default homepage
        handleNotFoundError: function(error) {
            var currentRoute = Backbone.history.getFragment();
            if (currentRoute.substr(0, 5) === 'Home/') {
                app.router.redirect('#Home');
                //Prevent the default error handler
                return false;
            }
        },
        handleValidationError: function(error) {
            return false;
        }
    },

    /**
     * What is the current Visible State of the dashboard
     */
    dashboardVisibleState: 'open',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('The class `View.Layouts.Base.DashboardLayout`' +
            'has been deprecated since 7.9.0.0 and will be removed in 7.11.0.0. ' +
            'Please use `View.Layouts.Dashboards.DashboardLayout` instead.');

        var context = options.context;
        var module = context.parent && context.parent.get('module') || context.get('module');

        if (options.meta && options.meta.method && options.meta.method === 'record' && !context.get('modelId')) {
            context.set('create', true);
        }

        var hasDashboardModels;

        // The dashboard can be used to display facets on the search page.
        // This is a special use case for dashboards.
        // This checks to see if we're in the search context (i.e. the search page).
        if (context.parent && context.parent.get('search')) {
            // Note that dashboard.js is initialized twice because `navigateLayout` will call initComponents directly,
            // which creates a new context for each dashboard.
            // See `navigateLayout` for more details.
            // Also note that the module for the facets dashboard is set to `Home` in the search layout metadata.
            // Therefore, we have two brother contexts, both of which are in the `Home` module.
            // One is the initial dashboard that is created when the search layout is created.
            // The other is instantiated by the dashboard's `navigateLayout` method.
            var contextBro = context.parent.getChildContext({module: 'Home'});
            hasDashboardModels = contextBro.get('collection') && contextBro.get('collection').length;
            if (hasDashboardModels) {
                context.set({
                    // For the search page, we hardcode the facet dashboard index to 0.
                    // This is possible because in search, we only allow the
                    // facets dashboard.
                    // See `loadData` for more details.
                    model: contextBro.get('collection').at(0),
                    collection: this._getNewDashboardObject('collection', context),
                    skipFetch: true
                });
            }
        }

        if (!hasDashboardModels) {
            var model = this._getNewDashboardObject('model', context);
            if (context.get('modelId')) {
                model.set('id', context.get('modelId'), {silent: true});
            }
            context.set({
                model: model,
                collection: this._getNewDashboardObject('collection', context)
            });
        }

        this._super('initialize', [options]);

        this._bindButtonEvents();

        this.model.on('setMode', function(mode) {
            if (mode === 'edit' || mode === 'create') {
                this.$('.dashboard').addClass('edit');
            } else {
                this.$('.dashboard').removeClass('edit');
            }
        }, this);

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.listenTo(defaultLayout, 'sidebar:state:changed', function(state) {
                this.dashboardVisibleState = state;
            }, this);

            try {
                this.dashboardVisibleState = defaultLayout.isSidePaneVisible() ? 'open' : 'close';
            } catch (error) {
                // this happens when the dashboard component is initially created because the defaultLayout doesn't
                // have _hideLastStateKey key set yet.  Just ignore this for now as with the way dashboards work
                // it this code will get run again once the logic below selects which dashboard to show.
            }
        }

        if (module === 'Home' && context.has('modelId')) {
            // save it as last visit
            var lastVisitedStateKey = this.getLastStateKey();
            app.user.lastState.set(lastVisitedStateKey, context.get('modelId'));
        }
    },

    /**
     * Binds the button events that are specific to the record pane.
     *
     * @protected
     */
    _bindButtonEvents: function() {
        this.context.on('button:save_button:click', this.handleSave, this);
    },

    /**
     * Overrides {@link View.Layout#initComponents} to trigger `change:metadata`
     * event if we are in the search results page.
     *
     * For other dashboards than the facet dashboard, `change:metadata` is
     * triggered by {@link View.Fields.Base.Home.LayoutbuttonField} but we don't
     * use this field in the facets dashboard so we need to trigger it here.
     *
     * @override
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);
        if (this.isSearchContext()) {
            // For non-search dashboards, `change:metadata` is triggered by the
            // `layoutbutton.js`. We don't use this field in the facets
            // dashboard, so we need to trigger it here.
            this.model.trigger('change:metadata');
        }
    },

    /**
     * Indicates if we are in the search page or not.
     *
     * @return {boolean} `true` means we are in the search page.
     */
    isSearchContext: function() {
        return this.context.parent && this.context.parent.get('search');
    },

    /**
     * Gets the brother context.
     *
     * @param {string} module The module to get the brother context from.
     * @return {Core.Context} The brother context.
     */
    getContextBro: function(module) {
        return this.context.parent.getChildContext({module: module});
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        // Dashboards store their own metadata as part of their model.
        // For search facet dashboard, we do not want to load the dashboard
        // metadata from the database. Instead, we build the metadata below.
        if (this.isSearchContext()) {
            // The model does not have metadata the first time this function
            // is called. In subsequent calls, the model should have metadata
            // so we do not need to fetch it.
            if (this.model.has('metadata')) {
                return;
            }

            this._loadSearchDashboard();

            this.context.set('skipFetch', true);
            this.navigateLayout('search');
            return;
        }

        if (this.context.parent && !this.context.parent.isDataFetched()) {
            var parent = this.context.parent.get('modelId') ?
                this.context.parent.get('model') : this.context.parent.get('collection');

            if (parent) {
                parent.once('sync', function() {
                    this._super('loadData', [options]);
                }, this);
            }
        } else {
            this._super('loadData', [options]);
        }
    },

    /**
     * Loads the facet dashboard for the search page, and add it.
     *
     * @private
     */
    _loadSearchDashboard: function() {
        var dashboardMeta = this._getInitialDashboardMetadata();
        var model = this._getNewDashboardObject('model', this.context);
        // In `dashMeta`, we have a `metadata` property which contains all
        // the metadata needed for the dashboard.
        model.set(dashboardMeta);
        this.collection.add(model);
    },

    /**
     * Navigate to the create layout when create button is clicked.
     *
     * @param {Event} evt Mouse event.
     */
    createClicked: function(evt) {
        if (this.model.dashboardModule === 'Home') {
            var route = app.router.buildRoute(this.module, null, 'create');
            app.router.navigate(route, {trigger: true});
        } else {
            this.navigateLayout('create');
        }
    },

    /**
     * Places only components that include the Dashlet plugin and places them in the 'main-pane' div of
     * the dashlet layout.
     * @param {app.view.Component} component
     * @private
     */
    _placeComponent: function(component) {
        var dashboardEl = this.$('[data-dashboard]');
        var css = this.context.get('create') ? ' edit' : '';

        if (dashboardEl.length === 0) {
            dashboardEl = $('<div></div>').attr({
                'class': 'cols row-fluid'
            });
            this.$el.append(
                $('<div></div>')
                    .addClass('dashboard' + css)
                    .attr({'data-dashboard': 'true'})
                    .append(dashboardEl)
            );
        } else {
            dashboardEl = dashboardEl.children('.row-fluid');
        }
        dashboardEl.append(component.el);
    },

    /**
     * If current context doesn't contain dashboard model id,
     * it will trigger set default dashboard to create default metadata
     */
    bindDataChange: function() {
        if (this.isSearchContext()) {
            return;
        }
        var modelId = this.context.get('modelId');
        if (!(modelId && this.context.get('create')) && this.collection) {
            // On the search page, we don't want to save the facets dashboard
            // in the database, so we don't need to listen to changes on the
            // collection nor do we need to call `setDefaultDashboard`.
            this.collection.on('reset', this.setDefaultDashboard, this);
        }
    },

    /**
     * Build the default dashboard metadata only if dashboards are empty.
     *
     * Default dashboard metadata are stored in the following layout metadata
     * <pre>
     * listview - list-dashboard
     * recordview - record-dashboard
     * </pre>
     * If the default dashboard is not assigned,
     * the layout will render dashboard-empty template.
     */
    setDefaultDashboard: function() {
        if (this.disposed) {
            return;
        }
        var lastVisitedStateKey = this.getLastStateKey();
        var lastViewed = app.user.lastState.get(lastVisitedStateKey);
        var model;

        // FIXME: SC-4915 will change this to rely on the `hidden` context flag
        // instead.
        var hasParentContext = this.context && this.context.parent;
        var parentModule = hasParentContext && this.context.parent.get('module') || 'Home';

        if (this.collection.length > 0) {
            var currentModule = this.context.get('module');
            model = _.first(this.collection.models);

            if (lastViewed) {
                var lastVisitedModel = this.collection.get(lastViewed);
                //if last visited dashboard not in the fetching list,
                //it should navigate to the first searched dashboard.
                //And it should clean out the previous last visited dashboard,
                //since it is no longer existed.
                if (!_.isEmpty(lastVisitedModel)) {
                    app.user.lastState.set(lastVisitedStateKey, '');
                    model = lastVisitedModel;
                }
            }

            if (currentModule == 'Home' && _.isString(lastViewed) && lastViewed.indexOf('bwc_dashboard') !== -1) {
                app.router.navigate(lastViewed, {trigger: true});
            } else {
                // use the _navigate helper
                this._navigate(model);
            }
        } else {
            var _initDashboard = this._getInitialDashboardMetadata();

            // If there is no initial dashboard, render the empty template and bail
            if (!_initDashboard || _.isEmpty(_initDashboard.metadata)) {
                this._renderEmptyTemplate();
                return;
            }

            // Since we have an initial dashboard,
            // Drill-down to the dashlet level to check permissions for that module.
            _.each(_initDashboard.metadata.components, function(component, componentKey) {
                _.each(component.rows, function(row, rowKey) {
                    // Loop the cells checking access, rebuilding the cell array to only contain permitted dashlets.
                    _initDashboard.metadata.components[componentKey].rows[rowKey] =
                        _.filter(row, function(cell) {
                            var module = (cell.context && cell.context.module) ? cell.context.module : this.module;
                            return (app.acl.hasAccess('access', module));
                        });
                }, this);

                // Now that we've processed all the rows in this component,
                // rebuild the array to only have rows with dashlets.
                _initDashboard.metadata.components[componentKey].rows =
                    _.filter(_initDashboard.metadata.components[componentKey].rows, function(row) {
                        return (row.length > 0);
                    });
            }, this);

            model = this._getNewDashboardObject('model', this.context);
            model.set(_initDashboard);
            if (this.context.get('modelId')) {
                model.set('id', this.context.get('modelId'), {silent: true});
            }
            // make sure that the model actually has some metadata
            if (!_.isUndefined(model.get('metadata'))) {
                model.save({}, this._getDashboardModelSaveParams());
                this.collection.add(model);
            }
        }
    },

    /**
     * Gets initial dashboard metadata
     *
     * @return {Object} dashboard metadata
     * @private
     */
    _getInitialDashboardMetadata: function() {
        var layoutName = this.dashboardLayouts[this.context.parent && this.context.parent.get('layout') || 'record'];
        var initDash = app.metadata.getLayout(this.model.dashboardModule, layoutName) || {};
        return initDash;
    },

    /**
     * Build the cache key for last visited dashboard
     * Combine parent module and view name to build the unique id
     *
     * @return {string} hash key.
     */
    getLastStateKey: function() {
        if (this._lastStateKey) {
            return this._lastStateKey;
        }

        var model = this.context.get('model');
        var view = model.get('view_name');
        var module = model.dashboardModule;
        var key = module + '.' + view;

        this._lastStateKey = app.user.lastState.key(key, this);
        return this._lastStateKey;
    },

    /**
     * Utility method to use when trying to figure out how we need to navigate when switching dashboards
     *
     * @param {Backbone.Model} (dashboard) The dashboard we are trying to navigate to
     * @private
     */
    _navigate: function(dashboard) {
        if (this.disposed) {
            return;
        }

        var hasParentContext = (this.context && this.context.parent);
        var hasModelId = (dashboard && dashboard.has('id'));
        var actualModule = (hasParentContext) ? this.context.parent.get('module') : this.module;
        var isHomeModule = (actualModule === 'Home');

        if (hasParentContext && hasModelId) {
            // we are on a module and we have an dashboard id
            this._navigateLayout(dashboard.get('id'));
        } else if (hasParentContext && !hasModelId) {
            // we are on a module but we don't have a dashboard id
            this._navigateLayout('list');
        } else if (!hasParentContext && hasModelId && isHomeModule) {
            // we on the Home module and we have a dashboard id
            app.navigate(this.context, dashboard);
        } else if (isHomeModule) {
            // we on the Home module and we don't have a dashboard
            var route = app.router.buildRoute(this.module);
            app.router.navigate(route, {trigger: true});
        }
    },

    /**
     * Intercept the navigateLayout calls to make sure that the dashboard we are currently on didn't change.
     * If it did, we need to prompt and make sure they want to continue or cancel.
     *
     * @param {string} dashboard What dashboard do we want to display
     * @return {boolean}
     * @private
     */
    _navigateLayout: function(dashboard) {
        var onConfirm = _.bind(function() {
            this.navigateLayout(dashboard);
        }, this);
        var headerpane = this.getComponent('dashboard-headerpane');

        // if we have a headerpane and it was changed then run the warnUnsavedChanges method
        if (headerpane && headerpane.changed) {
            return headerpane.warnUnsavedChanges(
                onConfirm,
                undefined,
                _.bind(function() {
                    // when the cancel button is presses, we need to clear out the collection
                    // because it messes with the add dashlet screen.
                    this.collection.reset([], {silent: true});
                }, this)
            );
        }

        // if we didn't have a headerpane or we did have one, but nothing changed, just run the normal method
        onConfirm();
    },

    /**
     * For the RHS dashboard, this method loads entire dashboard component
     *
     * @param {string} id dashboard id. This id can be the dashboard id, or
     * the following strings: create, list, search.
     * @param {string} type (Deprecated) the dashboard type.
     */
    navigateLayout: function(id, type) {
        if (!_.isUndefined(type)) {
            // TODO: Remove the `type` parameter. This is to be done in TY-654
            app.logger.warn('The `type` parameter to `View.Layouts.Base.DashboardLayout.navigateLayout`' +
                'has been deprecated since 7.9.0.0. Please update your code to stop using it.');
        }
        var layout = this.layout;
        var lastVisitedStateKey = this.getLastStateKey();

        // For search dashboards, use the search-dashboard-headerpane
        var headerPaneView = (id === 'search') ? 'search-dashboard-headerpane' : 'dashboard-headerpane';

        this.dispose();

        //if dashboard layout navigates to the different dashboard,
        //it should store last visited dashboard id.
        if (!_.contains(['create', 'list'], id)) {
            app.user.lastState.set(lastVisitedStateKey, id);
        }

        var ctxVars = {};
        if (id === 'create') {
            ctxVars.create = true;
        } else if (id !== 'list') {
            ctxVars.modelId = id;
        }

        layout.initComponents([
            {
                // Note that we reinitialize the dashboard layout itself, creating a new context (forceNew: true)
                layout: {
                    type: 'dashboard',
                    components: (id === 'list') ? [] : [
                        {
                            view: headerPaneView
                        },
                        {
                            layout: 'dashlet-main'
                        }
                    ],
                    last_state: {
                        id: 'last-visit'
                    }
                },
                context: _.extend({
                    module: 'Home',
                    forceNew: true
                }, ctxVars)
            }
        ]);

        layout.removeComponent(0);
        layout.loadData();
        layout.render();
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        if (this.collection) {
            this.collection.off('reset', this.setDefaultDashboard, this);
        }

        if (this.context.parent) {
            var model = this.context.parent.get('model');
            var collection = this.context.parent.get('collection');

            if (model) {
                model.off('sync', null, this);
            }
            if (collection) {
                collection.off('sync', null, this);
            }
        }

        this._super('unbindData');
    },

    /**
     * Returns a Dashboard Model or Dashboard Collection based on modelOrCollection
     *
     * @param {string} modelOrCollection The return type, 'model' or 'collection'
     * @param {Object} context
     * @return {Bean|BeanCollection}
     * @private
     */
    _getNewDashboardObject: function(modelOrCollection, context) {
        var obj;
        var ctx = context && context.parent || context;
        var module = ctx.get('module') || context.get('module');
        var layoutName = ctx.get('layout') || '';
        var sync = function(method, model, options) {
            options = app.data.parseOptionsForSync(method, model, options);
            // there is no max limit for number of dashboards permodule view
            if (options && options.params) {
                options.params.max_num = -1;
            }

            var callbacks = app.data.getSyncCallbacks(method, model, options);
            var path = (this.dashboardModule === 'Home' || model.id) ?
                this.apiModule : this.apiModule + '/' + this.dashboardModule;

            if (method === 'read') {
                options.params.view_name = layoutName;
            }

            app.data.trigger('data:sync:start', method, model, options);
            model.trigger('data:sync:start', method, options);

            app.api.records(method, path, model.attributes, options.params, callbacks);
        };

        if (module === 'Home') {
            layoutName = '';
        }
        switch (modelOrCollection) {
            case 'model':
                obj = this._getNewDashboardModel(module, layoutName, sync);
                break;

            case 'collection':
                obj = this._getNewDashboardCollection(module, layoutName, sync);
                break;
        }

        return obj;
    },

    /**
     * Returns a new Dashboard Bean with proper view_name and sync function set
     *
     * @param {string} module The name of the module we're in
     * @param {string} layoutName The name of the layout
     * @param {Function} syncFn The sync function to use
     * @param {boolean} [getNew=true] If you want a new instance or just the
     *   Dashboard definition.
     * @return {Dashboard} a new Dashboard Bean
     * @private
     */
    _getNewDashboardModel: function(module, layoutName, syncFn, getNew) {
        getNew = (_.isUndefined(getNew)) ? true : getNew;
        var Dashboard = app.Bean.extend({
            sync: syncFn,
            apiModule: 'Dashboards',
            module: 'Home',
            dashboardModule: module,
            maxColumns: (module === 'Home') ? 3 : 1,
            minColumnSpanSize: (module === 'Home') ? 4 : 12,
            defaults: {
                view_name: layoutName
            }
        });
        return (getNew) ? new Dashboard() : Dashboard;
    },

    /**
     * Returns a new DashboardCollection with proper view_name and sync function set
     *
     * @param {string} module The name of the module we're in
     * @param {string} layoutName The name of the layout
     * @param {Function} syncFn The sync function to use
     * @param {boolean} [getNew=true] If you want a new instance or just the
     *   DashboardCollection definition.
     * @return {DashboardCollection} A new Dashboard BeanCollection
     * @private
     */
    _getNewDashboardCollection: function(module, layoutName, syncFn, getNew) {
        getNew = (_.isUndefined(getNew)) ? true : getNew;

        var Dashboard = this._getNewDashboardModel(module, layoutName, syncFn, false);
        var DashboardCollection = app.BeanCollection.extend({
            sync: syncFn,
            apiModule: 'Dashboards',
            module: 'Home',
            dashboardModule: module,
            model: Dashboard
        });

        return (getNew) ? new DashboardCollection() : DashboardCollection;
    },

    /**
     * Collects params for Dashboard model save
     *
     * @return {Object} The dashboard model params to pass to its save function
     * @private
     */
    _getDashboardModelSaveParams: function() {
        var params = {
            silent: true,
            //Don't show alerts for this request
            showAlerts: false
        };

        params.error = _.bind(this._renderEmptyTemplate, this);

        params.success = _.bind(function(model) {
            if (!this.disposed) {
                this._navigate(model);
            }
        }, this);

        return params;
    },

    /**
     * Gets the empty dashboard layout template
     * and renders it to <pre><code>this.$el</code></pre>
     *
     * @private
     */
    _renderEmptyTemplate: function() {
        var tplName = this.type || this.name;
        var template = app.template.getLayout(tplName + '.dashboard-empty');

        this.$el.html(template(this));
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.stopListening(defaultLayout);
        }

        this.dashboardLayouts = null;
        this._super('_dispose');
    },

    /**
     * Saves the dashboard to the server.
     */
    handleSave: function() {
        this.model.save({}, {
            //Show alerts for this request
            showAlerts: true,
            fieldsToValidate: {
                'name': {
                    required: true
                },
                'metadata': {
                    required: true
                }
            },
            success: _.bind(function() {
                this.model.unset('updated');
                if (this.context.get('create')) {
                    // We have a parent context only for dashboards in the RHS.
                    if (this.context.parent) {
                        this.getContextBro('Home').get('collection').add(this.model);
                        this.navigateLayout(this.model.id);
                    } else {
                        app.navigate(this.context, this.model);
                    }
                } else {
                    this.context.trigger('record:set:state', 'view');
                }
            }, this),
            error: function() {
                app.alert.show('error_while_save', {
                    level: 'error',
                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                });
            }
        });
    }
}) },
"find-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Find-duplicates Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Sidebar:Toggle'
    ]
}) },
"subpanel-with-massupdate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelWithMassupdateLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelWithMassupdateLayout
 * @extends View.Layouts.Base.SubpanelLayout
 */
({
	// Subpanel-with-massupdate Layout (base) 

    extendsFrom:"SubpanelLayout",

    /**
     * Overriding to just check the items in a subpanel-with-massupdate
     * @inheritdoc
     * @override
     */
    _stopComponentToggle: function(component) {
        // subpanel header top should always render
        return component.name === "panel-top" || component.name === 'massupdate'
        || (!_.isUndefined(component.$el)
        && component.$el.hasClass('subpanel-header'));
    }
}) },
"activities": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ActivitiesLayout
 * @alias SUGAR.App.view.layouts.BaseActivitiesLayout
 * @extends View.Layout
 */
({
	// Activities Layout (base) 

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (!app.config.activityStreamsEnabled) {
            this.$('.search-filter').addClass('hide');
        }

        return this;
    }
}) },
"quicksearch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.QuicksearchLayout
 * @alias SUGAR.App.view.views.BaseQuicksearchLayout
 * @extends View.Layout
 */
({
	// Quicksearch Layout (base) 

    className: 'search',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The collection for executing searches and passing results.
         * This is to be shared and used by components.
         */
        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of this.collection.
        this.collection = app.data.createMixedBeanCollection();

        this.selectedTags = [];

        /**
         * Key to indicate version 2 search (new global search). This is used by the component views to determine
         * what version of the API to use. Default is false.
         * @type {boolean}
         */
        // FIXME SC-4254 Remove this.v2
        this.v2 = this.meta.v2 || false;

        /**
         * Index of the focused component. Only the focused component should have keyboard listeners.
         * @type {number}
         */
        this.compOnFocusIndex = 0;

        /**
         * Maximum viewport width of responsive mode. Under this width we should
         * be in responsive mode, and above in desktop mode.
         * @type {number}
         */
        this.maxResponsiveWidth = 540;

        /**
         * Tells if we're in responsive mode or not.
         *
         * In responsive mode, the search bar is hidden when collapsed and only
         * the magnifying glass is shown. When it's expanded, it takes the full
         * width of the screen.
         *
         * @type {boolean}
         */
        this.isResponsiveMode = false;

        /**
         * Indicates if the search bar is expanded
         * @type {boolean}
         */
        this.expanded = false;

        // shortcut keys
        // Focus the search bar
        app.shortcuts.registerGlobal({
            id: 'Search:Focus',
            keys: ['s', 'mod+alt+0'],
            component: this,
            description: 'LBL_SHORTCUT_SEARCH',
            handler: function() {
                this.trigger('navigate:to:component', 'quicksearch-bar');
                this.triggerExpand();
            }
        });

        // When a component is trying to navigate from its last element to the next component,
        // Check to make sure there is a next navigable component. If it exists, set it to the component to focus
        this.before('navigate:next:component', function() {
            var i = this.compOnFocusIndex, comp;
            while (comp = this._components[++i]) {
                if (_.result(comp, 'isFocusable')) {
                    this.compOnFocusIndex = i;
                    return true;
                }
            }
            return false;
        }, this);

        // When a component is trying to navigate from its first element to the previous component,
        // Check to make sure there is a previous navigable component. If it exists, set it to the component to focus
        this.before('navigate:previous:component', function() {
            var i = this.compOnFocusIndex, comp;
            while (comp = this._components[--i]) {
                if (_.result(comp, 'isFocusable')) {
                    this.compOnFocusIndex = i;
                    return true;
                }
            }
            return false;
        }, this);

        // Navigate to the next component. We have already set this.compOnFocusIndex in the before function.
        this.on('navigate:next:component', function() {
            this._components[this.compOnFocusIndex].trigger('navigate:focus:receive', true);
        }, this);

        // Navigate to the previous component. We have already set this.compOnFocusIndex in the previous function.
        this.on('navigate:previous:component', function() {
            this._components[this.compOnFocusIndex].trigger('navigate:focus:receive', false);
        }, this);

        // Navigate to a specific component. This bypasses the previous/next logic.
        this.on('navigate:to:component', function(componentName) {
            var newIndex = this.compOnFocusIndex;
            // Find the index of the component that is requesting focus.
            // We cannot use `layout.getComponent()` because that only returns the component, not the index.
            _.each(this._components, function(component, index) {
                if (componentName === component.name) {
                    newIndex = index;
                    return;
                }
            });
            // Unfocus the old component and focus on the new component.
            this._components[this.compOnFocusIndex].trigger('navigate:focus:lost');
            this.compOnFocusIndex = newIndex;
            this._components[this.compOnFocusIndex].trigger('navigate:focus:receive');
        }, this);

        // Reset navigation
        this.on('quicksearch:close', function(keepExpanded) {
            this.removeFocus();
            if (!this.expanded) {
                return;
            }
            this.collection.abortFetchRequest();
            if (keepExpanded) {
                return;
            }
            this.collapse();
        }, this);

        this.on('quicksearch:expand', this.expand);

        // Listener for app:view:change to expand or collapse the search bar
        app.events.on('app:view:change', function() {
            if (this.context.get('search')) {
                this.triggerExpand();
            } else {
                _.bind(this.collapse, this);
            }
        }, this);

        this.$el.focusin(_.bind(function() {
            this.$el.off('focusout');
            this.$el.focusout(_.bind(function() {
                this.$el.off('focusout');
                _.defer(_.bind(function() {
                    // We use `has(':focus')` instead of `is(':focus')` to check
                    // if the focused element is or is inside `this.$el`.
                    if (this.$el.has(':focus').length === 0) {
                        this.trigger('quicksearch:close', this.context.get('search'));
                    }
                }, this));
            }, this));
        }, this));

        // Listener for display of tags ribbon menu
        this.on('quicksearch:tag:open', function() {
            this.$el.addClass('quicksearch-tags-open');
        }, this);

        // Listener for hiding of tags ribbon menu
        this.on('quicksearch:tag:close', function() {
            this.$el.removeClass('quicksearch-tags-open');
        }, this);

        // On window resize, if expanded, recalculate expansion
        $(window)
            .off('resize.quicksearch')
            .on('resize.quicksearch', _.debounce(_.bind(this.resizeHandler, this), 10));
    },

    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        if (component.name === 'quicksearch-modulelist' ||
            component.name === 'quicksearch-taglist' ||
            component.name === 'quicksearch-bar'
        ) {
            this.$('[data-component=searchbar]').append(component.el);
        } else {
            this._super('_placeComponent', [component]);
        }
    },

    /**
     * Removes the current focus and resets the focused index
     */
    removeFocus: function() {
        this._components[this.compOnFocusIndex].trigger('navigate:focus:lost');
        this.compOnFocusIndex = 0;
    },

    /**
     * Expand quicksearch bar asynchronously.
     * @param {boolean} update `true` means the expansion is to update the width.
     *                  `false` means the expansion is new and needs animation.
     */
    triggerExpand: function(update) {
        _.defer(_.bind(this.expand, this, update));
    },

    /**
     * Expands the quicksearch.
     *
     * @param {boolean} update `true` means the expansion is to update the width.
     *                  `false` means the expansion is new and needs animation.
     */
    expand: function(update) {
        // if the search bar is already expanded and it is not an update,
        // do nothing.
        if (this.expanded && !update) {
            return;
        }

        this.expanded = true;
        this.$el.addClass('expanded');

        // On route, call the router handler.
        app.router
            .off('route', this.routerHandler)
            .on('route', this.routerHandler, this);

        this.trigger('quicksearch:expanded');
        this.trigger('quicksearch:button:toggle', false);

        if (this.isResponsiveMode) {
            this.trigger('navigate:to:component', 'quicksearch-bar');
            return;
        }

        // Calculate the target searchbox width
        var newWidth = this._calculateExpansion();

        // if the newWidth is not defined, then the menu hasn't completely
        // loaded, and we should do nothing.
        if (_.isUndefined(newWidth)) {
            return;
        }

        // For new expansions, we need to clear out the modules.
        var headerLayout = this.closestComponent('header');
        if (_.isUndefined(headerLayout)) {
            return;
        }
        headerLayout.trigger('view:resize', headerLayout.getModuleListMinWidth());

        // Now that there is space for the search bar to expand, animate the
        // expansion.
        if (update) {
            this.$('[data-component=searchbar]').width(newWidth);
        } else {
            this.$('[data-component=searchbar]').animate({width: newWidth}, {duration: 100});
        }

        // Turn off the default header resize listener
        headerLayout.setModuleListResize(false);
    },

    /**
     * Resizes the expanded search bar when the window is resized.
     * @private
     */
    resizeHandler: function() {
        this._toggleResponsiveMode();
        if (this.expanded && !this.isResponsiveMode) {
            this.triggerExpand(true);
        }
    },

    /**
     * Renders the layout and toggles the responsive class.
     *
     * @private
     */
    _render: function() {
        this._super('_render');
        this._toggleResponsiveMode();
    },

    /**
     * Toggles the responsive mode according to the viewport width.
     *
     * @private
     */
    _toggleResponsiveMode: function() {
        this.isResponsiveMode = $(window).width() < this.maxResponsiveWidth;
    },

    /**
     * Handles the route event on the router.
     *
     * This simple function allows us to reuse a function pointer to the router
     * handler. The router does not allow namespaced events such as
     * `route.quicksearch`. So, this function pointer is necessary to
     * properly dispose the event handler.
     */
    routerHandler: function() {
        this.trigger('quicksearch:close', this.context.get('search'));
    },

    /**
     * Calculates the target width for the search bar expansion based off the current state of the megamenu.
     *
     * @return {number} The target width for expansion.
     * @private
     */
    _calculateExpansion: function() {
        var headerLayout = this.closestComponent('header');
        if (_.isUndefined(headerLayout)) {
            return;
        }

        // The starting width of the input box
        var searchbarStartingWidth = this.$('[data-component=searchbar]').outerWidth();

        // The total width of the module list header
        var totalModuleWidth = headerLayout.getModuleListWidth();

        // The minimum width necessary for module list header
        var minimumModuleWidth = headerLayout.getModuleListMinWidth();

        // The target width is most of the module list, saving room for the
        // minimum module list width.
        return searchbarStartingWidth +
            totalModuleWidth -
            minimumModuleWidth;
    },

    /**
     * Collapses the quicksearch.
     */
    collapse: function() {
        this.expanded = false;
        this.$el.removeClass('expanded');

        this.trigger('quicksearch:collapse');
        app.router.off('route', this.routerHandler);
        this.trigger('quicksearch:button:toggle', true);

        if (this.isResponsiveMode) {
            return;
        }
        var headerLayout = this.closestComponent('header');
        if (_.isUndefined(headerLayout)) {
            return;
        }

        // Turn on the default header resize listener
        headerLayout.setModuleListResize(true);

        // jQuery `width` function with no arguments (or null arguments) only
        // returns the current width. Calling `width('')` with the empty string
        // sets the width to an empty value, which the browser ignores and
        // uses the css width.
        this.$('[data-component=searchbar]').width('');
        headerLayout.resize();
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        app.router.off('route', null, this);
        this.$el.off();
        $(window).off('resize.quicksearch');
        this._super('unbind');
    }
}) },
"sweetspot-config-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SweetspotConfigListLayout
 * @alias SUGAR.App.view.layouts.BaseSweetspotConfigListLayout
 * @extends View.Layout
 */
({
	// Sweetspot-config-list Layout (base) 

    className: 'columns',

    // FIXME: Change this to 'UnsavedChanges' when SC-4167 gets merged. It won't
    // work until then, because 'Editable' can only be attached to a view.
    plugins: ['Editable'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initRows();
        this._bindEvents();
    },

    /**
     * Initializes this layout by adding
     * {@link View.Views.Base.SweetspotConfigListRowView rows} of configured
     * hotkeys if they exist in user preferences.
     *
     * @protected
     * @return {undefined} Returns `undefined` if there are no configured
     *   hotkeys.
     */
    _initRows: function() {
        var data = app.user.getPreference('sweetspot');
        data = data && data.hotkeys;
        if (_.isEmpty(data)) {
            // Always add an empty row if we don't have anything configured.
            this.addRow();
            return;
        }

        _.each(data, function(row) {
            _.each(row.keyword, function(word) {
                this._initRow(row, word);
            }, this);
        }, this);
    },

    /**
     * Adds a {@link View.Views.Base.SweetspotConfigListRowView row view} to the
     * layout, and sets the `keyword` and `action` attributes on the model of
     * the added row component.
     *
     * @param {Object} row The object containing row attributes.
     * @param {string} keyword The `keyword` attribute of the row.
     * @param {string} action The `action` attribute of the row.
     */
    _initRow: function(row, keyword, action) {
        action = action || row.action;
        keyword = keyword || row.keyword;

        var rowComponent = this.addRow();
        rowComponent.model.set('action', action);
        rowComponent.model.set('keyword', keyword);
    },

    /**
     * Binds the events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        // Config data events
        this.context.on('sweetspot:ask:configs', this.generateConfig, this);

        // Config list row events
        this.context.on('sweetspot:config:addRow', this.addRow, this);
        this.context.on('sweetspot:config:removeRow', this.removeRow, this);
    },

    /**
     * @override
     */
    _placeComponent: function(component) {
        this.$('[data-sweetspot=actions]').append(component.el);
    },

    /**
     * Adds a {@link View.Views.Base.SweetspotConfigListRowView row view} to the
     * layout.
     *
     * @param {View.View} component The component that triggered this event.
     */
    addRow: function(component) {
        var def = _.extend(
                {view: 'sweetspot-config-list-row'},
                app.metadata.getView(null, 'sweetspot-config-list-row')
            );
        var rowComponent = this.createComponentFromDef(def, this.context, this.module);

        if (component) {
            // Add the row after the row where the user clicked the '+' sign.
            component.$el.after(rowComponent.el);
        } else {
            this.addComponent(rowComponent, def);
        }
        rowComponent.render();
        return rowComponent;
    },

    /**
     * Removes and disposes this row view from the
     * {@link View.Views.Base.SweetspotConfigListLayout list layout}
     *
     * @param {View.View} component The component that triggered this event.
     */
    removeRow: function(component) {
        this.collection.remove(component.model);
        component.dispose();
        this.removeComponent(component);

        if (this.$('[data-sweetspot=actions]').children().length === 0) {
            this.addRow();
        }
    },

    /**
     * Generates an object that the
     * {@link View.Layouts.Base.SweetspotConfigLayout config layout} uses to
     * save configurations to the user preferences.
     */
    generateConfig: function() {
        var data = this.collection.toJSON();
        data = this._formatData(data);

        this.context.trigger('sweetspot:receive:configs', data);
    },

    /**
     * Formatter method that sanitizes and prepares the data to be used by
     * {@link View.Layouts.Base.SweetspotConfigLayout#saveConfig}. Also allows
     * for multiple hotkeys to be associated with a single action.
     *
     * @protected
     * @param {Array} data The unsanitized configuration data.
     * @return {Array} The formatted data.
     */
    _formatData: function(data) {
        var result = this._sanitizeConfig(data);
        result = this._joinKeywordConfigs(result);
        result = this._formatForUserPrefs(result);

        return result;
    },

    /**
     * This is a helper function that takes in the sanitized configuration data
     * and analyzes if there are actions being assigned to multiple keywords.
     *
     * If there are actions with more than one keyword, the corresponding
     * keywords are joined together in an array. For example:
     *
     *     [{action: '#Bugs', keyword: 'b1'}, {action: '#Bugs', keyword: 'b2'}]
     *
     * would be transformed to:
     *
     *     [{action: '#Bugs', keyword: ['b1', 'b2']}]
     *
     * By default, this function transforms the keyword attribute to an array.
     * For example:
     *
     *    [{action: '#Bugs', keyword: 'b1'}]
     *
     * would be transformed to:
     *
     *    [{action: '#Bugs', keyword: ['b1']}]
     *
     * @private
     * @param {Array} data The sanitized configuration data.
     * @return {Array} The configuration data, with single/multiple keywords per
     *   action stored in an array.
     */
    _joinKeywordConfigs: function(data) {
        var result = {};

        _.each(data, function(obj) {
            result[obj.action] = result[obj.action] || obj;
            var keyword = _.isArray(obj.keyword) ? obj.keyword : [obj.keyword];
            result[obj.action].keyword = _.union(result[obj.action].keyword, keyword);
        });
        return _.toArray(result);
    },

    /**
     * Sanitizes the configuration data by removing empty/falsy values.
     *
     * @protected
     * @param {Array} data The unsanitized configuration data.
     * @return {Array} The sanitized configuration data.
     */
    _sanitizeConfig: function(data) {
        data = _.reject(data, function(row) {
            return !row.keyword || !row.action;
        });

        return data;
    },

    /**
     * This method prepares the attributes payload for the call to
     * {@link Core.User#updatePreferences}.
     *
     * @protected
     * @param {Array} data The unprepared configuration data.
     * @return {Object} The prepared configuration data.
     */
    _formatForUserPrefs: function(data) {
        return {hotkeys: data};
    },

    /**
     * Compare with the user preferences and return true if the collection
     * contains changes.
     *
     * This method is called by {@link app.plugins.Editable}.
     *
     * @return {boolean} `true` if current collection contains unsaved changes,
     *   `false` otherwise.
     */
    hasUnsavedChanges: function() {
        var prefs = app.user.getPreference('sweetspot');
        var oldConfig = prefs && prefs.hotkeys;
        var newConfig = this.collection.toJSON();
        var isChanged = !_.isEqual(oldConfig, newConfig);

        return isChanged;
    }
}) },
"panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PanelLayout
 * @alias SUGAR.App.view.layouts.BasePanelLayout
 * @extends View.Layout
 */
({
	// Panel Layout (base) 

    /**
     * @inheritdoc
     */
    className: 'filtered tabbable tabs-left',

    // "Hide/Show" state per panel
    HIDE_SHOW_KEY: 'hide-show',
    HIDE_SHOW: {
        HIDE: 'hide',
        SHOW: 'show'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initPanelState();
    },

    /**
     * Sets the `collapsed` state of the panel's context, depending on if
     * `app.config.collapseSubpanels` is configured or if the panel was
     * previously shown/hidden.
     *
     * @protected
     */
    _initPanelState: function() {
        var collapse;
        this.hideShowLastStateKey = app.user.lastState.key(this.HIDE_SHOW_KEY, this);

        if (app.config.collapseSubpanels) {
            collapse = true;
        } else {
            var hideShowLastState = app.user.lastState.get(this.hideShowLastStateKey);
            collapse = _.isUndefined(hideShowLastState) || hideShowLastState !== this.HIDE_SHOW.SHOW;
        }
        this.context.set('collapsed', collapse);
    },

    /**
     * @inheritdoc
     *
     * Decorate the subpanel based on if the collection is empty or not.
     *
     * When context is reloaded, we open the panel only if `skipFetch` is
     * `false`.
     *
     * When the context's collapse attribute changes, we confirm that the
     * panel's status is in sync with the flag (expanded/collapsed).
     */
    bindDataChange: function() {
        this.listenTo(this.collection, 'reset add remove', function() {
            this.$('.subpanel').toggleClass('empty', this.collection.length === 0);
        }, this);

        this.listenTo(this.context, 'refresh:count', function(hasAtLeast, properties) {
            this.$('.subpanel').toggleClass('empty', !properties.length);
        }, this);

        this.listenTo(this.context.parent, 'panel-top:refresh', function(link) {
            app.logger.warn('`panel-top:refresh` is deprecated. Use `context.reloadData()` to reload and expand.');
            if (this.context.get('link') === link) {
                this.context.resetLoadFlag();
                this.toggle(true);
            }
        });

        this.listenTo(this.context, 'reload', function() {
            if (!this.context.get('skipFetch')) {
                this.toggle(true);
            }
        });

        this.listenTo(this.context, 'change:collapsed', function(context, collapsed) {
            this.toggle(!collapsed);
        });
    },

    /**
     * Places layout component in the DOM.
     * @override
     * @param {Component} component
     */
    _placeComponent: function(component) {
        this.$(".subpanel").append(component.el);
    },

    /**
     * Renders the `panel-top` component if the subpanel is in a collapsed
     * state, otherwise renders the subpanel.
     */
    _render: function() {
        var collapsed = this.context.get('collapsed');
        if (collapsed) {
            // FIXME: We're assuming that the first component is always the
            // panel-top. This should be fixed when panel-top-create is removed
            // from core in SC-4535.
            this._components[0].render();
        } else {
            /**
             * Internal flag used to determine if we are rendering the
             * component(s) in the panel layout for the first time.
             *
             * @protected
             * @property {boolean}
             */
            this._canToggle = true;
            this._super('_render');
        }

        this.$el.attr({
            'data-subpanel-link': this.options.context.get('link')
        });
        this.$('.subpanel').toggleClass('closed', collapsed);
    },

    /**
     * Saves the collapsed/expanded state of the subpanel in localStorage.
     *
     * @private
     * @param {boolean} [show] `true` to expand, `false` to collapse. Collapses
     *   by default.
     */
    _setCollapsedState: function(show) {
        var state = show ? this.HIDE_SHOW.SHOW : this.HIDE_SHOW.HIDE;
        app.user.lastState.set(this.hideShowLastStateKey, state);
    },

    /**
     * Toggles the panel.
     *
     * @private
     * @param {boolean} [show] `true` to show, `false` to hide, `undefined` to
     *   toggle.
     */
    toggle: function(show) {
        if (this.context.get('isCreateSubpanel')) {
            // no toggle available on create
            return;
        }

        show = _.isUndefined(show) ? this.context.get('collapsed') : show;

        this.$('.subpanel').toggleClass('closed', !show);
        this.context.set('collapsed', !show);
        this._toggleComponents(show);

        // no longer need to skip
        this.context.set('skipFetch', false);
        this.context.loadData();

        this._setCollapsedState(show);
    },

    /**
     * Show or hide component except `panel-top`(subpanel-header) component.
     *
     * @private
     * @param {boolean} [show] `true` to show, `false` to hide. Defaults to
     *   `false`.
     */
    _toggleComponents: function(show) {
        _.each(this._components, function(component) {
            // FIXME: The layout should not be responsible for this. Will be
            // addressed as part of SC-4533.
            if (this._stopComponentToggle(component)) {
                return;
            }
            if (!this._canToggle) {
                component.render();
            } else if (show) {
                component.show();
            } else {
                component.hide();
            }
        }, this);
        this._canToggle = true;
    },

    /**
     * Extensible check to see if this component should be allowed to be toggled.
     * If this returns true: _toggleComponent will return without further render/show/hide checks
     * If this returns false: _toggleComponent will continue through render/show/hide checks
     *
     * @param component
     * @return {boolean}
     * @private
     */
    _stopComponentToggle: function(component) {
        return component.$el.hasClass('subpanel-header');
    }
}) },
"modal": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ModalLayout
 * @alias SUGAR.App.view.layouts.BaseModalLayout
 * @extends View.Layout
 */
/**
 *
 * Create a modal popup that renders popup layout container
 * array(
 *      'layout' => 'modal',
 *      'showEvent' => [event name] //corresponding trigger name (a single string or array of strings)
 *      ),
 * @fires [event name] Create popup modal window and draws specified type of layout
 *      @params Parameters - [Object] {
 *              span - [int] size of modal[1-12]
 *              options - (Optional) 3rd party options goes here
 *
 *              components - [Array] list of either views or layouts (optional for single layout)
 *                           i.e. [ {view: ... } , {layout: ..., context: ... }, ...]
 *
 *                  context should be within the each component metadata.
 *                  context - [Object] configured context attributes
 *                        i.e. { module:..., link:..., modelId:... }
 *                        {
 *                            module - [String] Module name (i.e. Accounts, Contacts, etc) (optional),
 *                            link - [String] related module name (optional),
 *                            modelId - [String] model ID (optional)
 *                        }
 *      }
 *
 *      @params callback - [function(model)] - called by trigger "modal:callback" with correponded model
 *
 * @fires "modal:callback" Executes binded callback function with the updated model as parameter
 *      @params model - object Backbone model that relates to the current job
 *
 * @fires "modal:close" Close popup modal and release layout for popup
 *
 * How to Use:
 * in the view dashlet
 *     this.layout.trigger([event name], ...)
 * in the field dashlet
 *     this.view.layout.trigger([event name], ...)
 */
({
	// Modal Layout (base) 

    baseComponents: [
        { 'view' : 'modal-header' }
    ],
    initialize: function(options, skipModalJsCheck) {
        var self = this,
            showEvent = options.meta.showEvent;

        if (!skipModalJsCheck) {
            if(!_.isFunction(this.$el.modal)) {
                app.logger.error("Unable to load modal.js: Needs bootstrap modal plugin.");
            }
        }

        this.metaComponents = options.meta.components;
        options.meta.components = this.baseComponents;
        if (options.meta.before){
            _.each(options.meta.before, function(callback, event){
                self.before(event, callback);
            });
        }
        app.view.Layout.prototype.initialize.call(this, options);
        options.meta.components = this.metaComponents; //revert components metadata back to original
        if (showEvent) {
            if(_.isArray(showEvent)) {
                //Bind the multiple event handler names
                _.each(showEvent, function(evt, index) {
                    self._bindShowEvent(evt);
                });
            } else {
                self._bindShowEvent(showEvent);
            }
        }
    },
    _bindShowEvent : function(event, delegate){
        var self = this;
        if (_.isObject(event))
        {
            delegate = event.delegate;
            event = event.event;
        }
        if (delegate){
            self.layout.events = self.layout.events || {};
            self.layout.events[event] = function(params, callback){self.show(params, callback)};
            self.layout.delegateEvents();
        } else {
            self.layout.on(event, function(params, callback){self.show(params, callback);}, self);
        }
    },
    getBodyComponents: function() {
        return _.rest(this._components, this._initComponentSize);
    },
    _placeComponent: function(comp, def) {
        if(this.$('.modal:first').length == 0) {
            this.$el.append(
                $('<div>', {'class' : 'modal hide'}).append(
                    this.$body
                )
            );
        }

        if(def.bodyComponent) {
            if(_.isUndefined(this.$body)) {
                this.$body = $('<div>', {'class' : 'modal-body'});
                this.$('.modal:first').append(this.$body);
            }
            this.$body.append(comp.el);
        } else {
            this.$('.modal:first').append(comp.el);
        }
    },

    /**
     *
     * @param params
     * @param callback
     * @private
     */
    _buildComponentsBeforeShow : function(params, callback) {
        var self = this,
            params = params || {},
            buttons = params.buttons || [],
            message = params.message || '',
            components = (params.components || this.metaComponents || []),
            title = (params.title || this.meta.title) + '';
        if(message && components.length == 0) {
            this.confirmMessage = message;
            components.push({view: 'modal-confirm'});
        }
        //stops for empty component elements
        if(components.length == 0) {
            app.logger.error("Unable to display modal dialog: no components or message");
            return false;
        }

        //set title and buttons for modal-header
        var header_view = self.getComponent('modal-header');
        if(header_view) {
            header_view.setTitle(title);
            header_view.setButton(buttons);
        }

        //if previous modal-body exists, remove it.
        if(self._initComponentSize) {
            for(var i = 0; i < self._components.length; i++) {
                self._components[self._components.length - 1].$el.remove();
                self.removeComponent(self._components.length - 1);
            }
        } else {
            self._initComponentSize = self._components.length;
        }

        this.initComponents(components);

        self.context.off("modal:callback");
        self.context.on("modal:callback", function(model) {
            callback(model);
            self.hide();
        },self);
        self.context.off("modal:close");
        self.context.on("modal:close", self.hide, self);


    },

    show: function(params, callback) {
        if (!this.triggerBefore("show") || this.disposed) return false;
        var self = this;
        if (params.before){
            _.each(params.before, function(callback, event){
                self.offBefore(event);
                self.before(event, callback);
            });
        }

        if (this._buildComponentsBeforeShow(params, callback) === false)
            return false;
        this.loadData();
        this.render();
        var width = params ? params.width : null,
            options = params ? params.options || {} : {},
            modal_container = this.$(".modal:first");

        //Clean out previous span css class
        modal_container.attr("style", "");
        if(_.isNumber(width)) {
            modal_container.width(width);
            modal_container.css('marginLeft', -(width/2) + 'px');
        }
        if(!_.isFunction(modal_container.modal)) {
            app.logger.error("Unable to load modal.js: Needs bootstrap modal plugin.");
            return false;
        }

        modal_container.modal(_.extend({keyboard:false, backdrop:'static'}, options.modal));
        modal_container.modal('show');

        this.trigger("show");
        return true;
    },
    hide: function(event) {
        if (!this.triggerBefore("hide")) return false;
        //restore back to the scroll position at the top
        var modal_container = this.$(".modal:first");
        modal_container.scrollTop(0);

        if(!_.isFunction(modal_container.modal)) {
            app.logger.error("Unable to load modal.js: Needs bootstrap modal plugin.");
            return false;
        }
        modal_container.modal('hide');
        this.trigger("hide");
        return true;
    }
}) },
"dashlet-row": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletRowLayout
 * @alias SUGAR.App.view.layouts.BaseDashletRowLayout
 * @extends View.Layout
 */
({
	// Dashlet-row Layout (base) 

    tagName: 'li',

    events: {
        'click .remove-row': 'removeClicked'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.index = options.meta.index;
        options.meta = this.setMetadata(options.meta);

        this._super('initialize', [options]);

        this.model.on("setMode", this.setMode, this);
        this.model.on("applyDragAndDrop", this.applyDragAndDrop, this);
        this.setMode(this.model.mode);
    },

    /**
     * Updates and sets metadata based on the meta param
     * @param {Object} meta
     * @return {Object} meta
     */
    setMetadata: function(meta) {
        meta.components = meta.components || [];
        _.each(meta.components, function(component, index){
            meta.components[index] = {
                layout: {
                    type : 'dashlet-cell',
                    index : this.index + '' + index,
                    components: component
                }
            };
        }, this);

        var addRowDashlet = {
            layout: {
                type: 'dashlet',
                index: this.index + '' + meta.components.length,
                empty: true,
                components: [
                    {
                        view: 'dashlet-row-empty',
                        context: {
                            module:'Home',
                            forceNew:true,
                            create:true
                        }
                    }
                ]
            }
        };
        meta.components.push(addRowDashlet);
        if(meta.css_class) meta.css_class += ' ';
        meta.css_class = 'span' + (meta.width || 12);
        return meta;
    },

    /**
     * @inheritdoc
     */
    _placeComponent: function(comp, def, prepend) {
        var nameId = 'dashlet_';
        var $body = this.$el.children(".dashlet-row");

        // If this is the last row of the dashlet list, mark it as such
        if (def.layout.empty) {
            nameId += 'last_';
        }

        // Now add the dashlet index
        nameId += comp.index;

        if($body.length === 0) {
            $body = $("<ul></ul>").addClass("dashlet-row");
            this.$el.append($body);
        }

        var headerTemplate = app.template.getLayout(this.name + '.header') || app.template.empty,
            $container = $("<div></div>", {'class': 'rows well well-invisible'})
                .append(headerTemplate())
                .append(comp.el),
            $el = $('<li></li>', {
                'class': 'row-fluid',
                'data-sortable': '1',
                'name': nameId
            }).data('index', function() {
                return comp.index + '';
            }).append($container);

        if(prepend) {
            $body.children("li:last").before($el);
        } else {
            $body.append($el);
        }
    },

    /**
     * @inheritdoc
     */
    addComponent: function(component, def) {
        if(this.prependComponent) {
            if (!component.layout) component.layout = this;
            this._components.splice(this._components.length - 1, 0, component);
            this._placeComponent(component, def, true);
            this.prependComponent = false;
        } else {
            this._super('addComponent', [component, def]);
        }
    },

    /**
     * Adds a row to the dashboard
     *
     * @param {Number} columns the number of columns in this row
     */
    addRow: function(columns) {
        var span = 12 / columns,
            components = [];
        _.times(columns, function() {
            components.push({
                width: span
            });
        });
        var metadata = this.model.get('metadata'),
            position = this.index.split(''),
            component = metadata.components;
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);
        component.rows.push(app.utils.deepCopy(components));
        this.model.set("metadata", metadata, {silent: true});
        this.model.trigger("change:layout");

        this.prependComponent = true;
        _.each(this._components, function(component){
            component.index++;
        }, this);
        this._addComponentsFromDef([{
            layout: {
                type : 'dashlet-cell',
                index: this.index + '' + (this._components.length - 1),
                components: components
            }
        }]);
        _.each(this._components, function(component, index){
            component.index = this.index + '' + index;
        }, this);

        //init components of the most recently created row
        this._components[this._components.length-2].initComponents();

        this.setMode(this.model.mode);
    },

    /**
     * Displays a confirmation alert when removing a row.
     *
     * @param {Event} evt The `click` event.
     */
    removeClicked: function(evt) {
        var cell = $(evt.currentTarget).closest('.row-fluid'),
            index = (cell.data('index')()).split('').pop();
        if (!cell.find('[data-dashlet]').length) {
            this.removeRow(index);
            return;
        }
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_REMOVE_DASHLET_ROW_CONFIRM', this.module),
            onConfirm: _.bind(function() {
                this.removeRow(index);
            }, this)
        });
    },

    /**
     * Removes a row.
     *
     * @param {Number} index The index of the row to remove.
     */
    removeRow: function(index) {
        var metadata = this.model.get("metadata"),
            position = this.index.split(''),
            component = metadata.components;
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);
        component.rows.splice(index, 1);
        this._components[index].dispose();
        this._components.splice(index, 1);
        _.each(this._components, function(component, index) {
            // Update each row,
            component.index = this.index + '' + index;
            // And each cell of each row.
            _.each(component._components, function(cell, cellIndex) {
                cell.index = component.index + '' + cellIndex;
            });
        }, this);

        this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger("change:layout");
        this.$el.children(".dashlet-row").children("li:eq(" + index + ")").remove();
    },

    /**
     * @inheritdoc
     */
    setMode: function(type) {
        if(type === 'edit' || (this.model._previousMode === 'edit' && type === 'drag')) {
            this.$el.children(".dashlet-row").sortable("enable");
            this.$el.children(".dashlet-row").children("li").not(":last").addClass("sortable").children(".rows").removeClass("well-invisible").children(".btn-link").toggleClass("hide", false);
        } else {
            this.$el.children(".dashlet-row").sortable("disable");
            this.$el.children(".dashlet-row").children("li").not(":last").addClass("sortable").children(".rows").addClass("well-invisible").children(".btn-link").toggleClass("hide", true);
        }
    },

    /**
     * Adds drag-and-drop functionality to the row
     */
    applyDragAndDrop: function() {
        var self = this;
        this.$el.children(".dashlet-row").sortable({
            axis: "y",
            items: "li.sortable",
            handle: ".move",
            forcePlaceholderSize: true,
            placeholder: "placeholder",
            update: function(event, ui) {
                var sourceIndex = ui.item.first().data('index')(),
                    targetIndex = ui.item.first().next().data('index')();

                self.switchComponent(targetIndex, sourceIndex);
            }
        });
        this.setMode(this.model.mode);
    },

    /**
     * Switch the places of two components
     *
     * @param {String} target key
     * @param {String} source key
     */
    switchComponent: function(target, source) {
        var metadata = this.model.get("metadata"),
            position = this.index.split(''),
            component = metadata.components,
            targetIndex = target.split('').pop(),
            sourceIndex = source.split('').pop();
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);

        var sourceMetadata = component.rows[sourceIndex],
            sourceComponent = this._components[sourceIndex];

        if(sourceIndex > targetIndex) {
            //dragging up
            component.rows.splice(sourceIndex, 1);
            component.rows.splice(targetIndex, 0, sourceMetadata);

            this._components.splice(sourceIndex, 1);
            this._components.splice(targetIndex, 0, sourceComponent);
        } else {
            //dragging down
            component.rows.splice(targetIndex, 0, sourceMetadata);
            component.rows.splice(sourceIndex, 1);

            this._components.splice(targetIndex, 0, sourceComponent);
            this._components.splice(sourceIndex, 1);
        }

        _.each(this._components, function(component, index) {
            component.index = this.index + '' + index;
        }, this);

        this.model.set('metadata', app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger('change:layout');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var $dashletRowChildren = this.$el.children('.dashlet-row');
        _.each($dashletRowChildren, function(child) {
            var $child = $(child);
            if (!_.isUndefined($child.sortable('instance'))) {
                $child.sortable('destroy');
            }
        });
        this.model.off('applyDragAndDrop', null, this);
        this.model.off('setMode', null, this);
        this._super('_dispose');
    }
}) },
"dashlet-cell": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletCellLayout
 * @alias SUGAR.App.view.layouts.BaseDashletCellLayout
 * @extends View.Layouts.Base.DashletRowLayout
 */
({
	// Dashlet-cell Layout (base) 

    extendsFrom: 'DashletRowLayout',
    tagName: 'ul',
    className: 'dashlet-cell rows row-fluid',

    /**
     * @inheritdoc
     */
    _placeComponent: function(comp, def) {
        var span = 'dashlet-container span' + (def.width || 12),
            self = this;
        this.$el.append($('<li>', {'class': span, name: 'dashlet_' + comp.index}).data('index', function() {
            var index = def.layout.index.split('').pop();
            return self.index + '' + index;
        }).append(comp.el));
    },

    /**
     * Updates and sets metadata based on the meta param
     * @param {Object} meta
     * @return {Object} meta
     */
    setMetadata: function(meta) {
        meta.components = meta.components || [];
        _.each(meta.components, function(component, index){
            if(!(component.view || component.layout)) {
                meta.components[index] = _.extend({}, {
                    layout: {
                        type: 'dashlet',
                        index: this.index + '' + index,
                        empty: true,
                        components: [
                            {
                                view: 'dashlet-cell-empty',
                                context:{
                                    module:'Home',
                                    create:true
                                }
                            }
                        ]
                    }
                }, component);
            } else {
                var def = component.view || component.layout;
                if (!_.isObject(def)) {
                    def = component;
                }
                if(component.context) {
                    _.extend(component.context, {
                        forceNew: true
                    })
                }
                meta.components[index] = {
                    layout: {
                        type: 'dashlet',
                        index: this.index + '' + index,
                        label: def.label || def.name || "",
                        components: [
                            component
                        ]
                    },
                    width: component.width
                };
            }
        }, this);

        return meta;
    }
}) },
"toggle": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout that provides basic functionality for toggling visibility of
 * sub-layouts & views.
 *
 * @class View.Layouts.Base.ToggleLayout
 * @alias SUGAR.App.view.layouts.BaseToggleLayout
 * @extends View.Layout
 */
({
	// Toggle Layout (base) 

    /**
     * Components to be toggled
     * Key is the name of the layout or view
     * Value is an object with icon/label if toggle buttons are to be displayed, empty object otherwise
     */
    availableToggles: {},

    /**
     * Default component to show when this layout is initialized
     */
    defaultToggle: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.toggleComponents = [];
        this.componentsList = {};
        this.availableToggles = options.meta.available_toggles || this.availableToggles;
        this.defaultToggle = options.meta.default_toggle || this.defaultToggle;

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);

        _.each(this.componentsList, function(comp) {
            if (_.isFunction(comp.initComponents)) {
                comp.initComponents();
            }
        });

        if (this.defaultToggle) {
            this.showComponent(this.defaultToggle);
        }

        this.on('toggle:showcomponent', this.showComponent, this);
    },

    /**
     * Defer rendering/appending of toggle-able components and render/append the rest
     * @param component
     */
    _placeComponent: function(component) {
        if (!_.isUndefined(this.availableToggles[component.name])) {
            this.toggleComponents.push(component);
            this.componentsList[component.name] = component;
            this._components.splice(this._components.indexOf(component), 1);
        } else {
            component.render();
            this.getContainer(component).append(component.el);
        }
    },

    /**
     * Container where the content should be placed (topmost layout element by default)
     * Override for a different container
     * @param component useful if the container is dependent on the component - not used in base implementation
     */
    getContainer: function(component) {
        return this.$el;
    },

    /**
     * Show the given component and hide the other toggle-able components.
     * Render the named component if it is in our list of components that have
     * not yet been rendered and append it to the appropriate container.
     *
     * The firing of the 'append' event is done after showing the component to
     * ensure that its DOM surroundings (ie. element width) are completely set
     * up - allowing anything listening to adjust accordingly.
     *
     * @param {string} name Name of the component to show
     */
    showComponent: function(name) {
        var oldToggle = this.currentToggle;

        _.each(this.toggleComponents, function(component) {
            if (component.name === name) {
                component.show();
            } else {
                component.hide();
            }
        }, this);

        if (this.componentsList[name]) {
            this.componentsList[name].render();
            this._components.push(this.componentsList[name]);
            this.getContainer(this.componentsList[name]).append(this.componentsList[name].el);
            // notify the component it's been appended to the container.
            // it may want to adapt to its new neighborhood
            this.componentsList[name].trigger("append");
            this.componentsList[name] = null;
        }

        this.currentToggle = name;
        this.trigger('toggle:change', name, oldToggle);
    },

    /**
     * Clean up any components that were never rendered and added to _components
     * @private
     */
    _dispose: function() {
        _.each(this.componentsList, function(component) {
            if (component) {
                component.dispose();
            }
        });
        this.componentsList = {};
        this.toggleComponents = null;
        app.view.Layout.prototype._dispose.call(this);
    }

}) },
"audit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Audit Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: ['AuditHeaderPanel:Close']
}) },
"shortcuts": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ShortcutsLayout
 * @alias SUGAR.App.view.layouts.BaseShortcutsLayout
 * @extends View.Layout
 */
({
	// Shortcuts Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: ['Headerpane:Cancel'],

    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        this.$('[data-action=render]').append(component.el);
    },

    /**
     * Do not fetch data.
     */
    loadData: $.noop
}) },
"search": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout for the global search results page.
 *
 * @class View.Layouts.Base.SearchLayout
 * @alias SUGAR.App.view.layouts.BaseSearchLayout
 * @extends View.Layout
 */
({
	// Search Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.set('search', true);
        this.collection.query = this.context.get('searchTerm') || '';

        /**
         * Flag to indicate if the search has been filtered using facets or not.
         *
         * @property {boolean} `true` if the search has been filtered.
         */
        this.filteredSearch = false;
        /**
         * Object containing the selected facets in the current search.
         *
         * @property {Object} selectedFacets
         */
        this.selectedFacets = {};

        this.context.on('search:fire:new', function() {
            this.search();
        }, this);

        this.context.on('facet:apply', this.filter, this);

        this.collection.on('sync', function(collection) {
            var isCollection = (collection instanceof App.BeanCollection);
            if (!isCollection) {
                return;
            }
            app.utils.GlobalSearch.formatRecords(collection, true);

            if (!_.isEmpty(collection.xmod_aggs)) {
                if (!this.filteredSearch) {
                    this._initializeSelectedFacets(collection.xmod_aggs);
                }

                this.context.set('selectedFacets', this.selectedFacets);
                this.context.set('facets', collection.xmod_aggs, {silent: true});
                this.context.trigger('facets:change', collection.xmod_aggs);
            }

        }, this);

        this.context.on('facets:reset', this.search, this);

        this.collection.setOption('params', {xmod_aggs: true});
    },

    /**
     * Builds the selected facets object to be sent to the server.
     *
     * @param {Object} facets The facets object that comes from the server.
     * @private
     */
    _initializeSelectedFacets: function(facets) {
        _.each(facets, function(facet, key) {
            if (key === 'modules') {
                this.selectedFacets[key] = [];
            } else {
                this.selectedFacets[key] = false;
            }
        }, this);
    },

    /**
     * Updates {@link #selectedFacets} with the facet change.
     *
     * @param {String} facetId The facet type.
     * @param {String} facetCriteriaId The id of the facet criteria.
     * @param {boolean} isSingleItem `true` if it's a single item facet.
     * @private
     */
    _updateSelectedFacets: function(facetId, facetCriteriaId, isSingleItem) {
        if (isSingleItem) {
            this.selectedFacets[facetId] = !this.selectedFacets[facetId];
            return;
        }
        var index;
        if (this.selectedFacets[facetId]) {
            index = this.selectedFacets[facetId].indexOf(facetCriteriaId);
        } else {
            this.selectedFacets[facetId] = [];
        }
        if (_.isUndefined(index) || index === -1) {
            this.selectedFacets[facetId].splice(0, 0, facetCriteriaId);
        } else {
            this.selectedFacets[facetId].splice(index, 1);
            if (this.selectedFacets[facetId].length === 0) {
                delete this.selectedFacets[facetId];
            }
        }
    },

    /**
     * Searches on a term and a module list.
     *
     * @param {boolean} reset `true` if we reset the filters.
     */
    search: function(reset) {
        // Prevents to trigger a new fetch if the user clicks on
        if (reset && !this.filteredSearch) {
            return;
        }
        var searchTerm = this.context.get('searchTerm');
        var moduleList = this.context.get('module_list') || [];
        this.filteredSearch = false;

        var tagFilters = _.pluck(this.context.get('tags'), 'id');

        this.collection.fetch({query: searchTerm, module_list: moduleList,
            apiOptions:
            {
                data: {
                    tag_filters: tagFilters
                },
                fetchWithPost: true,
                useNewApi: true
            }
        });
    },

    /**
     * Refines the search applying a facet change.
     *
     * @param facetId The facet id.
     * @param facetCriteriaId The facet criteria id.
     * @param isSingleItem `true` if it's a single criteria facet.
     */
    filter: function(facetId, facetCriteriaId, isSingleItem) {
        this._updateSelectedFacets(facetId, facetCriteriaId, isSingleItem);

        var searchTerm = this.context.get('searchTerm');
        var moduleList = this.context.get('module_list') || [];
        this.filteredSearch = true;
        var tagFilters = _.pluck(this.context.get('tags'), 'id');
        this.collection.fetch({query: searchTerm, module_list: moduleList,
            apiOptions:
            {
                data: {
                    agg_filters: this.selectedFacets,
                    tag_filters: tagFilters
                },
                fetchWithPost: true,
                useNewApi: true
            }
        });
    },

    /**
     * We override `loadData` to not send the `fields` param in the
     * request, so it's consistent with the request sent by
     * {@link View.Views.Base.QuicksearchBarView#fireSearchRequest fireSearchRequest}
     * method in the quicksearch bar.
     * Note that the `fields` param is not used anymore by the globalsearch API.
     *
     * @inheritdoc
     */
    loadData: function(options) {
        options = options || {};

        options.module_list = this.context.get('module_list') || [];

        // pull tag ids out of context and pass them into our options to filter
        var tagFilters = _.pluck(this.context.get('tags'), 'id');
        if (tagFilters) {
            options.apiOptions = options.apiOptions || {};
            options.apiOptions.data = {tag_filters: tagFilters};
            options.apiOptions.fetchWithPost = true;
            options.apiOptions.useNewApi = true;
        }

        this._super('loadData', [options]);
    }
}) },
"records": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Records Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'List:Headerpane:Create',
        'List:Select:Down',
        'List:Select:Up',
        'List:Scroll:Left',
        'List:Scroll:Right',
        'List:Select:Open',
        'List:Inline:Edit',
        'List:Delete',
        'List:Inline:Cancel',
        'List:Inline:Save',
        'List:Favorite',
        'List:Follow',
        'List:Preview',
        'List:Select',
        'SelectAll:Checkbox',
        'SelectAll:Dropdown',
        'Filter:Search',
        'Filter:Create',
        'Filter:Edit',
        'Filter:Show'
    ]
}) },
"selection-list-module-switch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SelectionListModuleSwitchLayout
 * @alias SUGAR.App.view.layouts.BaseSelectionListModuleSwitchLayout
 * @extends View.Layouts.Base.SelectionListLayout
 */
({
	// Selection-list-module-switch Layout (base) 

    extendsFrom: 'SelectionListLayout',

    /**
     * Build the module list for the dropdown from filterList attribute that is set
     * on the context.
     * @inheritdoc
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this._filterList = this.context.get('filterList');
        this.context.set('filterList', this._buildModuleSwitchList(this._filterList));

        this.context.on('selection-list:reload', this.reload, this);
    },

    /**
     * Given a list of modules, it checks to see if the user has access to those modules
     * and returns a list in a form that Select2 dropdown accepts.
     * @param {Array} modules - List of modules to be displayed in the dropdown.
     * @return {Array}
     * @private
     */
    _buildModuleSwitchList: function(modules) {
        var filter = [];

        _.each(modules, function(module) {
            if (app.acl.hasAccess('list', module)) {
                filter.push({id: module, text: app.lang.get('LBL_MODULE_NAME', module)});
            }
        }, this);

        return filter;
    },

    /**
     * Reload this drawer layout.
     * @param {string} module
     */
    reload: function(module) {
        var self = this;
        // Need to defer so that we do not reload and dispose the drawer before all event
        // callbacks have completely finished.
        _.defer(function() {
            app.drawer.load({
                layout: 'selection-list-module-switch',
                context: {
                    module: module,
                    fields: self.context.get('fields'),
                    filterOptions: self.context.get('filterOptions'),
                    filterList: self._filterList
                }
            });
        });
    }
}) },
"dashletconfiguration": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletconfigurationLayout
 * @alias SUGAR.App.view.layouts.BaseDashletconfigurationLayout
 * @extends View.Layout
 */
({
	// Dashletconfiguration Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Dashlet:Config:Cancel',
        'Dashlet:Config:Save'
    ],

    initialize: function(options) {
        var meta = app.metadata.getLayout(options.module, options.name),
            main_panel;

        _.each(meta.components, function(component) {
            main_panel = _.find(component.layout.components, function(childComponent) {
                return childComponent.layout && childComponent.layout.name === 'main-pane';
            }, this);
        }, this);
        if(main_panel){
            main_panel.layout.components = _.union(main_panel.layout.components, options.meta.components);
        }
        options.meta = meta;
        this._super('initialize', [options]);
    }
}) },
"dashablelist-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashablelistFilterLayout
 * @alias SUGAR.App.view.layouts.BaseDashablelistFilterLayout
 * @extends View.Layout
 */
({
	// Dashablelist-filter Layout (base) 

    className: 'dashablelist-filter',

    /**
     * @inheritdoc
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);

        // We need to initialize the filterpanel with the filter and module
        // saved on the dashlet.
        var filterPanelLayout = this.getComponent('filterpanel');
        if (filterPanelLayout) {
            filterPanelLayout.before('render', this._reinitializeFilterPanel, this);
            this.listenTo(this.layout, 'dashlet:filter:reinitialize', filterPanelLayout.render);
        }
    },

    /**
     * This function sets the `currentModule` on the filterpanel layout, and
     * the `currentFilterId` on its context. It is invoked before
     * `filter:reinitialize` is triggered from `_render` on the filterpanel
     * layout.
     *
     * @private
     */
    _reinitializeFilterPanel: function() {
        var filterPanelLayout = this.getComponent('filterpanel');
        if (!filterPanelLayout) {
            return;
        }

        var moduleName = this.model.get('module'),
            id = this.model.get('filter_id');

        filterPanelLayout.currentModule = moduleName;
        this.context.set('currentFilterId', id);
    }
}) },
"header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.HeaderLayout
 * @alias SUGAR.App.view.layouts.BaseHeaderLayout
 * @extends View.Layout
 */
({
	// Header Layout (base) 

    /**
     * Listen to events to resize the header to fit the browser width
     * @param options
     */
    initialize: function(options) {
        app.view.Layout.prototype.initialize.call(this, options);
        this.on('header:update:route', this.resize, this);
        app.events.on('app:view:change', this.resize, this);
        // Event listeners for showing and hiding the megamenu on auth expiration
        app.events.on('app:login', this.hide, this);
        app.events.on('app:login:success', this.show, this);

        var resize = _.bind(this.resize, this);
        $(window)
            .off('resize.header')
            .on('resize.header', resize);
    },

    /**
     * Places all components within this layout inside nav-collapse div
     * @param component
     * @private
     */
    _placeComponent: function(component) {
        this.$el.find('.nav-collapse').append(component.$el);
    },

    /**
     * Calculates the width that the module list should resize to and triggers an event
     * that tells the module list to resize
     */
    resize: function() {
        var resizeWidth = this.getModuleListWidth();
        this.trigger('view:resize', resizeWidth);
    },

    /**
     * Returns the calculated module list width.
     * @return {number}
     */
    getModuleListWidth: function() {
        var maxMenuWidth = $(window).width();
        var totalWidth = 0;

        _.each(this._components, function(component) {
            if (component.name !== 'module-list') {
                // only calculate width for visible components
                if (component.$el.is(':visible')) {
                    totalWidth += component.$el.outerWidth(true);
                }
            }
        });
        return maxMenuWidth - totalWidth;
    },

    /**
     * Returns the minimum module list width.
     * @return {number}
     */
    getModuleListMinWidth: function() {
        var moduleListView = this.getComponent('module-list');
        if (moduleListView) {
            return moduleListView.computeMinWidth();
        }
    },

    /**
     * Sets whether or not the module-list should listen to the window resize.
     * @param {boolean} resize
     */
    setModuleListResize: function(resize) {
        this.getComponent('module-list').toggleResize(resize);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // If we are authenticated show the megamenu
        if (app.api.isAuthenticated()) {
            this.show();
        } else {
            this.hide();
        }
    },

    /**
     * @inheritdoc
     */
    show: function() {
        this._super('show');
        this.resize();
    }
}) },
"base": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The Base Layout that all Layouts should extend from before extending
 * {@link #View.Layout}.
 *
 * Use this controller to specify your customizations for the Base platform.
 * This should contain any special override that only applies to Base platform
 * and not to Sidecar's library.
 *
 * Any Layout in a module can skip the default fallback and extend this one
 * directly. In your `BaseModuleMyLayout` component that lives in the file
 * `modules/<module>/clients/base/layouts/my-layout/my-layout.js`, you can
 * directly extend the `BaseLayout` skipping the normal extend flow which will
 * extend automatically from `BaseMyLayout` that might live in
 * `clients/base/layouts/my-layout/my-layout.js`. Simply define your controller
 * with:
 *
 * ```
 * ({
	// Base Layout (base) 

 *     extendsFrom: 'BaseLayout',
 *     // ...
 * })
 * ```
 *
 * This controller exists to force the component to be created and not fallback
 * to the default flow (which happens when the component isn't found).
 *
 * @class View.Layouts.Base.BaseLayout
 * @alias SUGAR.App.view.layouts.BaseBaseLayout
 * @extends View.Layout
 */
({
    /**
     * The Base Layout will always clear any tooltips after `render` or `dispose`.
     */
    initialize: function() {
        this._super('initialize', arguments);
        if (app.tooltip) {
            this.on('render', app.tooltip.clear);
        }
    }
}) },
"shortcuts-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ShortcutsConfigLayout
 * @alias SUGAR.App.view.layouts.BaseShortcutsConfigLayout
 * @extends View.Layout
 */
({
	// Shortcuts-config Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Headerpane:Save'
    ],

    /**
     * @inheritdoc
     */
    _placeComponent: function(component) {
        this.$('[data-action=render]').append(component.el);
    },

    /**
     * Do not fetch data.
     */
    loadData: $.noop
}) },
"dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletLayout
 * @alias SUGAR.App.view.layouts.BaseDashletLayout
 * @extends View.Layout
 */
({
	// Dashlet Layout (base) 

    /**
     * A reference to the main dashboard
     */
    dashboard: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.index = options.meta.index;
        this._super('initialize', [options]);

        if (!(this.meta.preview || this.meta.empty)) {
            // grab a reference to the dashboard to pass down
            this.dashboard = this.findLayout('dashboard', options.layout);
        }

        //set current model draggable
        this.on('render', function() {
            // If the user has write access, allow drag & drop
            if (app.acl.hasAccessToModel('edit', this.model)) {
                this.model.trigger('applyDragAndDrop');
            } else {
                this.$('[data-toggle=dashlet]').css('cursor', 'default');
            }
        }, this);
        this.context.on('dashboard:collapse:fire', this.collapse, this);
    },

    /**
     * Search recursively through the <pre><code>layout.layout</code></pre> list
     * until the <pre><code>layout.name == name</code></pre>
     *
     * @param {String} name the name of the layout you're looking for
     * @param {Object} layout the layout object to look through
     * @return {Mixed}
     */
    findLayout: function(name, layout) {
        return (layout.name === name || layout.type === name) ?
            layout :
            layout.layout ?
                this.findLayout(name, layout.layout) :
                null;
    },

    /**
     * @inheritdoc
     * Append dashlet toolbar view based on custom_toolbar definition
     *
     * @param {Array} list of component metadata
     */
    _addComponentsFromDef: function(components) {
        if (!(this.meta.preview || this.meta.empty)) {
            var dashletDef = _.first(components),
                dashletMeta,
                dashletModule,
                toolbar = {},
                pattern = /^(LBL|TPL|NTC|MSG)_(_|[a-zA-Z0-9])*$/,
                label = this.meta.label;
            //try to get the dashlet dashlet metadata
            if(dashletDef.view) {
                toolbar = dashletDef.view['custom_toolbar'] || {};
                dashletMeta = app.metadata.getView(dashletDef.view.module, dashletDef.view.name || dashletDef.view.type);
                dashletModule = dashletDef.view.module ? dashletDef.view.module : null;
            } else if (dashletDef.layout) {
                toolbar = dashletDef.view['custom_toolbar'] || {};
                dashletMeta = app.metadata.getLayout(dashletDef.layout.module, dashletDef.layout.name || dashletDef.layout.type);
                dashletModule = dashletDef.layout.module ? dashletDef.layout.module : null;
            }
            if (!dashletModule && dashletDef.context && dashletDef.context.module) {
                dashletModule = dashletDef.context.module;
            }
            if (pattern.test(this.meta.label)) {
                label = app.lang.get(label, dashletModule, dashletDef.view || dashletDef.layout);
            }
            //determine whether it contains custom_toolbar or not
            if (_.isEmpty(toolbar) && dashletMeta && dashletMeta['custom_toolbar']) {
                toolbar = dashletMeta['custom_toolbar'];
            }
            if(toolbar !== "no") {
                components.push({
                    view: {
                        name: 'dashlet-toolbar',
                        label: label,
                        toolbar: toolbar
                    },
                    context: {
                        module: 'Home',
                        skipFetch: true
                    }
                });
            } else {
                this.hasToolbar = false;
            }
        }
        if (this.meta.empty) {
            this.$el.html(app.template.empty(this));
        } else {
            this.$el.html(this.template(this));
        }

        var context = this.context.parent || this.context;
        this._super('_addComponentsFromDef', [components, context, context.get("module")]);
    },

    /**
     * @inheritdoc
     * Set default skipFetch as false.
     * Able to get the custom title label from the dashlet component.
     */
    createComponentFromDef: function(def, context, module) {
        //pass the parent context only to the main dashlet component
        if (def.view && !_.isUndefined(def.view.toolbar)) {
            var dashlet = _.first(this._components);
            if (_.isFunction(dashlet.getLabel)) {
                def.view.label = dashlet.getLabel();
            }
            context = dashlet.context;
        }
        //set default skipFetch as false
        var skipFetch = def.view ? def.view.skipFetch : def.layout.skipFetch;
        if (def.context && skipFetch !== false) {
            def.context.skipFetch = true;
        }
        return this._super('createComponentFromDef', [def, context, module]);
    },

    /**
     * Set current dashlet as invisible
     */
    setInvisible: function() {
        if (this._invisible === true) {
            return;
        }
        var comp = _.first(this._components);
        this.model.on("setMode", this.setMode, this);
        this._invisible = true;
        this.$el.addClass('hide');
        this.listenTo(comp, "render", this.unsetInvisible, this);
    },

    /**
     * Set current dashlet back as visible
     */
    unsetInvisible: function() {
        if (this._invisible !== true) {
            return;
        }
        var comp = _.first(this._components);
        comp.trigger("show");
        this._invisible = false;
        this.model.off("setMode", null, this);
        this.$el.removeClass('hide');
        this.stopListening(comp, "render");
    },

    /**
     * @inheritdoc
     * Place the each component to the right location
     *
     * @param comp
     * @param def
     */
    _placeComponent: function(comp, def) {
        if(this.meta.empty) {
            //add-a-dashlet component
            this.$el.append(comp.el);
        } else if(this.meta.preview) {
            //preview mode
            this.$el.addClass('preview-data');
            this.$('[data-dashlet=dashlet]').append(comp.el);
        } else if (_.isUndefined(def)) {
            this.$('[data-dashlet=dashlet]').after(comp.el);
        } else if(def.view && !_.isUndefined(def.view.toolbar)) {
            //toolbar view
            this.$('[data-dashlet=toolbar]').append(comp.el);
        } else {
            //main dashlet component
            this.$('[data-dashlet=dashlet]').append(comp.el);
        }
    },

    /**
     * Convert the dashlet setting metadata into the dashboard model data
     *
     * @param {Object} setting metadata
     * @return {Object} component metadata
     */
    setDashletMetadata: function(meta) {
        var metadata = this.model.get("metadata"),
            component = this.getCurrentComponent(metadata, this.index);

        _.each(meta, function(value, key){
            this[key] = value;
        }, component);

        this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger("change:layout");
        //auto save
        if(this.model.mode === 'view') {
            this.model.save(null, {
                silent: true,
                //Show alerts for this request
                showAlerts: true,
                success: _.bind(function() {
                    this.model.unset('updated');
                }, this)
            });
        }
        return component;
    },

    /**
     * Retrives the seperate component metadata from the whole dashboard components
     *
     * @param {Object} metadata for all dashboard componenets
     * @param {String} tree based trace key (each digit represents the index number of the each level)
     * @return {Object} component metadata
     */
    getCurrentComponent: function(metadata, tracekey) {
        var position = tracekey.split(''),
            component = metadata.components;
        _.each(position, function(index){
            component = component.rows ? component.rows[index] : component[index];
        }, this);

        return component;
    },

    /**
     * Append the dashlet component from the setting metadata
     *
     * @param {Object} setting metadata
     */
    addDashlet: function(meta) {
        var component = this.setDashletMetadata(meta),
            def = component.view || component.layout || component;

        this.meta.empty = false;
        this.meta.label = def.label || def.name || "";
        //clear previous dashlet
        _.each(this._components, function(component) {
            component.layout = null;
            component.dispose();
        }, this);
        this._components = [];

        if(component.context) {
            _.extend(component.context, {
                forceNew: true
            })
        }
        this.meta.components = [component];
        this.initComponents(this.meta.components);
        this.model.set('updated', true);
        this.loadData();
        this.render();
    },

    /**
     * Remove the current attached dashlet component
     */
    removeDashlet: function() {
        var cellLayout = this.layout,
            rowLayout = cellLayout.layout;
        if (this.model.mode === 'view' && cellLayout._components.length === 1) {
            var dashletRow = this.closestComponent('dashlet-row');
            // this.layout needs to have method to return all the components
            dashletRow.removeRow(this.layout.index.split('').pop());
            dashletRow.model.save(null, {showAlerts: true});
            return;
        }
        var metadata = this.model.get("metadata"),
            component = this.getCurrentComponent(metadata, this.index);
        _.each(component, function(value, key){
            if(key!=='width') {
                delete component[key];
            }
        }, this);
        this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger("change:layout");
        //auto save
        if(this.model.mode === 'view') {
            this.model.save(null, {
                //Show alerts for this request
                showAlerts: true
            });
        } else {
            this.model.set('updated', true);
        }
        this.meta.empty = true;
        //clear previous dashlet
        _.each(this._components, function(component) {
            component.layout = null;
            component.dispose();
        }, this);
        this._components = [];
        this.initComponents([
            {
                view: 'dashlet-cell-empty',
                context: {
                    module: 'Home',
                    skipFetch: true
                }
            }
        ]);
        this.render();
    },

    /**
     * Calls the layout's addRow function to add another row
     *
     * @param {Number} columns the number of columns to add
     */
    addRow: function(columns) {
        this.layout.addRow(columns);
    },

    /**
     * Refresh the dashlet
     *
     * Call dashlet's loadData to refetch the remote data
     *
     * @param {Object} options
     */
    reloadDashlet: function(options) {
        var component = _.first(this._components),
            context = component.context;
        context.resetLoadFlag();
        component.loadData(options);
    },

    /**
     * Edit current dashlet's settings
     *
     * Convert the current componenet's metadata into setting metadata
     * and then it loads its dashlet's configuration view
     *
     * @param {Window.Event}
     */
    editDashlet: function(evt) {
        var self = this,
            meta = app.utils.deepCopy(_.first(this.meta.components)),
            type = meta.layout ? "layout" : "view";
        if(_.isString(meta[type])) {
            meta[type] = {name:meta[type], config:true};
        } else {
            meta[type].config = true;
        }
        meta[type] = _.extend({}, meta[type], meta.context);

        if(meta.context) {
            meta.context.skipFetch = true;
            delete meta.context.link;
        }

        app.drawer.open({
            layout: {
                name: 'dashletconfiguration',
                components: [meta]
            },
            context: {
                model: new app.Bean(),
                forceNew: true
            }
        }, function(model) {
            if(!model) return;

            var conf = model.toJSON(),
                dash = {
                    context: {
                        module: model.get("module") || (meta.context ? meta.context.module : null),
                        link: model.get("link") || null
                    }
                };
            delete conf.config;
            if(_.isEmpty(dash.context.module) && _.isEmpty(dash.context.link)) {
                delete dash.context;
            }
            dash[type] = conf;
            self.addDashlet(dash);
        });
    },

    /**
     * Open Report detail view on a new tab
     */
    viewReport: function() {
        var meta = app.utils.deepCopy(_.first(this.meta.components));

        if (meta.view && meta.view.saved_report_id) {
            var link = app.bwc.buildRoute('Reports', meta.view.saved_report_id);
            window.open('index.php#' + link, '_blank');
        }
    },

    /**
     * Fold/Unfold the dashlet
     *
     * @param {Boolean} true if it needs to be collapsed
     */
    collapse: function(collapsed) {
        if (this.hasToolbar === false) {
            return;
        }
        this.$(".dashlet-toggle > i").toggleClass("fa-chevron-down", collapsed);
        this.$(".dashlet-toggle > i").toggleClass("fa-chevron-up", !collapsed);
        this.$(".thumbnail").toggleClass("collapsed", collapsed);
        this.$("[data-dashlet=dashlet]").toggleClass("hide", collapsed);
    },

    /**
     * Displays current invisible dashlet when current mode is on edit/drag
     *
     * @param {String} (edit|drag|view)
     */
    setMode: function(type) {
        if (!this._invisible) {
            return;
        }
        if (type === 'edit' || type === 'drag') {
            this.show();
        } else {
            this.hide();
        }
    },

    /**
     * Sets the Dashlet layout Title
     * @param title
     */
    setTitle: function(title) {
        // make sure we've got an $el before using it
        if (this.$el) {
            var $titleEl = this.$('h4.dashlet-title');
            if($titleEl.length) {
                $titleEl.text(title);
            }
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.model.off("setMode", null, this);
        this.off("render");
        this.context.off("dashboard:collapse:fire", null, this);
        this._super('_dispose');
    }
}) },
"help": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The base layout for the help component.
 *
 * @class View.Layouts.Base.HelpLayout
 * @alias SUGAR.App.view.layouts.BaseHelpLayout
 * @extends View.Layout
 */
({
	// Help Layout (base) 

    events: {
        'click [data-action=close]': 'close'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The internal state of this layout.
         * By default this layout is closed ({@link #toggle} will call render).
         *
         * FIXME TY-1798/TY-1800 This is needed due to the bad popover plugin.
         *
         * @type {boolean}
         * @private
         */
        this._isOpen = false;

        /**
         * This is the Help button in the footer.
         * Needed to render the modal by calling `popover` on the button.
         *
         * @type {jQuery}
         */
        this.button = options.button;

        /**
         * `True` if the helpObject has been created for the current view,
         * `false` otherwise.
         *
         * @type {boolean}
         * @private
         */
        this._helpObjectCreated = false;

        /**
         * Each view requires its own help object.
         * On view change, the helpObject needs to be recreated.
         */
        app.events.on('app:view:change', _.bind(function() {
            this._helpObjectCreated = false;
            if (this.button) {
                this.button.popover('destroy');
            }
        }, this));
    },

    /**
     * Initializes the popover plugin for the button given.
     *
     * @param {jQuery} button The jQuery button.
     * @private
     */
    _initPopover: function(button) {
        button.popover({
            title: this._getTitle('LBL_HELP_' + app.controller.context.get('layout').toUpperCase() + '_TITLE'),
            content: _.bind(function() {
                return this.$el;
            }, this),
            html: true,
            placement: 'top',
            trigger: 'manual',
            template: '<div class="popover footer-modal feedback helpmodal" data-modal="help">' +
                '<div class="arrow"></div><h3 class="popover-title"></h3>' +
                '<div class="popover-content"></div></div>'
        });

        // Reposition the modal so all of its contents are within the window.
        button.on('shown.bs.popover', _.bind(this._positionPopover, this));
    },

    /**
     * Fetches the title of the help modal.
     * If none exists, returns a default help title.
     *
     * @param {string} titleKey The modal title label.
     * @return {string} The converted title.
     * @private
     */
    _getTitle: function(titleKey) {
        var title = app.lang.get(titleKey, app.controller.context.get('module'), app.controller.context);
        return title === titleKey ? app.lang.get('LBL_HELP') : title;
    },

    /**
     * Toggles the help on the side pane.
     *
     * @param {boolean} show `true` to show the help, `false` to hide it.
     * @param {View.Component} [comp] Component that triggered
     * \'app:help:toggle\' event.
     * @deprecated Since 7.9. Will be removed in 7.11.
     *   Please use the `toggle` method instead.
     */
    toggleHelp: function(show, comp) {
        app.logger.warn('The function `View.Layouts.Base.HelpLayout.toggleHelp` is deprecated in 7.9.0.0' +
            ' and will be removed in 7.11.0.0. Please use `View.Layouts.Base.HelpLayout.toggle` instead.');

        if (!app.drawer.isActive(this.$el)) {
            return;
        }
        if (show || this.module === 'Home') {
            var defaultLayout = this.closestComponent('sidebar');
            if (defaultLayout) {
                defaultLayout.toggleSidePane(show);
            }
        }

        this._toggleHelpPane(show);

        var event = show ? 'app:help:shown' : 'app:help:hidden';
        app.events.trigger(event);
    },

    /**
     * Shows the help pane and hides the other panes in the RHS.
     *
     * FIXME: SC-4915 will remove this method.
     *
     * @param {boolean} show `true` to show the help pane, `false` to hide it.
     * @private
     */
    _toggleHelpPane: function(show) {
        var toggle = show ? 'hide' : 'show';
        var $layout = this.$el.closest('[data-component=sidebar]');
        $layout.find('[data-component=dashboard-pane]')[toggle]();
        $layout.find('[data-component=side-pane]').toggleClass('active', !show);
        $layout.find('[data-component=preview-pane]').removeClass('active');
    },

    /**
     * Toggle this view (by re-rendering).
     *
     * @param {boolean} [show] `true` to show, `false` to hide, `undefined`
     *   to toggle the current state.
     */
    toggle: function(show) {
        if (!this.button) {
            return;
        }

        if (_.isUndefined(show)) {
            this._isOpen = !this._isOpen;
        } else {
            this._isOpen = show;
        }

        this.button.popover('destroy');

        if (this._isOpen) {
            this._initHelpObject();
            this.render();
            this._initPopover(this.button);
            this.button.popover('show');
            this.bindOutsideClick();
        } else {
            this.unbindOutsideClick();
        }

        this.trigger(this._isOpen ? 'show' : 'hide', this, this._isOpen);
    },

    /**
     * Creates the helpObject if it has not yet been created for this.
     *
     * @private
     */
    _initHelpObject: function() {
        if (!this._helpObjectCreated) {
            this.getComponent('base').getComponent('helplet').createHelpObject();
            this._helpObjectCreated = true;
        }
    },

    /**
     * Sets the horizontal position of the modal.
     *
     * @private
     */
    _positionPopover: function() {
        var $popoverContainer = this.button.data()['bs.popover'].tip();
        var left;
        if (app.lang.direction === 'rtl') {
            // Leave 16px of space between lhs edge of popover and the screen.
            left = 16;
        } else {
            // Leave 16px of space between rhs edge of popover and the screen.
            left = $(window).width() - $popoverContainer.width() - 16;
        }
        $popoverContainer.css('left', left);
    },

    /**
     * Closes the Help modal if event target is outside of the Help modal.
     *
     * param {Object} evt jQuery event.
     */
    closeOnOutsideClick: function(evt) {
        if ($(evt.target).closest('[data-modal=help]').length === 0) {
            this.toggle(false);
        }
    },

    /**
     * Binds the outside `click` event.
     */
    bindOutsideClick: function() {
        $('body').bind('click.' + this.cid, _.bind(this.closeOnOutsideClick, this));
    },

    /**
     * Unbinds the outside `click` event.
     */
    unbindOutsideClick: function() {
        $('body').unbind('click.' + this.cid);
    },

    /**
     * Triggered when the close button on the help-header view is pressed.
     */
    close: function() {
        this.toggle(false);
    },

    /**
     * @inheritdoc
     *
     * During dispose destroy the popover.
     */
    _dispose: function() {
        this.unbindOutsideClick();
        if (this.button) {
            this.button.popover('destroy');
        }
        this._super('_dispose');
    }
}) },
"tabbed-layout": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.TabbedLayoutLayout
 * @alias SUGAR.App.view.layouts.BaseTabbedLayoutLayout
 * @extends View.Layout
 */
({
	// Tabbed-layout Layout (base) 

    initialize: function(options) {
        this.firstIsActive = false;
        this.template = app.template.get("l.tabbed-layout");
        this.renderHtml();

        app.view.Layout.prototype.initialize.call(this, options);
    },

    renderHtml: function() {
        this.$el.html(this.template(this));
    },

    // Assign the tabs
    _placeComponent: function(comp, def) {
        var id = _.uniqueId('record-bottom'),
            nav = $('<li/>').html('<a href="#' + id + '" onclick="return false;" data-toggle="tab">' + app.lang.get(def.layout.name, this.module) + '</a>'),
            content = $('<div/>').addClass('tab-pane').attr('id', id).html(comp.el);

        if (!this.firstIsActive) {
            nav.addClass('active');
            content.addClass('active');
        }

        this.firstIsActive = true;
        this.$('.tab-content').append(content);
        this.$('.nav').append(nav);
    }
}) },
"merge-duplicates-preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.MergeDuplicatesPreviewLayout
 * @alias SUGAR.App.view.layouts.BaseMergeDuplicatesPreviewLayout
 * @extends View.Layout
 */
({
	// Merge-duplicates-preview Layout (base) 

    extendsFrom: 'PreviewLayout',

    initialize: function(options) {
        this._super('initialize', [options]);
    }
}) },
"togglepanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout for tabbing between filterable components.
 * Mostly to toggle between Activity Stream and list views
 *
 * @class View.Layouts.Base.TogglepanelLayout
 * @alias SUGAR.App.view.layouts.BaseTogglepanelLayout
 * @extends View.Layout
 */
({
	// Togglepanel Layout (base) 

    events: {
        'click .toggle-actions .btn': 'toggleView'
    },

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function (opts) {
        this.componentsList = {}; //components that can be toggled
        this.toggles = []; //toggle buttons to display to user
        this.processToggles(opts);
        this._super('initialize', [opts]);
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var allComponents = this._components;
        this._components = this.getNonToggleComponents();
        this._super('loadData', [options]);
        this._components = allComponents;
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        // Only render components that cannot be toggled.
        var allComponents = this._components;
        this._components = this.getNonToggleComponents();
        this._super('_render');
        this._components = allComponents;

        // get the last viewed layout
        this.toggleViewLastStateKey = app.user.lastState.key('toggle-view', this);
        var lastViewed = app.user.lastState.get(this.toggleViewLastStateKey);

        // show the first toggle if the last viewed state isn't set in the metadata
        if (_.isUndefined(lastViewed) || this.isToggleButtonDisabled(lastViewed)) {
            var enabledToggles = _.filter(this.toggles, function(toggle) {
                return !toggle.disabled;
            });
            if (enabledToggles.length > 0) {
                lastViewed = _.first(enabledToggles).toggle;
            }
        }

        if (lastViewed) {
            this.showComponent(lastViewed, true);//SP-1766-don't double render!
            // Toggle the appropriate button and layout for initial render
            this.$('[data-view="' + lastViewed + '"]')
                .button('toggle')
                .attr('aria-pressed', true);
        }
    },

    /**
     * Get components that cannot be toggled.
     */
    getNonToggleComponents: function() {
        return _.filter(this._components, function(component) {
            return !_.contains(this.componentsList, component);
        }, this);
    },

    /**
     * Checks whether the toggle button is disabled
     * @param {string} name  The name of the button to check
     * @return {boolean}
     */
    isToggleButtonDisabled: function (name) {
        var disabled = false,
            toggleButton;

        toggleButton = _.find(this.toggles, function (toggle) {
            return toggle.toggle === name;
        });

        if (toggleButton) {
            disabled = toggleButton.disabled;
        }
        return disabled;
    },

    /**
     * Get components from the metadata and declare toggles.
     *
     * @param {Object} options The Backbone.View initialization options.
     */
    processToggles: function(options) {
        var temp = {};

        //Go through components and figure out which toggles we should add
        _.each(options.meta.components, function (component) {
            var toggle;
            if (component.view) {
                toggle = component.view;
            } else if (component.layout) {
                toggle = (_.isString(component.layout)) ? component.layout : component.layout.type;
            }

            var availableToggle = _.find(options.meta.availableToggles, function (curr) {
                return curr.name === toggle;
            }, this);
            if (toggle && availableToggle) {
                var disabled = !!availableToggle.disabled;
                temp[toggle] = {toggle: toggle, title: availableToggle.label, 'class': availableToggle.icon, disabled: disabled};
            }
        }, this);

        // Sort the toggles by the order in the availableToggles list
        _.each(options.meta.availableToggles, function(toggle) {
            if (temp[toggle.name]) {
                this.toggles.push(temp[toggle.name]);
            }
        }, this);
    },

    /**
     * @override
     * @private
     * @param {Component} component
     * @param {Object} def
     */
    _placeComponent: function (component, def) {
        var toggleAvailable = _.isObject(_.find(this.options.meta.availableToggles, function (curr) {
            return curr.name === component.name;
        }));

        if (toggleAvailable) {
            this.componentsList[component.name] = component;
        }

        this.$('.main-content').append(component.el);
    },

    /**
     * Show a toggle
     * @param {Event} e
     */
    toggleView: function (e) {
        var $el = this.$(e.currentTarget);
        // Only toggle if we click on an inactive button
        if (!$el.hasClass("active")) {
            var data = $el.data();
            app.user.lastState.set(this.toggleViewLastStateKey, data.view);
            this.showComponent(data.view);
            this._toggleAria($el);
        }
    },

    /**
     * Sets all button accessibility 'aria-pressed' attributes to false
     * then sets the active button 'aria-pressed' attribute to true.
     *
     * @private
     */
    _toggleAria: function(btn) {
        this.$el.find('.btn').attr('aria-pressed', false);
        btn.attr('aria-pressed', true);
    },

    /**
     * Show and render a given component. Hide all others.
     * @param {string} name
     * @param {boolean} silent
     */
    showComponent: function (name, silent) {
        if (!name) return;

        _.each(this.componentsList, function (comp) {
            if (comp.name === name) {
                comp.show();

                // Should only render if the component has never rendered before.
                if (!comp._skipRenderWhenToggled) {
                    comp.render();
                    comp._skipRenderWhenToggled = true;
                }
            } else {
                comp.hide();
            }
        }, this);

        //Need to respect silent param if true as it prevents double rendering:
        //SP-1766-Filter for sidecar modules causes two requests to list view
        this.trigger('filterpanel:change', name, silent);
    },

    /**
     * @override
     * @private
     */
    _dispose: function () {
        _.each(this.componentsList, function (component) {
            if (component) {
                component.dispose();
            }
        });
        this.componentsList = {};
        app.view.Layout.prototype._dispose.call(this);
    }
}) },
"resolve-conflicts": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Resolve-conflicts Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Sidebar:Toggle'
    ]
}) },
"module-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Module list sets all the user defined modules visible in the main menu.
 *
 * This layout is responsible to keep the all the menus (created using
 * {@link View.Views.BaseModuleMenuView}) in a valid state.
 * It shows the menu in the main bar as well as in the dropdown (show more)
 * and keeps it in sync to provide the best user experience possible, while
 * keeping the DOM changes to a minimum.
 *
 * @class View.Layouts.Base.ModuleListLayout
 * @alias SUGAR.App.view.layouts.BaseModuleListLayout
 * @extends View.Layout
 */
({
	// Module-list Layout (base) 

    className: 'module-list',
    plugins: ['Dropdown'],

    /**
     * The catalog of modules linked to their menus (short and long).
     *
     * The menu element is to the partial created at {@link #_placeComponent}
     * method.
     *
     * @property {Object} A hash of module name with each short and long menus:
     * <pre><code>
     *     {
     *         'Home': {long: el1, short: el2},
     *         'Accounts': {long: el3, short: el4},
     *         //...
     *     }
     * </code></pre>
     *
     * @protected
     */
    _catalog: {},

    /**
     * The cached `[data-action=more-modules]` since this view can be quite
     * big.
     *
     * @property {jQuery} The jQuery element pointing to our
     *   `[data-action=more-modules]` element.
     *
     * @protected
     */
    _$moreModulesDD: undefined,

    /**
     * @inheritdoc
     *
     * Hooks to `app:sync:complete` to handle the refresh of the menu items
     * that are available after a complete sync.
     * Hooks to `app:view:change` to keep the active module highlighted.
     */
    initialize: function(options) {

        app.events.on('app:sync:complete', this._resetMenu, this);
        app.events.on('app:view:change', this.handleViewChange, this);

        this._super('initialize', [options]);

        if (this.layout) {
            this.toggleResize(true);
        }
    },

    /**
     * Toggles the resize listener on or off.
     * Pass `true` to turn the listener on, or `false` to turn the listener off.
     * @param {boolean} resize
     */
    toggleResize: function(resize) {
        this.layout.off('view:resize');
        if (resize) {
            this.layout.on('view:resize', this.resize, this);
        }
    },

    /**
     * Method called on `app:view:change` hooked in
     * {@link BaseModuleListLayout#initialize}.
     *
     * It sets the active module to the one set in the context and fires a
     * `header:update:route` event to it's parent layout.
     */
    handleViewChange: function() {
        var module = app.controller.context.get('module');
        var component = app.drawer.getActive();
        if (component && component.context.get('fromRouter')) {
            module = component.context.get('module');
        }

        this._setActiveModule(module);
        this.layout.trigger('header:update:route');
    },

    /**
     * @inheritdoc
     *
     * If it is a `module-menu` component, we wrap it with our `list` template
     * and place it before the `more-modules` drop down or inside the drop down
     * if we are handling a short version of the menu.
     * The short version is always hidden, since it will be toggled on the
     * first resize call (when it overflows the existing width).
     *
     * @param {View.View/View.Layout} component View or layout component.
     * @protected
     */
    _placeComponent: function(component) {
        if (component.name !== 'module-menu') {
            this.$el.append(component.el);
            return;
        }

        var tpl = app.template.getLayout(this.name + '.list', component.module) ||
            app.template.getLayout(this.name + '.list'),
            $content = $(tpl({module: component.module})).append(component.el);

        // initialize catalog if isn't initialized
        this._catalog[component.module] = this._catalog[component.module] || {};

        if (component.meta && component.meta.short) {
            $content.addClass('hidden');
            this._catalog[component.module].short = $content;
            this._$moreModulesDD.find('[data-container="overflow"]').append($content);
        } else {
            this._catalog[component.module].long = $content;
            this.$('[data-action="more-modules"]').before($content);
        }
    },

    /**
     * Resets the menu based on new metadata information.
     *
     * It resets components, catalog and template (html), and calls
     * {@link #resize} with the last known space available for this view.
     *
     * @protected
     */
    _resetMenu: function() {

        this._components = [];
        this._catalog = {};
        this.$el.html(this.template(this, this.options));

        // cache the more-dropdown now
        this._$moreModulesDD = this.$('[data-action="more-modules"]');

        this._addDefaultMenus();
        this._setActiveModule(app.controller.context.get('module'));
        this.render();
        this.resize(this._width);
    },

    /**
     * Adds all default menu views as components in both full and short
     * version.
     *
     * This will set the menu as sticky to differentiate from the others that
     * are added based on navigation/reference only.
     *
     * @private
     */
    _addDefaultMenus: function() {

        var moduleList = app.metadata.getModuleNames({filter: 'display_tab', access: 'read'});

        _.each(moduleList, function(module) {
            this._addMenu(module, true);
        }, this);
    },

    /**
     * Adds a menu as a component. Sticky menus aren't added to `more-modules`
     * list.
     *
     * @param {String} module The module
     * @param {Boolean} [sticky=false] Set to `true` if this is a menu that is
     *   part of user preferences.
     * @return {Object} The `menu.long` and `menu.short` components created.
     *   If `sticky` param is `false`, then no `menu.short` is provided.
     * @private
     */
    _addMenu: function(module, sticky) {
        var menu = {};

        var def = {
            view: {
                type: 'module-menu',
                sticky: sticky,
                short: false
            }
        };
        menu.long = this.createComponentFromDef(def, null, module);
        this.addComponent(menu.long, def);

        if (!sticky) {
            return menu;
        }

        def = {
            view: {
                type: 'module-menu',
                short: true
            }
        };
        menu.short = this.createComponentFromDef(def, null, module);
        this.addComponent(menu.short, def);

        return menu;
    },

    /**
     * Resize the module list to the specified width and move the extra module
     * names to the `more-modules` drop down.
     *
     * @param {number} width The width that we have available.
     */
    resize: function(width) {
        /**
         * Cached version of last width available for this view.
         *
         * @type {number}
         * @private
         */
        this._width = width;

        if (width <= 0 || _.isEmpty(this._components)) {
            return;
        }

        var $moduleList = this.$('[data-container=module-list]'),
            $dropdown = this._$moreModulesDD.find('[data-container=overflow]');

        if ($moduleList.outerWidth(true) >= width) {
            this.removeModulesFromList($moduleList, width);
        } else {
            this.addModulesToList($moduleList, width);
        }
        this._$moreModulesDD.toggleClass('hidden', $dropdown.children('li').not('.hidden').length === 0);
    },

    /**
     * Computes the minimum width required for the module list.
     * This includes: the cube, the current module, and the more modules drop down.
     * @return {number}
     */
    computeMinWidth: function() {
        var minWidth = 0;
        var $moduleChildren = this.$('[data-container=module-list]').children();

        // The cube
        var $first = $moduleChildren.first();
        minWidth += $first.outerWidth() + 1;

        // The current active module
        var firstModule = $moduleChildren.filter('.active').not($first);
        if (firstModule.length) {
            minWidth += firstModule.outerWidth() + 1;
        } else {
            // or the first module
            minWidth += $moduleChildren.eq(1).outerWidth() + 1;
        }

        // More Modules dropdown
        minWidth += $moduleChildren.last().outerWidth() + 1;
        return minWidth;
    },

    /**
     * Move modules from the dropdown to the list to fit the specified width.
     * @param {jQuery} $modules The jQuery element that contains all the
     *   modules.
     * @param {Number} width The current width we have available.
     */
    addModulesToList: function($modules, width) {
        var $dropdown = this._$moreModulesDD.find('[data-container=overflow]'),
            $toHide = $dropdown.children('li').not('.hidden').first(),
            currentWidth = $modules.outerWidth(true);

        while (currentWidth < width && $toHide.length > 0) {
            this.toggleModule($toHide.data('module'), true);

            $toHide = $dropdown.children('li').not('.hidden').first();

            currentWidth = $modules.outerWidth(true);
        }

        if (currentWidth >= width) {
            this.removeModulesFromList($modules, width);
        }
    },

    /**
     * Move modules from the list to the dropdown to fit the specified width
     * @param {jQuery} $modules The jQuery element that contains all the
     *   modules.
     * @param {Number} width The current width we have available.
     */
    removeModulesFromList: function($modules, width) {

        var $toHide = this._$moreModulesDD.prev();

        while ($modules.outerWidth(true) > width && $toHide.length > 0) {
            if (!this.isRemovableModule($toHide.data('module'))) {
                $toHide = $toHide.prev();
                continue;
            }

            this.toggleModule($toHide.data('module'), false);

            $toHide = $toHide.prev();
        }
    },

    /**
     * Toggle module menu given. This will make sure it will be always in sync.
     *
     * We decided to assume that the `more-modules` drop down is the master of
     * the information to keep in sync.
     *
     * If we don't have a short menu version (on `more-modules` drop down),
     * it means that we don't need to keep it in sync and just show/hide based
     * on the module name. Think at this as a cached menu until we get another
     * `app:sync:complete` event.
     *
     * @param {String} module The module you want to turn on/off.
     * @param {Boolean} [state] `true` to show it on mega menu, `false`
     *   otherwise. If no state given, will toggle.
     *
     * @chainable
     */
    toggleModule: function(module, state) {
        // cache version only
        if (!this._catalog[module].short) {
            state = !_.isUndefined(state) ? !state : undefined;
            this._catalog[module].long.toggleClass('hidden', state);
            return this;
        }

        // keep it in sync
        var newState = this._catalog[module].short.toggleClass('hidden', state).hasClass('hidden');
        this._catalog[module].long.toggleClass('hidden', !newState);

        return this;
    },

    /**
     * Sets the module given as active and shown in the main nav bar.
     *
     * This waits for the full `this._components` to be set first. If we fail
     * to do that, we will see the current module context as the first menu.
     *
     * The module to be shown as active in the main nav bar is mapped by
     * {@link Core.MetadataManager#getTabMappedModule} to be displayed.
     *
     * Cached versions of the modules are always hidden if not active.
     *
     * @param {String} module the Module to set as Active on the menu.
     *
     * @protected
     * @chainable
     */
    _setActiveModule: function(module) {

        if (_.isEmpty(this._components)) {
            // wait until we have the mega menu in place
            return this;
        }

        var tabMap = app.metadata.getModuleTabMap(),
            mappedModule = _.isUndefined(tabMap[module]) ? module : tabMap[module],
            $activeModule = this.$('[data-container=module-list]').children('.active').removeClass('active'),
            activeModule = $activeModule.data('module'),
            moduleList = app.metadata.getFullModuleList(),
            inModuleList = !_.isUndefined(moduleList[mappedModule]);

        if (this._catalog[activeModule] && !this._catalog[activeModule].short) {
            // hide the cached version only module
            this.toggleModule(activeModule, false);
        }

        // If this is a tab-mapped module, but not mapped to anything
        // or invalid mapping, don't continue execution.
        if (!mappedModule || !inModuleList) {
            return this;
        }

        if (!this._catalog[mappedModule]) {
            this._addMenu(mappedModule, false).long.render();
        }

        this._catalog[mappedModule].long.addClass('active');
        this.toggleModule(mappedModule, true);

        return this;
    },

    /**
     * Returns `true` if a certain module can be removed from the main nav bar,
     * `false` otherwise.
     *
     * Currently we can't remove the Home module (sugar cube) neither the
     * current active module.
     *
     * @param {String} module The module to check.
     *
     * @return {Boolean} `true` if the module is safe to be removed.
     */
    isRemovableModule: function(module) {
        return !(module === 'Home' || this.isActiveModule(module));
    },

    /**
     * Returns `true` when the module is active in main nav bar, `false`
     * otherwise.
     *
     * This is normally based on the `App.controller.context` current module
     * and then sets a fallback mechanism to determine which module it is,
     * that you can see described in {@link #_setActiveModule}.
     *
     * @param {String} module The module to check.
     *
     * @return {Boolean} `true` if the module is safe to be removed.
     */
    isActiveModule: function(module) {
        return this._catalog[module].long.hasClass('active');
    }

}) },
"subpanels-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelsCreateLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelsCreateLayout
 * @extends View.Layouts.Base.SubpanelsLayout
 */
({
	// Subpanels-create Layout (base) 

    extendsFrom: 'SubpanelsLayout',

    initialize: function(options) {
        app.logger.warn('`BaseSubpanelsCreateLayout` controller ' +
            'has been deprecated since 7.8.0 and will be removed in 7.9.0. To use `BaseSubpanelsLayout` controller, ' +
            'specify the `type` property in your `subpanels-create` metadata file instead.');

        this._super('initialize', [options]);
    }
}) },
"asdashlet-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ASDashletFilterLayout
 * @alias SUGAR.App.view.layouts.BaseASDashletFilterLayout
 * @extends View.Layout
 */
({
	// Asdashlet-filter Layout (base) 

    className: 'dashablelist-filter',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //Set up a listener for the configuration save
        this.listenTo(this.layout, 'asdashlet:config:save', this.saveFilterToDashlet);
    },

    /**
     * Set the current filter ID and def to be seen on the dashlet
     *
     * @private
     */
    saveFilterToDashlet: function() {
        var filterPanelLayout = this.getComponent('filterpanel');
        if (!filterPanelLayout) {
            return;
        }

        this.model.set('currentFilterId', filterPanelLayout.context.get('currentFilterId'));
    }
}) },
"create-nodupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Create-nodupecheck Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'Create:Save',
        'Create:Cancel'
    ]
}) },
"dupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout displays a list of duplicate records found along with a count
 *
 * Note: Next step will be to add ability to switch to a filter list (and back).
 *       This is why this is in a layout.
 *
 * @class View.Layouts.Base.DupecheckLayout
 * @alias SUGAR.App.view.layouts.BaseDupecheckLayout
 * @extends View.Layout
 */
({
	// Dupecheck Layout (base) 

    initialize: function(options) {
        if(options.context.has('dupelisttype')) {
            options.meta = this.switchListView(options.meta, options.context.get('dupelisttype'));
        }
        app.view.Layout.prototype.initialize.call(this, options);
    },

    switchListView: function(meta, dupelisttype) {
        var listView = _.find(meta.components, function(component) {
            return (component.name === 'dupecheck-list');
        });
        listView.view = dupelisttype;
        return meta;
    }
}) },
"config-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ConfigDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseConfigDrawerLayout
 * @extends View.Layout
 */
({
	// Config-drawer Layout (base) 


    /**
     * Holds an object with the current module in it for parsing language strings
     *
     * <pre><code>
     *  { module: this.module }
     * </pre></code>
     */
    moduleLangObj: undefined,

    /**
     * Check to make sure the module actually has a config in metadata
     */
    configMetadataOK: false,

    /**
     * If User access to this module is OK
     */
    accessUserOK: false,

    /**
     * If User's access to module-specific ACLs are OK
     */
    accessModuleOK: false,

    /**
     * If DB or other module-specific configuration are OK
     */
    accessConfigOK: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.moduleLangObj = {
            module: this.module
        };

        if (this.checkAccess()) {
            // get the context model
            var ctxModel = options.context.get('model'),
                metadata = app.metadata.getModule(this.module);
            // empty the model
            ctxModel.clear({silent: true});

            if (_.has(metadata, 'config')) {
                // load the model with module's config
                ctxModel.set(metadata.config);
            }

            this.loadConfig(options);
        }
    },

    /**
     * @inheritdoc
     * @private
     */
    _render: function() {
        if (this.checkAccess()) {
            this._super('_render');
        } else {
            this.blockModule();
        }
    },

    /**
     * Continues initializing Config and loads data
     *
     * @param {Object} [options] The `options` param passed in to initialize
     */
    loadConfig: function(options) {
        this._super('loadData');
    },

    /**
     * Checks if User has access to this module
     * Should be overridden in modules to provide module-specific access requirements
     *
     * @return {boolean}
     */
    checkAccess: function() {
        this.configMetadataOK = this._checkConfigMetadata();
        this.accessUserOK = this._checkUserAccess();
        this.accessModuleOK = this._checkModuleAccess();
        this.accessConfigOK = this._checkModuleConfig();
        return (this.configMetadataOK && this.accessUserOK && this.accessModuleOK && this.accessConfigOK);
    },

    /**
     * Checks if there's actually config in the metadata for the current module
     *
     * @return {boolean}
     * @private
     */
    _checkConfigMetadata: function() {
        return !_.isEmpty(app.metadata.getModule(this.module, 'config'));
    },

    /**
     * Checks if the User has access to the current module
     *
     * @return {boolean}
     * @private
     */
    _checkUserAccess: function() {
        return !_.has(app.user.getAcls()[this.module], 'access');
    },

    /**
     * Allow modules to have specific access checks to allow configuration
     * Ex. Forecasts is only configurable by SystemAdmins & Forecasts Developers, not Forecasts admins
     *
     * @return {boolean}
     * @private
     */
    _checkModuleAccess: function() {
        return true;
    },

    /**
     * Adds an extra level for if the config cannot be loaded because of some module-specific case
     * Ex. Forecasts config doesn't have the right Sales Stage Won/Lost
     *
     * @return {boolean}
     * @private
     */
    _checkModuleConfig: function() {
        return true;
    },

    /**
     * Blocks config from continuing to load
     */
    blockModule: function() {
        var title = app.lang.get('LBL_CONFIG_BLOCKED_TITLE', this.module, this.moduleLangObj),
            msg;

        if (!this.configMetadataOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_NO_CONFIG_METADATA', this.module, this.moduleLangObj);
        } else if (!this.accessUserOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_USER_ACCESS', this.module, this.moduleLangObj);
        } else if (!this.accessModuleOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_MODULE_ACCESS', this.module, this.moduleLangObj);
        } else if (!this.accessConfigOK) {
            msg = app.lang.get('LBL_CONFIG_BLOCKED_DESC_CONFIG_ACCESS', this.module, this.moduleLangObj);
        }

        this.displayNoAccessAlert(title, msg);
    },

    /**
     * Displays an Error Alert with the passed in title and message
     *
     * @param {String} title Already-translated language string for the Alert's title
     * @param {String} msg Already-translated language string for the Alert's message
     */
    displayNoAccessAlert: function(title, msg) {
        var alert = app.alert.show('no_access_to_module_' + this.module, {
            level: 'error',
            title: title,
            messages: [msg]
        });

        var $close = alert.getCloseSelector();
        $close.on('click', function() {
            $close.off();
            app.router.navigate('#Home', {trigger: true});
        });
        app.accessibility.run($close, 'click');

        app.drawer.close(this.context, this.module);
    },

    /**
     * Overrides loadData to defer it running until we call it in _onceInitSelectedUser
     *
     * @override
     */
    loadData: function() {
    }
}) },
"bwc": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.BwcLayout
 * @alias SUGAR.App.view.layouts.BaseBwcLayout
 * @extends View.Layout
 */
({
	// Bwc Layout (base) 

    className: 'bwc layout',

    loadData: function() {
        // don't load record list for bwc modules
    }
}) },
"history-default": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This is the extension of {@link View.Layouts.Base.DefaultLayout} that is used
 * for the history summary drawer.
 *
 * The aim of this extension is to make the right pane collapsed by default, and
 * to remove stickiness so the pane is always collapsed when you initialize the
 * layout.
 *
 * @class View.Layouts.Base.HistoryDefaultLayout
 * @alias SUGAR.App.view.layouts.BaseHistoryDefaultLayout
 * @extends View.Layouts.Base.DefaultLayout
 */
({
	// History-default Layout (base) 

    extendsFrom: 'DefaultLayout',

    /**
     * Extend to return `false` the first time this method is called, so the
     * pane is always collapsed on first load.
     *
     * @inheritdoc
     */
    isSidePaneVisible: function() {
        if (this._isSidePaneVisibleCalledOnce !== true) {
            this._isSidePaneVisibleCalledOnce = true;
            app.user.lastState.set(this._hideLastStateKey, 1);
            return false;
        }
        return this._super('isSidePaneVisible');
    },

    /**
     * Removes the cache entry because it is unnecessary to keep it since we
     * reset it on first load.
     *
     * @inheritdoc
     */
    _dispose: function() {
        app.user.lastState.remove(this._hideLastStateKey);

        this._super('_dispose');
    }
}) },
"pii": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PiiLayout
 * @alias SUGAR.App.view.layouts.BasePiiLayout
 * @extends View.Layouts.Base.DefaultLayout
 */
({
	// Pii Layout (base) 

    extendsFrom: 'DefaultLayout',

    plugins: ['ShortcutSession'],

    shortcuts: ['PiiHeaderPanel:Close']
}) },
"subpanel-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelCreateLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelCreateLayout
 * @extends View.Layouts.Base.SubpanelLayout
 */
({
	// Subpanel-create Layout (base) 

    extendsFrom: 'SubpanelLayout',

    initialize: function(options) {
        app.logger.warn('`BaseSubpanelCreateLayout` controller ' +
            'has been deprecated since 7.8.0 and will be removed in 7.9.0. To use `BaseSubpanelLayout` controller, ' +
            'specify the `type` property in your `subpanel-create` metadata file instead.');

        this._super('initialize', [options]);
    }
}) },
"activitystream": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ActivitystreamLayout
 * @alias SUGAR.App.view.layouts.BaseActivitystreamLayout
 * @extends View.Layout
 */
({
	// Activitystream Layout (base) 

    className: "block filtered activitystream-layout",

    initialize: function(opts) {
        this.renderedActivities = {};
        this.isActivtyStreamsEnabled = app.config.activityStreamsEnabled;

        this._super('initialize', [opts]);

        this.setCollectionOptions();
        this.exposeDataTransfer();

        this.context.on("activitystream:post:prepend", this.prependPost, this);
        this.context.on('activitystream:paginate', this.paginate, this);

        // Remove active state from all preview buttons
        app.events.on('preview:close', function() {
            this.clearRowDecorations();
        }, this);
    },

    /**
     * Removes highlighted styling from stream activities.
     */
    clearRowDecorations: function() {
        if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            var activities = this.$('.activitystream-posts-comments-container');
            activities.removeClass('highlighted');
            activities.find('.preview-btn')
                .removeClass('active')
                .attr('aria-pressed', false);
        }
    },

    /**
     * Set endpoint and the success callback for retrieving activities.
     */
    setCollectionOptions: function() {
        var self = this;
        var endpoint = function(method, model, options, callbacks) {
            var real_module = self.context.parent.get('module'),
                layoutType = self.context.parent.get('layout'),
                modelId = self.context.parent.get('modelId'),
                action = model.module, // equal to 'Activities'
                url;
            switch (layoutType) {
                case "activities":
                    url = app.api.buildURL(real_module, null, {}, options.params);
                    break;
                case "records":
                    url = app.api.buildURL(real_module, action, {}, options.params);
                    break;
                case "record":
                    url = app.api.buildURL(real_module, null, {id: modelId, link: 'activities'}, options.params);
                    break;
            }
            return app.api.call("read", url, null, callbacks);
        };

        this.context.get('collection').setOption({
            endpoint: endpoint,
            success: function(collection) {
                collection.each(function(model) {
                    self.renderPost(model);
                });
            },
            error: function() {
                self.collection.dataFetched = true;
                self.collection.reset();
            }
        });
    },

    /**
     * Expose the dataTransfer object for drag and drop file uploads.
     */
    exposeDataTransfer: function() {
        jQuery.event.props.push('dataTransfer');
    },

    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('add', function(model) {
                this.renderPost(model);
            }, this);
            this.collection.on('reset', function() {
                this.disposeAllActivities();
                this.collection.each(function(post) {
                    this.renderPost(post);
                }, this);
            }, this);
        }

        if (this.context.parent) {
            var model = this.context.parent.get("model");
            this.listenTo(model, "sync", _.once(function() {
                // Only attach to the sync event after the inital sync is done.
                this.listenTo(model, "sync", function() {
                    var options = this.context.get("collectionOptions");
                    this.collection.fetch(options);
                });
            }));
        }
    },

    prependPost: function(model) {
        var view = this.renderPost(model);
        view.$el.parent().prepend(view.$el);
    },

    loadData: function(options) {
        // We want to ensure the data related to this activity loads before the
        // stream for a better user experience.
        var parentCol = this.context.parent.get("collection");
        if (parentCol.isEmpty()) {
            parentCol.once("sync", function(){
                this._load(options);
            }, this);
        } else {
            this._load(options);
        }
    },

    _load: function(options) {
        if (_.isUndefined(this.context.parent.get('layout'))) {
            return;
        }
        options = _.extend({}, options, this.context.get('collectionOptions'));
        this.collection.fetch(options);
    },

    renderPost: function(model, readonly) {
        var view;
        if(_.has(this.renderedActivities, model.id)) {
            view = this.renderedActivities[model.id];
        } else {
            view = app.view.createView({
                context: this.context,
                type: "activitystream",
                module: this.module,
                layout: this,
                model: model,
                readonly: readonly
            });
            this.addComponent(view);
            this.renderedActivities[model.id] = view;
            view.render();
        }
        return view;
    },

    _placeComponent: function(component) {
        if (this.disposed)
            return;

        if(component.name === "activitystream") {
            this.$el.find(".activitystream-list").append(component.el);
        } else if (component.name === 'activitystream-bottom') {
            this.$el.append(component.el);
            component.render();
        } else {
            this.$el.prepend(component.el);
        }
    },

    unbindData: function() {
        var model, collection;

        if (this.context.parent) {
            model = this.context.parent.get("model");
            collection = this.context.parent.get("collection");

            if (model) {
                model.off("change sync", null, this);
            }
            if (collection) {
                collection.off("sync", null, this);
            }
        }

        app.view.Layout.prototype.unbindData.call(this);
    },

    /**
     * Dispose all previously rendered activities
     */
    disposeAllActivities: function() {
        var nonActivities = [];
        _.each(this._components, function(component) {
            if (component.name !== 'activitystream') {
                nonActivities.push(component);
            } else {
                component.dispose();
            }
        });
        this._components = nonActivities;
        this.renderedActivities = {};
    },

    /**
     * Get the next set of activity stream posts.
     */
    paginate: function() {
        this.collection.paginate({
            add: true
        });
    }
}) },
"filterpanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.FilterpanelLayout
 * @alias SUGAR.App.view.layouts.BaseFilterpanelLayout
 * @extends View.Layouts.Base.TogglepanelLayout
 */
({
	// Filterpanel Layout (base) 

    extendsFrom: 'TogglepanelLayout',

    /**
     * @inheritdoc
     *
     * Certain options can be set in the filterpanel metadata:
     *     - `auto_apply`: this will determine whether or not to apply the
     *       filter while completing filter rows. This is used mainly because
     *       getRelevantContextList may return the global context and will
     *       filter its collection automatically, and sometimes this is not
     *       desired (e.g. a drawer layout with a filterpanel embedded).
     *
     *     - `stickiness`: this will determine whether or not to save
     *       properties pertaining to filters in localstorage. This is needed
     *       for certain views that have filterpanels, do not require
     *       stickiness and do not want to affect already-stored values in
     *       localstorage (e.g. the filterpanel layout in dashboardconfiguration
     *       shouldn't affect the stickiness of filters on record/list views,
     *       so it should be set to false).
     *
     *     - `show_actions`: this will determine whether or not the
     *       `delete`, `reset`, and `cancel` action buttons will be rendered on
     *       the `filter-actions` view.
     *
     *     @example
     *     <pre><code>
     *         'layout' => array(
     *              'type' =>'filterpanel',
     *              'filter_options' => array(
     *                  'auto_apply' => false,
     *                  'stickiness' => false,
     *                  'show_actions' => false,
     *              ),
     *          ),
     *     </code></pre>
     */
    initialize: function(opts) {
        // The filter options default to true.
        var defaultOptions = {
            'auto_apply': true,
            'stickiness': true,
            'show_actions': true
        };

        this.events = _.extend({}, this.events, {
            'click [data-action=refreshList]': '_refreshList'
        });

        var moduleMeta = app.metadata.getModule(opts.module) || {};
        this.disableActivityStreamToggle(opts.module, moduleMeta, opts.meta || {});

        this.on("filterpanel:change:module", function(module, link) {
            this.currentModule = module;
            this.currentLink = link;
        }, this);

        this.on('filter:create:open', function() {
            this.$('.filter-options').removeClass('hide');

            // "filter:create:open" is triggered even when the edit drawer is
            // being closed, so protect against saving the shortcuts when that
            // happens
            var activeShortcutSession = app.shortcuts.getCurrentSession();
            if (_.isNull(activeShortcutSession)
                || (activeShortcutSession && activeShortcutSession.layout !== this)) {
                app.shortcuts.saveSession();
                app.shortcuts.createSession([
                    'Filter:Add',
                    'Filter:Remove',
                    'Filter:Close',
                    'Filter:Save',
                    'Filter:Delete',
                    'Filter:Reset'
                ], this);
            }
        }, this);

        this.on('filter:create:close', function() {
            this.$('.filter-options').addClass('hide');

            // "filter:create:close" is triggered even when filter:create:open has not been called
            var activeShortcutSession = app.shortcuts.getCurrentSession();
            if (activeShortcutSession && (activeShortcutSession.layout === this)) {
                app.shortcuts.restoreSession();
            }
        }, this);

        // This is required, for example, if we've disabled the subapanels panel so that app doesn't attempt to render later
        this.on('filterpanel:lastviewed:set', function(viewed) {
            this.toggleViewLastStateKey = this.toggleViewLastStateKey || app.user.lastState.key('toggle-view', this);
            var lastViewed = app.user.lastState.get(this.toggleViewLastStateKey);
            if (lastViewed !== viewed) {
                app.user.lastState.set(this.toggleViewLastStateKey, viewed);
            }
        }, this);

        this._super("initialize", [opts]);

        // Set the filter that's currently being edited.
        this.context.editingFilter = null;

        // Obtain any options set in the metadata and override the defaultOptions with them
        // to set on the context.
        var filterOptions = _.extend(defaultOptions, this.meta.filter_options, this.context.get('filterOptions'));
        this.context.set('filterOptions', filterOptions);

        // The `defaultModule` will either evaluate to the model's module (more
        // specific, and used on dashablelist filters), or the module on the
        // current context.
        var lastViewed = app.user.lastState.get(this.toggleViewLastStateKey),
            defaultModule = this.module || this.model.get('module') || this.context.get('module');

        this.trigger('filterpanel:change:module', (moduleMeta.activityStreamEnabled && lastViewed === 'activitystream') ? 'Activities' : defaultModule);
    },

    /**
     * Applies last filter
     * @param {Collection} collection the collection to retrieve the filter definition
     * @param {String} condition(optional) You can specify a condition in order to prevent applying filtering
     */
    applyLastFilter: function(collection, condition) {
        var triggerFilter = true;
        if (_.size(collection.origFilterDef)) {
            if (condition === 'favorite') {
                //Here we are verifying the filter applied contains $favorite otherwise we don't really care about
                //refreshing the listview
                triggerFilter = !_.isUndefined(_.find(collection.origFilterDef, function(value, key) {
                    return key === '$favorite' || (value && !_.isUndefined(value.$favorite));
                }));
            }
            if (triggerFilter) {
                var query = this.$('.search input.search-name').val();
                this.trigger('filter:apply', query, collection.origFilterDef);
            }
        }
    },

    /**
     * Refreshes the list view by applying filters.
     *
     * @private
     */
    _refreshList: function() {
        this.trigger('filter:apply');
    },
    
    /**
     * Disables the activity stream toggle if activity stream is not enabled for a module
     * @param {String} moduleName The name of the module
     * @param {Object} moduleMeta The metadata for the module
     * @param {Object} viewMeta The metadata for the component
     */
    disableActivityStreamToggle: function(moduleName, moduleMeta, viewMeta) {
        if (moduleName !== 'Activities' && !moduleMeta.activityStreamEnabled) {
            _.each(viewMeta.availableToggles, function(toggle) {
                if (toggle.name === 'activitystream') {
                    toggle.disabled = true;
                    toggle.label = 'LBL_ACTIVITY_STREAM_DISABLED';
                }
            });
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        this._super('_render');
        // `filter-rows` view is outside of `filter` layout and is rendered after `filter` layout is rendered.
        // Now that we are able to preserve last search, we need to initialize filter only once all the filter
        // components rendered.
        this.trigger('filter:reinitialize');
    }
}) },
"filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout for filtering a collection.
 *
 * Composed of a module dropdown(optional), a filter dropdown and an input.
 *
 * @class View.Layouts.Base.FilterLayout
 * @alias SUGAR.App.view.layouts.BaseFilterLayout
 * @extends View.Layout
 */
({
	// Filter Layout (base) 

    className: 'filter-view search',

    events: {
        'click .add-on.fa-times': function() { this.trigger('filter:clear:quicksearch'); }
    },

    /**
     * The collection of filters.
     *
     * @property {Data.BeanCollection}
     */
    filters: null,

    /**
     * @override
     * @param {Object} opts
     */
    initialize: function(opts) {
        var filterLayout = app.view._getController({type:'layout',name:'filter'});
        filterLayout.loadedModules = filterLayout.loadedModules || {};
        app.view.Layout.prototype.initialize.call(this, opts);

        this.layoutType = app.utils.deepCopy(this.options.meta.layoutType) || this.context.get('layout') || this.context.get('layoutName') || app.controller.context.get('layout');

        this.aclToCheck = (this.layoutType === 'record')? 'view' : 'list';

        // Can't use getRelevantContextList here, because the context may not
        // have all the children we need.
        if (this.layoutType === 'records' || this.layoutType === 'activities') {
            // filters will handle data fetching so we skip the standard data fetch
            this.context.set('skipFetch', true);
        } else {
            if(this.context.parent) {
                this.context.parent.set('skipFetch', true);
            }
            this.context.on('context:child:add', function(childCtx) {
                if (childCtx.get('link')) {
                    // We're in a subpanel.
                    childCtx.set('skipFetch', true);
                }
            }, this);
        }

        /**
         * bind events
         */
        this.on('filter:apply', this.applyFilter, this);

        this.on('filter:create:close', function() {
            if (!this.createPanelIsOpen()) {
                return;
            }
            this.layout.trigger('filter:create:close');
            // When canceling creating a new filter, we want to go back to the `all_records` filter
            if (this.getLastFilter(this.layout.currentModule, this.layoutType) === 'create') {
                // For that we need to remove the last state key and trigger reinitialize
                this.clearLastFilter(this.layout.currentModule, this.layoutType);
                this.layout.trigger("filter:reinitialize");
            }
            this.context.editingFilter = null;
        }, this);

        this.on('filter:create:open', function(filterModel) {
            this.context.editingFilter = filterModel;
            this.layout.trigger('filter:create:open', filterModel);
        }, this);

        this.on('subpanel:change', function(linkName) {
            this.layout.trigger('subpanel:change', linkName);
        }, this);

        this.on('filter:get', this.initializeFilterState, this);

        this.on('filter:change:filter', this.handleFilterChange, this);

        this.layout.on('filter:apply', function(query, def) {
            this.trigger('filter:apply', query, def);
        }, this);

        this.layout.on('filterpanel:change', this.handleFilterPanelChange, this);
        this.layout.on('filterpanel:toggle:button', this.toggleFilterButton, this);

        //When a filter is saved, update the cache and set the filter to be the currently used filter
        this.context.on('filter:add', this.addFilter, this);

        // When a filter is deleted, update the cache and set the default filter
        // to be the currently used filter.
        this.layout.on('filter:remove', this.removeFilter, this);

        this.layout.on('filter:reinitialize', function() {
            this.initializeFilterState(this.layout.currentModule, this.layout.currentLink);
        }, this);

        this.listenTo(app.events, 'dashlet:filter:save', this.refreshDropdown);
    },

    /**
     * This function refreshes the list of filters in the filter dropdown, and
     * is invoked when a filter is saved on a dashlet (`dashlet:filter:save`).
     * It triggers a `filter:reinitialize` event and resets the cached
     * module in `loadedModules` on the filter layout if the dashlet module
     * matches the `currentModule` on the filter layout.
     *
     * @param {String} module
     */
    refreshDropdown: function(module) {
        if (module === this.layout.currentModule) {
            var filterLayout = app.view._getController({type:'layout', name:'filter'});
            filterLayout.loadedModules[module] = false;
            this.layout.trigger('filter:reinitialize');
        }
    },

    /**
     * handles filter removal
     * @param model
     */
    removeFilter: function(model) {
        this.filters.collection.remove(model);
        this.context.set('currentFilterId', null);
        this.clearLastFilter(this.layout.currentModule, this.layoutType);
        this.layout.trigger('filter:reinitialize');
    },

    /**
     * Saves last filter id to app cache.
     *
     * @param {String} filterModule The name of the filtered module.
     * @param {String} layoutName The name of the current layout.
     * @param {String} filterId The filter id.
     */
    setLastFilter: function(filterModule, layoutName, filterId) {
        var filterOptions = this.context.get('filterOptions') || {};
        this.context.set('currentFilterId', filterId);
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('last-' + filterModule + '-' + layoutName, this);
            app.user.lastState.set(key, filterId);
        }
    },

    /**
     * Gets last filter id from cache.
     *
     * @param {String} filterModule The name of the filtered module.
     * @param {String} layoutName The name of the current layout.
     * @return {String} The filter id.
     */
    getLastFilter: function(filterModule, layoutName) {
        // Check if we've already loaded it.
        var filter = this.context.get('currentFilterId');
        if (!_.isEmpty(filter)) {
            return filter;
        }

        var filterOptions = this.context.get('filterOptions') || {};
        // Load from cache.
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('last-' + filterModule + '-' + layoutName, this);
            filter = app.user.lastState.get(key);
        }

        // Check if there is an initial filter defined that we should use instead.
        if (_.isEmpty(filter) && filterOptions.initial_filter) {
            filter = filterOptions.initial_filter;
        }

        this.context.set('currentFilterId', filter);
        return filter;
    },

    /**
     * Clears last filter id from cache.
     *
     * @param {String} filterModule The name of the filtered module.
     * @param {String} layoutName The name of the current layout.
     */
    clearLastFilter: function(filterModule, layoutName) {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('last-' + filterModule + '-' + layoutName, this);
            app.user.lastState.remove(key);
        }
        this.clearFilterEditState();
    },

    /**
     * Retrieves the current edit state from cache.
     *
     * @return {Object} The filter attributes if found.
     */
    retrieveFilterEditState: function() {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('edit-' + this.layout.currentModule + '-' + this.layoutType, this);
            return app.user.lastState.get(key);
        }
    },

    /**
     * Saves the current edit state into the cache
     *
     * @param {Object} filter
     */
    saveFilterEditState: function(filter) {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('edit-' + this.layout.currentModule + '-' + this.layoutType, this);
            app.user.lastState.set(key, filter);
        }
    },

    /**
     * Removes the edit state from the cache
     */
    clearFilterEditState: function() {
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.stickiness !== false) {
            var key = app.user.lastState.key('edit-' + this.layout.currentModule + '-' + this.layoutType, this);
            app.user.lastState.remove(key);
        }
    },

    /**
     * Removes deprecated cache entries of one module.
     *
     * The {@link Data.Base.FiltersBeanCollection} is now responsible for
     * storing the list of filters in memory. This list is no longer saved to
     * the local storage.
     *
     * First version, the list was stored with a key looking like this:
     *
     *     this.module + ':filter:saved-' + this.layout.currentModule
     *
     * Second version, the list was stored with a key looking like this:
     *
     *     module + ':filter:saved-filters
     *
     * Examples of keys we need to remove:
     *
     *     Home:filter:saved-Accounts
     *     Accounts:filter:saved-Accounts
     *     Contacts:filter:saved-Accounts
     *     Accounts:filter:saved-filters
     *     Contacts:filter:saved-filters
     *
     * @param {String} module The module name.
     */
    removeDeprecatedCache: function(module) {
        app.user.lastState.remove(app.user.lastState.key('saved-' + module, this));

        var layoutModule = this.module;
        this.module = module;
        // The filter collection used to be cached. It's now only saved in
        // memory so we need to remove the potential existing cache entry.
        app.user.lastState.remove(app.user.lastState.key('saved-filters', this));
        this.module = layoutModule;
    },

    /**
     * Handles filter addition or update.
     *
     * @param {Data.Base.FiltersBean} model The filter model that is created or
     *   updated.
     */
    addFilter: function(model) {
        var id = model.get('id');
        this.filters.collection.add(model, {merge: true});
        this.filters.collection.trigger('cache:update', model);
        this.setLastFilter(this.layout.currentModule, this.layoutType, id);
        this.context.set('currentFilterId', id);
        this.clearFilterEditState();
        this.layout.trigger('filter:reinitialize');
    },

    /**
     * Enables or disables a filter toggle button (e.g. activity or subpanel toggle buttons)
     * @param {String} toggleDataView the string used in `data-view` attribute for that toggle element (e.g. 'subpanels', 'activitystream')
     * @param {Boolean} on pass true to enable, false to disable
     */
    toggleFilterButton: function (toggleDataView, on) {
        var toggleButtons = this.layout.$('.toggle-actions a.btn');

        // Loops toggle buttons for 'data-view' that corresponds to `toggleDataView` and enables/disables per `on`
        _.each(toggleButtons, function(btn) {
            if($(btn).data('view') === toggleDataView) {
                if(on) {
                    $(btn).removeAttr('disabled').removeClass('disabled');
                } else {
                    $(btn).attr('disabled', 'disabled').addClass('disabled');
                    $(btn).attr('title', app.lang.get('LBL_NO_DATA_AVAILABLE'));
                }
            }
        });
    },

    /**
     * Handles filter panel changes between activity and subpanels
     * @param {String} name Name of panel
     * @param {Boolean} silent Whether to trigger filter events
     * @param {Boolean} setLastViewed Whether to set last viewed to `name` panel
     */
    handleFilterPanelChange: function(name, silent, setLastViewed) {
        this.showingActivities = name === 'activitystream';
        var module = this.showingActivities ? "Activities" : this.module;
        var link;

        this.$el.css('visibility', app.acl.hasAccess(this.aclToCheck, module) ? 'visible' : 'hidden');
        if(this.layoutType === 'record' && !this.showingActivities) {
            // FIXME: TY-499 will address removing the dependancy on this.layout
            module = link = app.user.lastState.get(app.user.lastState.key('subpanels-last', this.layout)) || 'all_modules';
            if (link !== 'all_modules') {
                module = app.data.getRelatedModule(this.module, link);
            }
        } else {
            link = null;
        }
        if (!silent) {
            this.trigger("filter:render:module");
            this.trigger("filter:change:module", module, link);
        }
        if (setLastViewed) {
            // Asks filterpanel to update user.lastState with new panel name as last viewed
            this.layout.trigger('filterpanel:lastviewed:set', name);
        }
    },

    /**
     * Handles filter change.
     *
     * @param {String} id The filter id.
     */
    handleFilterChange: function(id) {
        this.setLastFilter(this.layout.currentModule, this.layoutType, id);

        var filter, editState = this.retrieveFilterEditState();
        // Figure out if we have an edit state. This would mean user was editing the filter so we want him to retrieve
        // the filter form in the state he left it.
        filter = this.filters.collection.get(id) || app.data.createBean('Filters', {module_name: this.moduleName});
        if (editState && (editState.id === id || (id==='create' && !editState.id))) {
            filter.set(editState);
        } else {
            editState = false;
        }

        this.context.set('currentFilterId', filter.get('id'));

        var editable = filter.get('editable') !== false;

        // If the user selects a filter that has an incomplete filter
        // definition (i.e. filter definition != filter_template), open the
        // filterpanel to indicate it is ready for further editing.
        var isIncompleteFilter = filter.get('filter_template') &&
            JSON.stringify(filter.get('filter_definition')) !== JSON.stringify(filter.get('filter_template'));

        // If the user selects a filter template that gets populated by values
        // passed in the context/metadata, open the filterpanel to show the
        // actual search.
        var isTemplateFilter = filter.get('is_template');

        var modelHasChanged = !_.isEmpty(filter.changedAttributes(filter.getSynced()));

        if (editable &&
            (isIncompleteFilter || isTemplateFilter || editState || id === 'create' || modelHasChanged)
        ) {
            this.layout.trigger('filter:set:name', '');
            this.trigger('filter:create:open', filter);
            this.layout.trigger('filter:toggle:savestate', true);
        } else {
            // FIXME: TY-1457 should improve this
            this.context.editingFilter = null;
            this.layout.trigger('filter:create:close');
        }

        var ctxList = this.getRelevantContextList();
        var clear = false;
        //Determine if we need to clear the collections
        _.each(ctxList, function(ctx) {
            var filterDef = filter.get('filter_definition');
            var orig = ctx.get('collection').origFilterDef;
            ctx.get('collection').origFilterDef = filterDef;  //Set new filter def on each collection
            if (_.isUndefined(orig) || !_.isEqual(orig, filterDef)) {
                clear = true;
            }
        });
        //If so, reset collections and trigger quicksearch to repopulate
        if (clear) {
            _.each(ctxList, function(ctx) {
                ctx.get('collection').resetPagination();
                // Silently reset the collection otherwise the view is re-rendered.
                // It will be re-rendered on request response.
                ctx.get('collection').reset(null, { silent: true });
            });
            this.trigger('filter:apply');
        }
    },
    /**
     * Applies filter on current contexts
     * @param {String} query search string
     * @param {Object} dynamicFilterDef(optional)
     */
    applyFilter: function(query, dynamicFilterDef) {
        // TODO: getRelevantContextList needs to be refactored to handle filterpanels in drawer layouts,
        // as it will return the global context instead of filtering a list view within the drawer context.
        // As a result, this flag is needed to prevent filtering on the global context.
        var filterOptions = this.context.get('filterOptions') || {};
        if (filterOptions.auto_apply === false) {
            return;
        }

        // to make sure quick filter is handled properly
        if (_.isEmpty(query)) {
            var filterQuicksearchView = this.getComponent('filter-quicksearch');
            query = filterQuicksearchView && filterQuicksearchView.$el.val() || '';
        }

        //If the quicksearch field is not empty, append a remove icon so the user can clear the search easily
        this._toggleClearQuickSearchIcon(!_.isEmpty(query));
        var self = this;
        var ctxList = this.getRelevantContextList();

        // Here we split the relevant contexts into two groups, 'count', and
        // 'fetch'. For the 'count' contexts, we do a 'fetchOnlyIds' on their
        // collection so we can update the count and highlight the subpanel
        // icon, even though they are collapsed. For the 'fetch' group, we do a
        // full collection fetch so the subpanel can render its list view.
        var relevantCtx = _.groupBy(ctxList, function(ctx) {
            return ctx.get('collapsed') ? 'count' : 'fetch';
        });

        var batchId = relevantCtx.count && relevantCtx.count.length > 1 ? _.uniqueId() : false;
        _.each(relevantCtx.count, function(ctx) {
            var ctxCollection = ctx.get('collection');
            var origFilterDef = dynamicFilterDef || ctxCollection.origFilterDef || [];
            var filterDef = self.buildFilterDef(origFilterDef, query, ctx);
            var options = {
                //Show alerts for this request
                showAlerts: true,
                apiOptions: {
                    bulk: batchId
                }
            };

            ctxCollection.filterDef = filterDef;
            ctxCollection.origFilterDef = origFilterDef;
            ctxCollection.resetPagination();

            options = _.extend(options, ctx.get('collectionOptions'));
            ctx.resetLoadFlag({recursive: false});
            ctx.set('skipFetch', true);
            ctx.loadData(options);

            // We need to reset twice so we can trigger the other bulk call.
            ctx.resetLoadFlag({recursive: false});
            options.success = _.bind(function(hasAmount, properties) {
                if (!this.disposed) {
                    ctx.trigger('refresh:count', hasAmount, properties);
                }
            }, this);
            ctxCollection.hasAtLeast(ctx.get('limit'), options);
        });

        // FIXME: Filters should not be triggering the bulk request and should
        // be moved to subpanels instead. Will be fixed as part of SC-4533.
        if (batchId) {
            app.api.triggerBulkCall(batchId);
        }

        batchId = relevantCtx.fetch && relevantCtx.fetch.length > 1 ? _.uniqueId() : false;
        _.each(relevantCtx.fetch, function(ctx) {
            var ctxCollection = ctx.get('collection');
            var origFilterDef = dynamicFilterDef || ctxCollection.origFilterDef || [];
            var filterDef = self.buildFilterDef(origFilterDef, query, ctx);
            var options = {
                //Show alerts for this request
                showAlerts: true,
                apiOptions: {
                    bulk: batchId
                },
                success: function(collection, response, options) {
                    // Close the preview pane to ensure that the preview
                    // collection is in sync with the list collection.
                    app.events.trigger('preview:close');
                }
            };

            ctxCollection.filterDef = filterDef;
            ctxCollection.origFilterDef = origFilterDef;

            ctx.resetLoadFlag({recursive: false});
            ctx.set('skipFetch', false);
            ctx.loadData(options);
        });
        if (batchId) {
            app.api.triggerBulkCall(batchId);
        }
    },

    /**
     * Look for the relevant contexts. It can be
     * - the activity stream context
     * - the list view context on records layout
     * - the selection list view context on records layout
     * - the contexts of the subpanels on record layout
     * @return {Array} array of contexts
     */
    getRelevantContextList: function() {
        var contextList = [];
        if (this.showingActivities) {
            _.each(this.layout._components, function(component) {
                var ctx = component.context;
                if (component.name == 'activitystream' && !ctx.get('modelId') && ctx.get('collection')) {
                    //FIXME: filter layout's _components array has multiple references to same activitystreams layout object
                    contextList.push(ctx);

                }
            });
        } else {
            if (this.layoutType === 'records') {
                var ctx = this.context;
                if (!ctx.get('modelId') && ctx.get('collection')) {
                    contextList.push(ctx);
                }
            } else {
                //Locate and add subpanel contexts
                _.each(this.context.children, function(ctx) {
                    if (ctx.get('isSubpanel') && !ctx.get('hidden') && !ctx.get('modelId') && ctx.get('collection')) {
                        contextList.push(ctx);
                    }
                });
            }
        }
        return _.uniq(contextList);
    },

    /**
     * Builds the filter definition based on preselected filter and module quick search fields
     * @param {Object} oSelectedFilter
     * @param {String} searchTerm
     * @param {Context} context
     * @return {Array} array containing filter def
     */
    buildFilterDef: function(oSelectedFilter, searchTerm, context) {
        var selectedFilter = app.utils.deepCopy(oSelectedFilter),
            isSelectedFilter = _.size(selectedFilter) > 0,
            module = context.get('module'),
            filtersBeanPrototype = app.data.getBeanClass('Filters').prototype,
            searchFilter = filtersBeanPrototype.buildSearchTermFilter(module, searchTerm),
            isSearchFilter = _.size(searchFilter) > 0;

        selectedFilter = _.isArray(selectedFilter) ? selectedFilter : [selectedFilter];
        /**
         * Filter fields that don't exist either on vardefs or search definition.
         *
         * Special fields (fields that start with `$`) like `$favorite` aren't
         * cleared.
         *
         * TODO move this to a plugin method when refactoring the code (see SC-2555)
         * TODO we should support cleanup on all levels (currently made on 1st
         * level only).
         */
        var specialField = /^\$/,
            meta = app.metadata.getModule(module);
        selectedFilter = _.filter(selectedFilter, function(def) {
            var fieldName = _.keys(def).pop();
            return specialField.test(fieldName) || meta.fields[fieldName];
        }, this);

        if (isSelectedFilter && isSearchFilter) {
            selectedFilter.push(searchFilter[0]);
            return [{'$and': selectedFilter }];
        } else if (isSelectedFilter) {
            return selectedFilter;
        } else if (isSearchFilter) {
            return searchFilter;
        }

        return [];
    },

    /**
     * Loads the full filter panel for a module.
     *
     * @param {String} moduleName The module name.
     * @param {String} [linkName] The related module link name, by default it
     *   will load the last selected filter,
     * @param {String} [filterId] The filter ID to initialize with. By default
     *   it will load the last selected filter or the default filter from
     *   metadata.
     */
    initializeFilterState: function(moduleName, linkName, filterId) {

        if (this.showingActivities) {
            moduleName = 'Activities';
            linkName = null;
        } else {
            moduleName = moduleName || this.module;

            if (this.layoutType === 'record') {
                // FIXME: TY-499 will address removing the dependancy on this.layout
                linkName = app.user.lastState.get(app.user.lastState.key('subpanels-last', this.layout)) ||
                    linkName ||
                    'all_modules';

                // if the incoming module is the same as the layoutModule then we need to find the other side.
                if (linkName !== 'all_modules' && this.layout.module === moduleName) {
                    moduleName = app.data.getRelatedModule(moduleName, linkName) || moduleName;
                }

                // For subpanels where layoutType is record and linkName is all_modules,
                // only the all_records filter should be used.
                if (linkName === 'all_modules') {
                    filterId = 'all_records';
                }
            }
        }

        filterId = filterId || this.getLastFilter(moduleName, this.layoutType);

        this.layout.trigger('filterpanel:change:module', moduleName, linkName);
        this.trigger('filter:change:module', moduleName, linkName, true);
        this.getFilters(moduleName, filterId);
    },

    /**
     * Retrieves the appropriate list of filters from cache if found, otherwise
     * from the server.
     *
     * @param {String} moduleName The module name.
     * @param {String} [defaultId] The filter `id` to select once loaded.
     */
    getFilters: function(moduleName, defaultId) {
        if (moduleName === 'all_modules') {
            this.selectFilter('all_records');
            return;
        }
        var filterOptions = this.context.get('filterOptions') || {};

        if (this.filters) {
            this.filters.dispose();
        }

        // Remove deprecated cache entries.
        this.removeDeprecatedCache(moduleName);

        this.filters = app.data.createBeanCollection('Filters');
        this.filters.setModuleName(moduleName);
        this.filters.setFilterOptions(filterOptions);

        this.filters.load({
            success: _.bind(function() {
                if (this.disposed) {
                    return;
                }
                defaultId = defaultId || this.filters.collection.defaultFilterFromMeta;
                this.selectFilter(defaultId);

            }, this)
        });
    },

    /**
     * Selects a filter.
     *
     * @triggers filter:select:filter to select the filter in the dropdown.
     *
     * @param {String} filterId The filter id to select.
     * @return {String} The selected filter id.
     */
    selectFilter: function(filterId) {
        var possibleFilters,
            selectedFilterId = filterId;

        if (selectedFilterId !== 'create') {
            possibleFilters = [selectedFilterId, this.filters.collection.defaultFilterFromMeta, 'all_records'];
            possibleFilters = _.filter(possibleFilters, this.filters.collection.get, this.filters.collection);
            selectedFilterId = _.first(possibleFilters);
        }
        this.trigger('filter:render:filter');
        this.trigger('filter:select:filter', selectedFilterId);
        return selectedFilterId;
    },

    /**
     * Utility function to know if the create filter panel is opened.
     * @return {boolean} `true` if opened, `false` otherwise
     */
    createPanelIsOpen: function() {
        return !this.layout.$(".filter-options").is(":hidden");
    },

    /**
     * Determines whether a user can create a filter for the current module.
     * @return {boolean} `true` if creatable, `false` otherwise
     */
    canCreateFilter: function() {
        // Check for create in meta and make sure that we're only showing one
        // module, then return false if any is false.
        var contexts = this.getRelevantContextList(),
            creatable = app.acl.hasAccess("create", "Filters"),
            meta;
        // Short circuit if we don't have the ACLs to create Filter beans.

        if (creatable && contexts.length === 1) {
            meta = app.metadata.getModule(contexts[0].get("module"));
            if (meta && _.isObject(meta.filters)) {
                _.each(meta.filters, function(value) {
                    if (_.isObject(value)) {
                        creatable = creatable && value.meta.create !== false;
                    }
                });
            }
        }

        return creatable;
    },

    /**
     * Append or remove an icon to the quicksearch input so the user can clear the search easily
     * @param {Boolean} addIt TRUE if you want to add it, FALSO to remove
     */
    _toggleClearQuickSearchIcon: function(addIt) {
        if (addIt && !this.$('.fa-times.add-on')[0]) {
            this.$el.append('<i class="fa fa-times add-on"></i>');
        } else if (!addIt) {
            this.$('.fa-times.add-on').remove();
        }
    },

    /**
     * @override
     * @private
     */
    _render: function() {
        if (app.acl.hasAccess(this.aclToCheck, this.module)) {
            app.view.Layout.prototype._render.call(this);
        }
    },

    /**
     * @override
     */
    unbind: function() {
        if (this.filters) {
            this.filters.dispose();
        }
        this.filters = null;
        app.view.Layout.prototype.unbind.call(this);
    }

}) },
"subpanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelLayout
 * @extends View.Layouts.Base.PanelLayout
 */
({
	// Subpanel Layout (base) 

    extendsFrom: 'PanelLayout',

    /**
     * What is our current dataview
     */
    dataView: 'subpanel-list',

    /**
     * @override
     */
    initialize: function(options) {
        //Check for the override_subpanel_list_view from the parent layout metadata and replace the list view if found.
        if (options.meta && options.def && options.def.override_subpanel_list_view) {
            _.each(options.meta.components, function(def) {
                if (def.view && def.view.indexOf('subpanel-list') !== -1) {
                    def.view = options.def.override_subpanel_list_view;
                }
            });
            // set the dataview if we override it
            this.dataView = options.def.override_subpanel_list_view;
            // override last_state.id with "override_subpanel_list_view" for unique state name.
            if (options.meta.last_state.id) {
                options.meta.last_state.id = options.def.override_subpanel_list_view;
            }
        }

        if (options.meta && options.def && options.def.override_paneltop_view) {
            _.each(options.meta.components, function(def) {
                if (def.view && def.view == 'panel-top') {
                    def.view = options.def.override_paneltop_view;
                }
            });
        }

        this._super('initialize', [options]);

        // if the dataView variable does not equal 'subpanel-list', it means it was changed
        // and we need to set the correct dataView on the context so when the data is fetched via
        // the api, it pulls the correct fields.
        if (this.dataView !== 'subpanel-list') {
            this.context.set('dataView', this.dataView);
        }

        // FIXME in SC-3360 - this is a hacky flag to be able to fetch a collection of
        // links. We will be able to remove this code once we introduce the CollectionsAPI.
        var ignoreRole = this.context.get('ignore_role');
        if (ignoreRole) {
            var collection = this.collection;
            var options = collection.getOption() || {};
            var params = options.params || {};
            params.ignore_role = ignoreRole;
            collection.setOption('params', params);
        }

        // binding so subpanels can trigger other subpanels to reload by link name
        // example: ctx.trigger('subpanel:reload', {links: ['opportunities','revenuelineitems']});
        if (this.context.parent) {
            this.context.parent.on('subpanel:reload', function(args) {
                app.logger.warn('`subpanel:reload` is deprecated. Use `context.reloadData()` to reload and expand.');
                if (!_.isUndefined(args) && _.isArray(args.links) && _.contains(args.links, this.context.get('link'))) {
                    this.context.reloadData({recursive: false});
                }
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    show: function() {
        this.context.set('hidden', false);
        this._super('show');
    },

    /**
     * @inheritdoc
     */
    hide: function() {
        this.context.set('hidden', true);
        this._super('hide');
    }
}) },
"sweetspot-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SweetspotConfigLayout
 * @alias SUGAR.App.view.layouts.BaseSweetspotConfigLayout
 * @extends View.Layout
 */
({
	// Sweetspot-config Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'SweetSpot:Config:Save',
        'SweetSpot:Config:Cancel'
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._bindEvents();
    },

    /**
     * @override
     */
    _placeComponent: function(component) {
        this.$('.main-pane').append(component.el);
    },

    /**
     * Binds the events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        this.context.on('sweetspot:cancel:config', this.cancelConfig, this);

        // Button events
        this.context.on('button:save_button:click', this.saveConfig, this);
        this.context.on('button:cancel_button:click', this.cancelConfig, this);
    },


    /**
     * This method prepares the attributes payload for the call to
     * {@link Core.User#updatePreferences}.
     *
     * @protected
     * @param {Object} data The unprepared configuration data.
     * @return {Object} The prepared configuration data.
     */
    _formatForUserPrefs: function(data) {
        return {sweetspot: data};
    },

    /**
     * Receives all the configuration models from the subcomponents, to be
     * saved in user preferences.
     *
     * @protected
     */
    _getAllConfigs: function() {
        var config = {};
        this.context.off('sweetspot:receive:configs');
        this.context.on('sweetspot:receive:configs', function(data) {
            _.extend(config, data);
        });
        this.context.trigger('sweetspot:ask:configs');
        return config;
    },

    /**
     * Saves the sanitized Sweet Spot settings in user preferences and closes
     * the drawer.
     */
    saveConfig: function() {
        var data = this._getAllConfigs();
        data = this._formatForUserPrefs(data);

        this.context.trigger('sweetspot:config:enableButtons', false);
        app.alert.show('sweetspot', {
            level: 'process',
            title: app.lang.get('LBL_SAVING'),
            autoClose: false
        });

        app.user.updatePreferences(data, _.bind(this._saveConfigCallback, this));
    },

    /**
     * Callback for the call to {@link Core.User#updatePreferences}.
     *
     * @param {string} err Error message returned by the server.
     */
    _saveConfigCallback: function(err) {
        app.alert.dismiss('sweetspot');
        if (err) {
            var errorMsg = app.lang.get('LBL_SWEETSPOT_CONFIG_ERR', this.module, {errorMsg: err});
            this.context.trigger('sweetspot:config:enableButtons', true);
            app.alert.show('config-failed', {
                level: 'error',
                title: 'LBL_SWEETSPOT',
                messages: errorMsg
            });
            return;
        }
        app.drawer.close(this.collection);
        app.events.trigger('sweetspot:reset');
    },

    /**
     * Closes the config drawer without saving changes.
     */
    cancelConfig: function() {
        app.drawer.close();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.context.off('sweetspot:receive:configs');
        this._super('_dispose');
    }
}) },
"wizard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout used for Wizards (like the first time login wizard).
 * Extend this layout and provide metadata for your wizard page components.
 *
 * Default implementation allows you to register a callback on the context
 * to get notified when Wizard is finished.
 *
 * For example,
 *
 *     context.set("callbacks", {
 *         complete: function(){...}
 *     }
 *
 * @class View.Layouts.Base.WizardLayout
 * @alias SUGAR.App.view.layouts.BaseWizardLayout
 * @extends View.Layout
 */
({
	// Wizard Layout (base) 


    /**
     * Current page index shown in Wizard
     * @private
     */
    _currentIndex: 0,

    /**
     * @param {Object} options
     * @override
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        $(window).on('keypress.' + this.cid, _.bind(this.handleKeypress, this));
    },

    /**
     * Place only initial wizard page at first
     * @param component Wizard page component
     * @override
     * @private
     */
    _placeComponent: function(component){
        if (component == this._components[this._currentIndex]) {
            this.$el.append(component.el);
        }
    },

    /**
     * Add only wizard pages that the current user needs to see.
     *
     * @param {View.Layout/View.View} component Component (view or layout) to add
     * @param {Object} def Metadata definition
     * @override
     */
    addComponent: function(component, def) {
        component = this._addButtonsForComponent(component);
        if (_.result(component, 'showPage')) {
            this._super('addComponent', [component, def]);
        }
    },
    /**
     * Helper to add appropriate buttons based on which page of wizard we're on.
     * Assumes that button 0 is previous, 1 is next, 2 is finish (Start Sugar).
     * Should only be called internal by `addComponent`.
     * @param {Object} component component from `addComponent`
     * @private
     */
    _addButtonsForComponent: function(component) {
        var buttons = [];
        component.meta = component.meta || {};
        //Adds appropriate button for component based on position in wizard
        _.each(this.meta.components, function(comp, i) {
            //found a match, add appropriate buttons based on wizard position
            if (comp.view === component.name) {
                if (i===0) {
                    //next button only
                    buttons.push(this.meta.buttons[1]);
                } else if (i === this.meta.components.length-1) {
                    // previous/start sugar buttons
                    buttons.push(this.meta.buttons[0]);
                    buttons.push(this.meta.buttons[2]);
                } else {
                    // previous/next buttons
                    buttons.push(this.meta.buttons[0]);
                    buttons.push(this.meta.buttons[1]);
                }
            }
        }, this);
        component.meta.buttons = buttons;
        return component;
    },

    /**
     * Renders a different page from the wizard
     * @param {number} newIndex New page index to select
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    setPage: function(newIndex){
        if (newIndex !== this._currentIndex &&
                (newIndex >= 0 && newIndex < this._components.length)) {
            //detach preserves jQuery event listeners, etc.
            this._components[this._currentIndex].$el.detach();
            this._currentIndex = newIndex;
            this.$el.append(this._components[this._currentIndex].el);

            // Wait for the wizard-page to tell us it's ready for interactions from keypresses.
            this.on('wizard-page:render:complete', function() {
                $(window).on('keypress.' + this.cid, _.bind(this.handleKeypress, this));
            });

            this._components[this._currentIndex].render();
        }
        return this.getProgress();
    },

    /**
     * Only render the current component (WizardPageView) instead of each component in layout
     * @override
     * @private
     */
    _renderHtml: function() {
        if (Modernizr.touch) {
            app.$contentEl.addClass('content-overflow-visible');
        }
        if (this._components) {
            this._components[this._currentIndex].render();
        }
    },

    /**
     * Returns current progress through wizard
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    getProgress: function(){
        return {
            page: this._currentIndex + 1,
            lastPage: this._components.length
        };
    },

    /**
     * Moves to previous page, if possible.
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    previousPage: function(){
        // We're navigating, don't get any more keypresses.
        $(window).off('keypress.' + this.cid);
        return this.setPage(this._currentIndex - 1);
    },

    /**
     * Moves to next page, if possible.
     * @return {Object} How far the user has progressed through the wizard
     * @return {number} return.page The current page number
     * @return {number} return.lastPage The last page number
     */
    nextPage: function(){
        // We're navigating, don't get any more keypresses.
        $(window).off('keypress.' + this.cid);
        return this.setPage(this._currentIndex + 1);
    },

    /**
     * Disposes of layout then calls finished callback if registered
     */
    finished: function(){
        if (Modernizr.touch) {
            app.$contentEl.removeClass('content-overflow-visible');
        }
        var callbacks = this.context.get("callbacks"); //save callbacks first
        this.dispose();
        if (callbacks && callbacks.complete) {
            callbacks.complete();
        }
    },

    /**
     * Process next on key 'Enter'
     * @param e
     */
    handleKeypress: function(e) {
        var wizardPage = this._components[this._currentIndex];
        // Check wizardPage no matter which key we're trapping (for future expansion).
        if (wizardPage) {
            // Check if we're catching enter.
            if (e.keyCode === 13) {
                document.activeElement.blur();
                if (wizardPage.isPageComplete()) {
                    // Once we're navigating, don't get any more keypresses.
                    $(window).off('keypress.' + this.cid);
                    wizardPage.next();
                }
            }
        }
    },

    /**
     * @private
     * @override
     */
    _dispose: function() {
        // We're done with this view, remove the keypress bind.
        $(window).off('keypress.' + this.cid);
        this._super('_dispose');
    }
}) },
"default": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DefaultLayout
 * @alias SUGAR.App.view.layouts.BaseDefaultLayout
 * @extends View.Layout
 */
/**
 * Some events have been deprecated in 7.2 and removed.
 * List of changes:
 *
 * - `toggleSidebar` has been migrated to `sidebar:toggle`. It allows one param
 *    to indicate the state. {@link Layout.Default#toggleSidePane}
 *
 * - `openSidebar` has been removed. You can open the sidebar by triggering
 *    `sidebar:toggle` and passing `true`. Note that you can also close the
 *    sidebar by triggering `sidebar:toggle` and passing `false`.
 *
 * - `toggleSidebarArrows` has been removed. Trigger `sidebar:state:changed`
 *    with the value `open` or `close` instead.
 *
 * - `openSidebarArrows` has been removed. Trigger `sidebar:state:changed` with
 *    the value `open` instead.
 */
({
	// Default Layout (base) 

    className: 'row-fluid',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        /**
         * Name of the last state. This can be overridden in metadata, please
         * refer to the example.
         *
         * Example:
         *
         *     array(
         *          'default_hide' => '1',
         *          'hide_key' => 'hide-merge',
         *     ),
         *
         * @cfg {String}
         */
        this.HIDE_KEY = 'hide';

        /**
         * Default value for hiding the sidepane. `1` is hidden, `0` is show.
         * This is because the code which retrieves data from local storage
         * checks the value of the data and will return undefined if the result
         * resolves to a boolean false.
         *
         * Since an undefined hide value means "use the default" and int 0 means
         * show, but they both resolve to false, this causes complications. As a
         * result, we have to use a string.
         *
         * Using a string `0` or `1` is superior to something like "yes" and
         * "no" because we can use parseInt instead of an if/else setup.
         *
         * This setting can be overridden in metadata, please refer to the
         * example.
         *
         * Example:
         *
         *     array(
         *          'default_hide' => '1',
         *          'hide_key' => 'hide-merge',
         *     ),
         *
         * @property {String}
         * @protected
         */
        this._defaultHide = '0';

        /**
         * Key for storing the last state. This key is used in localstorage of the
         * browser. It is generated using `HIDE_KEY`
         *
         * Example:
         *
         *     state:Accounts:default:hide_last_state_key
         *
         *
         * @property {String}
         * @protected
         */
        this._hideLastStateKey = null;

        this._super('initialize', [options]);
        if (!_.isUndefined(this.meta.default_hide)) {
            this._defaultHide = this.meta.default_hide;
        }
        if (!_.isUndefined(this.meta.hide_key)) {
            this.HIDE_KEY = this.meta.hide_key;
        }

        this.on('sidebar:toggle', this.toggleSidePane, this);

        this.meta.last_state = this.meta.last_state || { id: 'default' };

        this._hideLastStateKey = app.user.lastState.key(this.HIDE_KEY, this);

        //Update the panel to be open or closed depending on how user left it last
        this._toggleVisibility(this.isSidePaneVisible());
    },

    /**
     * Check whether the side pane is currently visible.
     *
     * @return {Boolean} `true` if visible, `false` otherwise.
     */
    isSidePaneVisible: function() {
        var hideLastState = app.user.lastState.get(this._hideLastStateKey);
        var hidden = hideLastState || this._defaultHide;
        return !parseInt(hidden, 10);
    },

    /**
     * Toggle sidebar and save the current state.
     *
     * Both the hidden and show state is stored. In the default configuration,
     * the side pane is `visible`.
     * In the non-default case, the hidden state is represented by `0`, and the
     * show state is represented by `1`.
     *
     * @param {Boolean} [visible] Pass `true` to show the sidepane, `false` to
     *  hide it, otherwise will toggle the current state.
     */
    toggleSidePane: function(visible) {
        var isVisible = this.isSidePaneVisible();

        visible = _.isUndefined(visible) ? !isVisible : visible;

        if (isVisible === visible) {
            return;
        }

        app.user.lastState.set(
            this._hideLastStateKey,
            visible ? '0' : '1'
        );

        this._toggleVisibility(visible);
    },

    /**
     * Toggle visibility of the side pane.
     *
     * Toggling visibility can affect the content width in the same way as a
     * window resize. Thus we will trigger window `resize` so that any content
     * listening for a window `resize` can readjust themselves.
     *
     * @param {Boolean} visible `true` to show the side pane, `false` otherwise.
     * @private
     */
    _toggleVisibility: function(visible) {
        this.$('.main-pane').toggleClass('span12', !visible).toggleClass('span8', visible);

        this.$('.side').toggleClass('side-collapsed', !visible);

        $(window).trigger('resize');

        this.trigger('sidebar:state:changed', visible ? 'open' : 'close');
    },

    /**
     * Get the width of either the main or side pane depending upon where the
     * component resides.
     *
     * @param {View.Component} component The component.
     * @return {Number} The component width.
     */
    getPaneWidth: function(component) {
        if (!this.$el) {
            return 0;
        }
        var paneSelectors = ['.main-pane', '.side'];
        var pane = _.find(paneSelectors, function(selector) {
                var $pane = this.$(selector).get(0);
                return $pane && $.contains($pane, component.el);
            }, this);

        return this.$(pane).width() || 0;
    }
}) },
"dashlet-main": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DashletMainLayout
 * @alias SUGAR.App.view.layouts.BaseDashletMainLayout
 * @extends View.Layout
 */
({
	// Dashlet-main Layout (base) 

    tagName: "ul",
    className: "dashlets row-fluid",

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if(this.model) {
            this.model.on("change:metadata", this.setMetadata, this);
            this.model.on("change:layout", this.setWidth, this);
            this.model.on("applyDragAndDrop", this.applyDragAndDrop, this);
            this.model.on("setMode", function(mode) {
                this.model._previousMode = this.model.mode;
                this.model.mode = mode;
            }, this);
            this.model.trigger('setMode', this.context.get("create") ? 'edit' : 'view');
        }
    },

    /**
     * Replace all components based on the dashboard metadata value
     */
    setMetadata: function() {
        if(!this.model.get("metadata")) return;
        //Clean all components
        _.each(this._components, function(component) {
            component.dispose();
        }, this);
        this._components = [];
        this.$el.children().remove();

        var components = app.utils.deepCopy(this.model.get("metadata")).components;
        _.each(components, function(component, index) {
            this.initComponents([{
                layout: {
                    type: 'dashlet-row',
                    width: component.width,
                    components: component.rows,
                    index: index + ''
                }
            }]);
        } , this);

        this.loadData();
        this.render();
    },

    /**
     * Set current main layout's width proportion
     */
    setWidth: function() {
        var metadata = this.model.get("metadata"),
            $el = this.$el.children();

        _.each(metadata.components, function(component, index){
            $el.get(index).className = $el.get(index).className.replace(/span\d+\s*/, '');
            $($el.get(index)).addClass("span" + component.width);
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Resets the original css classes, and adds the dashboard classes if
     * defined.
     */
    _render: function() {
        this.$el.removeClass();
        this.$el.addClass(this.className);
        this._super('_render');
        if (this.model.has('css_class')) {
            this.$el.addClass(this.model.get('css_class'));
        }
    },

    /**
     * Set all appended dashlets drag-and-droppable
     */
    applyDragAndDrop: function() {
        if (this.model.get('drag_and_drop') === false) {
            return;
        }
        var self = this;
        this.$('.dashlet:not(.empty)').draggable({
            revert: 'invalid',
            handle: 'h4',
            scroll: true,
            scrollSensitivity: 100, //pixel
            appendTo: this.$el,
            start: function(event, ui) {
                $(this).css({visibility: 'hidden'});
                self.model.trigger("setMode", "drag");
                self.context.trigger('dashlet:draggable:start');
            },
            stop: function() {
                self.model.trigger("setMode", self.model._previousMode);
                self.$(".dashlet.ui-draggable").attr("style", "");
                self.context.trigger('dashlet:draggable:stop');
            },
            helper: function() {
                var $clone = $(this).clone();
                $clone
                    .addClass('helper')
                    .css({opacity: 0.8})
                    .width($(this).width());
                $clone.find('.btn-toolbar').remove();
                return $clone;
            }
        });

        this.$('.dashlet-container').droppable({
            activeClass: 'ui-droppable-active',
            hoverClass: 'active',
            tolerance: 'pointer',
            accept: function($el) {
                return $el.data('type') === 'dashlet' && self.$(this).find('[data-action=droppable]').length === 1;
            },
            drop: function(event, ui) {
                var sourceIndex = ui.draggable.parents(".dashlet-container:first").data('index')(),
                    targetIndex = self.$(this).data('index')();
                self.switchComponent(targetIndex, sourceIndex);
            }
        });
    },

    /**
     * Retrives the seperate component metadata from the whole dashboard components
     *
     * @param {Object} metadata for all dashboard componenets
     * @param {String} tree based trace key (each digit represents the index number of the each level)
     * @return {Object} component metadata and its dashlet frame layout
     */
    getCurrentComponent: function(metadata, tracekey) {
        var position = tracekey.split(''),
            component = metadata.components;
        _.each(position, function(index) {
            component = component.rows ? component.rows[index] : component[index];
        }, this);

        var layout = this;
        _.each(position, function(index) {
            layout = layout._components[index];
        }, this);
        return {
            metadata: component,
            layout: layout
        };
    },

    /**
     * Switch the places of two components
     *
     * @param {String} target key
     * @param {String} source key
     */
    switchComponent: function(target, source) {
        if (target === source) {
            return;
        }
        var metadata = this.model.get('metadata'),
            targetComponent = this.getCurrentComponent(metadata, target),
            sourceComponent = this.getCurrentComponent(metadata, source);

        //Swap the metadata except 'width' property since it's previous size
        var cloneMeta = app.utils.deepCopy(targetComponent.metadata);
        _.each(targetComponent.metadata, function(value, key) {
            if (key !== 'width') {
                delete targetComponent.metadata[key];
            }
        }, this);
        _.each(sourceComponent.metadata, function(value, key) {
            if (key !== 'width') {
                targetComponent.metadata[key] = value;
                delete sourceComponent.metadata[key];
            }
        }, this);
        _.each(cloneMeta, function(value, key) {
            if (key !== 'width') {
                sourceComponent.metadata[key] = value;
            }
        }, this);

        this.model.set('metadata', app.utils.deepCopy(metadata), {silent: true});
        this.model.trigger('change:layout');
        if (this.model._previousMode === 'view') {
            //Autosave for view mode
            this.model.save(null, {
                //Show alerts for this request
                showAlerts: true
            });
        }
        //Swap the view components
        var targetDashlet = targetComponent.layout._components.splice(0);
        var sourceDashlet = sourceComponent.layout._components.splice(0);

        //switch the metadata
        var targetMeta = app.utils.deepCopy(targetComponent.layout.meta);
        var sourceMeta = app.utils.deepCopy(sourceComponent.layout.meta);
        targetComponent.layout.meta = sourceMeta;
        sourceComponent.layout.meta = targetMeta;

        _.each(targetDashlet, function(comp) {
            sourceComponent.layout._components.push(comp);
            comp.layout = sourceComponent.layout;
        }, this);
        _.each(sourceDashlet, function(comp) {
            targetComponent.layout._components.push(comp);
            comp.layout = targetComponent.layout;
        }, this);
        //switch invisibility
        var targetInvisible = targetComponent.layout._invisible;
        var sourceInvisible = sourceComponent.layout._invisible;
        if (targetInvisible) {
            sourceComponent.layout.setInvisible();
        } else {
            sourceComponent.layout.unsetInvisible();
        }
        if (sourceInvisible) {
            targetComponent.layout.setInvisible();
        } else {
            targetComponent.layout.unsetInvisible();
        }

        //Swap the DOM
        var cloneEl = targetComponent.layout.$el.children(':first').get(0);
        targetComponent.layout.$el.append(sourceComponent.layout.$el.children(':not(.helper)').get(0));
        sourceComponent.layout.$el.append(cloneEl);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var $dashlets = this.$('.dashlet');
        var $dashletContainers = this.$('.dashlet-container');

        // Make sure the element is initialized to be draggable before destroying.
        _.each($dashlets, function(dashlet) {
            var $dashlet = $(dashlet);
            if (!_.isUndefined($dashlet.draggable('instance'))) {
                $dashlet.draggable('destroy');
            }
        });

        // Make sure the element is initialized to be droppable before destroying.
        _.each($dashletContainers, function(dashletContainer) {
            var $dashletContainer = $(dashletContainer);
            if (!_.isUndefined($dashletContainer.droppable('instance'))) {
                $dashletContainer.droppable('destroy');
            }
        });

        this._super('_dispose');
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.CreateLayout
 * @alias SUGAR.App.view.layouts.CreateLayout
 * @extends View.Layout
 */
({
	// Create Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'Create:Save',
        'Create:Cancel',
        'Dropdown:More'
    ]
}) },
"fluid": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout that places components using bootstrap fluid layout divs.
 *
 * @class View.Layouts.Base.FluidLayout
 * @alias SUGAR.App.view.layouts.BaseFluidLayout
 * @extends View.Layout
 */
({
	// Fluid Layout (base) 

    /**
     * Places a view's element on the page. This should be overriden by any custom layout types.
     * In layout defs, the child component should have a `span` definition corresponding to the bootstrap scaffold.
     * @param {View.View} comp
     * @protected
     */
    _placeComponent: function(comp, def) {
        var compdef = def.layout || def.view,
            size = compdef.span || 4;

        if (!this.$el.children()[0]) {
            this.$el.addClass("container-fluid").append('<div class="row-fluid"></div>');
        }

        //Create a new td and add the layout to it
        $().add("<div></div>").addClass("span" + size).append(comp.el).appendTo(this.$el.find("div.row-fluid")[0]);
    }
}) },
"footer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.FooterLayout
 * @alias SUGAR.App.view.layouts.BaseFooterLayout
 * @extends View.Layout
 */
({
	// Footer Layout (base) 

    /**
     * Places all components within this layout inside `btn-toolbar` div.
     *
     * @param {View.View|View.Layout} component View or layout component.
     * @override
     * @protected
     */
    _placeComponent: function(component) {
        this.$('.btn-toolbar').append(component.el);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        // FiXME SC-5765 the logo should be a separate view, so we can update it based
        // on the re-render of this layout
        this.$('[data-metadata="logo"]').attr('src', app.metadata.getLogoUrl());
        return this._super('_render');
    }
}) },
"subpanels": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SubpanelsLayout
 * @alias SUGAR.App.view.layouts.BaseSubpanelsLayout
 * @extends View.Layout
 */
({
	// Subpanels Layout (base) 

    /**
     * @inheritdoc
     */
    className: 'subpanels-layout',

    /**
     * Default settings used for the sortable plugin.
     *
     * - `{Boolean} sortable` Whether or not this layout should be sortable.
     * - `{Boolean} showAlerts` Whether or not to show alerts when the subpanel
     *   ordering is changed.
     *
     * These defaults can be overridden through the metadata (shown below) or by
     * customizing this layout.
     *
     *     // ...
     *     'settings' => array(
     *         'sortable' => false,
     *         //...
     *     ),
     *     //...
     *
     * @property {Object}
     * @protected
     */
    _defaultSettings: {
        showAlerts: true,
        sortable: true
    },

    /**
     * Settings after applying metadata settings on top of
     * {@link #_defaultSettings}.
     *
     * @property {Object}
     * @protected
     */
    _settings: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initSettings();
        this._bindEvents();
    },

    /**
     * Merges settings defined in the metadata with {@link #_defaultSettings}.
     *
     * @protected
     * @chainable
     */
    _initSettings: function() {
        this._settings = _.extend({},
            this._defaultSettings,
            this.meta && this.meta.settings || {}
        );
        return this;
    },

    /**
     * Binds events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        if (this.layout) {
            this.listenTo(this.layout, 'subpanel:change', this.showSubpanel);
        }

        this.on('subpanels:reordered', this._saveNewOrder, this);
    },

    /**
     * Initializes the jQuery Sortable plugin to this layout, only if the
     * `sortable` property on the {@link #_settings} object is set to `true`.
     *
     * By default, the `handle` to drag subpanels is specified as the
     * `panel-top` component. The `helper` attribute is set to `clone` because
     * Firefox dispatches a click event when the dragged element is removed and
     * inserted by jQuery, see:
     * [bug ticket](https://bugzilla.mozilla.org/show_bug.cgi?id=787944).
     *
     * @protected
     * @chainable
     */
    _initSortablePlugin: function() {
        if (this._settings && this._settings.sortable === true) {
            this.$el.sortable({
                axis: 'y',
                containment: this.$el,
                handle: '[data-sortable-subpanel=true]',
                helper: 'clone',
                tolerance: 'pointer',
                scrollSensitivity: 50,
                scrollSpeed: 15,
                update: _.bind(this.handleSort, this)
            });
        }
        return this;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        this._initSortablePlugin();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (!_.isEmpty(this.$el.data('sortable'))) {
            this.$el.sortable('destroy');
        }
        this._super('_dispose');
    },

    /**
     * The subpanels list is saved into local storage.
     *
     * Displays a `success` alert message if the `showAlerts` setting is `true`.
     *
     * This method is called by the `subpanel:reordered` event, see
     * {@link #initialize}.
     *
     * @protected
     * @param {Object} component The `subpanel` component
     * @param {String[]} order The new order of `subpanel` components.
     */
    _saveNewOrder: function(component, order) {
        var key = app.user.lastState.buildKey('order', 'subpanels', this.module);
        app.user.lastState.set(key, order);

        if (this._settings.showAlerts === true) {
            app.alert.show('subpanel_order_updated', {
                level: 'success',
                messages: app.lang.get('LBL_SAVED_LAYOUT', this.module),
                autoClose: true
            });
        }
    },

    /**
     * Handler for subpanel re-order.
     *
     * @param {Event} evt The jQuery update event.
     * @param {Object} ui The jQuery UI object.
     */
    handleSort: function(evt, ui) {
        var newOrder = this.$el.sortable('toArray', {
                attribute: 'data-subpanel-link'
            });

        this.trigger('subpanels:reordered', this, newOrder);
    },

    /**
     * Removes subpanels that user doesn't have access to. SP-924: Error message when opening subpanel
     * user doesn't have access to.
     *
     * @param {Array} components list of child components from layout definition
     * @return {Object} pruned components
     * @private
     * @override
     */
    _pruneNoAccessComponents: function(components) {
        var prunedComponents = [];
        var layoutFromContext = this.context ? this.context.get('layout') || this.context.get('layoutName') : null;
        this.layoutType = layoutFromContext ? layoutFromContext : app.controller.context.get('layout');
        this.aclToCheck = this.aclToCheck || 'list';
        _.each(components, function(component) {
            var relatedModule,
                link = component.context ? component.context.link : null;
            if (link) {
                relatedModule = app.data.getRelatedModule(this.module, link);
                if (!relatedModule || relatedModule && app.acl.hasAccess(this.aclToCheck, relatedModule)) {
                    prunedComponents.push(component);
                }
            }
        }, this);
        return prunedComponents;
    },

    /**
     *
     * Removes hidden subpanels from list of components before adding them to layout
     *
     * @param {Array} components list of child components from layout definition
     * @return {Object} pruned components
     * @private
     * @override
     */
    _pruneHiddenComponents: function(components) {
        var hiddenSubpanels = app.metadata.getHiddenSubpanels();
        var visibleSubpanels = _.filter(components, function(component){
            var relatedModule = app.data.getRelatedModule(this.module, component.context.link);
            return _.isEmpty(_.find(hiddenSubpanels, function(hiddenPanel){
                if (relatedModule !== false) {
                    //hidden subpanels seem to come back in lower case, so we do a case insenstiive compare of module names
                    return hiddenPanel.toLowerCase() === relatedModule.toLowerCase();
                }
                return true;
            }));
        }, this);
        return visibleSubpanels;
    },

    /**
     * @inheritdoc
     *
     * We override this method which is called early in the Sidecar framework to
     * prune any hidden or acl prohibited components.
     */
    _addComponentsFromDef: function(components, context, module) {
        // First checks for hidden components, then checks for ACLs on those components.
        var allowedComponents = this._pruneHiddenComponents(components);
        allowedComponents = this._pruneNoAccessComponents(allowedComponents);
        allowedComponents = this.reorderSubpanels(allowedComponents);

        // Call original Layout with pruned components
        this._super('_addComponentsFromDef', [allowedComponents, context, module]);
        this._markComponentsAsSubpanels();
        this._disableSubpanelToggleButton(allowedComponents);
    },

    /**
     * Orders the `subpanel` components and strips out any components from the
     * specified `order` that are no longer available.
     *
     * @param {Array} components The list of `subpanel` component objects.
     * @return {Array} The ordered list of `subpanel` component objects.
     */
    reorderSubpanels: function(components) {
        var key = app.user.lastState.buildKey('order', 'subpanels', this.module),
            order = app.user.lastState.get(key);

        if (_.isEmpty(order)) {
            return components;
        }

        var componentOrder = _.pluck(_.pluck(components, 'context'), 'link');
        order = _.intersection(order, componentOrder);

        _.each(order, function(link, index) {
            var comp = _.find(components, function(comp) {
                return comp.context.link === link;
            });
            comp.position = ++index;
        });

        components = _.sortBy(components, function(comp) {
            return comp.position;
        });

        return components;
    },

    /**
     * If no subpanels are left after pruning hidden and ACL-prevented
     * subpanels, we disable the filter panel's subpanel toggle button.
     *
     * @param {Array} allowedComponents The pruned subpanels.
     */
    _disableSubpanelToggleButton: function(allowedComponents) {
        if (!this.layout || !_.isEmpty(allowedComponents)) {
            return;
        }

        this.layout.trigger('filterpanel:change', 'activitystream', true, true);
        this.layout.trigger('filterpanel:toggle:button', 'subpanels', false);
    },

    /**
     * Show the subpanel for the given linkName and hide all others
     * @param {String} linkName name of subpanel link
     */
    showSubpanel: function(linkName) {
        if (!app.config.collapseSubpanels) {
            // this.layout is the filter layout which subpanels is child of; we
            // use it here as it has a last_state key in its meta
            // FIXME: TY-499 will address removing the dependancy on this.layout
            var cacheKey = app.user.lastState.key('subpanels-last', this.layout);
            if (linkName) {
                app.user.lastState.set(cacheKey, linkName);
            } else {
                // Fixes SP-836; esentially, we need to clear subpanel-last-<module>
                // anytime 'All' selected.
                app.user.lastState.remove(cacheKey);
            }
        }

        _.each(this._components, function(component) {
            var link = component.context.get('link');
            if (!linkName) {
                component.show();
            } else if (linkName === link) {
                component.show();
                component.context.set('collapsed', false);
            } else {
                component.hide();
            }
        });
    },

    /**
     * Mark component context as being subpanels
     */
    _markComponentsAsSubpanels: function() {
        _.each(this._components, function(component) {
            component.context.set("isSubpanel", true);
        });
    },

    /**
     * Load data for all subpanels. Need to override the layout's loadData() because
     * it calls loadData() for the context, which we do not want to do here.
     * @param options
     */
    loadData: function(options) {
        var self = this,
            load = function(){
                _.each(this._components, function(component) {
                    component.loadData(options);
                });
            };
        if (self.context.parent && !self.context.parent.isDataFetched()) {
            var parent = this.context.parent.get("model");
            parent.once("sync", load);
        }
        else {
            load();
        }
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PreviewLayout
 * @alias SUGAR.App.view.layouts.BasePreviewLayout
 * @extends View.Layout
 */
({
	// Preview Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._bindPreviewEvents();

        /**
         * Creates a child context, which will carry the previewed model.
         *
         * @type {Core.Context}
         */
        this.context = this.context.getChildContext({});
    },

    /**
     * Binds the events that this preview layout uses.
     *
     * @private
     */
    _bindPreviewEvents: function() {
        app.events.on('preview:render', this._toggle, this);
        app.events.on('preview:open', this.showPreviewPanel, this);
        app.events.on('preview:close', this.hidePreviewPanel, this);
        app.events.on('preview:pagination:hide', this.hidePagination, this);
    },

    /**
     * Checks if {@link #$el this layout element} is in the active drawer, if
     * there is an instance of
     * {@link View.Layouts.Base.DrawerLayout app.drawer}. In case no drawers are
     * defined, this function returns `true`.
     *
     * @return {boolean} `true` if
     *   {@link View.Layouts.Base.DrawerLayout app.drawer} is not defined, or if
     *   this layout is in the active drawer, `false` otherwise.
     */
    _isActive: function() {
        if (_.isEmpty(app.drawer)) {
            return true;
        }

        return app.drawer.isActive(this.$el);
    },

    /**
     * Initializes the preview panel if the given model is different from the
     * model on the {@link #context}. Shows the preview panel if this
     * layout is {@link #_hidden hidden}, hides it otherwise.
     *
     * @private
     * @param {Data.Bean} model The {@link Data.Bean model} being previewed.
     * @param {Data.BeanCollection} collection The
     *   {@link Data.BeanCollection collection} of preview models.
     */
    _toggle: function(model, collection) {
        if (!this._isActive()) {
            return;
        }

        var isSameModel = model === this.context.get('model');

        if (isSameModel) {
            if (this._hidden) {
                this.showPreviewPanel();
                app.events.trigger('list:preview:decorate', model, this);
            } else {
                this.hidePreviewPanel();
            }
        } else {
            this._initPreviewPanel(model, collection);
        }
    },

    /**
     * Initializes the preview layout components using the correct module.
     *
     * @private
     * @param {Data.Bean} model The {@link Data.Bean model} being previewed.
     * @param {Data.BeanCollection} collection The
     *   {@link Data.BeanCollection collection} of preview models.
     */
    _initPreviewPanel: function(model, collection) {
        if (!this._isActive()) {
            return;
        }

        var attrs = {
            model: model,
            collection: collection,
            module: model.module,
            modelId: model.id
        };

        // If `this._components` is empty, its the first time we are
        // initializing the preview panel. Otherwise, if the modules are
        // different, we need to reinitialize the preview panel with the new
        // metadata from that module.
        var hasComponents = !_.isEmpty(this._components);
        var modelChanged = this.context.get('module') !== model.module;

        if (!hasComponents || modelChanged) {
            this._disposeComponents();
            this.context.set(attrs);
            this.initComponents(this._componentsMeta, this.context, model.module);
            if (hasComponents) {
                // In case we already have components, reload the
                // data to remove previous load data (e.g. fetchCalled, etc)
                this.context.reloadData({resetCollection: false});
            } else {
                this.context.loadData();
            }
            this.render();
        } else {
            this.context.set(attrs);
            this.context.reloadData({resetCollection: false});
        }

        this.showPreviewPanel();
        app.events.trigger('list:preview:decorate', model, this);
    },

    /**
     * Shows the preview panel, if it is part of the active drawer or if there
     * is no drawer open.
     */
    showPreviewPanel: function() {
        if (!this._isActive()) {
            return;
        }

        var layout = this.$el.parents('.sidebar-content');
        layout.find('.side-pane').removeClass('active');
        layout.find('.dashboard-pane').hide();
        layout.find('.preview-pane').addClass('active');

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            defaultLayout.trigger('sidebar:toggle', true);
        }
        this._hidden = false;
    },

    /**
     * Hides the preview panel, if it is part of the active drawer or if there
     * is no drawer open.
     */
    hidePreviewPanel: function() {
        if (!this._isActive()) {
            return;
        }

        var layout = this.$el.parents('.sidebar-content');
        layout.find('.side-pane').addClass('active');
        layout.find('.dashboard-pane').show();
        layout.find('.preview-pane').removeClass('active');
        app.events.trigger('list:preview:decorate', false);
        this._hidden = true;
    },

    hidePagination: function() {
        if (!this._isActive()) {
            return;
        }

        this.hideNextPrevious = true;
        this.trigger('preview:pagination:update');
    }
}) },
"config-drawer-content": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ConfigDrawerContentLayout
 * @alias SUGAR.App.view.layouts.BaseConfigDrawerContentLayout
 * @extends View.Layout
 *
 * Triggered Events:
 *  config:howtoData:change - When a different accordion panel is clicked, a howtoData:change event will be triggered
 *      with the current how-to data for View.Views.Base.ConfigHowToView to listen for and update
 */
({
	// Config-drawer-content Layout (base) 

    events: {
        'click .accordion-toggle': 'onAccordionToggleClicked'
    },

    /**
     * The HTML ID of the Accordion divs
     */
    collapseDivId: 'config-accordion',

    /**
     * The currently-selected config panel
     */
    selectedPanel: undefined,

    /**
     * The current HowTo data Object
     */
    currentHowToData: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.currentHowToData = {};
        this._initHowTo();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var $toggles;

        this._super('_render');

        //This is because backbone injects a wrapper element.
        this.$el.addClass('accordion');
        this.$el.attr('id', this.collapseDivId);
        $toggles = this.$('.accordion-toggle');
        // ignore the first accordion toggle
        $toggles.splice(0, 1);
        $toggles.addClass('collapsed');

        //apply the accordion to this layout
        this.$('.collapse').collapse({
            toggle: false,
            parent: '#' + this.collapseDivId
        });

        // select the first panel in metadata
        this.selectPanel(_.first(this.meta.components).view);
    },

    /**
     * Used to select a specific panel by name
     * Correct names can be found in the specific view's hbs
     * Specifically found in the id attribute of '.accordion-heading a'
     *
     * @param {String} panelName The ID name of the panel to select
     */
    selectPanel: function(panelName) {
        this.selectedPanel = panelName;
        this.$('#' + panelName + 'Collapse').collapse('show');
    },

    /**
     * Event handler for 'click .accordion-toggle' event
     *
     * @param {jQuery.Event|undefined} evt
     */
    onAccordionToggleClicked: function(evt) {
        var panelName = (evt) ? $(evt.currentTarget).data('help-id') : this.selectedPanel;
        var oldPanel;
        var newPanel;

        if (evt && panelName === this.selectedPanel) {
            // dont allow closing the same tab
            return false;
        }

        this._switchHowToData(panelName);

        this.context.trigger('config:howtoData:change', this.currentHowToData);

        if (this.selectedPanel) {
            oldPanel = _.find(this._components, function(component) {
                return component.name === this.selectedPanel;
            }, this);

            if (oldPanel) {
                oldPanel.$('.accordion-toggle').addClass('collapsed');
                oldPanel.trigger('config:panel:hide');
            }
        }

        this.selectedPanel = panelName;

        newPanel = _.find(this._components, function(component) {
            return component.name === panelName;
        }, this);
        newPanel.trigger('config:panel:show');
    },

    /**
     * Function for child modules to initialize their own HowTo data
     *
     * @private
     */
    _initHowTo: function() {
    },

    /**
     * Handles switching the HowTo text and info by a specific accordion view being toggled
     *
     * @param {string} helpId The panel component name
     * @private
     */
    _switchHowToData: function(helpId) {
    },

    /**
     * Allows child config views with specific needs to be able to 'manually' update the HowTo text
     *
     * @param title
     * @param text
     */
    changeHowToData: function(title, text) {
        this.currentHowToData.title = title;
        this.currentHowToData.text = text;
        this.context.trigger('config:howtoData:change', this.currentHowToData);
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'Record:Edit',
        'Record:Delete',
        'Record:Save',
        'Record:Cancel',
        'Record:Previous',
        'Record:Next',
        'Record:Favorite',
        'Record:Follow',
        'Record:Copy',
        'Record:Action:More'
    ]
}) },
"sweetspot": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SweetspotLayout
 * @alias SUGAR.App.view.layouts.BaseSweetspotLayout
 * @extends View.Layout
 */
({
	// Sweetspot Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // FIXME Sidecar should be modified to allow multiple top level contexts. When this happens, quick search
        // should use that context instead of layout.collection.
        this.collection = app.data.createMixedBeanCollection();

        app.shortcuts.registerGlobal({
            id: 'Sweetspot:Toggle',
            keys: 'mod+shift+space',
            component: this,
            description: 'LBL_SHORTCUT_SWEETSPOT',
            callOnFocus: true,
            handler: this.toggle
        });
        app.events.on('app:logout app:login', this.hide, this);
        app.events.on('app:sync:complete sweetspot:reset', this._setTheme, this);

        this.on('sweetspot:config', this.openConfigPanel, this);
        this.on('sweetspot:calc:resultsHeight', this.calculateResultsHeight, this);

        /**
         * Flag to indicate the visible state of the sweet spot.
         *
         * @type {boolean}
         * @private
         */
        this._isVisible = false;
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        if (!this.isReady()) {
            return;
        }
        this._super('_render');
        this._setTheme();
    },

    /**
     * Sets the theme for sweetspot.
     *
     * @protected
     */
    _setTheme: function() {
        var prefs = app.user.getPreference('sweetspot');
        var theme = prefs && prefs.theme;

        this.$el.removeAttr('data-theme');
        if (theme) {
            this.$el.attr('data-theme', theme);
        }
    },

    /**
     * Binds events that this layout uses.
     *
     * @protected
     */
    _bindEvents: function() {
        this.createShortcuts();
        this.bindOutsideClick();
        this.bindResize();
    },

    /**
     * Unbinds events that this layout uses.
     *
     * @protected
     */
    _unbindEvents: function() {
        this.removeShortcuts();
        this.unbindOutsideClick();
        this.unbindResize();
    },

    /**
     * Binds the outside `click` event.
     */
    bindOutsideClick: function() {
        $('body').bind('click.' + this.cid, _.bind(function(e) {
            if ($(e.target).closest('#sweetspot').length === 0) {
                this.hide();
            }
        }, this));
    },

    /**
     * Unbinds the outside `click` event.
     */
    unbindOutsideClick: function() {
        $('body').unbind('click.' + this.cid);
    },

    /**
     * Create new shortcut session and add shortcut to hide SweetSpot
     */
    createShortcuts: function() {
        app.shortcuts.saveSession();
        app.shortcuts.createSession(['SweetSpot:Toggle:Off'], this);
        app.shortcuts.registerGlobal({
            id: 'Sweetspot:Toggle:Off',
            keys: 'esc',
            component: this,
            description: 'LBL_SHORTCUT_SWEETSPOT_HIDE',
            callOnFocus: true,
            handler: this.hide
        });
    },

    /**
     * Remove shortcuts for SweetSpot and restore previous session.
     */
    removeShortcuts: function() {
        app.shortcuts.restoreSession();
    },

    /**
     * Binds the `resize` event.
     */
    bindResize: function() {
        $(window).on('resize.sweetspot-' + this.cid, _.bind(this.calculateResultsHeight, this));
    },

    /**
     * Unbinds the `resize` event.
     */
    unbindResize: function() {
        $(window).off('resize.sweetspot-' + this.cid);
    },

    /**
     * Checks if this layout is ready to be {@link #show displayed}, or
     * {@link #_render rendered}.
     *
     * FIXME SC-2761: Checking `isVisible` on the header component is necessary
     * for disabling this layout on full-page modal views like the first login
     * wizard. However, hiding additionalComponents should be event driven,
     * see https://github.com/sugarcrm/Mango/pull/18722#discussion_r11782561.
     *
     * @return {boolean} `true` if this layout is OK to render/show, `false`
     *   otherwise.
     */
    isReady: function() {
        return app.api.isAuthenticated() && app.isSynced && app.additionalComponents.header.isVisible();
    },

    /**
     * @override
     */
    isVisible: function() {
        return this._isVisible;
    },

    /**
     * @override
     */
    show: function() {
        if (this.isVisible()) {
            return;
        }
        if (!this.triggerBefore('show')) {
            return false;
        }
        if (!this.isReady()) {
            return;
        }

        this._isVisible = true;
        this.$('input').val('');
        this.$el.fadeToggle(50, 'linear', _.bind(this.focusInput, this));
        this.trigger('show');
        this.calculateResultsHeight();
        this._bindEvents();
    },

    /**
     * @override
     */
    hide: function() {
        if (!this.isVisible()) {
            return;
        }
        if (!this.triggerBefore('hide')) {
            return false;
        }

        this._isVisible = false;
        this._unbindEvents();
        this.$el.fadeToggle(50, 'linear');
        this.$el.removeClass('has-results');
        this.trigger('hide');
    },

    /**
     * Toggles the Sweet Spot.
     */
    toggle: function() {
        if (this.isVisible()) {
            this.hide();
        } else {
            this.show();
        }
    },

    /**
     * Focuses on the Sweet Spot input.
     */
    focusInput: function() {
        this.$('input').focus();
    },

    /**
     * Opens a drawer with the {@link View.Layouts.Base.SweetspotConfigLayout}
     * to configure the Sweet Spot.
     */
    openConfigPanel: function() {
        // TODO: This is bad and there should be an option in drawer.js to
        // prevent opening an already-open drawer of the same type.
        var activeDrawerLayout = app.drawer.getActive();
        if (activeDrawerLayout && activeDrawerLayout.type === 'sweetspot-config') {
            return;
        }

        app.drawer.open({
            layout: 'sweetspot-config',
            context: {
                skipFetch: true,
                forceNew: true
            }
        });
    },

    /**
     * Trigger a system action.
     *
     * @param {string} method Name of the method in {@link #_systemActions}.
     */
    triggerSystemAction: function(method) {
        if (!_.isFunction(this._systemActions[method])) {
            return;
        }
        this._systemActions[method].call(this);
    },

    /**
     * List of system action callbacks.
     *
     * Use {@link #triggerSystemAction} to trigger them.
     */
    _systemActions: {
        openConfig: function() {
            this.openConfigPanel();
        }
    },

    /**
     * Calculates the results dropdown height based on the window height and
     * triggers 'sweetspot:results:adjustMaxHeight' passing the value.
     */
    calculateResultsHeight: function() {
        var distanceToFooter = 80;
        var resultsMaxHeight = $(window).height() - this.$el.offset().top - $('footer').height() - distanceToFooter;
        if (resultsMaxHeight > 460) {
            resultsMaxHeight = 460;
        }

        this.trigger('sweetspot:results:adjustMaxHeight', resultsMaxHeight);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this._unbindEvents();
        this._super('_dispose');
    }
}) },
"list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Layout that places components using bootstrap fluid layout divs.
 *
 * @class View.Layouts.Base.ListLayout
 * @alias SUGAR.App.view.layouts.BaseListLayout
 * @extends View.Layout
 */
({
	// List Layout (base) 

    /**
     * Places a view's element on the page. This shoudl be overriden by any custom layout types.
     * @param {View.View} comp
     * @protected
     * @method
     */
    _placeComponent: function(comp, def) {
        var size = def.size || 12;

        // Helper to create boiler plate layout containers
        function createLayoutContainers(self) {
            // Only creates the containers once
            if (!self.$el.children()[0]) {
                comp.$el.addClass('list');
            }
        }

        createLayoutContainers(this);

        // All components of this layout will be placed within the
        // innermost container div.
        this.$el.append(comp.el);
    }

}) },
"preview-activitystream": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PreviewActivityStreamLayout
 * @alias SUGAR.App.view.layouts.BasePreviewActivityStreamLayout
 * @extends View.Layouts.Base.ActivitystreamLayout
 */
({
	// Preview-activitystream Layout (base) 

    extendsFrom: 'ActivitystreamLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The instance of the {@link Core.Context preview layout context}.
         * @type {Core.Context}
         */
        this._previewContext = this.context.parent;

        app.events.on('preview:close', function() {
            this.disposeAllActivities();
        }, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.fetchActivities(this._previewContext.get('model'), this._previewContext.get('collection'));
        this._super('_render');
    },

    /**
     * Fetch and render activities.
     *
     * @param {Data.Bean} model The {@link Data.Bean model} being previewed.
     * @param {Data.BeanCollection} collection The
     *   {@link Data.BeanCollection collection} of preview models.
     */
    fetchActivities: function(model, collection) {
        if (app.metadata.getModule(model.module).isBwcEnabled) {
            // don't fetch activities for BWC modules
            return;
        }
        this.disposeAllActivities();
        this.collection.dataFetched = false;
        this.$el.hide();

        this.collection.reset();
        this.collection.resetPagination();
        this.collection.setOption('endpoint', function(method, collection, options, callbacks) {
            var url = app.api.buildURL(model.module, null, {id: model.get('id'), link: 'activities'}, options.params);

            return app.api.call('read', url, null, callbacks);
        });
        this.collection.fetch({
            /*
             * Render activity stream
             */
            showAlerts: true,
            success: _.bind(this.renderActivities, this)
        });
    },

    /**
     * Render activity stream once the preview pane opens. Hide it when there are no activities.
     * @param collection
     */
    renderActivities: function(collection) {
        var self = this;
        if (this.disposed) {
            return;
        }

        if (collection.length) {
            collection.each(function(activity) {
                self.renderPost(activity, true);
            });
            this.$el.show();
        }
    },

    /**
     * No need to set collectionOptions.
     */
    setCollectionOptions: function() {},

    /**
     * No need to expose data transfer object since this activity stream is readonly.
     */
    exposeDataTransfer: function() {},

    /**
     * Don't load activity stream until 'preview:render' event has been fired.
     */
    loadData: function() {},

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('add', function(activity) {
            if (!this.disposed) {
                this.renderPost(activity, true);
            }
        }, this);

        this._previewContext.on('change:model', this.render, this);
    },

    /**
     * @inheritdoc
     */
    unbind: function() {
        this._previewContext.off('change:model', this.render, this);
        this._super('unbind');
    }
}) },
"dashletselect": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dashletselect Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: ['Dashlet:Select:Cancel']
}) },
"selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.SelectionListLayout
 * @alias SUGAR.App.view.layouts.BaseSelectionListLayout
 * @extends View.Layout
 */
({
	// Selection-list Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Sidebar:Toggle'
    ],

    loadData: function(options) {
        var fields = _.union(this.getFieldNames(), (this.context.get('fields') || []));
        this.context.set('fields', fields);
        this._super('loadData', [options]);
    }
}) },
"merge-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Merge-duplicates Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Headerpane:Cancel',
        'Headerpane:Save',
        'Sidebar:Toggle'
    ]
}) }
}}

,
	"modules":{
		"Login":{
}
	}}})(SUGAR.App);
