(function(app) {
 SUGAR.jssource = {
	"modules":{
		"Home":{"fieldTemplates": {
"base": {
"layoutsizer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Home.LayoutsizerField
 * @alias SUGAR.App.view.fields.BaseHomeLayoutsizerField
 * @extends View.Fields.Base.BaseField
 */
({
	// Layoutsizer FieldTemplate (base) 

    spanMin: 2,
    spanTotal: 12,
    spanStep: 1,
    format: function(value) {
        var metadata = this.model.get("metadata");
        return (metadata && metadata.components) ? metadata.components.length - 1 : 0;
    },
    _loadTemplate: function() {
        app.view.Field.prototype._loadTemplate.call(this);
        if(this.action !== 'edit') {
            this.template = app.template.empty;
        }
    },
    _render: function() {
        app.view.Field.prototype._render.call(this);
        if(this.action === 'edit' && this.value > 0) {
            var self = this,
                metadata = this.model.get("metadata");
            this.$('#layoutwidth').empty().noUiSlider('init', {
                    knobs: this.value,
                    scale: [0,this.spanTotal],
                    step: this.spanStep,
                    connect: false,
                    end: function(type) {
                        if(type !== 'move') {
                            var values = $(this).noUiSlider('value');
                            self.setValue(values);
                        }
                    }
                })
                .append(function(){
                    var html = "",
                        segments = (self.spanTotal / self.spanStep) + 1,
                        segmentWidth = $(this).width() / (segments - 1),
                        acum = 0;
                    _.times(segments, function(i){
                        acum = (segmentWidth * i) - 2;
                        html += "<div class='ticks' style='left:"+acum+"px'></div>";
                    }, this);
                    return html;
                });
            this.setSliderPosition(metadata);
        } else {
            this.$('.noUiSliderEnds').hide();
        }
    },
    setSliderPosition: function(metadata) {
        var divider = 0;
        _.each(_.pluck(metadata.components, 'width'), function(span, index) {
            if(index >= this.value) return;
            divider = divider + parseInt(span, 10);
            this.$('#layoutwidth').noUiSlider('move', {
                handle: index,
                to: divider
            });
        }, this);
    },
    setValue: function(value) {
        var metadata = this.model.get("metadata"),
            divider = 0;
        _.each(metadata.components, function(component, index){
            if(index == metadata.components.length - 1) {
                component.width = this.spanTotal - divider;
                if(component.width < this.spanMin) {
                    var adjustment = this.spanMin - component.width;
                    for(var i = index - 1; i >= 0; i--) {
                        metadata.components[i].width -= adjustment;
                        if(metadata.components[i].width < this.spanMin) {
                            adjustment = this.spanMin - metadata.components[i].width;
                            metadata.components[i].width = this.spanMin;
                        } else {
                            adjustment = 0;
                        }
                    }
                    component.width = this.spanMin;
                }
            } else {
                component.width = value[index] - divider;
                if(component.width < this.spanMin) {
                    component.width = this.spanMin;
                }
                divider += component.width;
            }
        }, this);
        this.setSliderPosition(metadata);
        this.model.set("metadata", metadata, {silent: true});
        this.model.trigger("change:layout");
    },
    bindDataChange: function() {
        if (this.model) {
            this.model.on("change:metadata", this.render, this);
        }
    },
    bindDomChange: function() {

    }
}) },
"sugar-dashlet-label": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Home.SugarDashletLabelField
 * @alias SUGAR.App.view.fields.BaseHomeSugarDashletLabelField
 * @extends View.Fields.Base.LabelField
 *
 * Label for trademarked `Sugar Dashlet&reg;` term.
 */
({
	// Sugar-dashlet-label FieldTemplate (base) 

    extendsFrom: 'LabelField'
}) },
"layoutbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Home.LayoutbuttonField
 * @alias SUGAR.App.view.fields.BaseHomeLayoutbuttonField
 * @extends View.Fields.Base.BaseField
 */
({
	// Layoutbutton FieldTemplate (base) 

    events: {
        'click .btn.layout' : 'layoutClicked'
    },

    extendsFrom: 'ButtonField',
    getFieldElement: function() {
        return this.$el;
    },
    _render: function() {
        var buttonField = app.view._getController({type: 'field', name: 'button', platform: app.config.platform});
        buttonField.prototype._render.call(this);
    },
    _loadTemplate: function() {
        app.view.Field.prototype._loadTemplate.call(this);
        if(this.action !== 'edit' || (this.model.maxColumns <= 1)) {
            this.template = app.template.empty;
        }
    },
    format: function(value) {
        var metadata = this.model.get("metadata");
        if(metadata) {
            return (metadata.components) ? metadata.components.length : 1;
        }
        return value;
    },
    layoutClicked: function(evt) {
        var value = $(evt.currentTarget).data('value');
        this.setLayout(value);
    },
    setLayout: function(value) {
        var span = 12 / value;
        if(this.value) {

            if (value === this.value) {
                return;
            }
            var setComponent = function() {
                var metadata = this.model.get("metadata");

                _.each(metadata.components, function(component){
                    component.width = span;
                }, this);

                if(metadata.components.length > value) {
                    _.times(metadata.components.length - value, function(index){
                        metadata.components[value - 1].rows = metadata.components[value - 1].rows.concat(metadata.components[value + index].rows);
                    },this);
                    metadata.components.splice(value);
                } else {
                    _.times(value - metadata.components.length, function(index) {
                        metadata.components.push({
                            rows: [],
                            width: span
                        });
                    }, this);
                }
                this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
                this.model.trigger("change:metadata");
            };
            if(value !== this.value) {
                app.alert.show('resize_confirmation', {
                    level: 'confirmation',
                    messages: app.lang.get('LBL_DASHBOARD_LAYOUT_CONFIRM', this.module),
                    onConfirm: _.bind(setComponent, this),
                    onCancel: _.bind(this.render,this) // reverse the toggle done
                });
            } else {
                setComponent.call(this);
            }
        } else {
            //new data
            var metadata = {
                components: []
            };
            _.times(value, function(index) {
                metadata.components.push({
                    rows: [],
                    width: span
                });
            }, this);

            this.model.set("metadata", app.utils.deepCopy(metadata), {silent: true});
            this.model.trigger("change:metadata");
        }
    },
    bindDomChange: function() {

    },
    bindDataChange: function() {
        if (this.model) {
            this.model.on("change:metadata", this.render, this);
            if(this.model.isNew()) {
                //Assign default layout set
                this.setLayout(1);
                //clean out model changed attributes not to warn unsaved changes
                this.model.changed = {};
            }
        }
    }
}) },
"favorite": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Dashboards.FavoriteField
 * @alias SUGAR.App.view.fields.DashboardsBaseFavoriteField
 * @extends View.Fields.Base.FavoriteField
 */
({
	// Favorite FieldTemplate (base) 

    // FIXME TY-1463 Remove this file.
    /**
     * Check first if the model exists before rendering.
     *
     * The dashboards currently reside in the Home module. The Home module does
     * not have favorites enabled. The dashboards do have favorites enabled.
     * In order to show the favorite icon on dashboards, we need to bypass
     * the favoritesEnabled check.
     *
     * @override
     * @private
     */
    _render: function() {
        // can't favorite something without an id
        if (!this.model.get('id')) {
            return null;
        }
        return app.view.Field.prototype._render.call(this);
    }
}) },
"dashboardtitle": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Home.DashboardtitleField
 * @alias SUGAR.App.view.fields.BaseHomeDashboardtitleField
 * @extends View.Fields.Base.BaseField
 */
({
	// Dashboardtitle FieldTemplate (base) 

    events: {
        'click .dropdown-toggle': 'toggleClicked',
        'click a[data-id]': 'navigateClicked',
        'click a[data-action=manager]': 'managerClicked'
    },
    dashboards: null,
    toggleClicked: function(evt) {
        var self = this;
        if (!_.isEmpty(this.dashboards)) {
            return;
        }

        var contextBro = this.context.parent.getChildContext({module: 'Home'});
        var collection = contextBro.get('collection').clone();
        var pattern = /^(LBL|TPL|NTC|MSG)_(_|[a-zA-Z0-9])*$/;
        collection.remove(self.model, {silent: true});
        _.each(collection.models, function(model) {
            if (pattern.test(model.get('name'))) {
                model.set('name',
                    app.lang.get(model.get('name'), model.get('dashboard_module'))
                );
            }
        });
        self.dashboards = collection;
        var optionTemplate = app.template.getField(self.type, 'options', self.module);
        self.$('.dropdown-menu').html(optionTemplate(collection));
    },
    /**
     * Handle the click from the UI
     * @param {Object} evt The jQuery Event Object
     */
    navigateClicked: function(evt) {
        var id = $(evt.currentTarget).data('id');
        this.navigate(id);
    },
    /**
     * Navigate the user to the manage dashboards view
     */
    managerClicked: function() {
        var controllerContext = app.controller.context;
        var dashboardModule = controllerContext.get('module');
        var dashboardLayout = controllerContext.get('layout');
        app.router.navigate('#Dashboards?moduleName=' + dashboardModule +
            '&viewName=' + dashboardLayout, {trigger: true});
    },
    /**
     * Change the Dashboard
     * @param {string} id The ID of the Dashboard to load
     * @param {string} [type] (Deprecated) The type of dashboard being loaded, default is undefined
     */
    navigate: function(id, type) {
        if (!_.isUndefined(type)) {
            // TODO: Remove the `type` parameter. This is to be done in TY-654
            app.logger.warn('The `type` parameter to `View.Fields.Base.Home.DashboardtitleField`' +
            'has been deprecated since 7.9.0.0. Please update your code to stop using it.');
        }
        this.view.layout.navigateLayout(id);
    },
    /**
     * Inspect the dashlet's label and convert i18n string only if it's concerned
     *
     * @param {String} i18n string or user typed string
     * @return {String} Translated string
     */
    format: function(value) {
        var module = this.context.parent && this.context.parent.get('module') || this.context.get('module');
        return app.lang.get(value, module) || value;
    },

    /**
     * @inheritdoc
     *
     * Override template for dashboard title on home page.
     * Need display it as label so use `f.base.detail` template.
     */
    _loadTemplate: function() {
        app.view.Field.prototype._loadTemplate.call(this);

        if (this.context && this.context.get('model') &&
            this.context.get('model').dashboardModule === 'Home'
        ) {
            this.template = app.template.getField('base', this.tplName) || this.template;
        }
    },

    /**
     * Called by record view to set max width of inner record-cell div
     * to prevent long names from overflowing the outer record-cell container
     */
    setMaxWidth: function(width) {
        this.$el.css({'max-width': width});
    },

    /**
     * Return the width of padding on inner record-cell
     */
    getCellPadding: function() {
        var padding = 0,
            $cell = this.$('.dropdown-toggle');

        if (!_.isEmpty($cell)) {
            padding = parseInt($cell.css('padding-left'), 10) + parseInt($cell.css('padding-right'), 10);
        }

        return padding;
    }
}) }
}}
,
"views": {
"base": {
"about-source-code": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Home.AboutSourceCodeView
 * @alias SUGAR.App.view.views.BaseHomeAboutSourceCodeView
 * @extends View.View
 */
({
	// About-source-code View (base) 

    /**
     * The server info object. See {@link Core.MetadataManager#getServerInfo}.
     *
     * @property {String}
     */
    serverInfo: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.serverInfo = app.metadata.getServerInfo();
    }
}) },
"search-dashboard-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SearchDashboardHeaderpaneView
 * @alias SUGAR.App.view.views.BaseSearchDashboardHeaderpaneView
 * @extends View.View
 */
({
	// Search-dashboard-headerpane View (base) 

    className: 'search-dashboard-headerpane',
    events: {
        'click a[name=collapse_button]' : 'collapseClicked',
        'click a[name=expand_button]' : 'expandClicked',
        'click a[name=reset_button]' : 'resetClicked'
    },

    /**
     * Collapses all the dashlets in the dashboard.
     */
    collapseClicked: function() {
        this.context.trigger('dashboard:collapse:fire', true);
    },

    /**
     * Expands all the dashlets in the dashboard.
     */
    expandClicked: function() {
        this.context.trigger('dashboard:collapse:fire', false);
    },

    /**
     * Triggers 'facets:reset' event to reset the facets applied on the search.
     */
    resetClicked: function() {
        this.context.parent.trigger('facets:reset', true);
    }
}) },
"module-menu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Module menu provides a reusable and easy render of a module Menu.
 *
 * This also helps doing customization of the menu per module and provides more
 * metadata driven features.
 *
 * @class View.Views.Base.Home.ModuleMenuView
 * @alias SUGAR.App.view.views.BaseHomeModuleMenuView
 * @extends View.Views.Base.ModuleMenuView
 */
({
	// Module-menu View (base) 

    extendsFrom: 'ModuleMenuView',

    /**
     * The collection used to list dashboards on the dropdown.
     *
     * This is initialized on {@link #_initCollections}.
     *
     * @property
     * @type {Data.BeanCollection}
     */
    dashboards: null,

    /**
     * The collection used to list the recently viewed on the dropdown,
     * since it needs to use a {@link Data.MixedBeanCollection}
     *
     * This is initialized on {@link #_initCollections}.
     *
     * @property
     * @type {Data.MixedBeanCollection}
     */
    recentlyViewed: null,

    /**
     * Default settings used when none are supplied through metadata.
     *
     * Supported settings:
     * - {Number} dashboards Number of dashboards to show on the dashboards
     *   container. Pass 0 if you don't want to support dashboards listed here.
     * - {Number} favorites Number of records to show on the favorites
     *   container. Pass 0 if you don't want to support favorites.
     * - {Number} recently_viewed Number of records to show on the recently
     *   viewed container. Pass 0 if you don't want to support recently viewed.
     * - {Number} recently_viewed_toggle Threshold of records to use for
     *   toggling the recently viewed container. Pass 0 if you don't want to
     *   support recently viewed.
     *
     * Example:
     * ```
     * // ...
     * 'settings' => array(
     *     'dashboards' => 10,
     *     'favorites' => 5,
     *     'recently_viewed' => 9,
     *     'recently_viewed_toggle' => 4,
     *     //...
     * ),
     * //...
     * ```
     *
     * @protected
     */
    _defaultSettings: {
        dashboards: 20,
        favorites: 3,
        recently_viewed: 10,
        recently_viewed_toggle: 3
    },

    /**
     * Key for storing the last state of the recently viewed toggle.
     *
     * @type {String}
     */
    TOGGLE_RECENTS_KEY: 'more',

    /**
     * The lastState key to use in order to retrieve or save last recently
     * viewed toggle.
     */
    _recentToggleKey: null,

    /**
     * @inheritdoc
     *
     * Initializes the collections that will be used when the dropdown is
     * opened.
     *
     * Initializes Legacy dashboards.
     *
     * Sets the recently viewed toggle key to be ready to use when the dropdown
     * is opened.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.events = _.extend({}, this.events, {
            'click [data-toggle="recently-viewed"]': 'handleToggleRecentlyViewed'
        });

        this._initCollections();
        this._initLegacyDashboards();

        this.meta.last_state = { id: 'recent' };
        this._recentToggleKey = app.user.lastState.key(this.TOGGLE_RECENTS_KEY, this);
    },

    /**
     * Creates the collections needed for list of dashboards and recently
     * viewed.
     *
     * The views' collection is pointing to the Home module and we might need
     * to use that later for something that could be populated from that
     * module. Therefore, we create other collections to be used for extra
     * information that exists on the Home dropdown menu.
     *
     * @chainable
     * @private
     */
    _initCollections: function() {

        this.dashboards = app.data.createBeanCollection('Dashboards');
        this.recentlyViewed = app.data.createMixedBeanCollection();

        return this;
    },

    /**
     * Sets the legacy dashboards link if it is configured to be enabled.
     *
     * We are not using the `hide_dashboard_bwc` form, because we don't provide
     * this feature by default and it is enabled only on upgrades from 6.x..
     * This will be removed in the future, when all dashlets are available in
     * 7.x..
     *
     * @chainable
     * @private
     */
    _initLegacyDashboards: function() {
        if (app.config.enableLegacyDashboards && app.config.enableLegacyDashboards === true) {
            this.dashboardBwcLink = app.bwc.buildRoute(this.module, null, 'bwc_dashboard');
        }
        return this;
    },

    /**
     * @inheritdoc
     *
     * Adds the title and the class for the Home module (Sugar cube).
     */
    _renderHtml: function() {
        this._super('_renderHtml');

        this.$el.attr('title', app.lang.get('LBL_TABGROUP_HOME', this.module));
        this.$el.addClass('home btn-group');
    },

    /**
     * @override
     *
     * Populates all available dashboards when opening the menu. We override
     * this function without calling the parent one because we don't want to
     * reuse any of it.
     *
     * **Attention** We only populate up to 20 dashboards.
     *
     * TODO We need to keep changing the endpoint until SIDECAR-493 is
     * implemented.
     */
    populateMenu: function() {
        var pattern = /^(LBL|TPL|NTC|MSG)_(_|[a-zA-Z0-9])*$/;
        this.$('.active').removeClass('active');
        this.dashboards.fetch({
            'limit': this._settings['dashboards'],
            'filter': [{
                'dashboard_module': 'Home',
                '$or': [
                    {'$favorite': ''},
                    {'default_dashboard': 1}
                ]
            }],
            'order_by': {'date_modified': 'DESC'},
            'showAlerts': false,
            'success': _.bind(function(data) {
                var module = this.module;
                _.each(data.models, function(model) {
                    if (pattern.test(model.get('name'))) {
                        model.set('name', app.lang.get(model.get('name'), module));
                    }
                    // hardcode the module to `Home` due to different link that
                    // we support
                    model.module = 'Home';
                });

                this._renderPartial('dashboards', {
                    collection: this.dashboards,
                    active: this.context.get('module') === 'Home' && this.context.get('model')
                });

            }, this),
            'endpoint': function(method, model, options, callbacks) {
                app.api.records(method, 'Dashboards', model.attributes, options.params, callbacks);
            }
        });

        this.populateRecentlyViewed(false);
    },

    /**
     * Populates recently viewed records with a limit based on last state key.
     *
     * Based on the state it will read 2 different metadata properties:
     *
     * - `recently_viewed_toggle` for the value to start toggling
     * - `recently_viewed` for maximum records to retrieve
     *
     * Defaults to `recently_viewed_toggle` if no state is defined.
     *
     * @param {Boolean} focusToggle Whether to set focus on the toggle after rendering
     */
    populateRecentlyViewed: function(focusToggle) {

        var visible = app.user.lastState.get(this._recentToggleKey),
            threshold = this._settings['recently_viewed_toggle'],
            limit = this._settings[visible ? 'recently_viewed' : 'recently_viewed_toggle'];

        if (limit <= 0) {
            return;
        }

        var modules = this._getModulesForRecentlyViewed();
        if (_.isEmpty(modules)) {
            return;
        }

        this.recentlyViewed.fetch({
            'showAlerts': false,
            'fields': ['id', 'name'],
            'date': '-7 DAY',
            'limit': limit,
            'module_list': modules,
            'success': _.bind(function(data) {
                this._renderPartial('recently-viewed', {
                    collection: this.recentlyViewed,
                    open: !visible,
                    showRecentToggle: data.models.length > threshold || data.next_offset !== -1
                });
                if (focusToggle && this.isOpen()) {
                    // put focus back on toggle after renderPartial
                    this._focusRecentlyViewedToggle();
                }
            }, this),
            'endpoint': function(method, model, options, callbacks) {
                var url = app.api.buildURL('recent', 'read', options.attributes, options.params);
                app.api.call(method, url, null, callbacks, options.params);
            }
        });

        return;
    },

    /**
     * Set focus on the recently viewed toggle
     * @private
     */
    _focusRecentlyViewedToggle: function() {
        this.$('[data-toggle="recently-viewed"]').focus();
    },

    /**
     * Retrieve a list of modules where support for recently viewed records is
     * enabled and current user has access to list their records.
     *
     * Dashboards is discarded since it is already populated by default on the
     * drop down list {@link #populateMenu}.
     *
     * To disable recently viewed items for a specific module, please set the
     * `recently_viewed => 0` on:
     *
     * - `{custom/,}modules/{module}/clients/{platform}/view/module-menu/module-menu.php`
     *
     * @return {Array} List of supported modules names.
     * @private
     */
    _getModulesForRecentlyViewed: function() {
        // FIXME: we should find a better option instead of relying on visible
        // modules
        var modules = app.metadata.getModuleNames({filter: 'visible', access: 'list'});

        modules = _.filter(modules, function(module) {
            var view = app.metadata.getView(module, 'module-menu');
            return !view || !view.settings || view.settings.recently_viewed > 0;
        });

        return modules;
    },

    /**
     * Handles the toggle of the more recently viewed mixed records.
     *
     * This triggers a refresh on the data to be retrieved based on the amount
     * defined in metadata for the given state. This way we limit the amount of
     * data to be retrieve to the current state and not getting always the
     * maximum.
     *
     * @param {Event} event The click event that triggered the toggle.
     */
    handleToggleRecentlyViewed: function(event) {
        app.user.lastState.set(this._recentToggleKey, Number(!app.user.lastState.get(this._recentToggleKey)));
        this.populateRecentlyViewed(true);
        event.stopPropagation();
    }
}) },
"top-activity-user": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Home.TopActivityUserView
 * @alias SUGAR.App.view.views.BaseHomeTopActivityUserView
 * @extends View.View
 */
({
	// Top-activity-user View (base) 

    plugins: ['Dashlet', 'GridBuilder'],
    events: {
        'change select[name=filter_duration]': 'filterChanged'
    },
    /**
     * Track if current user is manager.
     */
    isManager: false,
    initDashlet: function(viewName) {
        this.collection = new app.BeanCollection();
        this.isManager = app.user.get('is_manager');
        if(!this.meta.config) {
            this.collection.on("reset", this.render, this);
        }
    },
    _mapping: {
        meetings: {
            icon: 'fa-comments',
            label: 'LBL_MOST_MEETING_HELD'
        },
        inbound_emails: {
            icon: 'fa-envelope',
            label: 'LBL_MOST_EMAILS_RECEIVED'
        },
        outbound_emails: {
            icon: 'fa-envelope-o',
            label: 'LBL_MOST_EMAILS_SENT'
        },
        calls: {
            icon: 'fa-phone',
            label: 'LBL_MOST_CALLS_MADE'
        }
    },
    loadData: function(params) {
        if(this.meta.config) {
            return;
        }
        var url = app.api.buildURL('mostactiveusers', null, null, {days: this.settings.get("filter_duration")}),
            self = this;
        app.api.call("read", url, null, {
            success: function(data) {
                if(self.disposed) {
                    return;
                }
                var models = [];
                _.each(data, function(attributes, module){
                    if(_.isEmpty(attributes)) {
                        return;
                    }
                    var model = new app.Bean(_.extend({
                        id: _.uniqueId('aui')
                    }, attributes));
                    model.module = module;
                    model.set("name", model.get("first_name") + ' ' + model.get("last_name"));
                    model.set("icon", self._mapping[module]['icon']);
                    var template = Handlebars.compile(app.lang.get(self._mapping[module]['label'], self.module));
                    model.set("label", template({
                        count: model.get("count")
                    }));
                    model.set("pictureUrl", app.api.buildFileURL({
                        module: "Users",
                        id: model.get("user_id"),
                        field: "picture"
                    }));
                    models.push(model);
                }, this);
                self.collection.reset(models);
            },
            complete: params ? params.complete : null
        });
    },
    filterChanged: function(evt) {
        this.loadData();
    },

    _dispose: function() {
        if(this.collection) {
            this.collection.off("reset", null, this);
        }
        app.view.View.prototype._dispose.call(this);
    }
}) },
"about-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Home.AboutHeaderpaneView
 * @alias SUGAR.App.view.views.BaseHomeAboutHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// About-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * @override
     *
     * Formats the title with the current server info.
     */
    _formatTitle: function(title) {
        var serverInfo = app.metadata.getServerInfo();
        return app.lang.get(title, this.module, serverInfo) + this._getMarketingVersion(serverInfo.marketing_version);
    },

    /**
     * Gets the marketing version, formatted for presentation on the UI
     * @param {string} ver The marketing version before formatting
     * @return {string}
     * @private
     */
    _getMarketingVersion: function(ver) {
        // If ver is null or undefined, reset it
        ver = ver || '';

        // Clean it up for sanity
        ver = ver.trim();

        // If the version has content, wrap it in parens
        if (ver !== '') {
            ver = ' (' + ver + ')';
        }

        return ver;
    }
}) },
"about-language-packs": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Home.AboutLanguagePacksView
 * @alias SUGAR.App.view.views.BaseHomeAboutLanguagePacksView
 * @extends View.View
 */
({
	// About-language-packs View (base) 

    linkTemplate: null,

    /**
     * @inheritdoc
     *
     * Initializes the link template to be used on the render.
     */
    initialize: function(opts) {
        app.view.View.prototype.initialize.call(this, opts);

        this.linkTemplate = app.template.getView(this.name + '.link', this.module);
    },

    /**
     * @inheritdoc
     *
     * Override the title to pass the context with the server info.
     */
    _renderHtml: function() {
        _.each(this.meta.providers, function(provider) {
            provider.link = this.linkTemplate(provider);
        }, this);

        app.view.View.prototype._renderHtml.call(this);
    }
}) },
"webpage": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Home.WebpageView
 * @alias SUGAR.App.view.views.BaseHomeWebpageView
 * @extends View.View
 */
({
	// Webpage View (base) 

    plugins: ['Dashlet'],

    /**
     * @property {Object} _defaultOptions
     * @property {number} _defaultOptions.limit Default number of rows displayed
     *   in a dashlet.
     *
     * @protected
     */
    _defaultOptions: {
        limit: 10,
    },

    bindDataChange: function(){
        if(!this.meta.config) {
            this.model.on("change", this.render, this);
        }
    },

    _render: function() {
        if (!this.meta.config) {
            this.dashletConfig.view_panel[0].height = this.settings.get('limit') * this.rowHeight;
        }
        app.view.View.prototype._render.call(this);
    },

    initDashlet: function(view) {
        this.viewName = view;
        var settings = _.extend({}, this._defaultOptions, this.settings.attributes);
        this.settings.set(settings);
    },

    loadData: function(options) {
        if (options && options.complete) {
            options.complete();
        }
    }
}) },
"search-facet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Home.SearchFacetView
 * @alias SUGAR.App.view.views.BaseSearchFacetView
 * @extends View.View
 */
({
	// Search-facet View (base) 

    events: {
        'click [data-facet-criteria]': 'itemClicked'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * The facet id.
         *
         * @property {String}
         */
        this.facetId = this.meta.facet_id;
        /**
         * Boolean to indicate if the facet is a single criteria facet or a multi
         * criterias facet. `true` is a single criteria facet.
         *
         * @type {boolean}
         */
        this.isSingleItem = this.meta.ui_type === 'single';
        /**
         * The array of facets criterias to be displayed.
         *
         * @property {Array} facetItems
         */
        this.facetItems = [];

        if (this.context.get('facets') && this.context.get('facets')[this.facetId]) {
            this.parseFacetsData();
        }

        this.bindFacetsEvents();
    },

    /**
     * Binds context events related to facets changes.
     */
    bindFacetsEvents: function() {
        this.context.on('facets:change', this.parseFacetsData, this);
    },

    /**
     * Parses facets data and renders the view.
     */
    parseFacetsData: function() {
        var currentFacet = this.context.get('facets')[this.facetId];
        var selectedFacets = this.context.get('selectedFacets');

        if (_.isUndefined(currentFacet)) {
            this.render();
            return;
        }

        if (this.isSingleItem && currentFacet.results.count === 0) {
            this.$el.addClass('disabled');
            this.$el.data('action', 'disabled');
        } else {
            this.$el.data('action', 'enabled');
            this.$el.removeClass('disabled');
        }

        if (this.clickedFacet) {
            this.clickedFacet = false;
            return;
        }
        if (_.isUndefined(currentFacet)) {
            app.logger.warn('The facet type : ' + this.facetId + 'is not returned by the server.' +
                ' Therefore, the facet dashlet will have no data.');
            return;
        }
        var results = currentFacet.results;
        this.facetItems = [];

        if (this.isSingleItem) {
            this.facetItems = [{
                key: this.facetId,
                label: app.lang.get(this.meta.label, 'Filters'),
                count: results.count,
                selected: selectedFacets[this.facetId]
            }];
            this.render();
            return;
        }

        var labelFunction = this._getDefaultLabel;

        _.each(results, function(val, key) {
            var selected = _.contains(selectedFacets[this.facetId], key);
            this.facetItems.push({key: key, label: labelFunction(key), count: val, selected: selected});
        }, this);

        if (_.isEmpty(this.facetItems)) {
            this.layout.context.trigger('dashboard:collapse:fire', true);
        } else {
            this.layout.context.trigger('dashboard:collapse:fire', false);
            this.facetItems = _.sortBy(this.facetItems, 'count').reverse();
        }
        this.render();
    },

    /**
     * Selects or unselect a facet item.
     *
     * @param {Event} event The `click` event.
     */
    itemClicked: function(event) {
        var currentTarget = this.$(event.currentTarget);
        if (this.$el.data('action') === 'disabled') {
            return;
        }
        if (!this.clickedFacet && !this.collection.dataFetched) {
            return;
        }

        var facetCriteriaId = currentTarget.data('facet-criteria');

        currentTarget.toggleClass('selected');
        this.clickedFacet = true;
        this.context.trigger('facet:apply', this.facetId, facetCriteriaId, this.isSingleItem);
    },

    /**
     * Gets the facet criteria id to use it as a label.
     *
     * @param {Object} bucket The facet item.
     * @return {string} The label for this item.
     * @private
     */
    _getDefaultLabel: function(key) {
        return app.lang.getModuleName(key, {plural: true});
    }
}) },
"twitter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Home.TwitterView
 * @alias SUGAR.App.view.views.BaseHomeTwitterView
 * @extends View.View
 */
({
	// Twitter View (base) 

    plugins: ['Dashlet', 'RelativeTime', 'Connector'],
    limit : 20,
    events: {
        'click .connect-twitter': 'onConnectTwitterClick',
        'click .create-case': 'createCase'
    },

    initDashlet: function() {
        this.initDashletConfig();
        var serverInfo = app.metadata.getServerInfo();
        this.tweet2case = serverInfo.system_tweettocase_on ? true : false;
        var limit = this.settings.get('limit') || this.limit;
        this.settings.set('limit', limit);
        this.cacheKey = 'twitter.dashlet.current_user_cache';
        var currentUserCache = app.cache.get(this.cacheKey);
        if (currentUserCache && currentUserCache.current_twitter_user_name) {
            self.current_twitter_user_name = currentUserCache.current_twitter_user_name;
        }
        if (currentUserCache && currentUserCache.current_twitter_user_pic) {
            self.current_twitter_user_pic = currentUserCache.current_twitter_user_pic;
        }
        this.caseCreateAcl = app.acl.hasAccess('edit','Cases');
    },

    initDashletConfig: function() {
        this.moduleType = app.controller.context.get('module');
        this.layoutType = app.controller.context.get('layout');
        // if config view override with module specific
        if (this.meta.config && this.layoutType === 'record') {
            this.dashletConfig = app.metadata.getView(this.moduleType, this.name) || this.dashletConfig;
            // if record view that's not the Home module's record view, disable twitter name settings config
            if (this.moduleType !== 'Home' &&
                this.dashletConfig.config &&
                this.dashletConfig.config.fields) {
                // get rid of the twitter name field
                this.dashletConfig.config.fields = _.filter(this.dashletConfig.config.fields,
                    function(field) {
                        return field.name !== 'twitter';
                    });
            }
        }
    },

    onConnectTwitterClick: function(event) {
        if ( !_.isUndefined(event.currentTarget) ) {
            event.preventDefault();
            var href = this.$(event.currentTarget).attr('href');
            app.bwc.login(false, function(response){
                window.open(href);
            });
        }
    },
    /**
     * opens case create drawer with case attributes prefilled
     * @param event
     */
    createCase: function (event) {
        var module = 'Cases';
        var layout = 'create';
        var self = this;

        // set up and open the drawer
        app.drawer.reset();
        app.drawer.open({
            layout: layout,
            context: {
                create: true,
                module: module
            }
        }, function (refresh, createModelPointer) {
            if (refresh) {
                var collection = app.controller.context.get('collection');
                if (collection && collection.module === module) {
                    collection.fetch({
                        //Don't show alerts for this request
                        showAlerts: false
                    });
                }
            }
        });

        var createLayout = _.last(app.drawer._components),
            tweetId = this.$(event.target).data('url').split('/');
            tweetId = tweetId[tweetId.length-1];
        var createValues = {
            'source':'Twitter',
            'name': app.lang.get('LBL_CASE_FROM_TWITTER_TITLE', 'Cases') + ' ' + tweetId +' @'+ this.$(event.target).data('screen_name'),
            'description': app.lang.get('LBL_TWITTER_SOURCE', 'Cases') +' '+  this.$(event.target).data('url')
        };
        // update the create models values
        this.createModel = createLayout.model;
        if (this.model) {
            if(this.model.module == 'Accounts') {
                createValues.account_name = this.model.get('name');
                createValues.account_id = this.model.get('id');
            } else {
                createValues.account_name = this.model.get('account_name');
                createValues.account_id = this.model.get('account_id');
            }
        }

        this.setCreateModelFields(this.createModel, createValues);

        this.createModel.on('sync', _.once(function (model) {
            // add activity stream on save
            var activity = app.data.createBean('Activities', {
                activity_type: "post",
                comment_count: 0,
                data: {
                    value: app.lang.get('LBL_TWITTER_SOURCE') +' '+ self.$(event.target).data('url'),
                    tags: []
                },
                tags: [],
                value: app.lang.get('LBL_TWITTER_SOURCE') +' '+ self.$(event.target).data('url'),
                deleted: "0",
                parent_id: model.id,
                parent_type: "Cases"
            });

            activity.save();

            //relate contact if we can find one
            var contacts = app.data.createBeanCollection('Contacts');
            var options = {
                filter: [
                    {
                        "twitter": {
                            "$equals": self.$(event.target).data('screen_name')
                        }
                    }
                ],
                success: function (data) {
                    if (data && data.models && data.models[0]) {
                        var url = app.api.buildURL('Cases', 'contacts', {id: self.createModel.id, relatedId: data.models[0].id, link: true});
                        app.api.call('create', url);
                    }
                }
            };
            contacts.fetch(options);
        }));
    },
    /**
     * sets fields on model according to acls
     * @param model
     * @param fields
     * @return {Mixed}
     */
    setCreateModelFields: function(model, fields) {
        var action = 'edit', module = 'Cases', ownerId = app.user.get('id');
        _.each(fields, function(value, fieldName) {
            if(app.acl.hasAccess(action, module, ownerId, fieldName)) {
                model.set(fieldName, value);
            }
        });

        return model;
    },
    _render: function () {
        if (this.tweets || this.meta.config) {
            app.view.View.prototype._render.call(this);
        }
    },

    bindDataChange: function(){
        if(this.model) {
            this.model.on('change', this.loadData, this);
        }
    },

    /**
     * Gets twitter name from one of various fields depending on context
     * @return {string} twitter name
     */
    getTwitterName: function() {
        var mapping = this.getConnectorModuleFieldMapping('ext_rest_twitter', this.moduleType);
        var twitter =
                this.model.get('twitter') ||
                this.model.get(mapping.name) ||
                this.model.get('name') ||
                this.model.get('account_name') ||
                this.model.get('full_name');
        //workaround because home module actually pulls a dashboard instead of an
        //empty home model
        if (this.layoutType === 'records' || this.moduleType === 'Home') {
            twitter = this.settings.get('twitter');
        }
        if (!twitter) {
            return false;
        }
        twitter = twitter.replace(/ /g, '');
        this.twitter = twitter;
        return twitter;
    },

    /**
     * Load twitter data
     *
     * @param {object} options
     * @return {boolean} `false` if twitter name could not be established
     */
    loadData: function(options) {
        if (this.disposed || this.meta.config) {
            return;
        }

        this.screen_name = this.settings.get('twitter') || false;
        this.tried = false;

        if (this.viewName === 'config') {
            return false;
        }
        this.loadDataCompleteCb = options ? options.complete : null;
        this.connectorCriteria = ['eapm_bean', 'test_passed'];
        this.checkConnector('ext_rest_twitter',
            _.bind(this.loadDataWithValidConnector, this),
            _.bind(this.handleLoadError, this),
            this.connectorCriteria);
    },

    /**
     * With a valid connector, load twitter data
     *
     * @param {object} connector - connector will have been validated already
     */
    loadDataWithValidConnector: function(connector) {
        if (!this.getTwitterName()) {
            if (_.isFunction(this.loadDataCompleteCb)) {
                this.loadDataCompleteCb();
            }
            return false;
        }

        var limit = parseInt(this.settings.get('limit'), 10) || this.limit,
            self = this;

        var currentUserUrl = app.api.buildURL('connector/twitter/currentUser','','',{connectorHash:connector.connectorHash});
        if (!this.current_twitter_user_name) {
            app.api.call('READ', currentUserUrl, {},{
                success: function(data) {
                    app.cache.set(self.cacheKey, {
                        'current_twitter_user_name': data.screen_name,
                        'current_twitter_user_pic': data.profile_image_url
                    });
                    self.current_twitter_user_name = data.screen_name;
                    self.current_twitter_user_pic = data.profile_image_url;
                    if (!this.disposed) {
                        self.render();
                    }
                },
                complete: self.loadDataCompleteCb
            });
        }

        var url = app.api.buildURL('connector/twitter','',{id:this.twitter},{count:limit,connectorHash:connector.connectorHash});
        app.api.call('READ', url, {},{
            success: function (data) {
                if (self.disposed) {
                    return;
                }
                var tweets = [];
                if (data.success !== false) {
                    _.each(data, function (tweet) {
                        var time = new Date(tweet.created_at.replace(/^\w+ (\w+) (\d+) ([\d:]+) \+0000 (\d+)$/,
                                '$1 $2 $4 $3 UTC')),
                            date = app.date.format(time, 'Y/m/d H:i:s'),
                        // retweeted tweets are sometimes truncated so use the original as source text
                            text = tweet.retweeted_status ? 'RT @'+tweet.retweeted_status.user.screen_name+': '+tweet.retweeted_status.text : tweet.text,
                            sourceUrl = tweet.source,
                            id = tweet.id_str,
                            name = tweet.user.name,
                            tokenText = text.split(' '),
                            screen_name = tweet.user.screen_name,
                            profile_image_url = tweet.user.profile_image_url_https,
                            j,
                            rightNow = new Date(),
                            diff = (rightNow.getTime() - time.getTime())/(1000*60*60*24),
                            useAbsTime = diff > 1;

                        // Search for links and turn them into hrefs
                        for (j = 0; j < tokenText.length; j++) {
                            if (tokenText[j].charAt(0) == 'h' && tokenText[j].charAt(1) == 't') {
                                tokenText[j] = "<a class='googledoc-fancybox' href=" + '"' + tokenText[j] + '"' + "target='_blank'>" + tokenText[j] + "</a>";
                            }
                        }

                        text = tokenText.join(' ');
                        tweets.push({id: id, name: name, screen_name: screen_name, profile_image_url: profile_image_url, text: text, source: sourceUrl, date: date, useAbsTime: useAbsTime});
                    }, this);
                }

                self.tweets = tweets;
                if (!this.disposed) {
                    self.template = app.template.get(self.name + '.Home');
                    self.render();
                }
            },
            error: function(data) {
                if (self.tried === false) {
                    self.tried = true;
                    // twitter get returned error, so re-get connectors
                    var name = 'ext_rest_twitter';
                    var funcWrapper = function () {
                        self.checkConnector(name,
                            _.bind(self.loadDataWithValidConnector, self),
                            _.bind(self.handleLoadError, self),
                            self.connectorCriteria);
                    };
                    self.getConnectors(name, funcWrapper);
                }
                else {
                    self.handleLoadError(null);
                }
            },
            complete: self.loadDataCompleteCb
        });
    },

    /**
     * Error handler for if connector validation errors at some point
     *
     * @param {object} connector
     */
    handleLoadError: function(connector) {
        if (this.disposed) {
            return;
        }
        this.showGeneric = true;
        this.errorLBL = app.lang.get('ERROR_UNABLE_TO_RETRIEVE_DATA');
        this.template = app.template.get(this.name + '.twitter-need-configure.Home');
        if (connector === null) {
            //Connector doesn't exist
            this.errorLBL = app.lang.get('LBL_ERROR_CANNOT_FIND_TWITTER') + this.twitter;
        }
        else if (!connector.test_passed && connector.testing_enabled) {
            //OAuth failed
            this.needOAuth = true;
            this.needConnect = false;
            this.showGeneric = false;
            this.showAdmin = app.acl.hasAccess('admin', 'Administration');
        }
        else if (!connector.eapm_bean) {
            //Not connected
            this.needOAuth = false;
            this.needConnect = true;
            this.showGeneric = false;
            this.showAdmin = app.acl.hasAccess('admin', 'Administration');
        }
        app.view.View.prototype._render.call(this);
        if (_.isFunction(this.loadDataCompleteCb)) {
            this.loadDataCompleteCb();
        }
    },

    _dispose: function() {
        if (this.model) {
            this.model.off('change', this.loadData, this);
        }

        app.view.View.prototype._dispose.call(this);
    }
}) },
"about-resources": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Home.AboutResourcesView
 * @alias SUGAR.App.view.views.BaseHomeAboutResourcesView
 * @extends View.View
 */
({
	// About-resources View (base) 

    /**
     * @inheritdoc
     *
     * Initializes the view with the serverInfo.
     */
    initialize: function(opts) {
        this.serverInfo = app.metadata.getServerInfo();
        app.view.View.prototype.initialize.call(this, opts);
    }
}) }
}}
,
"layouts": {
"base": {
"dashboard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Home.DashboardLayout
 * @alias SUGAR.App.view.layouts.HomeDashboardLayout
 * @extends View.Layouts.DashboardLayout
 * @deprecated 7.9.0 Will be removed in 7.11.0. Use
 *   {@link View.Layouts.Dashboards.DashboardLayout} instead.
 */
({
	// Dashboard Layout (base) 

    extendsFrom: 'DashboardLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Layouts.Home.DashboardLayout has been deprecated since 7.9.0.0. ' +
        'It will be removed in 7.11.0.0. Please use View.Layouts.Dashboards.DashboardLayout instead.');
        this._super('initialize', [options]);
    }
}) },
"records": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Home.RecordsLayout
 * @alias SUGAR.App.view.layouts.HomeRecordsLayout
 * @extends View.Layout
 * @deprecated 7.9.0 Will be removed in 7.11.0. Use
 *   {@link View.Layouts.Home.Record} instead.
 */
({
	// Records Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {

        app.logger.warn('View.Layouts.Home.RecordsLayout has been deprecated since 7.9.0.0. ' +
        'It will be removed in 7.11.0.0. Please use View.Layouts.Home.Record instead.');
        this._super('initialize', [options]);
    }
}) },
"list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Home.ListLayout
 * @alias SUGAR.App.view.layouts.HomeListLayout
 * @extends View.DashboardLayout
 * @deprecated 7.9.0 Will be removed in 7.11.0. Use
 *   {@link View.Layouts.Home.Record} instead.
 */
({
	// List Layout (base) 

    extendsFrom: 'DashboardLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Layouts.Home.ListLayout has been deprecated since 7.9.0.0. ' +
        'It will be removed in 7.11.0.0. Please use View.Layouts.Home.Record instead.');
        this._super('initialize', [options]);
    }
}) }
}}
,
"datas": {}

},
		"Contacts":{"fieldTemplates": {}
,
"views": {
"base": {
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['HistoricalSummary']);
        this.plugins.push('ContactsPortalMetadataFilter');
        this._super('initialize', [options]);
        this.removePortalFieldsIfPortalNotActive(this.meta);
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Preview View (base) 

    extendsFrom: 'PreviewView',


    initialize: function(options) {
        //Plugin is registered by the Contact record view
        this.plugins = _.union(this.plugins || [], ["ContactsPortalMetadataFilter"]);
        this._super("initialize", [options]);
    },

    /**
     * Gets the portal status from metadata to know if we render portal specific fields.
     * @override
     * @param options
     */
    _previewifyMetadata: function(meta) {
        meta = this._super("_previewifyMetadata", [meta]);
        this.removePortalFieldsIfPortalNotActive(meta);
        return meta;
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Contacts.CreateView
 * @alias SUGAR.App.view.views.ContactsCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    /**
     * Gets the portal status from metadata to know if we render portal specific fields.
     * @override
     * @param options
     */
    initialize: function(options) {
        //Plugin is registered by the Contact record view
        this.plugins = _.union(this.plugins || [], ["ContactsPortalMetadataFilter"]);
        this._super("initialize", [options]);
        this.removePortalFieldsIfPortalNotActive(this.meta);
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Accounts":{"fieldTemplates": {}
,
"views": {
"base": {
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Accounts.RecordView
 * @alias SUGAR.App.view.views.BaseAccountsRecordView
 * @extends View.Views.Base.RecordView
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['HistoricalSummary']);
        this._super('initialize', [options]);
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Opportunities":{"fieldTemplates": {
"base": {
"actiondropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Create a dropdown button that contains multiple
 * {@link View.Fields.Base.RowactionField} fields.
 *
 * @class View.Fields.Base.Opportunities.ActiondropdownField
 * @alias SUGAR.App.view.fields.BaseOpportunitiesActiondropdownField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Actiondropdown FieldTemplate (base) 

    extendsFrom: 'ActiondropdownField',

    /**
     * Enable or disable caret depending on if there are any enabled actions in the dropdown list
     *
     * @inheritdoc
     * @private
     */
    _updateCaret: function() {
        // Left empty on purpose, the menu should always show
    }
}) },
"rowactions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/*
 * @class View.Fields.Base.Opportunities.RowactionsField
 * @alias SUGAR.App.view.fields.BaseOpportunitiesRowactionsField
 * @extends View.Fields.Base.RowactionsField
 */
({
	// Rowactions FieldTemplate (base) 

    extendsFrom: 'RowactionsField',

    /**
     * Enable or disable caret depending on if there are any enabled actions in the dropdown list
     *
     * @inheritdoc
     * @private
     */
    _updateCaret: function() {
        // Left empty on purpose, the menu should always show
    }
}) },
"rowaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Rowaction FieldTemplate (base) 

    extendsFrom: "RowactionField",
    
    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.clone(this.plugins) || [];
        this.plugins.push('DisableDelete');
        this._super("initialize", [options]);
    }
}) },
"editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Editablelistbutton FieldTemplate (base) 

    extendsFrom: 'EditablelistbuttonField',
    /**
     * extend save options
     * @param {Object} options save options.
     * @return {Object} modified success param.
     */
    getCustomSaveOptions: function(options) {
        // make copy of original function we are extending
        var origSuccess = options.success;
        // return extended success function with added alert
        return {
            success: _.bind(function() {
                if (_.isFunction(origSuccess)) {
                    origSuccess.apply(this, arguments);
                }

                if(this.context.parent) {
                    var oppsCfg = app.metadata.getModule('Opportunities', 'config'),
                        reloadLinks = ['opportunities'];
                    if (oppsCfg && oppsCfg.opps_view_by == 'RevenueLineItems') {
                        reloadLinks.push('revenuelineitems');
                    }

                    this.context.parent.set('skipFetch', false);

                    // reload opportunities subpanel
                    this.context.parent.trigger('subpanel:reload', {links: reloadLinks});
                }
            }, this)
        };
    }
}) }
}}
,
"views": {
"base": {
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * Holds a reference to the alert this view triggers
     */
    alert: undefined,

    /**
     * Holds a reference to the alert this view triggers
     */
    cancelClicked: function() {
        /**
         * todo: this is a sad way to work around some problems with sugarlogic and revertAttributes
         * but it makes things work now. Probability listens for Sales Stage to change and then by
         * SugarLogic, it updates probability when sales_stage changes. When the user clicks cancel,
         * it goes to revertAttributes() which sets the model back how it was, but when you try to
         * navigate away, it picks up those new changes as unsaved changes to your model, and tries to
         * falsely warn the user. This sets the model back to those changed attributes (causing them to
         * show up in this.model.changed) then calls the parent cancelClicked function which does the
         * exact same thing, but that time, since the model was already set, it doesn't see anything in
         * this.model.changed, so it doesn't warn the user.
         */
        var changedAttributes = this.model.changedAttributes(this.model.getSynced());
        this.model.set(changedAttributes, { revert: true });
        this._super('cancelClicked');
    },

    /**
     * @inheritdoc
     * @param {Object} options
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['LinkedModel', 'HistoricalSummary', 'CommittedDeleteWarning']);
        this.addInitListener();

        this._super('initialize', [options]);

        app.utils.hideForecastCommitStageField(this.meta.panels);
    },
    
    /**
     * Add the initListener if RLI's are being used and the current user has Edit access to RLI's
     */
    addInitListener: function() {
        // if we are viewing by RevenueLineItems and we have access to edit/create RLI's then we should
        // display the warning if no rli's exist
        if (app.metadata.getModule('Opportunities', 'config').opps_view_by == 'RevenueLineItems' &&
            app.acl.hasAccess('edit', 'RevenueLineItems')) {
            this.once('init', function() {
                var rlis = this.model.getRelatedCollection('revenuelineitems');
                rlis.once('reset', function(collection) {
                    // check if the RLI collection is empty
                    // and make sure there isn't another RLI warning on the page
                    if (collection.length === 0 && $('#createRLI').length === 0) {
                        this.showRLIWarningMessage(this.model.module);
                    }
                }, this);
                rlis.fetch({relate: true});
            }, this);
        }
    },

    /**
     * Loops through all fields on the model returning only the fields with calculated => true set
     * @returns {Array}
     */
    getCalculatedFields: function() {
        return _.filter(this.model.fields, function (field) {
            return field.calculated;
        });
    },

    /**
     * @inheritdoc
     */
    setupDuplicateFields: function(prefill) {
        if (app.metadata.getModule('Opportunities', 'config').opps_view_by === 'RevenueLineItems') {
            var calcFields = this.getCalculatedFields();
            if (calcFields) {
                _.each(calcFields, function(field) {
                    prefill.unset(field.name);
                }, this);
            }
        }
    },

    /**
     * Display the warning message about missing RLIs
     */
    showRLIWarningMessage: function() {
        // add a callback to close the alert if users navigate from the page
        app.routing.before('route', this.dismissAlert, this);

        var message = app.lang.get('TPL_RLI_CREATE', 'Opportunities') +
            '  <a href="javascript:void(0);" id="createRLI">' +
            app.lang.get('TPL_RLI_CREATE_LINK_TEXT', 'Opportunities') + '</a>';

        this.alert = app.alert.show('opp-rli-create', {
            level: 'warning',
            autoClose: false,
            title: app.lang.get('LBL_ALERT_TITLE_WARNING') + ':',
            messages: message,
            onLinkClick: _.bind(function() {
                this.openRLICreate();
            }, this),
            onClose: _.bind(function() {
                app.routing.offBefore('route', this.dismissAlert, this);
            }, this)
        });
    },

    /**
     * Handle dismissing the RLI create alert
     */
    dismissAlert: function() {
        // close RLI warning alert
        app.alert.dismiss('opp-rli-create');
        // remove before route event listener
        app.routing.offBefore('route', this.dismissAlert, this);
    },

    /**
     * Open a new Drawer with the RLI Create Form
     */
    openRLICreate: function() {
        // close RLI warning alert
        this.dismissAlert();

        var model = this.createLinkModel(this.createdModel || this.model, 'revenuelineitems');

        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: model.module,
                model: model
            }
        }, _.bind(this.rliCreateClose, this));
    },

    /**
     * Callback for when the create drawer closes
     * @param {String} model
     */
    rliCreateClose: function(model) {
        if (!model) {
            return;
        }

        var ctx = this.listContext || this.context;

        ctx.resetLoadFlag();
        ctx.set('skipFetch', false);
        ctx.loadData();

        // find the child collection for the RLI subpanel
        // if we find one and it has the loadData method, call that method to
        // force the subpanel to load the data.
        var rli_ctx = _.find(ctx.children, function(child) {
            return child.get('module') === 'RevenueLineItems';
        }, this);
        if (!_.isUndefined(rli_ctx) && _.isFunction(rli_ctx.loadData)) {
            rli_ctx.loadData();
        }
    }
}) },
"product-quick-picks-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.Opportunities.ProductQuickPicksDashletView
 * @alias SUGAR.App.view.views.BaseOpportunitiesProductQuickPicksDashletView
 * @extends View.Views.Base.Opportunities.ProductQuickPicksView
 */
({
	// Product-quick-picks-dashlet View (base) 

    extendsFrom: 'OpportunitiesProductQuickPicksView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['Tooltip']);
        this._super('initialize', [options]);
    },

    /**
     * Calls the render method in parent class
     * assign class name to the dashlet component
     * @inheritdoc
     */
    render: function() {
        if (!this.meta.config) {
            this._super('render');
            if (this.closestComponent('dashlet-cell').$el) {
                this.closestComponent('dashlet-cell').$el.parents().eq(1).addClass('product-catalog-quick-picks');
            }
        }
    },

    /**
     * @inheritdoc
     */
    toggleLoading: function(startLoading) {
        if (this.layout.disposed === true) {
            return;
        }
        var $el = this.layout.$('i[data-action=loading]');
        if (startLoading) {
            $el.removeClass('fa-cog');
            $el.addClass('fa-refresh fa-spin');
        } else {
            $el.removeClass('fa-refresh fa-spin');
            $el.addClass('fa-cog');
        }
    }
}) },
"config-header-buttons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.OpportunitiesConfigHeaderButtonsView
 * @alias SUGAR.App.view.views.BaseOpportunitiesConfigHeaderButtonsView
 * @extends View.Views.Base.ConfigHeaderButtonsView
 */
({
	// Config-header-buttons View (base) 

    extendsFrom: 'ConfigHeaderButtonsView',

    /**
     * The current opps_view_by config setting when the view is initialized
     */
    currentOppsViewBySetting: undefined,

    /**
     * Stores if Forecasts is set up or not
     */
    isForecastsSetup: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.currentOppsViewBySetting = this.model.get('opps_view_by');

        // get the boolean form of if Forecasts is configured
        this.isForecastsSetup = !!app.metadata.getModule('Forecasts', 'config').is_setup;
    },

    /**
     * Before the save triggers, we need to show the alert so the users know it's doing something.
     * @private
     */
    _beforeSaveConfig: function() {
        app.alert.show('opp.config.save', {level: 'process', title: app.lang.getAppString('LBL_SAVING')});
    },

    /**
     * @inheritdoc
     * @param {function} onClose
     */
    showSavedConfirmation: function(onClose) {
        app.alert.dismiss('opp.config.save');
        this._super('showSavedConfirmation', [onClose]);
    },

    /**
     * Displays the Forecast warning confirm alert
     */
    displayWarningAlert: function() {
        var opportunity = this.model.get('opps_view_by') === 'Opportunities';
        var message = opportunity ? app.lang.get('LBL_OPPS_CONFIG_ALERT_TO_OPPS', 'Opportunities') :
            app.lang.get('LBL_OPPS_CONFIG_ALERT', 'Opportunities');

        app.alert.show('forecast-warning', {
            level: 'confirmation',
            title: app.lang.get('LBL_WARNING'),
            messages: message,
            onConfirm: _.bind(function() {
                this._super('saveConfig');
            }, this),
            onCancel: _.bind(function() {
                this.model.set('opps_view_by', this.currentOppsViewBySetting);
            }, this)
        });
    },

    /**
     * Overriding the default saveConfig to display the warning alert first, then on confirm of the
     * warning alert, save the config settings. Reloads metadata.
     *
     * @inheritdoc
     */
    saveConfig: function() {
        if (this.isForecastsSetup && this.currentOppsViewBySetting !== this.model.get('opps_view_by')) {
            this.displayWarningAlert();
        } else {
            this._super('saveConfig');
        }
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Opportunities.CreateView
 * @alias SUGAR.App.view.views.OpportunitiesCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    /**
     * Used by the alert openRLICreate method
     */
    createdModel: undefined,

    /**
     * Used by the openRLICreate method
     */
    listContext: undefined,

    /**
     * The original success message to call from the new one we set in the getCustomSaveOptions method
     */
    originalSuccess: undefined,

    /**
     * Holds a reference to the alert this view triggers
     */
    alert: undefined,

    /**
     * What are we viewing by
     */
    viewBy: 'Opportunities',

    /**
     * Does the current user has access to RLI's?
     */
    hasRliAccess: true,


    /**
     * If subpanel models are valid
     */
    validSubpanelModels: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins, ['LinkedModel']);
        this.viewBy = app.metadata.getModule('Opportunities', 'config').opps_view_by;
        this.hasRliAccess = app.acl.hasAccess('edit', 'RevenueLineItems');
        this._super('initialize', [options]);
        app.utils.hideForecastCommitStageField(this.meta.panels);
    },

    /**
     * @inheritdoc
     */
    initiateSave: function(callback) {
        this.disableButtons();
        async.waterfall([
            _.bind(function(cb) {
                async.parallel([
                    _.bind(this.validateSubpanelModelsWaterfall, this),
                    _.bind(this.validateModelWaterfall, this)
                ], function(err) {
                    // err is undefined if no errors
                    cb(!_.isUndefined(err));
                });
            }, this),
            _.bind(this.dupeCheckWaterfall, this),
            _.bind(this.createRecordWaterfall, this)
        ], _.bind(function(error) {
            this.enableButtons();
            if (error && error.status == 412 && !error.request.metadataRetry) {
                this.handleMetadataSyncError(error);
            } else if (!error && !this.disposed) {
                this.context.lastSaveAction = null;
                callback();
            }
        }, this));
    },

    /**
     * Check to see if all fields are valid
     *
     * @inheritdoc
     */
    validateModelWaterfall: function(callback) {
        // override this.model.doValidate() to display error if subpanel model validation failed
        this.model.trigger('validation:start');
        this.model.isValidAsync(this.getFields(this.module), _.bind(function(isValid, errors) {
            if (this.validSubpanelModels && isValid) {
                this.model.trigger('validation:success');
            } else if (!this.validSubpanelModels) {
                this.model.trigger('error:validation');
            }
            this.model.trigger('validation:complete', this.model._processValidationErrors(errors));
            callback(!isValid);
        }, this));
    },

    /**
     * Check to see if there are subpanel create models on this view
     * And trigger an event to tell the subpanel to validate itself
     *
     * @inheritdoc
     */
    validateSubpanelModelsWaterfall: function(callback) {
        this.hasSubpanelModels = false;
        this.validSubpanelModels = true;
        _.each(this.context.children, function(child) {
            if (child.get('isCreateSubpanel')) {
                this.hasSubpanelModels = true;
                this.context.trigger('subpanel:validateCollection:' + child.get('link'),
                    _.bind(function(notValid) {
                        if (this.validSubpanelModels && notValid) {
                            this.validSubpanelModels = false;
                        }
                        callback(notValid);
                    }, this),
                    true
                );
            }
        }, this);

        // If there are no subpanel models, callback false so the waterfall can continue
        if (!this.hasSubpanelModels) {
            return callback(false);
        }
    },


    /**
     * Custom logic to make sure that none of the rli records have changed
     *
     * @inheritdoc
     */
    hasUnsavedChanges: function() {
        var ret = this._super('hasUnsavedChanges');
        if (this.viewBy === 'RevenueLineItems' && this.hasRliAccess && ret === false) {
            // now lets check for RLI's
            var rli_context = this.context.getChildContext({link: 'revenuelineitems'});
            rli_context.prepare();

            // if there is more than one record in the related context collection, then return true
            if (rli_context.get('collection').length > 1) {
                ret = true;
            } else if (rli_context.get('collection').length === 0) {
                // if there is no RLI in the related context collection, then return false
                ret = false;
            } else {
                // if there is only one model, we need to verify that the model is not dirty.
                // check the non default attributes to make sure they are not empty.
                var model = rli_context.get('collection').at(0),
                    attr_keys = _.difference(_.keys(model.attributes), ['id']),
                    // if the value is not empty and it doesn't equal the default value
                    // we have a dirty model
                    unsavedRliChanges = _.find(attr_keys, function(attr) {
                        var val = model.get(attr);
                        return (!_.isEmpty(val) && (model._defaults[attr] !== val));
                    });

                ret = (!_.isUndefined(unsavedRliChanges));
            }
        }

        return ret;
    },

    /**
     * @inheritdoc
     */
    getCustomSaveOptions: function(options) {
        if (this.viewBy === 'RevenueLineItems') {
            this.createdModel = this.model;
            // since we are in a drawer
            this.listContext = this.context.parent || this.context;
            this.originalSuccess = options.success;

            if (app.metadata.getModule(this.module).isTBAEnabled === true) {
                // make sure new RLIs inherit opportunity's teamset and selected teams
                var addedRLIs = this.createdModel.get('revenuelineitems') || false;
                if (addedRLIs && addedRLIs.create && addedRLIs.create.length) {
                    _.each(addedRLIs.create, function (data) {
                        data.team_name = this.createdModel.get('team_name');
                    }, this);
                }
            }

            var success = _.bind(function(model) {
                this.originalSuccess(model);
                this._checkForRevenueLineItems(model, options);
            }, this);

            return {
                success: success
            };
        }
    },

    /**
     * Check for Revenue Line Items, if the user has edit access and non exist, then
     * display the RLI Warning Message.
     *
     * @param {{Data.Bean}} model
     * @param {{object}} options
     * @private
     */
    _checkForRevenueLineItems: function(model, options) {
        // lets make sure we have edit/create access to RLI's
        // if we do, lets make sure that the values where added
        if (this.hasRliAccess) {
            // check to see if we added RLIs during create
            var addedRLIs = model.get('revenuelineitems') || false;
            addedRLIs = (addedRLIs && addedRLIs.create && addedRLIs.create.length);
            if (!addedRLIs) {
                this.showRLIWarningMessage(this.listContext.get('module'));
            }
        }
    },

    /**
     * Display the warning message about missing RLIs
     */
    showRLIWarningMessage: function() {
        // add a callback to close the alert if users navigate from the page
        app.routing.before('route', this.dismissAlert, this);

        var message = app.lang.get('TPL_RLI_CREATE', 'Opportunities') +
            '  <a href="javascript:void(0);" id="createRLI">' +
            app.lang.get('TPL_RLI_CREATE_LINK_TEXT', 'Opportunities') + '</a>';

        this.alert = app.alert.show('opp-rli-create', {
            level: 'warning',
            autoClose: false,
            title: app.lang.get('LBL_ALERT_TITLE_WARNING') + ':',
            messages: message,
            onLinkClick: _.bind(function() {
                app.alert.dismiss('create-success');
                this.openRLICreate();
            }, this),
            onClose: _.bind(function() {
                app.routing.offBefore('route', this.dismissAlert, this);
            }, this)
        });
    },

    /**
     * Handle dismissing the RLI create alert
     */
    dismissAlert: function(data) {
        // if we are not navigating to the Opps list view, dismiss the alert
        if (data && !(data.args && data.args[0] === 'Opportunities' && data.route === 'list')) {
            app.alert.dismiss('opp-rli-create');
            // close RLI warning alert
            // remove before route event listener
            app.routing.offBefore('route', this.dismissAlert, this);
        }
    },

    /**
     * Open a new Drawer with the RLI Create Form
     */
    openRLICreate: function() {
        // close RLI warning alert
        this.dismissAlert(true);

        var model = this.createLinkModel(this.createdModel || this.model, 'revenuelineitems');

        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: model.module,
                model: model
            }
        }, _.bind(function(model) {
            if (!model) {
                return;
            }

            var ctx = this.listContext || this.context;

            ctx.reloadData({recursive: false});

            // reload opportunities and RLIs subpanels
            ctx.trigger('subpanel:reload', {links: ['opportunities', 'revenuelineitems']});
        }, this));
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.alert) {
            this.alert.getCloseSelector().off('click');
        }

        this._super('_dispose', []);
    }
}) },
"filter-rows": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Filter-rows View (base) 

    extendsFrom: 'FilterRowsView',

    /**
     * @inheritdoc
     */
    loadFilterFields: function(moduleName) {
        this._super('loadFilterFields', [moduleName]);

        var cfg = app.metadata.getModule("Forecasts", "config");
        if (cfg && cfg.is_setup === 1) {
            _.each(this.filterFields, function(field, key, list) {
                if (key.indexOf('_case') != -1) {
                    var fieldName = 'show_worksheet_' + key.replace('_case', '');
                    if (cfg[fieldName] !== 1) {
                        delete list[key];
                        delete this.fieldList[key];
                    }
                }
            }, this);
        } else {
            delete this.fieldList['commit_stage'];
            delete this.filterFields['commit_stage'];
        }
    }
}) },
"massupdate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Massupdate View (base) 

    extendsFrom: "MassupdateView",
    
    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['DisableMassDelete', 'CommittedDeleteWarning']);
        this._super("initialize", [options]);
    },

    /**
     *
     * @inheritdoc
     */
    setMetadata: function(options) {
        var config = app.metadata.getModule('Forecasts', 'config');

        this._super("setMetadata", [options]);

        if (!config || (config && !config.is_setup)) {
            _.each(options.meta.panels, function(panel) {
                _.every(panel.fields, function (item, index) {
                    if (_.isEqual(item.name, "commit_stage")) {
                        panel.fields.splice(index, 1);
                        return false;
                    }
                    return true;
                }, this);
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    save: function(forCalcFields) {
        var forecastCfg = app.metadata.getModule("Forecasts", "config");
        if (forecastCfg && forecastCfg.is_setup) {
            // Forecasts is enabled and setup
            var hasCommitStage = _.some(this.fieldValues, function(field) {
                    return field.name === 'commit_stage';
                }),
                hasClosedModels = false;

            if(!hasCommitStage && this.defaultOption.name === 'commit_stage') {
                hasCommitStage = true;
            }

            if(hasCommitStage) {
                hasClosedModels = this.checkMassUpdateClosedModels();
            }

            if(!hasClosedModels) {
                // if this has closed models, first time through will uncheck but not save
                // if this doesn't it will save like normal
                this._super('save', [forCalcFields]);
            }
        } else {
            // Forecasts is not enabled and the commit_stage field isn't in the mass update list
            this._super('save', [forCalcFields]);
        }
    }
}) },
"config-opps-view-by": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OpportunitiesConfigOppsViewByView
 * @alias SUGAR.App.view.views.BaseOpportunitiesConfigOppsViewByView
 * @extends View.Views.Base.ConfigPanelView
 */
({
	// Config-opps-view-by View (base) 

    extendsFrom: 'ConfigPanelView',

    /**
     * The current opps_view_by config setting when the view is initialized
     */
    currentOppsViewBySetting: undefined,

    /**
     * Are we currently waiting for the field items?
     */
    waitingForFieldItems: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // get the initial opps_view_by setting
        this.currentOppsViewBySetting = this.model.get('opps_view_by');
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:opps_view_by', function() {
            this.showRollupOptions();
        }, this);
    },

    /**
     * Displays the Latest/Earliest Date toggle
     */
    showRollupOptions: function() {
        if (this.currentOppsViewBySetting === 'RevenueLineItems' &&
            this.model.get('opps_view_by') === 'Opportunities') {
            this.getField('opps_closedate_rollup').show();
            this.$('[for=opps_closedate_rollup]').show();
            this.$('#sales-stage-text').show();

            // if there's no value here yet, set to latest
            if (!this.model.has('opps_closedate_rollup')) {
                this.$('input[value="latest"]').prop('checked', true);
            }
        } else {
            this.getField('opps_closedate_rollup').hide();
            this.$('[for=opps_closedate_rollup]').hide();
            this.$('#sales-stage-text').hide();
        }

        // update the title based on settings
        this.updateTitle();
    },

    /**
     * @inheritdoc
     */
    _render: function(options) {
        this._super('_render', [options]);

        this.showRollupOptions();
    },

    /**
     * @inheritdoc
     */
    _updateTitleValues: function() {
        var items = this._getFieldOptions();
        if (items) {
            // defensive coding in case user removed this options dom
            var title = '';
            if (items && _.isObject(items)) {
                title = items[this.model.get('opps_view_by')];
            }

            this.titleSelectedValues = title;
        }
    },

    /**
     * Get the options from the field, vs form the dom, since it's
     * customized to show the correct module names by the end point
     *
     * @return {boolean|Object}
     * @private
     */
    _getFieldOptions: function() {
        var f = this.getField('opps_view_by');

        if (_.isUndefined(f.items)) {
            if (this.waitingForFieldItems === false) {
                this.waitingForFieldItems = true;
                f.once('render', function() {
                    this.waitingForFieldItems = false;
                    this.updateTitle();
                }, this);
            }

            return false;
        } else {
            return f.items;
        }
    }
}) },
"panel-top": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
* @class View.Fields.Base.Opportunities.PanelTopField
* @alias App.view.fields.BaseOpportunitiesPanelTopField
* @extends View.Fields.Base.PanelTopField
*/
({
	// Panel-top View (base) 

    extendsFrom: "PanelTopView",

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.on('linked-model:create', this._reloadRevenueLineItems, this);
    },

    /**
     * Refreshes the RevenueLineItems subpanel when a new Opportunity is added
     * @private
     */
    _reloadRevenueLineItems: function() {
        if (app.metadata.getModule('Opportunities', 'config').opps_view_by == 'RevenueLineItems') {
            var $rliSubpanel = $('div[data-subpanel-link="revenuelineitems"]');
            // only reload RLI subpanel if it is opened
            if (!$('li.subpanel', $rliSubpanel).hasClass('closed')) {
                this.context.parent.trigger('subpanel:reload', {links: ['revenuelineitems']});
            } else {
                // RLI Panel is closed, filter components to find the RLI panel and update count
                var rliComponent = _.find(this.layout.layout._components, function(component) {
                    return component.module === 'RevenueLineItems';
                });

                var cc_field = rliComponent.getComponent('panel-top').getField('collection-count');

                app.api.count('Accounts', {
                    id: this.context.parent.get('modelId'),
                    link:'revenuelineitems'
                }, {
                    success: function(data) {
                        cc_field.updateCount({ length: data.record_count });
                    }
                });
            }
        }
    }
}) },
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.OpportunitiesRecordlistView
 * @alias SUGAR.App.view.views.BaseOpportunitiesRecordlistView
 * @extends View.Views.Base.RecordlistView
 */
({
	// Recordlist View (base) 

    extendsFrom: 'RecordlistView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['CommittedDeleteWarning']);
        this._super("initialize", [options]);
    },

    /**
     * @inheritdoc
     */
    parseFieldMetadata: function(options) {
        options = this._super('parseFieldMetadata', [options]);

        app.utils.hideForecastCommitStageField(options.meta.panels);

        return options;
    }
}) },
"product-quick-picks": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.Opportunities.RecentUsedProductView
 * @alias SUGAR.App.view.views.BaseOpportunitiesRecentUsedProductView
 * @extends View.Views.Base.TabbedDashletView
 */
({
	// Product-quick-picks View (base) 

    extendsFrom: 'BaseTabbedDashletView',

    className: 'product-catalog-quick-picks',

    events: {
        'click [data-action=page-clicked]': 'getPageNumClicked',
        'click [data-action=tab-switcher]': 'tabSwitcher',
        'click [data-action=page-nav-clicked]': 'onPageNavClicked',
        'click .recent-link': 'onNameClicked',
        'click .recent-records i': 'onIconClicked'
    },

    //declaring global variables
    activeTab: undefined,
    dataFetched: undefined,
    pageNumList: undefined,
    pageNumClicked: undefined,
    paginationLength: undefined,
    isPrevDisabled: undefined,
    isNextDisabled: undefined,
    isPageNumDisabled: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.without(this.plugins, 'Pagination');
        this.plugins = _.union(this.plugins, 'Tooltip');
        this._super('initialize', [options]);

        this.pageNumClicked = 1;
        this.paginationLength = 0;

        this.activeTab = '';

        this.pageNumList = [];

        this.dataFetched = false;
        this.isPrevDisabled = false;
        this.isNextDisabled = false;
        this.isPageNumDisabled = false;

        this.recentCollection = new Backbone.Collection();
    },

    /**
     * Initialize tabs.
     * @chainable
     * @protected
     */
    _initTabs: function() {
        this._super('_initTabs');
        //Remove Recent used tabs for Opportunity Only mode
        if (app.controller.context.get('module') !== 'Quotes' || this.layout.module === 'Opportunities') {
            if (app.metadata.getModule('Opportunities', 'config').opps_view_by === 'Opportunities') {
                this.tabs = _.without(this.tabs, _.findWhere(this.tabs, {
                    label: 'LBL_DASHLET_PRODUCT_QUICK_PICKS_RECENT_TAB'
                }));
            }
        }
        return this;
    },

    /**
     * Get url for recent/favorites api
     */
    getUrl: function(payloadData) {
        var tab = this.tabs[this.settings.get('activeTab')];
        if (tab.label === 'LBL_DASHLET_PRODUCT_QUICK_PICKS_RECENT_TAB') {
            this.activeTab = 'recent-product';
        } else {
            this.activeTab = 'favorites';
        }

        if (this.layout.module === 'Home') {
            return app.api.buildURL(app.controller.context.get('module'), this.activeTab, null,
                this.activeTab === 'favorites' ? payloadData : null
            );
        } else {
            return app.api.buildURL(this.layout.module, this.activeTab, null,
                this.activeTab === 'favorites' ? payloadData : null
            );
        }
    },

    /**
     * Gets the current pagination number <li> object
     * to be used while showing just three pages with current
     * page at center, in case total pages are more than 4
     */
    getCurrentObj: function() {
        return _.find(this.pageNumList, function(tmpObj) {
            return tmpObj.pageNum === this.pageNumClicked;
        }, this);
    },

    /**
     * {@inheritDoc}
     * @param options gets page number for Pagination in Favorites tab
     */
    loadData: function(options) {
        if (!this.tabs) {
            return;
        }
        var data = {
            results: [],
            // only show one page of results
            // if more results are needed, then the address book should be used
            more: false
        };
        var callbacks = {};
        var url;
        var payloadData = {};

        if (options && options.pageNum !== undefined) {
            this.pageNumClicked = options.pageNum;
        }

        if (this.activeTab === 'favorites') {
            payloadData.pageNum = this.pageNumClicked - 1;
        }
        url = this.getUrl(payloadData);
        this.toggleLoading(true);
        callbacks.success = _.bind(this.onProductFetchSuccess, this);
        callbacks.error = _.bind(function() {
            // don't add any recipients via the select2 callback
            this.dataFetched = true;
            this.toggleLoading(false);
            data.results = [];
        }, this);
        app.api.call('read', url, null, callbacks);
    },

    /**
     * This gets called on callback success of LoadData and fetches records
     * for dashlet rows
     * @param options gets page number for Pagination in Favorites tab
     * @param result response data from the api call
     */
    onProductFetchSuccess: function(result) {
        var favRecords = [];
        var tmpLeftEllipsesObject = {};
        var tmpRightEllipsesObject = {};

        var currentIndex = 0;
        var startIndex = 0;

        //reset global variables
        this.pageNumList = [];
        this.recentCollection.reset();

        this.dataFetched = true;
        this.isNextDisabled = false;
        this.isPrevDisabled = false;
        this.isPageNumDisabled = false;

        this.paginationLength = 0;

        //if some data is returned
        if (result.records.length > 0) {
            //if 'Recent used' is the active tab
            if (this.activeTab === 'recent-product') {
                this.recentCollection.reset(result.records);
            } else { //else 'Favorites' tab is active
                this.paginationLength = result.totalPages;

                this.pageNumClicked = this.pageNumClicked > this.paginationLength ?
                    this.pageNumClicked - 1 : this.pageNumClicked;

                if (this.pageNumClicked === this.paginationLength || this.paginationLength === 1) {
                    this.isNextDisabled = true;
                }
                if (this.pageNumClicked === 1 || this.paginationLength === 1) {
                    this.isPrevDisabled = true;
                }

                this.isPageNumDisabled = this.pageNumClicked === 1 && this.paginationLength === 1 ? true : false;

                tmpLeftEllipsesObject = {
                    isIcon: true,
                    listClass: 'favorite-pagination',
                    subListClass: 'left-ellipsis-icon fa fa-ellipsis-h'
                };

                tmpRightEllipsesObject = {
                    isIcon: true,
                    listClass: 'favorite-pagination',
                    subListClass: 'right-ellipsis-icon fa fa-ellipsis-h'
                };

                //Push details for each list item in the pagination
                for (var page = 0; page < result.totalPages; page++) {
                    this.pageNumList.push({
                        isIcon: false,
                        listClass: 'favorite-pagination',
                        subListClass: 'paginate-num-button btn btn-link btn-invisible',
                        pageNum: page + 1,
                        isActive: this.pageNumClicked === page + 1 && !this.isPageNumDisabled ? true : false
                    });
                }

                //If more than 4 pages then display just 3 pages with ellipsis
                if (result.totalPages > 4) {
                    currentIndex = this.pageNumList.indexOf(this.getCurrentObj());

                    if (currentIndex > 0) {
                        startIndex = currentIndex < this.pageNumList.length - 1 ?
                            currentIndex - 1 : this.pageNumList.length - 3;
                    } else {
                        startIndex = 0;
                    }

                    //Get just three objects with active item in the center
                    this.pageNumList = this.pageNumList.slice(startIndex, startIndex + 3);
                    if (startIndex !== 0) {
                        this.pageNumList.unshift(tmpLeftEllipsesObject);
                    }
                    if (result.totalPages - currentIndex >= 3) {
                        this.pageNumList.push(tmpRightEllipsesObject);
                    }
                }
            }

            //favRecords represents a page displayed on the Favorite tab
            for (var count = 0; count < result.records.length; count++) {
                favRecords[count] = result.records[count];
            }

            this.recentCollection.reset(favRecords);
        }
        _.each(this.recentCollection.models, function(model) {
            var name = model.get('name');
            var shortName = name.length > 25 ? name.substr(0, 25) + '...' : name;
            model.set({
                longName: name,
                shortName: shortName
            });
        }, this);
        this.toggleLoading(false);
        this.render();
    },

    /**
     * Get the page Number clicked in Favorites Tab
     * @param evt
     */
    getPageNumClicked: function(evt) {
        evt.preventDefault();
        var pageId = this.$(evt.target).data('page-id');
        if (this.pageNumClicked === pageId) {
            return;
        }
        this.loadData({
            pageNum: pageId
        });
        this.toggleLoading(false);
        this.render();
    },

    /**
     * Event handler for navigantion button click events in the pagination footer
     * @param evt
     */
    onPageNavClicked: function(evt) {
        evt.preventDefault();
        var $el = this.$(evt.target);
        var currentPageNum = $el.data('page-id');
        if ($el.hasClass('previous-fav') || $el.hasClass('nav-previous')) {
            this.loadData({
                pageNum: currentPageNum - 1
            });
        } else if ($el.hasClass('next-fav') || $el.hasClass('nav-next')) {
            this.loadData({
                pageNum: currentPageNum + 1
            });
        }
        this.toggleLoading(false);
        this.render();
    },

    /**
     * Event handler to handle click on record names
     * @param evt
     */
    onNameClicked: function(evt) {
        evt.preventDefault();
        var recordId = this.$(evt.target).parent().data('record-id');
        var data = this.recentCollection.get(recordId);
        if (data) {
            data = data.toJSON();
            // copy Template's id and name to where the QLI expects them
            data.product_template_id = data.id;
            data.product_template_name = data.name;
            data.created_by = data.created_by && data.created_by.trim();
            data.modified_user_id = data.modified_user_id && data.modified_user_id.trim();
            data.currency_id = data.currency_id && data.currency_id.trim();
            // remove ID/etc since we dont want Template ID to be the record id
            delete data.id;
            delete data.date_entered;
            delete data.date_modified;
            delete data.pricing_formula;
            delete data.my_favorite;

            var viewDetails = this.closestComponent('record') ?
                this.closestComponent('record') :
                this.closestComponent('create');

            if (!_.isUndefined(viewDetails)) {
                app.controller.context.trigger(viewDetails.cid + ':productCatalogDashlet:add', data);
            }
        }
    },

    /**
     * @inheritdoc
     */
    tabSwitcher: function(event) {
        this.dataFetched = false;
        this._super('tabSwitcher', [event]);
        //Resetting pageNumClicked on switching back to Favorites tab
        if (this.activeTab === 'favorites') {
            this.pageNumClicked = 1;
        }
        this.loadData();
    },

    /**
     * Toggles the spinning Loading icon on the header bar
     *
     * @param {boolean} startLoading If we should start the spinning icon or hide it
     */
    toggleLoading: function(startLoading) {
        if (startLoading) {
            this.$('.loading-icon').show();
        } else {
            this.$('.loading-icon').hide();
        }
    },

    /**
     * Fetches a Product Template record given the ID, and sends the response data to `callbacks.success`
     *
     * @param {string} id The ProductTemplate ID Hash to fetch
     * @private
     */
    _fetchProductTemplate: function(id) {
        var url = app.api.buildURL('ProductTemplates/' + id);
        app.api.call('read', url, null, null, {
            success: _.bind(this._openItemInDrawer, this)
        });
    },

    /**
     * Gets the record Id for the item corresponding to the clicked icon and passes it to
     * _fetchProductTemplate()
     *
     * @param evt
     */
    onIconClicked: function(evt) {
        var recordId = this.$(evt.target).parent().data('record-id');
        this._fetchProductTemplate(recordId);
    },

    /**
     * Sends the ProductTemplate data item to a Drawer layout
     *
     * @param {Object} data The ProductTemplate data
     * @private
     */
    _openItemInDrawer: function(response) {
        var data = app.data.createBean('ProductTemplates', response);
        var viewDetails = this.closestComponent('record') ?
            this.closestComponent('record').cid :
            this.closestComponent('create').cid;

        data.viewId = viewDetails;
        app.drawer.open({
            layout: 'product-catalog-dashlet-drawer-record',
            context: {
                module: 'ProductTemplates',
                model: data
            }
        });
    }
}) },
"merge-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Merge-duplicates View (base) 

    extendsFrom: 'MergeDuplicatesView',

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        var config = app.metadata.getModule('Forecasts', 'config');

        if (config && config.is_setup && config.forecast_by === 'Opportunities' &&
            app.metadata.getServerInfo().flavor !== 'PRO') {
            // make sure forecasts exists and is setup
            this.collection.on('change:sales_stage change:commit_stage reset', function(model) {
                var myModel = model;

                //check to see if this is a collection (for the reset event), use this.primaryRecord instead if true;
                if (!_.isUndefined(model.models)) {
                    myModel = this.primaryRecord;
                }
                var salesStage = myModel.get('sales_stage'),
                    commitStage = this.getField('commit_stage');

                if (salesStage && commitStage) {
                    if(_.contains(config.sales_stage_won, salesStage)) {
                        // check if the sales_stage has changed to a Closed Won stage
                        if(config.commit_stages_included.length) {
                            // set the commit_stage to the first included stage
                            myModel.set('commit_stage', _.first(config.commit_stages_included));
                        } else {
                            // otherwise set the commit stage to just "include"
                            myModel.set('commit_stage', 'include');
                        }
                        commitStage.setDisabled(true);
                        this.$('input[data-record-id="' + myModel.get('id') + '"][name="copy_commit_stage"]').prop("checked", true);
                    } else if(_.contains(config.sales_stage_lost, salesStage)) {
                        // check if the sales_stage has changed to a Closed Lost stage
                        // set the commit_stage to exclude
                        myModel.set('commit_stage', 'exclude');
                        commitStage.setDisabled(true);
                        this.$('input[data-record-id="' + myModel.get('id') + '"][name="copy_commit_stage"]').prop("checked", true);
                    } else {
                        commitStage.setDisabled(false);
                    }
                }
            }, this);
        }
    }
}) }
}}
,
"layouts": {
"base": {
"config-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.OpportunitiesConfigDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseOpportunitiesConfigDrawerLayout
 * @extends View.Layouts.Base.ConfigDrawerLayout
 */
({
	// Config-drawer Layout (base) 

    extendsFrom: 'ConfigDrawerLayout',

    /**
     * Checks Opportunities ACLs to see if the User is a system admin
     * or if the user has a developer role for the Opportunities module
     *
     * @inheritdoc
     */
    _checkModuleAccess: function() {
        var acls = app.user.getAcls().Opportunities,
            isSysAdmin = (app.user.get('type') == 'admin'),
            isDev = (!_.has(acls, 'developer'));

        return (isSysAdmin || isDev);
    }
}) },
"config-drawer-content": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.OpportunitiesConfigDrawerContentLayout
 * @alias SUGAR.App.view.layouts.BaseOpportunitiesConfigDrawerContentLayout
 * @extends View.Layouts.Base.ConfigDrawerContentLayout
 */
({
	// Config-drawer-content Layout (base) 

    extendsFrom: 'ConfigDrawerContentLayout',

    viewOppsByTitle: undefined,
    viewOppsByOppsTpl: undefined,
    viewOppsByRLIsTpl: undefined,

    /**
     * @inheritdoc
     */
    _initHowTo: function() {
        this.viewOppsByTitle = app.lang.get('LBL_OPPS_CONFIG_VIEW_BY_LABEL', 'Opportunities');

        var helpUrl = {
                more_info_url: '<a href="' + app.help.getMoreInfoHelpURL('config', 'OpportunitiesConfig')
                    + '" target="_blank">',
                more_info_url_close: '</a>'
            },
            viewOppsByOppsObj = app.help.get('Opportunities', 'config_opps', helpUrl),
            viewOppsByRLIsObj = app.help.get('Opportunities', 'config_rlis', helpUrl);

        this.viewOppsByOppsTpl = app.template.getLayout(this.name + '.help', this.module)(viewOppsByOppsObj);
        this.viewOppsByRLIsTpl = app.template.getLayout(this.name + '.help', this.module)(viewOppsByRLIsObj);
    },

    bindDataChange: function() {
        this._super('bindDataChange');

        this.model.on('change:opps_view_by', function(model, oppsViewBy) {
            this.changeHowToData(this.viewOppsByTitle, this._getText(oppsViewBy));
        }, this);
    },
    /**
     * @inheritdoc
     */
    _switchHowToData: function(helpId) {
        switch(helpId) {
            case 'config-opps-view-by':
                this.currentHowToData.title = this.viewOppsByTitle;
                this.currentHowToData.text = this._getText(this.model.get('opps_view_by'));
        }

        this._super('_switchHowToData');
    },

    /**
     * Returns the proper template text depending on the opps_view_by setting being passed in
     *
     * @param {String} oppsViewBy The Opps View By setting 'Opportunities' | 'RevenueLineItems'
     * @returns {String} HTML Template text for the right help text
     * @private
     */
    _getText: function(oppsViewBy) {
        return (oppsViewBy === 'Opportunities') ? this.viewOppsByOppsTpl : this.viewOppsByRLIsTpl;
    }
}) }
}}
,
"datas": {}

},
		"Cases":{"fieldTemplates": {}
,
"views": {
"base": {
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['HistoricalSummary', 'KBContent']);
        this._super('initialize', [options]);
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Notes":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Calls":{"fieldTemplates": {}
,
"views": {
"base": {
"resolve-conflicts-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Calls.ResolveConflictsListView
 * @alias SUGAR.App.view.views.BaseCallsResolveConflictsListView
 * @extends View.Views.Base.ResolveConflictsListView
 */
({
	// Resolve-conflicts-list View (base) 

    extendsFrom: 'ResolveConflictsListView',

    /**
     * @inheritdoc
     *
     * The invitees field should not be displayed on list views. It is removed
     * before comparing models so that it doesn't get included.
     */
    _buildFieldDefinitions: function(modelToSave, modelInDb) {
        modelToSave.unset('invitees');
        this._super('_buildFieldDefinitions', [modelToSave, modelInDb]);
    }
}) },
"create-nodupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Calls.CreateNodupecheckView
 * @alias SUGAR.App.view.views.CallsCreateNodupecheckView
 * @extends View.Views.Base.CreateNodupecheckView
 */
({
	// Create-nodupecheck View (base) 

    extendsFrom: 'CreateNodupecheckView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['AddAsInvitee', 'ReminderTimeDefaults']);
        this._super('initialize', [options]);
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Calls.CreateView
 * @alias SUGAR.App.view.views.CallsCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['AddAsInvitee', 'ReminderTimeDefaults']);
        this._super('initialize', [options]);
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['EditAllRecurrences', 'AddAsInvitee']);
        this._super('initialize', [options]);
    }
}) }
}}
,
"layouts": {}
,
"datas": {
"base": {
"model": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class Model.Datas.Base.CallsModel
 * @alias SUGAR.App.model.datas.BaseCallsModel
 * @extends Model.Bean
 */
({
	// Model Data (base) 

    plugins: ['VirtualCollection']
}) }
}}

},
		"Emails":{"fieldTemplates": {
"base": {
"compose-actionbar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Actionbar for the email compose view
 *
 * @class View.Fields.Base.Emails.ComposeActionbarField
 * @alias SUGAR.App.view.fields.BaseEmailsComposeActionbarField
 * @extends View.Fields.Base.FieldsetField
 *
 * @deprecated Use {@link View.Fields.Base.Emails.Htmleditable_tinymceField}
 * instead to add buttons for email composition.
 */
({
	// Compose-actionbar FieldTemplate (base) 

    extendsFrom: 'FieldsetField',

    events: {
        'click a:not(.dropdown-toggle)': 'handleButtonClick'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Fields.Base.Emails.SenderField is deprecated. Use ' +
            'View.Fields.Base.Emails.Htmleditable_tinymceField instead.');

        this._super('initialize', [options]);
        this.type = 'fieldset';
    },

    /**
     * Fire an event when any of the buttons on the actionbar are clicked
     * Events could be set via the data-event attribute or an event is built using the button name
     *
     * @param evt
     */
    handleButtonClick: function(evt) {
        var triggerName, buttonName,
            $currentTarget = $(evt.currentTarget);
        if ($currentTarget.data('event')) {
            triggerName = $currentTarget.data('event');
        } else {
            buttonName = $currentTarget.attr('name') || 'button';
            triggerName = 'actionbar:' + buttonName + ':clicked';
        }
        this.view.context.trigger(triggerName);
    }
}) },
"from": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Emails.FromField
 * @alias SUGAR.App.view.fields.BaseEmailsFromField
 * @extends View.Fields.Base.BaseField
 */
({
	// From FieldTemplate (base) 

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    /**
     * The selector for accessing the Select2 field when in edit mode. The
     * Select2 field is where the sender is displayed.
     *
     * @property {string}
     */
    fieldTag: 'input.select2',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['EmailParticipants', 'ListEditable']);
        this._super('initialize', [options]);

        // Specify the error label for when the sender's email address is
        // invalid.
        app.error.errorName2Keys[this.type] = app.lang.get('ERR_INVALID_SENDER', this.module);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.model) {
            // Avoids a full re-rendering when editing. The current value of
            // the field is formatted and passed directly to Select2 when in
            // edit mode.
            this.listenTo(this.model, 'change:' + this.name, _.bind(function() {
                var $el = this.$(this.fieldTag);

                if (_.isEmpty($el.data('select2'))) {
                    this.render();
                } else {
                    $el.select2('data', this.getFormattedValue());
                }
            }, this));
        }
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
        var $el = this.$(this.fieldTag);

        $el.on('select2-selecting', _.bind(function(event) {
            if (this.disposed) {
                event.preventDefault();
            }
        }, this));

        $el.on('change', _.bind(function(event) {
            var collection;

            if (this.model && !this.disposed) {
                collection = this.model.get(this.name);

                if (!_.isEmpty(event.added)) {
                    // Replace the current model in the collection, as there
                    // can only be one.
                    collection.remove(collection.models);
                    collection.add(event.added);
                }

                if (!_.isEmpty(event.removed)) {
                    collection.remove(event.removed);
                }
            }
        }, this));
    },

    /**
     * @inheritdoc
     *
     * Destroys the Select2 element.
     */
    unbindDom: function() {
        this.$(this.fieldTag).select2('destroy');
        this._super('unbindDom');
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var $el;
        var options;

        this._super('_render');

        $el = this.$(this.fieldTag);

        if ($el.length > 0) {
            options = this.getSelect2Options();
            options = _.extend(options, {
                allowClear: !this.def.required,
                multiple: false,

                /**
                 * Constructs a representation for a selected sender to be
                 * displayed in the field.
                 *
                 * See [Select2 Documentation](http://ivaynberg.github.io/select2/#documentation).
                 *
                 * @param {Data.Bean} sender
                 * @return {string}
                 * @private
                 */
                formatSelection: _.bind(function(sender) {
                    var template = app.template.getField(this.type, 'select2-selection', this.module);

                    return sender ? template({value: sender.toHeaderString({quote_name: true})}) : '';
                }, this),

                /**
                 * Constructs a representation for the sender to be displayed
                 * in the dropdown options after a query.
                 *
                 * See [Select2 Documentation](http://ivaynberg.github.io/select2/#documentation).
                 *
                 * @param {Data.Bean} sender
                 * @return {string}
                 */
                formatResult: _.bind(function(sender) {
                    var template = app.template.getField(this.type, 'select2-result', this.module);

                    return template({
                        value: sender.toHeaderString({quote_name: true}),
                        module: sender.get('parent_type')
                    });
                }, this),

                /**
                 * Don't escape a choice's markup since we built the HTML.
                 *
                 * See [Select2 Documentation](https://select2.github.io/select2/#documentation).
                 *
                 * @param {string} markup
                 * @return {string}
                 */
                escapeMarkup: function(markup) {
                    return markup;
                }
            });
            $el.select2(options).select2('val', []);

            if (this.isDisabled()) {
                $el.select2('disable');
            }
        }
    },

    /**
     * @inheritdoc
     * @return {Data.Bean}
     */
    format: function(value) {
        // Reset the tooltip.
        this.tooltip = '';

        if (value instanceof app.BeanCollection) {
            value = value.first();

            if (value) {
                value = this.prepareModel(value);
            }

            if (value) {
                this.tooltip = value.toHeaderString();
            }
        }

        return value;
    }
}) },
"emailaction-paneltop": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Emails.EmailactionPaneltopField
 * @alias SUGAR.App.view.fields.BaseEmailsEmailactionPaneltopField
 * @extends View.Fields.Base.EmailactionField
 */
({
	// Emailaction-paneltop FieldTemplate (base) 

    extendsFrom: 'EmailactionField',

    /**
     * @inheritdoc
     * Set type to emailaction to get the template
     */
    initialize: function(options) {
        this._super("initialize", [options]);
        this.type = 'emailaction';
        this.on('emailclient:close', this.handleEmailClientClose, this);
    },

    /**
     * When email compose is done, refresh the data in the Emails subpanel
     */
    handleEmailClientClose: function() {
        var context = this.context.parent || this.context;
        var links = app.utils.getLinksBetweenModules(context.get('module'), this.module);

        _.each(links, function(link) {
            context.trigger('panel-top:refresh', link.name);
        });
    },

    /**
     * No additional options are needed from the element in order to launch the
     * email client.
     *
     * @param {jQuery} [$link] The element from which to get options.
     * @return {Object}
     * @private
     * @deprecated Use
     * View.Fields.Base.Emails.EmailactionPaneltopField#emailOptionTo and
     * View.Fields.Base.Emails.EmailactionPaneltopField#emailOptionRelated
     * instead.
     */
    _retrieveEmailOptionsFromLink: function($link) {
        app.logger.warn('View.Fields.Base.Emails.EmailactionPaneltopField#_retrieveEmailOptionsFromLink is ' +
            'deprecated. Use View.Fields.Base.Emails.EmailactionPaneltopField#emailOptionTo and ' +
            'View.Fields.Base.Emails.EmailactionPaneltopField#emailOptionRelated instead.');
        return {};
    },

    /**
     * Returns the recipients to use in the To field of the email. If
     * `this.def.set_recipient_to_parent` is true, then the model is added to
     * the email's To field.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when identifying the recipients.
     * @return {undefined|Array}
     */
    emailOptionTo: function(model) {
        if (this.def.set_recipient_to_parent) {
            return [{
                bean: model
            }];
        }
    },

    /**
     * Returns the bean to use as the email's related record. If
     * `this.def.set_related_to_parent` is true, then the model is used.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model This model's parent is used as the email's
     * related record.
     * @return {undefined|Data.Bean}
     */
    emailOptionRelated: function(model) {
        if (this.def.set_related_to_parent) {
            return model;
        }
    }
}) },
"forward-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Forward action.
 *
 * This allows a user to "forward" an existing email.
 *
 * @class View.Fields.Base.Emails.ForwardActionField
 * @alias SUGAR.App.view.fields.EmailsBaseForwardActionField
 * @extends View.Fields.Base.EmailactionField
 */
({
	// Forward-action FieldTemplate (base) 

    extendsFrom: 'EmailactionField',

    /**
     * Template for forward header.
     *
     * @protected
     */
    _tplHeaderHtml: null,

    /**
     * The name of the template for forward header.
     *
     * @protected
     */
    _tplHeaderHtmlName: 'forward-header-html',

    /**
     * The prefix to apply to the subject.
     *
     * @protected
     */
    _subjectPrefix: 'LBL_FW',

    /**
     * The element ID to use to identify the forward content.
     *
     * The ID is added to the div wrapper around the content for later
     * identifying the portion of the email body which is the forward content
     * (e.g., when inserting templates into an email, but maintaining the
     * forward content).
     *
     * @protected
     */
    _contentId: 'forwardcontent',

    /**
     * @inheritdoc
     *
     * The forward content is built ahead of the button click to support the
     * option of doing a mailto link which needs to be built and set in the DOM
     * at render time.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // Use field templates from emailaction.
        this.type = 'emailaction';

        this.addEmailOptions({
            // If there is a default signature in email compose, it should be
            // placed above the forward content in the email body.
            signature_location: 'above',
            // Focus the editor and place the cursor at the beginning of all
            // content.
            cursor_location: 'above',
            // Prevent prepopulating the email with case data.
            skip_prepopulate_with_case: true
        });
    },

    /**
     * Returns the subject to use in the email.
     *
     * Any instances of "Re: ", "FW: ", and "FWD: " (case-insensitive) found at
     * the beginning of the subject are removed prior to applying the prefix.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when constructing the subject.
     * @return {undefined|string}
     */
    emailOptionSubject: function(model) {
        var pattern = /^((?:re|fw|fwd): *)*/i;
        var subject = model.get('name') || '';

        return app.lang.get(this._subjectPrefix, model.module) + ': ' + subject.replace(pattern, '');
    },

    /**
     * Returns the plain-text body to use in the email.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when constructing the body.
     * @return {undefined|string}
     */
    emailOptionDescription: function(model) {
        var headerParams;
        var header;
        var body;
        var description;

        if (!this.useSugarEmailClient()) {
            headerParams = this._getHeaderParams(model);
            header = this._getHeader(headerParams);
            body = model.get('description') || '';
            description = '\n' + header + '\n' + body;
        }

        return description;
    },

    /**
     * Returns the HTML body to use in the email.
     *
     * Ensure the result is a defined string and strip any signature wrapper
     * tags to ensure it doesn't get stripped if we insert a signature above
     * the forward content. Also strip any reply content class if this is a
     * forward to a previous reply. And strip any forward content class if this
     * is a forward to a previous forward.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when constructing the body.
     * @return {undefined|string}
     */
    emailOptionDescriptionHtml: function(model) {
        var tplHeaderHtml = this._getHeaderHtmlTemplate();
        var headerParams = this._getHeaderParams(model);
        var headerHtml = tplHeaderHtml(headerParams);
        var body = model.get('description_html') || '';

        body = body.replace('<div class="signature">', '<div>');
        body = body.replace('<div id="replycontent">', '<div>');
        body = body.replace('<div id="forwardcontent">', '<div>');

        return '<div></div><div id="' + this._contentId + '">' + headerHtml + body + '</div>';
    },

    /**
     * Returns the attachments to use in the email.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when building the attachments.
     * @return {undefined|Array}
     */
    emailOptionAttachments: function(model) {
        return model.get('attachments_collection').map(function(attachment) {
            var filename = attachment.get('filename') || attachment.get('name');

            return {
                _link: 'attachments',
                upload_id: attachment.get('upload_id') || attachment.get('id'),
                name: filename,
                filename: filename,
                file_mime_type: attachment.get('file_mime_type'),
                file_size: attachment.get('file_size'),
                file_ext: attachment.get('file_ext')
            };
        });
    },

    /**
     * Returns the bean to use as the email's related record.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model This model's parent is used as the email's
     * related record.
     * @return {undefined|Data.Bean}
     */
    emailOptionRelated: function(model) {
        var parent;

        if (model.get('parent') && model.get('parent').type && model.get('parent').id) {
            // We omit type because it is actually the module name and should
            // not be treated as an attribute.
            parent = app.data.createBean(model.get('parent').type, _.omit(model.get('parent'), 'type'));
        } else if (model.get('parent_type') && model.get('parent_id')) {
            parent = app.data.createBean(model.get('parent_type'), {
                id: model.get('parent_id'),
                name: model.get('parent_name')
            });
        }

        return parent;
    },

    /**
     * Returns the teamset array to seed the email's teams.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model This model's teams is used as the email's
     * teams.
     * @return {undefined|Array}
     */
    emailOptionTeams: function(model) {
        return model.get('team_name');
    },

    /**
     * Build the header for text only emails.
     *
     * @param {Object} params
     * @param {string} params.from
     * @param {string} [params.date] Date original email was sent
     * @param {string} params.to
     * @param {string} [params.cc]
     * @param {string} params.name The subject of the original email.
     * @return {string}
     * @private
     */
    _getHeader: function(params) {
        var header = '-----\n' + app.lang.get('LBL_FROM', params.module) + ': ' + (params.from || '') + '\n';
        var date;

        if (params.date) {
            date = app.date(params.date).formatUser();
            header += app.lang.get('LBL_DATE', params.module) + ': ' + date + '\n';
        }

        header += app.lang.get('LBL_TO_ADDRS', params.module) + ': ' + (params.to || '') + '\n';

        if (params.cc) {
            header += app.lang.get('LBL_CC', params.module) + ': ' + params.cc + '\n';
        }

        header += app.lang.get('LBL_SUBJECT', params.module) + ': ' + (params.name || '') + '\n';

        return header;
    },

    /**
     * Returns the template for producing the header HTML for the top of the
     * forward content.
     *
     * @return {Function}
     * @private
     */
    _getHeaderHtmlTemplate: function() {
        // Use `this.def.type` because `this.type` was changed to `emailaction`
        // during initialization.
        this._tplHeaderHtml = this._tplHeaderHtml ||
            app.template.getField(this.def.type, this._tplHeaderHtmlName, this.module);
        return this._tplHeaderHtml;
    },

    /**
     * Get the data required by the header template.
     *
     * @param {Data.Bean} model The params come from this model's attributes.
     * EmailClientLaunch plugin should dictate the model based on the context.
     * @return {Object}
     * @protected
     */
    _getHeaderParams: function(model) {
        return {
            module: model.module,
            from: this._formatEmailList(model.get('from_collection')),
            date: model.get('date_sent'),
            to: this._formatEmailList(model.get('to_collection')),
            cc: this._formatEmailList(model.get('cc_collection')),
            name: model.get('name')
        };
    },

    /**
     * Given a list of people, format a text only list for use in a forward
     * header.
     *
     * @param {Data.BeanCollection} collection A list of models
     * @protected
     */
    _formatEmailList: function(collection) {
        return collection.map(function(model) {
            return model.toHeaderString();
        }).join(', ');
    }
}) },
"quickcreate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Emails.QuickcreateField
 * @alias SUGAR.App.view.fields.BaseEmailsQuickcreateField
 * @extends View.Fields.Base.QuickcreateField
 */
({
	// Quickcreate FieldTemplate (base) 

    extendsFrom: 'QuickcreateField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['EmailClientLaunch']);
        this._super('initialize', [options]);

        if (this.context && this.context.has('model')) {
            // call updateEmailLinks if the user changes something on the context model
            // so if user changes the email address we make sure we've got the latest
            // email address in the quick Compose Email link
            this.context.get('model').on('change', this.updateEmailLinks, this);
        }

        app.routing.before('route', this._beforeRouteChanged, this);
        app.router.on('route', this._routeChanged, this);
    },

    /**
     * Before we navigate to a different page, we need to remove the
     * change event listener we added on the context model
     *
     * @protected
     */
    _beforeRouteChanged: function() {
        if (this.context && this.context.has('model')) {
            // route is about to change, need to remove previous
            // listeners before model gets changed
            this.context.get('model').off('change', null, this);
        }
    },

    /**
     * After the route has changed, we need to re-add the model listener
     * on the new context model. This also calls updateEmailLinks to blank
     * out any existing email on the current quickcreate link; e.g. re-set the
     * quick Compose Email link back to "mailto:"
     *
     * @protected
     */
    _routeChanged: function() {
        if (this.context && this.context.has('model')) {
            // route has changed, most likely a new model, need to add new listeners
            this.context.get('model').on('change', this.updateEmailLinks, this);
        }
        this.updateEmailLinks();
    },

    /**
     * Used by EmailClientLaunch as a hook point to retrieve email options that are specific to a view/field
     * In this case we are using it to retrieve the parent model to make this email compose launching
     * context aware - prepopulating the to address with the given model and the parent relate field
     *
     * @return {Object}
     * @private
     */
    _retrieveEmailOptionsFromLink: function() {
        var context = this.context.parent || this.context,
            parentModel = context.get('model'),
            emailOptions = {};

        if (parentModel && parentModel.id) {
            // set parent model as option to be passed to compose for To address & relate
            // if parentModel does not have email, it will be ignored as a To recipient
            // if parentModel's module is not an available module to relate, it will also be ignored
            emailOptions = {
                to: [{bean: parentModel}],
                related: parentModel
            };
        }

        return emailOptions;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // remove context model change listeners if they exist
        this._beforeRouteChanged();
        app.routing.offBefore('route', this.beforeRouteChanged, this);
        app.router.off('route', this.routeChanged, this);

        this._super('_dispose');
    }
}) },
"attachment-button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Attachment button is a label that is styled like a button and will trigger a
 * given file input field.
 *
 * @class View.Fields.Base.Emails.AttachmentButtonField
 * @alias SUGAR.App.view.fields.BaseEmailsAttachmentButtonField
 * @extends View.Fields.Base.ButtonField
 * @deprecated Use {@link View.Fields.Base.Emails.EmailAttachmentsField}
 * instead.
 */
({
	// Attachment-button FieldTemplate (base) 

    extendsFrom: 'ButtonField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Fields.Base.Emails.AttachmentButtonField is deprecated. Use ' +
            'View.Fields.Base.Emails.EmailAttachmentsField instead.');

        this._super('initialize',[options]);
        this.fileInputId = this.context.get('attachment_field_email_attachment');
    }
}) },
"reply-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Reply action.
 *
 * This allows a user to "reply" to an existing email.
 *
 * @class View.Fields.Base.Emails.ReplyActionField
 * @alias SUGAR.App.view.fields.EmailsBaseReplyActionField
 * @extends View.Fields.Base.Emails.ForwardActionField
 */
({
	// Reply-action FieldTemplate (base) 

    extendsFrom: 'EmailsForwardActionField',

    /**
     * The name of the template for the reply header.
     *
     * @inheritdoc
     */
    _tplHeaderHtmlName: 'reply-header-html',

    /**
     * @inheritdoc
     */
    _subjectPrefix: 'LBL_RE',

    /**
     * The element ID to use to identify the reply content.
     *
     * @inheritdoc
     */
    _contentId: 'replycontent',

    /**
     * @inheritdoc
     *
     * Updates the reply_to_id email option anytime the model's id attribute
     * changes.
     */
    bindDataChange: function() {
        var context = this.context.parent || this.context;
        var model = context.get('model');

        this._super('bindDataChange');

        if (model) {
            // Set the reply_to_id email option if the ID already exists.
            this.addEmailOptions({reply_to_id: model.get('id')});

            // Update the reply_to_id email option anytime the ID changes. This
            // might occur if the ID was discovered later. It is an edge-case.
            this.listenTo(model, 'change:id', function() {
                this.addEmailOptions({reply_to_id: model.get('id')});
            });
        }
    },

    /**
     * Returns the recipients to use in the To field of the email. The sender
     * from the original email is included.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when identifying the recipients.
     * @return {undefined|Array}
     */
    emailOptionTo: function(model) {
        var originalTo;
        var originalSender = model.get('from_collection');
        var to = this._createRecipients(originalSender);

        if (this.def.reply_all) {
            app.logger.warn('The reply_all option is deprecated. Use View.Fields.Base.Emails.ReplyAllActionField ' +
                'instead.');
            originalTo = model.get('to_collection');
            to = _.union(to, this._createRecipients(originalTo));
        }

        return to;
    },

    /**
     * Returns the recipients to use in the CC field of the email. The
     * `reply_all` option is deprecated. Use
     * View.Fields.Base.Emails.ReplyAllActionField instead.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when identifying the recipients.
     * @return {undefined|Array}
     */
    emailOptionCc: function(model) {
        var originalCc;
        var cc;

        if (this.def.reply_all) {
            app.logger.warn('The reply_all option is deprecated. Use View.Fields.Base.Emails.ReplyAllActionField ' +
                'instead.');
            originalCc = model.get('cc_collection');
            cc = this._createRecipients(originalCc);
        }

        return cc;
    },

    /**
     * Attachments are not carried over to replies.
     *
     * @inheritdoc
     */
    emailOptionAttachments: function(model) {
    },

    /**
     * Sets up the email options for the EmailClientLaunch plugin to use -
     * passing to the email compose drawer or building up the mailto link.
     *
     * @protected
     * @deprecated The EmailClientLaunch plugin handles email options.
     */
    _updateEmailOptions: function() {
        app.logger.warn('View.Fields.Base.Emails.ReplyActionField#_updateEmailOptions is deprecated. ' +
            'The EmailClientLaunch plugin handles email options.');
    },

    /**
     * Build the reply recipients based on the original email's from, to, and cc
     *
     * @param {boolean} all Whether this is reply to all (true) or just a standard
     *   reply (false).
     * @return {Object} To and Cc values for the reply email.
     * @return {Array} return.to The to values for the reply email.
     * @return {Array} return.cc The cc values for the reply email.
     * @protected
     * @deprecated Use
     * View.Fields.Base.Emails.ReplyActionField#emailOptionTo and
     * View.Fields.Base.Emails.ReplyActionField#emailOptionCc instead.
     */
    _getReplyRecipients: function(all) {
        app.logger.warn('View.Fields.Base.Emails.ReplyActionField#_getReplyRecipients is deprecated. Use ' +
            'View.Fields.Base.Emails.ReplyActionField#emailOptionTo and ' +
            'View.Fields.Base.Emails.ReplyActionField#emailOptionCc instead.');

        if (all) {
            app.logger.warn('The reply_all option is deprecated. Use View.Fields.Base.Emails.ReplyAllActionField ' +
                'instead.');
        }

        return {
            to: this.emailOptionTo(this.model) || [],
            cc: this.emailOptionCc(this.model) || []
        };
    },

    /**
     * Given the original subject, generate a reply subject.
     *
     * @param {string} subject
     * @protected
     * @deprecated Use
     * View.Fields.Base.Emails.ReplyActionField#emailOptionSubject instead.
     */
    _getReplySubject: function(subject) {
        app.logger.warn('View.Fields.Base.Emails.ReplyActionField#_getReplySubject is deprecated. Use ' +
            'View.Fields.Base.Emails.ReplyActionField#emailOptionSubject instead.');

        return this.emailOptionSubject(this.model);
    },

    /**
     * Get the data required by the header template.
     *
     * @return {Object}
     * @protected
     * @deprecated Use
     * View.Fields.Base.Emails.ReplyActionField#_getHeaderParams instead.
     */
    _getReplyHeaderParams: function() {
        app.logger.warn('View.Fields.Base.Emails.ReplyActionField#_getReplyHeaderParams is deprecated. Use ' +
            'View.Fields.Base.Emails.ReplyActionField#_getHeaderParams instead.');

        return this._getHeaderParams(this.model);
    },

    /**
     * Build the reply header for text only emails.
     *
     * @param {Object} params
     * @param {string} params.from
     * @param {string} [params.date] Date original email was sent
     * @param {string} params.to
     * @param {string} [params.cc]
     * @param {string} params.name The subject of the original email.
     * @return {string}
     * @private
     * @deprecated Use
     * View.Fields.Base.Emails.ReplyActionField#_getHeader instead.
     */
    _getReplyHeader: function(params) {
        app.logger.warn('View.Fields.Base.Emails.ReplyActionField#_getReplyHeader is deprecated. Use ' +
            'View.Fields.Base.Emails.ReplyActionField#_getHeader instead.');

        return this._getHeader(params);
    },

    /**
     * Create an array of email recipients from the collection, which can be
     * used as recipients to pass to the new email.
     *
     * @param {Data.BeanCollection} collection
     * @return {Array}
     * @private
     */
    _createRecipients: function(collection) {
        return collection.map(function(recipient) {
            var data = {
                email: app.data.createBean('EmailAddresses', recipient.get('email_addresses'))
            };
            var parent;

            if (recipient.hasParent()) {
                parent = recipient.getParent();

                if (parent) {
                    data.bean = parent;
                }
            }

            return data;
        });
    },

    /**
     * Retrieve the plain text version of the reply body.
     *
     * @param {Data.Bean} model The body should come from this model's
     * attributes. EmailClientLaunch plugin should dictate the model based on
     * the context.
     * @return {string} The reply body
     * @private
     */
    _getReplyBody: function(model) {
        // Falls back to the `this.model` for backward compatibility.
        model = model || this.model;

        return model.get('description') || '';
    },

    /**
     * Retrieve the HTML version of the email body.
     *
     * Ensure the result is a defined string and strip any signature wrapper
     * tags to ensure it doesn't get stripped if we insert a signature above
     * the forward content. Also strip any reply content class if this is a
     * forward to a previous reply. And strip any forward content class if this
     * is a forward to a previous forward.
     *
     * @return {string}
     * @protected
     * @deprecated Use
     * View.Fields.Base.Emails.ReplyActionField#emailOptionDescriptionHtml
     * instead.
     */
    _getReplyBodyHtml: function() {
        app.logger.warn('View.Fields.Base.Emails.ReplyActionField#_getReplyBodyHtml is deprecated. Use ' +
            'View.Fields.Base.Emails.ReplyActionField#emailOptionDescriptionHtml instead.');

        return this.emailOptionDescriptionHtml(this.model);
    }
}) },
"recipients": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Emails.RecipientsField
 * @alias SUGAR.App.view.fields.BaseEmailsRecipientsField
 * @extends View.Fields.Base.BaseField
 * @deprecated Use {@link View.Fields.Base.Emails.EmailRecipientsField}
 * instead.
 */
({
	// Recipients FieldTemplate (base) 

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    events: {
        'click .btn': '_showAddressBook'
    },

    fieldTag: 'input.select2',

    plugins: ['DragdropSelect2'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Fields.Base.Emails.RecipientsField is deprecated. Use ' +
            'View.Fields.Base.Emails.EmailRecipientsField instead.');

        this._super('initialize', [options]);
        // initialize the value to an empty collection
        this.model.setDefault(this.name, new Backbone.Collection);
    },

    /**
     * Sets up event handlers for syncing between the model and the recipients field.
     *
     * See {@link #format} for the acceptable formats for recipients.
     */
    bindDataChange: function() {
        /**
         * Sets up event handlers that allow external forces to manipulate the contents of the collection, while
         * maintaining the requirement for storing formatted recipients.
         */
        var bindCollectionChange = _.bind(function() {
            var value = this.model.get(this.name);
            if (value instanceof Backbone.Collection) {
                // on "add" we want to force the collection to be reset to guarantee that all models in the collection
                // have been properly formatted for use in this field
                value.on('add', function(models, collection) {
                    // Backbone destroys the models currently in the collection on reset, so we must clone the
                    // collection in order to add the same models again
                    collection.reset(collection.clone().models);
                }, this);
                // on "remove" the requisite models have already been removed, so we only need to bother updating the
                // value in the DOM
                value.on('remove', function(models, collection) {
                    // format the recipients and put them in the DOM
                    this._updateTheDom(this.format(this.model.get(this.name)));
                }, this);
                // on "reset" we want to replace all models in the collection with their formatted versions
                value.on('reset', function(collection) {
                    var recipients = this.format(collection.models);
                    // do this silently so we don't trigger another reset event and end up in an infinite loop
                    collection.reset(recipients, {silent: true});
                    // put the newly formatted recipients in the DOM
                    this._updateTheDom(recipients);
                }, this);
            }
        }, this);

        // set up collection event handlers for the initial collection (initialized during this.initialize)
        bindCollectionChange();

        // handle the value on the model being changed to something other than the initial collection
        this.model.on('change:' + this.name, function(model, recipients) {
            var value = this.model.get(this.name);
            if (!(value instanceof Backbone.Collection)) {
                // whoa! someone changed the value to be something other than a collection
                // stick that new value inside a collection and reset the value, so we're always dealing with a
                // collection... another change event will be triggered, so we'll end up in the else block right after
                // this
                this.model.set(this.name, new Backbone.Collection(value));
            } else {
                // phew! the value is a collection
                // but it's not the initial collection, so we'll have to set up collection event handlers for this
                // instance
                bindCollectionChange();
                // you never know what data someone sticks on the field, so we better reset the values in the collection
                // so that the recipients become formatted as we expect
                value.reset(recipients.clone().models);
            }
        }, this);
    },

    /**
     * Sets the value of the Select2 element, decorates any invalid recipients,
     * and rebuilds the tooltips for all recipients.
     *
     * @param {Array} recipients the return value for {@link #format}.
     */
    _updateTheDom: function(recipients) {
        // put the formatted recipients in the DOM
        this.getFieldElement().select2('data', recipients);
        this._decorateInvalidRecipients();
        if (!this.def.readonly) {
            this.setDragDropPluginEvents(this.getFieldElement());
        }
    },

    /**
     * Remove events from the field value if it is a collection
     */
    unbindData: function() {
        var value = this.model.get(this.name);
        if (value instanceof Backbone.Collection) {
            value.off(null, null, this);
        }

        this._super('unbindData');
    },

    /**
     * Render field with select2 widget
     *
     * @private
     */
    _render: function() {
        var $controlsEl;
        var $recipientsField;

        if (this.$el) {
            $controlsEl = this.$el.closest('.controls');
            if ($controlsEl.length) {
                $controlsEl.addClass('controls-one btn-fit');
            }
        }
        this._super('_render');

        $recipientsField = this.getFieldElement();

        if ($recipientsField.length > 0) {
            $recipientsField.select2({
                allowClear: true,
                multiple: true,
                width: 'off',
                containerCssClass: 'select2-choices-pills-close',
                containerCss: {'width': '100%'},
                minimumInputLength: 1,
                query: _.bind(function(query) {
                    this.loadOptions(query);
                }, this),
                createSearchChoice: _.bind(this.createOption, this),
                formatSelection: _.bind(this.formatSelection, this),
                formatResult: _.bind(this.formatResult, this),
                formatSearching: _.bind(this.formatSearching, this),
                formatInputTooShort: _.bind(this.formatInputTooShort, this),
                selectOnBlur: true
            });

            if (!!this.def.disabled) {
                $recipientsField.select2('disable');
            }

            if (!this.def.readonly) {
                this.setDragDropPluginEvents(this.getFieldElement());
            }
        }
    },

    /**
     * Fetches additional recipients from the server.
     *
     * See [Select2 Documentation of `query` parameter](http://ivaynberg.github.io/select2/#doc-query).
     *
     * @param {Object} query Possible attributes can be found in select2's
     *   documentation.
     */
    loadOptions: _.debounce(function(query) {
        var self = this,
            data = {
                results: [],
                // only show one page of results
                // if more results are needed, then the address book should be used
                more: false
            },
            options = {},
            callbacks = {},
            url;

        // add the search term to the URL params
        options.q = query.term;
        // the first 10 results should be enough
        // if more results are needed, then the address book should be used
        options.max_num = 10;
        // build the URL for fetching recipients that match the search term
        url = app.api.buildURL('Mail', 'recipients/find', null, options);
        // create the callbacks
        callbacks.success = function(result) {
            // the api returns objects formatted such that sidecar can convert them to beans
            // we need the records to be in a standard object format (@see RecipientsField::format) and the records
            // need to be converted into beans before we can format them
            var records = app.data.createMixedBeanCollection(result.records);
            // format and add the recipients that were found via the select2 callback
            data.results = self.format(records);
        };
        callbacks.error = function() {
            // don't add any recipients via the select2 callback
            data.results = [];
        };
        callbacks.complete = function() {
            // execute the select2 callback to add any new recipients
            query.callback(data);
        };
        app.api.call('read', url, null, callbacks);
    }, 300),

    /**
     * Create additional select2 options when loadOptions returns no matches for the search term.
     *
     * See [Select2 Documentation](http://ivaynberg.github.io/select2/#documentation).
     *
     * @param {String} term
     * @param {Array} data The options in the select2 drop-down after the query callback has been executed.
     * @return {Object}
     */
    createOption: function(term, data) {
        if (data.length === 0) {
            return {id: term, email: term};
        }
    },

    /**
     * Formats a recipient object for displaying selected recipients.
     *
     * See [Select2 Documentation](http://ivaynberg.github.io/select2/#documentation).
     *
     * @param {Object} recipient
     * @return {String}
     */
    formatSelection: function(recipient) {
        var value = recipient.name || recipient.email,
            template = app.template.getField(this.type, 'select2-selection', this.module);
        if (template) {
            return template({
                id: recipient.id,
                name: value,
                email: recipient.email,
                invalid: recipient._invalid
            });
        }
        return value;
    },

    /**
     * Formats a recipient object for displaying items in the recipient options list.
     *
     * See [Select2 Documentation](http://ivaynberg.github.io/select2/#documentation).
     *
     * @param {Object} recipient
     * @return {String}
     */
    formatResult: function(recipient) {
        var format,
            email = Handlebars.Utils.escapeExpression(recipient.email);

        if (recipient.name) {
            format = '"' + Handlebars.Utils.escapeExpression(recipient.name) + '" &lt;' + email + '&gt;';
        } else {
            format = email;
        }

        return format;
    },

    /**
     * Returns the localized message indicating that a search is in progress
     *
     * See [Select2 Documentation](http://ivaynberg.github.io/select2/#documentation).
     *
     * @return {string}
     */
    formatSearching: function() {
        return app.lang.get('LBL_LOADING', this.module);
    },

    /**
     * Suppresses the message indicating the number of characters remaining before a search will trigger
     *
     * See [Select2 Documentation](http://ivaynberg.github.io/select2/#documentation).
     *
     * @param {string} term Search string entered by user.
     * @param {number} min Minimum required term length.
     * @return {string}
     */
    formatInputTooShort: function(term, min) {
        return '';
    },

    /**
     * Formats a set of recipients into an array of objects that select2 understands.
     *
     * See {@link #_formatRecipient} for the acceptable/expected attributes to
     * be found on each recipient.
     *
     * @param {Mixed} data A Backbone collection, a single Backbone model or standard JavaScript object, or an array of
     *   Backbone models or standard JavaScript objects.
     * @return {Array}
     */
    format: function(data) {
        var formattedRecipients = [];
        // the lowest common denominator of potential inputs is an array of objects
        // force the parameter to be an array of either objects or Backbone models so that we're always dealing with
        // one data-structure type
        if (data instanceof Backbone.Collection) {
            // get the raw array of models
            data = data.models;
        } else if (data instanceof Backbone.Model || (_.isObject(data) && !_.isArray(data))) {
            // wrap the single model in an array so the code below behaves the same whether it's a model or a collection
            data = [data];
        }
        if (_.isArray(data)) {
            _.each(data, function(recipient) {
                var formattedRecipient;
                if (!(recipient instanceof Backbone.Model)) {
                    // force the object to be a Backbone.Model to allow for certain assumptions to be made
                    // there is no harm in this because the recipient will not be added to the return value if no email
                    // address is found on the model
                    recipient = new Backbone.Model(recipient);
                }
                formattedRecipient = this._formatRecipient(recipient);
                // only add the recipient if there is an email address
                if (!_.isEmpty(formattedRecipient.email)) {
                    formattedRecipients.push(formattedRecipient);
                }
            }, this);
        }
        return formattedRecipients;
    },

    /**
     * Determine whether or not the recipient pills should be locked.
     * @return {boolean}
     */
    recipientsLocked: function() {
        return this.def.readonly || false;
    },

    /**
     * Synchronize the recipient field value with the model and setup tooltips for email pills.
     */
    bindDomChange: function() {
        var self = this;
        this.getFieldElement()
            .on('change', function(event) {
                var value = $(this).select2('data');
                if (event.removed) {
                    value = _.filter(value, function(d) {
                        return d.id !== event.removed.id;
                    });
                }
                self.model.get(self.name).reset(value);
            })
            .on('select2-selecting', _.bind(this._handleEventOnSelected, this));
    },

    /**
     * Event handler for the Select2 "select2-selecting" event.
     *
     * @param {Event} event
     * @return {boolean}
     * @private
     */
    _handleEventOnSelected: function(event) {
        // only allow the user to select an option if it is determined to be a valid email address
        // returning true will select the option; false will prevent the option from being selected
        var isValidChoice = false;

        // since this event is fired twice, we only want to perform validation on the first event
        // event.object is not available on the second event
        if (event.object) {
            // the id and email address will not match when the email address came from the database and
            // we are assuming that email addresses stored in the database have already been validated
            if (event.object.id == event.object.email) {
                // this option must be a new email address that the application does not recognize
                // so mark it as valid and kick off an async validation
                isValidChoice = true;
                this._validateEmailAddress(event.object);
            } else {
                // the application should recognize the email address, so no need to validate it again
                // just assume it's a valid choice and we'll deal with the consequences later (server-side)
                isValidChoice = true;
            }
        }

        return isValidChoice;
    },

    /**
     * Destroy all select2 and tooltip plugins
     */
    unbindDom: function() {
        this.getFieldElement().select2('destroy');
        this._super('unbindDom');
    },

    /**
     * When in edit mode, the field includes an icon button for opening an address book. Clicking the button will
     * trigger an event to open the address book, which calls this method to do the dirty work. The selected recipients
     * are added to this field upon closing the address book.
     *
     * @private
     */
    _showAddressBook: function() {
        /**
         * Callback to add recipients, from a closing drawer, to the target Recipients field.
         * @param {undefined|Backbone.Collection} recipients
         */
        var addRecipients = _.bind(function(recipients) {
            if (recipients && recipients.length > 0) {
                this.model.get(this.name).add(recipients.models);
            }
        }, this);
        app.drawer.open(
            {
                layout: 'compose-addressbook',
                context: {
                    module: 'Emails',
                    mixed: true
                }
            },
            function(recipients) {
                addRecipients(recipients);
            }
        );
    },

    /**
     * update ul.select2-choices data attribute which prevents underrun of pills by
     * using a css definition for :before {content:''} set to float right
     *
     * @param {string} content
     */
    setContentBefore: function(content) {
        this.$('.select2-choices').attr('data-content-before', content);
    },

    /**
     * Gets the recipients DOM field
     *
     * @return {Object} DOM Element
     */
    getFieldElement: function() {
        return this.$(this.fieldTag);
    },

    /**
     * Format a recipient from a Backbone.Model to a standard JavaScript object with id, module, email, and name
     * attributes. Only id and email are required for the recipient to be considered valid
     * {@link #format}.
     *
     * All attributes are optional. However, if the email attribute is not present, then a primary email address should
     * exist on the bean. Without an email address that can be resolved, the recipient is considered to be invalid. The
     * bean attribute must be a Backbone.Model and it is likely to be a Bean. Data found in the bean is considered to be
     * secondary to the attributes found on its parent model. The bean is a mechanism for collecting additional
     * information about the recipient that may not have been explicitly set when the recipient was passed in.
     * @param {Backbone.Model} recipient
     * @return {Object}
     * @private
     */
    _formatRecipient: function(recipient) {
        var formattedRecipient = {};
        if (recipient instanceof Backbone.Model) {
            var bean = recipient.get('bean');
            // if there is a bean attribute, then more data can be extracted about the recipient to fill in any holes if
            // attributes are missing amongst the primary attributes
            // so follow the trail using recursion
            if (bean) {
                formattedRecipient = this._formatRecipient(bean);
            }
            // prioritize any values found on recipient over those already extracted from bean
            formattedRecipient = {
                id: recipient.get('id') || formattedRecipient.id || recipient.get('email'),
                module: recipient.get('module') || recipient.module || recipient.get('_module') || formattedRecipient.module,
                email: recipient.get('email') || formattedRecipient.email,
                locked: this.recipientsLocked(),
                name: recipient.get('name') || recipient.get('full_name') || formattedRecipient.name,
                _invalid: recipient.get('_invalid')
            };
            // don't bother with the recipient unless an id is present
            if (!_.isEmpty(formattedRecipient.id)) {
                // extract the primary email address for the recipient
                if (_.isArray(formattedRecipient.email)) {
                    var primaryEmailAddress = _.findWhere(formattedRecipient.email, {primary_address: true});

                    if (!_.isUndefined(primaryEmailAddress) && !_.isEmpty(primaryEmailAddress.email_address)) {
                        formattedRecipient.email = primaryEmailAddress.email_address;
                    }
                }
                // drop any values that are empty or non-compliant
                _.each(formattedRecipient, function(val, key) {
                    if ((_.isEmpty(formattedRecipient[key]) || !_.isString(formattedRecipient[key])) && !_.isBoolean(formattedRecipient[key])) {
                        delete formattedRecipient[key];
                    }
                });
            } else {
                // drop all values if an id isn't present
                formattedRecipient = {};
            }
        }
        return formattedRecipient;
    },

    /**
     * Validates an email address on the server asynchronously.
     *
     * Marks the recipient as invalid if it is not a valid email address.
     *
     * @param {Object} recipient
     * @param {string} recipient.id
     * @param {string} recipient.email
     * @private
     */
    _validateEmailAddress: function(recipient) {
        var callbacks = {};
        var url = app.api.buildURL('Mail', 'address/validate');

        callbacks.success = _.bind(function(result) {
            if (!result[recipient.email] && !this.disposed) {
                this._markRecipientInvalid(recipient.id);
            }
        }, this);
        callbacks.error = _.bind(function() {
            if (!this.disposed) {
                this._markRecipientInvalid(recipient.id);
            }
        }, this);

        app.api.call('create', url, [recipient.email], callbacks);
    },

    /**
     * Mark the given recipient as invalid in the collection and update select2.
     *
     * @param {string} recipientId
     * @private
     */
    _markRecipientInvalid: function(recipientId) {
        var recipients = this.model.get(this.name);
        var recipient = recipients.get(recipientId);
        recipient.set('_invalid', true);
        this._updateTheDom(this.format(recipients));
    },

    /**
     * Decorate any invalid recipients in this field.
     * @private
     */
    _decorateInvalidRecipients: function() {
        var self = this;
        var $invalidRecipients = this.$('.select2-search-choice [data-invalid="true"]');
        $invalidRecipients.each(function() {
            var $choice = $(this).closest('.select2-search-choice');
            $choice.addClass('select2-choice-danger');
            $(this).attr('data-title', app.lang.get('ERR_INVALID_EMAIL_ADDRESS', self.module));
        });
    }
}) },
"outbound-email": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
 /**
 * @class View.Fields.Base.Emails.OutboundEmailField
 * @alias SUGAR.App.view.fields.BaseEmailsOutboundEmailField
 * @extends View.Fields.Base.EnumField
 */
({
	// Outbound-email FieldTemplate (base) 

    extendsFrom: 'BaseEnumField',

    /**
     * Sets the field type to `enum` so that the `BaseEnumField` templates are
     * loaded. This is necessary when extending a field and using a
     * different name without any custom templates.
     *
     * Adds help text (LBL_OUTBOUND_EMAIL_ID_HELP) for admins.
     *
     * @inheritdoc
     */
    initialize: function(options) {
        if (app.user.get('type') === 'admin') {
            options.def.help = 'LBL_OUTBOUND_EMAIL_ID_HELP';
        }

        this._super('initialize', [options]);
        this.type = 'enum';
    },

    /**
     * @inheritdoc
     *
     * Only add the help tooltip if the help text is being hidden.
     */
    decorateHelper: function() {
        if (this.def.hideHelp) {
            this._super('decorateHelper');
        }
    },

    /**
     * @inheritdoc
     *
     * Dismisses any alerts with the key `email-client-status`.
     */
    _dispose: function() {
        app.alert.dismiss('email-client-status');
        this._super('_dispose');
    },

    /**
     * Shows a warning to the user when a not_authorized error is returned.
     *
     * @inheritdoc
     * @fires email_not_configured Triggered on the view to allow the view to
     * decide what should be done beyond warning the user. The error is passed
     * to listeners.
     */
    loadEnumOptions: function(fetch, callback, error) {
        var oError = error;

        error = _.bind(function(e) {
            if (e.code === 'not_authorized') {
                // Mark the error as having been handled so that it doesn't get
                // handled again.
                e.handled = true;
                app.alert.show('email-client-status', {
                    level: 'warning',
                    messages: app.lang.get(e.message, this.module),
                    autoClose: false,
                    onLinkClick: function() {
                        app.alert.dismiss('email-client-status');
                    }
                });
                this.view.trigger('email_not_configured', e);
            }

            if (oError) {
                oError(e);
            }
        }, this);

        this._super('loadEnumOptions', [fetch, callback, error]);
    }
}) },
"htmleditable_tinymce": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Emails.Htmleditable_tinymceField
 * @alias SUGAR.App.view.fields.BaseEmailsHtmleditable_tinymceField
 * @extends View.Fields.Base.Htmleditable_tinymceField
 */
({
	// Htmleditable_tinymce FieldTemplate (base) 

    extendsFrom: 'Htmleditable_tinymceField',

    /**
     * Force the field to display the correct view even if there is no data to
     * show.
     *
     * @property {boolean}
     */
    showNoData: false,

    /**
     * Constant for inserting content above the existing email body.
     *
     * @property {string}
     */
    ABOVE_CONTENT: 'above',

    /**
     * Constant for inserting content below the existing email body.
     *
     * @property {string}
     */
    BELOW_CONTENT: 'below',

    /**
     * Constant for inserting content into the email body at the current cursor
     * location.
     *
     * @property {string}
     */
    CURSOR_LOCATION: 'cursor',

    /**
     * The tinyMCE button object for the signature dropdown.
     *
     * @private
     * @property {Object|null}
     */
    _signatureBtn: null,

    /**
     * The number of signatures found from the API response.
     *
     * @private
     * @property {number}
     */
    _numSignatures: 0,

    /**
     * Track the editor focus/blur state.
     *
     * @private
     * @property {boolean}
     */
    _editorFocused: false,

    /**
     * @inheritdoc
     *
     * Stores the user's default signature on the context using the attribute
     * name `current_signature`. This attribute is updated anytime a new
     * signature is selected.
     *
     * Stores the initial signature location for inserting the default
     * signature. If the context already has `signature_location` attribute,
     * then that value is used. Otherwise, this attribute is defaulted to
     * insert the signature below any content. This attribute is updated
     * anytime a signature is inserted in a different location.
     *
     * The default signature is inserted in the initial location if the email
     * is new. The signature is not inserted if the email is an existing draft
     * that is being edited. If the initial location is the cursor, then the
     * signature is inserted after the editor is fully loaded and the cursor
     * has been placed.
     *
     * For new replies, the cursor is placed above the reply content, once the
     * editor has been loaded.
     */
    initialize: function(options) {
        var signature;
        var location;
        // We insert an empty <p> node in the tinyMCE editor and use that to
        // focus the cursor to the bottom of the tinyMCE editor. This is
        // because if the last element in the editor has content
        // (i.e. <p>Sincercely, John Doe</p>) and we select that element, the
        // cursor would be placed at the beginning of the content
        // (in the example, the cursor would be before the "S" in Sincerely).
        var emptyNode;

        this._super('initialize', [options]);

        // Get the default signature and store it on the context.
        signature = app.user.getPreference('signature_default');

        if (!(signature instanceof app.Bean)) {
            signature = app.data.createBean('UserSignatures', signature);
        }

        this.context.set('current_signature', signature);

        // Determine the initial signature location for inserting the default.
        location = this.context.get('signature_location');

        if (_.isEmpty(location)) {
            // Default the location.
            location = this.BELOW_CONTENT;
            this.context.set('signature_location', location);
        }

        // Don't do the following if updating an existing draft.
        if (this.model.isNew()) {
            // Insert the default signature.
            if (location === this.CURSOR_LOCATION) {
                // Need to wait for the editor before inserting.
                this.listenToOnce(this.context, 'tinymce:oninit', function() {
                    this._insertSignature(signature, location);
                });
            } else {
                this._insertSignature(signature, location);
            }

            // Focus the editor and place the cursor at the desired location.
            if (!_.isEmpty(this.context.get('cursor_location'))) {
                this.listenToOnce(this.context, 'tinymce:oninit', function() {
                    if (this._htmleditor) {
                        this._htmleditor.focus();

                        // Move the cursor to the bottom of the editor by
                        // inserting an empty node and selecting it.
                        if (this.context.get('cursor_location') == this.BELOW_CONTENT) {
                            emptyNode = this._insertNodeInEditor();

                            if (emptyNode) {
                                this._htmleditor.selection.setCursorLocation(emptyNode);
                                this._htmleditor.selection.collapse(true);
                            }
                        }
                    }
                });
            }
        }
    },

    /**
     * Suppress calling the sidecar _render method in detail view
     *
     * @inheritdoc
     */
    _render: function() {
        if (this._isEditView()) {
            this._super('_render');
            this.$el.toggleClass('detail', false).toggleClass('edit', true);
        } else {
            this.destroyTinyMCEEditor();
            this._renderView();
            this.$el.toggleClass('detail', true).toggleClass('edit', false);
        }
        return this;
    },

    /**
     * Replicate the sidecar render logic for detail view except for
     * manually appending an iframe instead of invoking the template
     *
     * @inheritdoc
     */
    _renderView: function() {
        var self = this;
        var iFrame;

        // sets this.tplName and this.action
        this._loadTemplate();

        if (this.model instanceof Backbone.Model) {
            this.value = this.getFormattedValue();
        }

        this.dir = _.result(this, 'direction');

        if (app.lang.direction === this.dir) {
            delete this.dir;
        }

        this.unbindDom();

        // begin custom rendering
        if (this.$el.find('iframe').length === 0) {
            iFrame = $('<iframe>', {
                src: '',
                class: 'htmleditable' + (this.def.span ? ' span' + this.def.span : ''),
                frameborder: 0,
                name: this.name
            });
            // Perform it on load for Firefox.
            iFrame.appendTo(this.$el).on('load', function() {
                self._setIframeBaseTarget(iFrame, '_blank');
            });
            this._setIframeBaseTarget(iFrame, '_blank');
        }

        this.setViewContent(this.value);
        // end custom rendering

        if (this.def && this.def.css_class) {
            this.getFieldElement().addClass(this.def.css_class);
        }

        this.$(this.fieldTag).attr('dir', this.dir);
        this.bindDomChange();
    },

    /**
     * @inheritdoc
     *
     * Resize the field's container based on the height of the iframe content
     * for preview.
     */
    setViewContent: function(value) {
        var field;
        // Pad this to the final height due to the iframe margins/padding
        var padding = 25;
        var contentHeight = 0;

        this._super('setViewContent', [value]);

        // Only set this field height if it is in the preview pane
        if (this.tplName !== 'preview') {
            return;
        }

        contentHeight = this._getContentHeight() + padding;

        // Only resize the editor when the content is fully loaded
        if (contentHeight > padding) {
            // Set the maximum height to 400px
            if (contentHeight > 400) {
                contentHeight = 400;
            }

            field = this._getHtmlEditableField();
            field.css('height', contentHeight);
        }
    },

    /**
     * Get the content height of the field's iframe.
     *
     * @private
     * @return {number} Returns 0 if the iframe isn't found.
     */
    _getContentHeight: function() {
        var editable = this._getHtmlEditableField();

        if (this._iframeHasBody(editable)) {
            return editable.contents().find('body')[0].offsetHeight;
        }

        return 0;
    },

    /**
     * Set iframe base target value
     *
     * @param {jQuery} iFrame The iframe element that the target will be added to.
     * @param {string} targetValue e.g. _self, _blank, _parent, _top or frameName
     * @private
     */
    _setIframeBaseTarget: function(iFrame, targetValue) {
        var target = $('<base>', {
            target: targetValue
        });

        target.appendTo(iFrame.contents().find('head'));
    },

    /**
     * @inheritdoc
     *
     * Adds buttons for uploading a local file and selecting a Sugar Document
     * to attach to the email.
     *
     * Adds a button for selecting and inserting a signature at the cursor.
     *
     * Adds a button for selecting and applying a template.
     *
     * @fires email_attachments:file on the view when the user elects to attach
     * a local file.
     */
    addCustomButtons: function(editor) {
        var self = this;
        var attachmentButtons = [];

        // Attachments can only be added if the user has permission to create
        // Notes records. Only add the attachment button(s) if the user is
        // allowed.
        if (app.acl.hasAccess('create', 'Notes')) {
            attachmentButtons.push({
                text: app.lang.get('LBL_ATTACH_FROM_LOCAL', this.module),
                onclick: _.bind(function(event) {
                    // Track click on the file attachment button.
                    app.analytics.trackEvent('click', 'tinymce_email_attachment_file_button', event);
                    this.view.trigger('email_attachments:file');
                }, this)
            });

            // The user can only select a document to attach if he/she has
            // permission to view Documents records in the selection list.
            // Don't add the Documents button if the user can't view and select
            // documents.
            if (app.acl.hasAccess('view', 'Documents')) {
                attachmentButtons.push({
                    text: app.lang.get('LBL_ATTACH_SUGAR_DOC', this.module),
                    onclick: _.bind(function(event) {
                        // Track click on the document attachment button.
                        app.analytics.trackEvent('click', 'tinymce_email_attachment_doc_button', event);
                        this._selectDocument();
                    }, this)
                });
            }

            editor.addButton('sugarattachment', {
                type: 'menubutton',
                tooltip: app.lang.get('LBL_ATTACHMENT', this.module),
                icon: 'paperclip',
                onclick: function(event) {
                    // Track click on the attachment button.
                    app.analytics.trackEvent('click', 'tinymce_email_attachment_button', event);
                },
                menu: attachmentButtons
            });
        }

        editor.addButton('sugarsignature', {
            type: 'menubutton',
            tooltip: app.lang.get('LBL_SIGNATURE', this.module),
            icon: 'pencil',
            // disable the signature button until they have been loaded
            disabled: true,
            onPostRender: function() {
                self._signatureBtn = this;
                // load the users signatures
                self._getSignatures();
            },
            onclick: function(event) {
                // Track click on the signature button.
                app.analytics.trackEvent('click', 'tinymce_email_signature_button', event);
            },
            // menu is populated from the _getSignatures() response
            menu: []
        });

        if (app.acl.hasAccess('view', 'EmailTemplates')) {
            editor.addButton('sugartemplate', {
                tooltip: app.lang.get('LBL_TEMPLATE', this.module),
                icon: 'file-o',
                onclick: _.bind(function(event) {
                    // Track click on the template button.
                    app.analytics.trackEvent('click', 'tinymce_email_template_button', event);
                    this._selectEmailTemplate();
                }, this)
            });
        }

        // Enable the signature button when the editor is focused and the user
        // has signatures that can be inserted.
        editor.on('focus', _.bind(function(e) {
            this._editorFocused = true;
            this.view.trigger('tinymce:focus');
            // the user has at least 1 signature
            if (this._numSignatures > 0) {
                // enable the signature button
                this._signatureBtn.disabled(false);
            }
        }, this));

        // Disable the signature button when the editor is blurred and the user
        // has signatures. Signatures are inserted at the cursor location. If
        // the button is not disabled when the editor is unfocused, then issues
        // would arise with the user clicking a signature to insert at the
        // cursor without a cursor being present.
        editor.on('blur', _.bind(function(e) {
            this._editorFocused = false;
            this.view.trigger('tinymce:blur');
            // the user has at least 1 signature
            if (this._numSignatures > 0) {
                // disable the signature button
                this._signatureBtn.disabled(true);
            }
        }, this));
    },

    /**
     * Inserts the content into the TinyMCE editor at the specified location.
     *
     * @private
     * @param {string} content
     * @param {string} [location="cursor"] Whether to insert the new content
     *   above existing content, below existing content, or at the cursor
     *   location. Defaults to being inserted at the cursor position.
     * @return {string} The updated content.
     */
    _insertInEditor: function(content, location) {
        var emailBody = this.model.get(this.name) || '';

        if (_.isEmpty(content)) {
            return emailBody;
        }

        // Default to the cursor location.
        location = location || this.CURSOR_LOCATION;

        // Add empty divs so user can place the cursor on the line before or
        // after.
        content = '<div></div>' + content + '<div></div>';

        if (location === this.CURSOR_LOCATION) {
            if (_.isNull(this._htmleditor)) {
                // Unable to insert content at the cursor without an editor.
                return emailBody;
            }

            this._htmleditor.execCommand('mceInsertContent', false, content);

            // Get the HTML content from the editor.
            emailBody = this._htmleditor.getContent();
        } else if (location === this.BELOW_CONTENT) {
            emailBody += content;
        } else if (location === this.ABOVE_CONTENT) {
            emailBody = content + emailBody;
        }

        // Update the model with the new content.
        this.model.set(this.name, emailBody);

        return emailBody;
    },

    /**
     * Inserts a unique element into the TinyMCE editor to the end of the
     * <body>.
     *
     * @private
     * @return {HTMLElement|boolean} The inserted element or false if an
     * element can't be inserted.
     */
    _insertNodeInEditor: function() {
        var body;
        var uniqueId;

        if (this._htmleditor) {
            body = this._htmleditor.getBody();
            uniqueId = this._htmleditor.dom.uniqueId();
            $('<p id="' + uniqueId + '"><br /></p>').appendTo(body);

            return this._htmleditor.dom.select('p#' + uniqueId)[0];
        }

        // There is no editor to insert the element into.
        return false;
    },

    /**
     * Fetches the signatures for the current user.
     *
     * @private
     */
    _getSignatures: function() {
        var signatures = app.data.createBeanCollection('UserSignatures');

        signatures.filterDef = [{
            user_id: {$equals: app.user.get('id')}
        }];
        signatures.fetch({
            max_num: -1, // Get as many as we can.
            success: _.bind(this._getSignaturesSuccess, this),
            error: function() {
                app.alert.show('server-error', {
                    level: 'error',
                    messages: 'ERR_GENERIC_SERVER_ERROR'
                });
            }
        });
    },

    /**
     * Add each signature as buttons under the signature button.
     *
     * @private
     * @param {Data.BeanCollection} signatures
     */
    _getSignaturesSuccess: function(signatures) {
        if (this.disposed === true) {
            return;
        }

        if (!_.isUndefined(signatures) && !_.isUndefined(signatures.models)) {
            signatures = signatures.models;
        } else {
            app.alert.show('server-error', {
                level: 'error',
                messages: 'ERR_GENERIC_SERVER_ERROR'
            });

            return;
        }

        if (!_.isNull(this._signatureBtn)) {
            // write the signature names to the control dropdown
            _.each(signatures, _.bind(function(signature) {
                this._signatureBtn.settings.menu.push({
                    text: signature.get('name'),
                    onclick: _.bind(function(event) {
                        // Track click on a signature.
                        app.analytics.trackEvent('click', 'email_signature', event);
                        this._insertSignature(signature, this.CURSOR_LOCATION);
                    }, this)
                });
            }, this));

            // Set the number of signatures the user has
            this._numSignatures = signatures.length;

            // If the editor is focused before the signatures are returned, enable the signature button
            if (this._editorFocused) {
                this._signatureBtn.disabled(false);
            }
        }
    },

    /**
     * Inserts the signature into the editor.
     *
     * @private
     * @param {Data.Bean} signature
     * @param {string} [location="cursor"] Whether to insert the new content
     * above existing content, below existing content, or at the cursor
     * location. Defaults to being inserted at the cursor position.
     */
    _insertSignature: function(signature, location) {
        var htmlBodyObj;
        var emailBody;
        var signatureHtml;
        var decodedSignature;
        var signatureContent;

        function decodeBrackets(str) {
            str = str.replace(/&lt;/gi, '<');
            str = str.replace(/&gt;/gi, '>');

            return str;
        }

        if (this.disposed === true) {
            return;
        }

        if (!(signature instanceof app.Bean)) {
            return;
        }

        signatureHtml = signature.get('signature_html');

        if (_.isEmpty(signatureHtml)) {
            return;
        }

        decodedSignature = decodeBrackets(signatureHtml);
        signatureContent = '<div class="signature keep">' + decodedSignature + '</div>';

        emailBody = this._insertInEditor(signatureContent, location);
        htmlBodyObj = $('<div>' + emailBody + '</div>');

        // Mark each signature to either keep or remove.
        $('div.signature', htmlBodyObj).each(function() {
            if (!$(this).hasClass('keep')) {
                // Mark for removal.
                $(this).addClass('remove');
            } else {
                // If the parent is also a signature, move the node out of the
                // parent so it isn't removed.
                if ($(this).parent().hasClass('signature')) {
                    // Move the signature outside of the nested signature.
                    $(this).parent().before(this);
                }

                // Remove the "keep" class so if another signature is added it
                // will remove this one.
                $(this).removeClass('keep');
            }
        });

        // After each signature is marked, perform the removal.
        htmlBodyObj.find('div.signature.remove').remove();

        emailBody = htmlBodyObj.html();
        this.model.set(this.name, emailBody);

        this.context.set('current_signature', signature);
        this.context.set('signature_location', location || this.CURSOR_LOCATION);
    },

    /**
     * Allows the user to select a template to apply.
     *
     * @private
     */
    _selectEmailTemplate: function() {
        var def = {
            layout: 'selection-list',
            context: {
                module: 'EmailTemplates',
                fields: [
                    'subject',
                    'body',
                    'body_html',
                    'text_only'
                ]
            }
        };

        app.drawer.open(def, _.bind(this._onEmailTemplateDrawerClose, this));
    },

    /**
     * Verifies that the user has access to the email template before applying
     * it.
     *
     * @private
     * @param {Data.Bean} model
     */
    _onEmailTemplateDrawerClose: function(model) {
        var emailTemplate;

        if (this.disposed === true) {
            return;
        }

        // This is an edge case where user has List but not View permission.
        // Search & Select will return only id and name if View permission is
        // not permitted for this record. Display appropriate error.
        if (model && _.isUndefined(model.subject)) {
            app.alert.show('no_access_error', {
                level: 'error',
                messages: app.lang.get('ERR_NO_ACCESS', this.module, {name: model.value})
            });
        } else if (model) {
            // `value` is not a real attribute.
            emailTemplate = app.data.createBean('EmailTemplates', _.omit(model, 'value'));
            this._confirmTemplate(emailTemplate);
        }
    },

    /**
     * Confirms that the user wishes to replace all content in the editor. The
     * template is applied if there is no existing content or if the user
     * confirms "yes".
     *
     * @private
     * @param {Data.Bean} template
     */
    _confirmTemplate: function(template) {
        var subject = this.model.get('name') || '';
        var text = this.model.get('description') || '';
        var html = this.model.get(this.name) || '';
        var fullContent = subject + text + html;

        if (_.isEmpty(fullContent)) {
            this._applyTemplate(template);
        } else {
            app.alert.show('delete_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_EMAILTEMPLATE_MESSAGE_SHOW_MSG', this.module),
                onConfirm: _.bind(function(event) {
                    // Track click on confirmation button.
                    app.analytics.trackEvent('click', 'email_template_confirm', event);
                    this._applyTemplate(template);
                }, this),
                onCancel: function(event) {
                    // Track click on cancel button.
                    app.analytics.trackEvent('click', 'email_template_cancel', event);
                }
            });
        }
    },

    /**
     * Inserts the template into the editor.
     *
     * The template's subject does not overwrite the existing subject if:
     *
     * 1. The email is a forward or reply.
     * 2. The template does not have a subject.
     *
     * @private
     * @fires email_attachments:template on the view with the selected template
     * as a parameter. {@link View.Fields.Base.Emails.EmailAttachmentsField}
     * adds the template's attachments to the email.
     * @param {Data.Bean} template
     */
    _applyTemplate: function(template) {
        var body;
        var replyContent;
        var forwardContent;
        var subject;
        var signature = this.context.get('current_signature');

        /**
         * Check the email body and pull out any forward/reply content from a
         * draft email.
         *
         * @param {string} body The full content to search.
         * @return {string} The forward/reply content.
         */
        function getForwardReplyContent(body, id) {
            var content = '';
            var $content;

            if (body) {
                $content = $('<div>' + body + '</div>').find('div#' + id);

                if ($content.length > 0) {
                    content = $content[0].outerHTML;
                }
            }

            return content;
        }

        if (this.disposed === true) {
            return;
        }

        // Track applying an email template.
        app.analytics.trackEvent('email_template', 'apply', template);

        replyContent = getForwardReplyContent(this.model.get(this.name), 'replycontent');
        forwardContent = getForwardReplyContent(this.model.get(this.name), 'forwardcontent');
        subject = template.get('subject');

        // Only use the subject if it's not a forward or reply.
        if (subject && !(replyContent || forwardContent)) {
            this.model.set('name', subject);
        }

        //TODO: May need to move over replaces special characters.
        body = template.get('text_only') ? template.get('body') : template.get('body_html');
        this.model.set(this.name, body);

        this.view.trigger('email_attachments:template', template);

        // The HTML signature is used even when the template is text-only.
        if (signature) {
            this._insertSignature(signature, this.BELOW_CONTENT);
        }

        // Append the reply content to the end of the email.
        if (replyContent) {
            this._insertInEditor(replyContent, this.BELOW_CONTENT);
        }

        // Append the forward content to the end of the email.
        if (forwardContent) {
            this._insertInEditor(forwardContent, this.BELOW_CONTENT);
        }
    },

    /**
     * Allows the user to select a document to attach.
     *
     * @private
     * @fires email_attachments:document on the view with the selected document
     * as a parameter. {@link View.Fields.Base.EmailAttachmentsField} attaches
     * the document to the email.
     */
    _selectDocument: function() {
        var def = {
            layout: 'selection-list',
            context: {
                module: 'Documents'
            }
        };

        app.drawer.open(def, _.bind(function(model) {
            var document;

            if (model) {
                // `value` is not a real attribute.
                document = app.data.createBean('Documents', _.omit(model, 'value'));
                this.view.trigger('email_attachments:document', document);
            }
        }, this));
    }
}) },
"email-recipients": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Emails.EmailRecipientsField
 * @alias SUGAR.App.view.fields.BaseEmailsEmailRecipientsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Email-recipients FieldTemplate (base) 

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    /**
     * The selector for accessing the Select2 field when in edit mode. The
     * Select2 field is where the recipients are displayed.
     *
     * @property {string}
     */
    fieldTag: 'input.select2',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var plugins = [
            'CollectionFieldLoadAll',
            'EmailParticipants',
            'DragdropSelect2',
            'ListEditable'
        ];

        this.plugins = _.union(this.plugins || [], plugins);
        this.events = _.extend({}, this.events, {
            'click .btn': '_showAddressBook'
        });
        this._super('initialize', [options]);

        // Specify the error label for when any recipient's email address is
        // invalid.
        app.error.errorName2Keys[this.type] = app.lang.get('ERR_INVALID_RECIPIENTS', this.module);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.model) {
            // Avoids a full re-rendering when editing. The current value of
            // the field is formatted and passed directly to Select2 when in
            // edit mode.
            this.listenTo(this.model, 'change:' + this.name, _.bind(function() {
                var $el = this.$(this.fieldTag);

                if (_.isEmpty($el.data('select2'))) {
                    this.render();
                } else {
                    $el.select2('data', this.getFormattedValue());
                    this._decorateRecipients();
                    this._enableDragDrop();
                }
            }, this));
        }
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
        var $el = this.$(this.fieldTag);

        $el.on('select2-selecting', _.bind(function(event) {
            // Don't add the choice if it duplicates an existing recipient.
            var duplicate = this.model.get(this.name).find(function(model) {
                if (event.choice.get('parent_id')) {
                    return event.choice.get('parent_type') === model.get('parent_type') &&
                        event.choice.get('parent_id') === model.get('parent_id');
                }

                return event.choice.get('email_address_id') === model.get('email_address_id') ||
                    event.choice.get('email_address') === model.get('email_address');
            });

            if (this.disposed || duplicate) {
                event.preventDefault();
            }
        }, this));

        $el.on('change', _.bind(function(event) {
            var collection;

            if (this.model && !this.disposed) {
                collection = this.model.get(this.name);

                if (!_.isEmpty(event.added)) {
                    collection.add(event.added);
                }

                if (!_.isEmpty(event.removed)) {
                    collection.remove(event.removed);
                }
            }
        }, this));
    },

    /**
     * @inheritdoc
     *
     * Destroys the Select2 element.
     */
    unbindDom: function() {
        this.$(this.fieldTag).select2('destroy');
        this._super('unbindDom');
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var $el;
        var options;

        this._super('_render');

        $el = this.$(this.fieldTag);

        if ($el.length > 0) {
            options = this.getSelect2Options();
            options = _.extend(options, {
                allowClear: true,
                multiple: true,
                containerCssClass: 'select2-choices-pills-close',

                /**
                 * Constructs a representation for a selected recipient to be
                 * displayed in the field.
                 *
                 * See [Select2 Documentation](http://ivaynberg.github.io/select2/#documentation).
                 *
                 * @param {Data.Bean} recipient
                 * @return {string}
                 * @private
                 */
                formatSelection: _.bind(function(recipient) {
                    var template = app.template.getField(this.type, 'select2-selection', this.module);
                    var name = recipient.get('parent_name') || '';
                    var email = recipient.get('email_address') || '';

                    // The name was erased, so let's use the label.
                    if (_.isEmpty(name) && recipient.nameIsErased) {
                        name = app.lang.get('LBL_VALUE_ERASED', recipient.module);
                    }

                    // The email was erased, so let's use the label.
                    if (_.isEmpty(email) && recipient.emailIsErased) {
                        email = app.lang.get('LBL_VALUE_ERASED', recipient.module);
                    }

                    return template({
                        cid: recipient.cid,
                        name: name || email,
                        email_address: email,
                        invalid: recipient.invalid,
                        opt_out: !!recipient.get('opt_out'),
                        name_is_erased: recipient.nameIsErased,
                        email_is_erased: recipient.emailIsErased
                    });
                }, this),

                /**
                 * Constructs a representation for the recipient to be
                 * displayed in the dropdown options after a query.
                 *
                 * See [Select2 Documentation](http://ivaynberg.github.io/select2/#documentation).
                 *
                 * @param {Data.Bean} recipient
                 * @return {string}
                 */
                formatResult: _.bind(function(recipient) {
                    var template = app.template.getField(this.type, 'select2-result', this.module);

                    return template({
                        value: recipient.toHeaderString({quote_name: true}),
                        module: recipient.get('parent_type')
                    });
                }, this),

                /**
                 * Don't escape a choice's markup since we built the HTML.
                 *
                 * See [Select2 Documentation](https://select2.github.io/select2/#documentation).
                 *
                 * @param {string} markup
                 * @return {string}
                 */
                escapeMarkup: function(markup) {
                    return markup;
                }
            });
            $el.select2(options).select2('val', []);

            if (this.isDisabled()) {
                $el.select2('disable');
            }

            this._decorateRecipients();
            this._enableDragDrop();
        }
    },

    /**
     * @inheritdoc
     * @return {Array}
     */
    format: function(value) {
        // Reset the tooltip.
        this.tooltip = '';

        if (value instanceof app.BeanCollection) {
            value = value.map(this.prepareModel, this);

            // Must wrap the callback in a function or else the collection's
            // index will be passed, causing the second parameter of
            // EmailParticipantsPlugin#formatForHeader to unintentionally
            // receive a value.
            this.tooltip = _.map(value, function(model) {
                return model.toHeaderString();
            }, this).join(', ');
        }

        return value;
    },

    /**
     * Decorates recipients that need it.
     *
     * @private
     */
    _decorateRecipients: function() {
        this._decorateOptedOutRecipients();
        this._decorateInvalidRecipients();
    },

    /**
     * Decorate any invalid recipients.
     *
     * @private
     */
    _decorateInvalidRecipients: function() {
        var self = this;
        var $invalidRecipients = this.$('.select2-search-choice [data-invalid="true"]');

        $invalidRecipients.each(function() {
            var $choice = $(this).closest('.select2-search-choice');
            $choice.addClass('select2-choice-danger');

            // Don't change the tooltip if the email address has been erased.
            if (!$(this).data('email-is-erased')) {
                $(this).attr('data-title', app.lang.get('ERR_INVALID_EMAIL_ADDRESS', self.module));
            }
        });
    },

    /**
     * Decorate any opted out email addresses.
     *
     * Email addresses that are opted out and invalid are not decorated by this
     * method. This preserves the invalid recipient decoration, since users
     * will need that decoration to correct their email before saving or
     * sending.
     *
     * @private
     */
    _decorateOptedOutRecipients: function() {
        var self = this;
        var $optedOutRecipients = this.$('.select2-search-choice [data-optout="true"]:not([data-invalid="true"])');

        if (this.def.decorate_opt_out === false) {
            return;
        }

        $optedOutRecipients.each(function() {
            var $choice = $(this).closest('.select2-search-choice');
            $choice.addClass('select2-choice-optout');
            $(this).attr('data-title', app.lang.get('LBL_EMAIL_ADDRESS_OPTED_OUT', self.module, {
                email_address: $choice.data('select2Data').get('email_address')
            }));
        });
    },

    /**
     * Enable the user to drag and drop recipients between recipient fields.
     *
     * @private
     */
    _enableDragDrop: function() {
        var $el = this.$(this.fieldTag);

        if (!this.def.readonly) {
            this.setDragDropPluginEvents($el);
        }
    },

    /**
     * When in edit mode, the field includes an icon button for opening an
     * address book. Clicking the button will trigger an event to open the
     * address book, which calls this method does. The selected recipients are
     * added to this field upon closing the address book.
     *
     * @private
     */
    _showAddressBook: function() {
        app.drawer.open(
            {
                layout: 'compose-addressbook',
                context: {
                    module: 'Emails',
                    mixed: true
                }
            },
            _.bind(function(recipients) {
                if (recipients && recipients.length > 0) {
                    // Set the correct link for the field where these
                    // recipients are being added.
                    var eps = recipients.map(function(recipient) {
                        recipient.set('_link', this.getLinkName());

                        return recipient;
                    }, this);

                    this.model.get(this.name).add(eps);
                }

                this.view.trigger('address-book-state', 'closed');
            }, this)
        );

        this.view.trigger('address-book-state', 'open');
    },

    /**
     * Moves the recipients to the target collection.
     *
     * @param {Data.BeanCollection} source The collection from which the
     *   recipients are removed.
     * @param {Data.BeanCollection} target The collection to which the
     *   items are added.
     * @param {Array} draggedItems The recipients that are to be removed from
     *   the source collection.
     * @param {Array} droppedItems The recipients that are to be added to
     *   the target collection.
     */
    dropDraggedItems: function(source, target, draggedItems, droppedItems) {
        source.remove(draggedItems);

        _.each(droppedItems, function(item) {
            // The `id` must be unset because we're effectively creating
            // a brand new model to be linked.
            item.unset('id');
            item.set('_link', this.getLinkName());
        }, this);

        target.add(droppedItems);
    }
}) },
"recipients-fieldset": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Recipients field group for handling expand to edit
 *
 * @class View.Fields.Base.Emails.RecipientsFieldsetField
 * @alias SUGAR.App.view.fields.BaseEmailsRecipientsFieldsetField
 * @extends View.Fields.Base.FieldsetField
 */
({
	// Recipients-fieldset FieldTemplate (base) 

    extendsFrom: 'FieldsetField',

    _addressBookState: 'closed',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.events = _.extend({}, this.events, {
            'click [data-toggle-field]': '_handleToggleButtonClick',
            'click .fieldset-field': '_focus'
        });
        this._super('initialize', [options]);

        this.listenTo(this.view, 'address-book-state', function(state) {
            this._addressBookState = state;
        });
        this.listenTo(this.view, 'tinymce:focus', this._blur);
        $(document).on('click.email-recipients', _.bind(this._blur, this));
    },

    /**
     * Adds the CC and BCC toggle buttons to the From field and sets the
     * visibility of those fields. Switches the field to edit mode when there
     * are no recipients and the user is creating an email.
     *
     * @inheritdoc
     */
    _render: function() {
        var cc = this.model.get('cc_collection');
        var bcc = this.model.get('bcc_collection');

        this._super('_render');

        this._addToggleButtons('outbound_email_id');
        this._toggleFieldVisibility('cc_collection', !!cc.length);
        this._toggleFieldVisibility('bcc_collection', !!bcc.length);
    },

    /**
     * @inheritdoc
     * @example
     * // Only the To field has recipients.
     * a@b.com, b@c.com
     * @example
     * // All fields have recipients.
     * a@b.com; CC: c@d.com; BCC: e@f.com
     * @example
     * // CC does not have recipients.
     * a@b.com; BCC: e@f.com
     * @example
     * Only the CC field has recipients.
     * CC: c@d.com
     */
    format: function(value) {
        return _.chain(this.fields)
            // The from field is not used for calculating the value.
            .where({type: 'email-recipients'})
            // Construct each field's string from it's formatted value.
            .reduce(function(fields, field) {
                var models = field.getFormattedValue();
                var str = _.map(models, function(model) {
                    var name = model.get('parent_name') || '';
                    var email = model.get('email_address') || '';

                    // The name was erased, so let's use the label.
                    if (_.isEmpty(name) && model.isNameErased()) {
                        name = app.lang.get('LBL_VALUE_ERASED', model.module);
                    }

                    if (!_.isEmpty(name)) {
                        return name;
                    }

                    // The email was erased, so let's use the label.
                    if (_.isEmpty(email) && model.isEmailErased()) {
                        email = app.lang.get('LBL_VALUE_ERASED', model.module);
                    }

                    return email;
                }).join(', ');

                if (!_.isEmpty(str)) {
                    fields[field.name] = str;
                }

                return fields;
            }, {})
            // Add the label for each field's string.
            .map(function(field, fieldName) {
                var label = '';

                if (fieldName === 'cc_collection') {
                    label = app.lang.get('LBL_CC', this.module) + ': ';
                } else if (fieldName === 'bcc_collection') {
                    label = app.lang.get('LBL_BCC', this.module) + ': ';
                }

                return label + field;
            }, this)
            .value()
            // Separate each field's string by a semi-colon.
            .join('; ');
    },

    /**
     * Cannot switch to detail mode if in create mode and there are no
     * recipients. The mode is set to edit.
     *
     * @inheritdoc
     */
    setMode: function(name) {
        var to = this.model.get('to_collection');
        var cc = this.model.get('cc_collection');
        var bcc = this.model.get('bcc_collection');
        var hasRecipients = to.length > 0 || cc.length > 0 || bcc.length > 0;

        if (this.view.createMode && name === 'detail' && !hasRecipients) {
            name = 'edit';
        }

        this._super('setMode', [name]);
    },

    /**
     * Switches the field to edit mode when the user clicks on the fieldset.
     *
     * @param {Event} [event]
     * @public
     */
    _focus: function(event) {
        if (this.disposed) {
            return;
        }

        // Stop the event from triggering _blur to be called.
        if (event) {
            event.stopPropagation();
        }

        if (this.action !== 'edit') {
            this.setMode('edit');
        }
    },

    /**
     * Switches the field to detail mode when the user clicks outside the
     * fieldset.
     *
     * @param {Event} [event]
     * @public
     */
    _blur: function(event) {
        if (this.disposed) {
            return;
        }

        // Don't change modes if the address book is open.
        if (this._addressBookState === 'open') {
            return;
        }

        if (this.action !== 'detail') {
            this.setMode('detail');
        }
    },

    /**
     * Add CC and BCC toggle buttons to the field.
     *
     * @param {string} fieldName The name of the field where the buttons are
     * added.
     * @private
     */
    _addToggleButtons: function(fieldName) {
        var field = this.view.getField(fieldName);
        var $field;
        var template;
        var html;

        if (!field) {
            return;
        }

        $field = field.$el.closest('.fieldset-field');

        if ($field.length > 0) {
            template = app.template.getField(this.type, 'recipient-options', this.module);
            html = template({module: this.module});
            $(html).appendTo($field);
        }
    },

    /**
     * Toggle the visibility of the field associated with the button that was
     * clicked.
     *
     * @param {Event} event
     * @private
     */
    _handleToggleButtonClick: function(event) {
        var $toggleButton = $(event.currentTarget);
        var fieldName = $toggleButton.data('toggle-field');

        this._toggleFieldVisibility(fieldName);
    },

    /**
     * Toggles the visibility of the field and the toggle state of its
     * associated button.
     *
     * @param {string} fieldName The name of the field to toggle.
     * @param {boolean} [show] True when the button should be inactive and the
     * field should be shown. The toggle is flipped when undefined.
     * @private
     */
    _toggleFieldVisibility: function(fieldName, show) {
        var toggleButtonSelector = '[data-toggle-field="' + fieldName + '"]';
        var $toggleButton = this.$(toggleButtonSelector);
        var field = this.view.getField(fieldName);

        // if explicit active state not set, toggle to opposite
        if (_.isUndefined(show)) {
            show = !$toggleButton.hasClass('active');
        }

        $toggleButton.toggleClass('active', show);

        if (field) {
            field.$el.closest('.fieldset-group').toggleClass('hide', !show);
        }

        this.view.trigger('email-recipients:toggled');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        $(document).off('click.email-recipients');
        this._super('_dispose');
    }
}) },
"name": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
 /**
 * @class View.Fields.Base.Emails.NameField
 * @alias SUGAR.App.view.fields.BaseEmailsNameField
 * @extends View.Fields.Base.NameField
 */
({
	// Name FieldTemplate (base) 

    extendsFrom: 'BaseNameField',

    /**
     * @inheritdoc
     *
     * Returns "(no subject)" when the email has no subject and not in edit
     * mode. This allows for the subject to be a link in a list view.
     */
    format: function(value) {
        if (_.isEmpty(value) && this.action !== 'edit') {
            return app.lang.get('LBL_NO_SUBJECT', this.module);
        }

        return value;
    },

    /**
     * Build email record route depending on whether or not the email is a
     * draft and whether the user has the Sugar Email Client option enabled.
     *
     * @return {string}
     */
    buildHref: function() {
        var action = this.def.route && this.def.route.action ? this.def.route.action : null;
        var module = this.model.module || this.context.get('module');

        if (this.model.get('state') === 'Draft' &&
            app.acl.hasAccessToModel('edit', this.model) &&
            this._useSugarEmailClient() &&
            !action
        ) {
            action = 'compose';
        }

        return '#' + app.router.buildRoute(module, this.model.get('id'), action);
    },

    /**
     * Determine if the user is configured to use the Sugar Email Client for
     * editing existing draft emails.
     *
     * @return {boolean}
     * @private
     */
    _useSugarEmailClient: function() {
        var emailClientPreference = app.user.getPreference('email_client_preference');

        return (
            emailClientPreference &&
            emailClientPreference.type === 'sugar' &&
            app.acl.hasAccess('edit', 'Emails')
        );
    }
}) },
"reply-all-action": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Reply all action.
 *
 * This allows a user to "reply all" to an existing email.
 *
 * @class View.Fields.Base.Emails.ReplyAllActionField
 * @alias SUGAR.App.view.fields.EmailsBaseReplyAllActionField
 * @extends View.Fields.Base.Emails.ReplyActionField
 */
({
	// Reply-all-action FieldTemplate (base) 

    extendsFrom: 'EmailsReplyActionField',

    /**
     * Returns the recipients to use in the To field of the email. The sender
     * and the recipients in the To field from the original email are included.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when identifying the recipients.
     * @return {undefined|Array}
     */
    emailOptionTo: function(model) {
        var originalTo = model.get('to_collection');
        var to = this._super('emailOptionTo', [model]) || [];

        to = _.union(to, this._createRecipients(originalTo));

        return to;
    },

    /**
     * Returns the recipients to use in the CC field of the email. These
     * recipients are the same ones who appeared in the original email's CC
     * field.
     *
     * @see EmailClientLaunch plugin.
     * @param {Data.Bean} model Use this model when identifying the recipients.
     * @return {undefined|Array}
     */
    emailOptionCc: function(model) {
        var originalCc = model.get('cc_collection');
        var cc = this._createRecipients(originalCc);

        return cc;
    },

    /**
     * Returns the template from View.Fields.Base.Emails.ReplyActionField.
     *
     * @inheritdoc
     */
    _getHeaderHtmlTemplate: function() {
        this._tplHeaderHtml = this._tplHeaderHtml ||
            app.template.getField('reply-action', this._tplHeaderHtmlName, 'Emails');

        return this._tplHeaderHtml;
    }
}) },
"email-attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Emails.EmailAttachmentsField
 * @alias SUGAR.App.view.fields.BaseEmailsEmailAttachmentsField
 * @extends View.Fields.Base.EmailAttachmentsField
 */
({
	// Email-attachments FieldTemplate (base) 

    extendsFrom: 'BaseEmailAttachmentsField',

    /**
     * @inheritdoc
     *
     * Adds a listener for the `email_attachments:template` event, which is
     * triggered on the view to add attachments. The handler will fetch the
     * attachments from a template, so that they can be copied to the email.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.listenTo(this.view, 'email_attachments:template', this._fetchTemplateAttachments);
    },

    /**
     * Retrieves all of an email template's attachments so they can be added to
     * the email.
     *
     * @param {Data.Bean} template The email template whose attachments are to
     * be added.
     * @private
     */
    _fetchTemplateAttachments: function(template) {
        var def;
        var notes = app.data.createBeanCollection('Notes');
        var request;

        if (this.disposed === true) {
            return;
        }

        def = [{
            //FIXME: email_type should be EmailTemplates
            email_id: {
                '$equals': template.get('id')
            }
        }];
        request = notes.fetch({
            filter: {
                filter: def
            },
            success: _.bind(this._handleTemplateAttachmentsFetchSuccess, this),
            complete: _.bind(function(request) {
                if (request && request.uid) {
                    delete this._requests[request.uid];
                }
            }, this)
        });

        // This request is not associated with a placeholder because
        // placeholders aren't used when handling templates.
        if (request && request.uid) {
            this._requests[request.uid] = request;
        }
    },

    /**
     * Handles a successful response from the API for retrieving an email
     * template's attachments.
     *
     * The relevant data is taken from each record and added as an attachment.
     * Before adding the new attachments, all existing attachments that came
     * from another email template are removed.
     *
     * @param {Data.BeanCollection} notes The collection of attachments from
     * the template.
     * @private
     */
    _handleTemplateAttachmentsFetchSuccess: function(notes) {
        var attachments;
        var existingTemplateAttachments;
        var newTemplateAttachments;

        if (this.disposed === true) {
            return;
        }

        // Remove all existing attachments that came from an email template.
        attachments = this.model.get(this.name);
        existingTemplateAttachments = attachments.where({file_source: 'EmailTemplates'});
        attachments.remove(existingTemplateAttachments);

        // Add the attachments from the new email template.
        newTemplateAttachments = notes.map(function(model) {
            return {
                _link: 'attachments',
                upload_id: model.get('id'),
                name: model.get('filename') || model.get('name'),
                filename: model.get('filename') || model.get('name'),
                file_mime_type: model.get('file_mime_type'),
                file_size: model.get('file_size'),
                file_ext: model.get('file_ext'),
                file_source: 'EmailTemplates'
            };
        });
        attachments.add(newTemplateAttachments, {merge: true});
    }
}) },
"sender": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Emails.SenderField
 * @alias SUGAR.App.view.fields.BaseEmailsSenderField
 * @extends View.Fields.Base.BaseField
 * @deprecated Use {@link View.Fields.Base.Emails.OutboundEmailField} instead.
 */
({
	// Sender FieldTemplate (base) 

    fieldTag: 'input.select2',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Fields.Base.Emails.SenderField is deprecated. Use ' +
            'View.Fields.Base.Emails.OutboundEmailField instead.');

        this._super('initialize', [options]);
        this.endpoint = this.def.endpoint;
    },

    _render: function() {
        var result = app.view.Field.prototype._render.call(this);

        if (this.tplName === 'edit') {
            var action = (this.endpoint.action) ? this.endpoint.action : null,
                attributes = (this.endpoint.attributes) ? this.endpoint.attributes : null,
                params = (this.endpoint.params) ? this.endpoint.params : null,
                myURL = app.api.buildURL(this.endpoint.module, action, attributes, params);

            app.api.call('GET', myURL, null, {
                success: _.bind(this.populateValues, this),
                error: function(error) {
                    // display error if not a metadata refresh
                    if (error.status !== 412) {
                        app.alert.show('server-error', {
                            level: 'error',
                            messages: 'ERR_GENERIC_SERVER_ERROR'
                        });
                    }
                    app.error.handleHttpError(error);
                }
            });
        }

        return result;
    },

    populateValues: function(results) {
        var self = this,
            defaultResult,
            defaultValue = {};

        if (this.disposed === true) {
            return; //if field is already disposed, bail out
        }

        if (!_.isEmpty(results)) {
            defaultResult = _.find(results, function(result) {
                return result.default;
            });

            defaultValue = (defaultResult) ? defaultResult : results[0];

            if (!this.model.has(this.name)) {
                this.model.set(this.name, defaultValue.id);
                this.model.setDefault(this.name, defaultValue.id);
            }
        }

        var format = function(item) {
            return item.display;
        };

        this.$(this.fieldTag).select2({
            data:{ results: results, text: 'display' },
            formatSelection: format,
            formatResult: format,
            width: '100%',
            placeholder: app.lang.get('LBL_SELECT_FROM_SENDER', this.module),
            initSelection: function(el, callback) {
                if (!_.isEmpty(defaultValue)) {
                      callback(defaultValue);
                }
            }
        }).on("change", function(e) {
            if (self.model.get(self.name) !== e.val) {
                self.model.set(self.name, e.val, {silent: true});
            }
        });
    },

    /**
     * @inheritdoc
     *
     * We need this empty so it won't affect refresh the select2 plugin
     */
    bindDomChange: function() {
    }
}) }
}}
,
"views": {
"base": {
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.RecordlistView
 * @alias SUGAR.App.view.views.BaseEmailsRecordlistView
 * @extends View.Views.Base.RecordlistView
 */
({
	// Recordlist View (base) 

    extendsFrom: 'RecordlistView',

    /**
     * @inheritdoc
     * When record name is empty, return (no subject)
     */
    _getNameForMessage: function(model) {
        var name = this._super('_getNameForMessage', [model]);

        if (_.isEmpty(name)) {
            return app.lang.get('LBL_NO_SUBJECT', this.module);
        }

        return name;
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.CreateView
 * @alias SUGAR.App.view.views.BaseEmailsCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    /**
     * The editor's height can never be smaller than this constant.
     *
     * @property {number}
     */
    MIN_EDITOR_HEIGHT: 200,

    /**
     * The padding that needs to be accounted for to prevent the scroll bar
     * from appearing when the editor is resized.
     *
     * @property {number}
     */
    EDITOR_RESIZE_PADDING: 5,

    /**
     * @inheritdoc
     */
    _titleLabel: 'LNK_NEW_ARCHIVE_EMAIL',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // batch queued calls to editor resize function
        this.resizeEditor = _.debounce(_.bind(this._resizeEditor, this), 100);

        this.listenTo(this.context, 'tinymce:oninit', function() {
            this.resizeEditor();
        });
        this.listenTo(app.drawer, 'drawer:resize', function() {
            this.resizeEditor();
        });
        this.on('more-less:toggled', function() {
            this.resizeEditor();
        }, this);
        this.on('email-recipients:toggled', function() {
            this.resizeEditor();
        }, this);
        $(window).on('resize.' + this.cid, this.resizeEditor);
    },

    /**
     * @inheritdoc
     *
     * Hides or shows the attachments field based on whether or not there are
     * attachments when changes to the attachments are detected.
     *
     * Disables the save button if the attachments exceed the
     * max_aggregate_email_attachments_bytes configuration. Alerts the user, as
     * well. Enables the save button and dismisses the alert if the attachments
     * are under the max_aggregate_email_attachments_bytes configuration
     * configuration.
     */
    bindDataChange: function() {
        if (this.model) {
            this.listenTo(this.model, 'change:attachments_collection', this._hideOrShowTheAttachmentsField);
            this.listenTo(this.model, 'attachments_collection:over_max_total_bytes', function(totalBytes, maxBytes) {
                var readableMax = app.utils.getReadableFileSize(maxBytes);
                var label = app.lang.get('LBL_TOTAL_ATTACHMENT_MAX_SIZE', this.module);
                var saveButton = this.getField(this.saveButtonName);

                app.alert.show('email-attachment-status', {
                    level: 'warning',
                    messages: app.utils.formatString(label, [readableMax])
                });

                if (saveButton) {
                    saveButton.setDisabled(true);
                }
            });
            this.listenTo(this.model, 'attachments_collection:under_max_total_bytes', function() {
                var saveButton = this.getField(this.saveButtonName);

                app.alert.dismiss('email-attachment-status');

                if (saveButton) {
                    saveButton.setDisabled(false);
                }
            });
        }

        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     *
     * EmailsApi responds with a 451 HTTP status code to report custom errors
     * related to sending email. Anytime a 451 code is encountered, the error
     * is alerted to the user, which should provide more useful information
     * than a standard HTTP error. Other errors in the 400-499 range are
     * handled normally in core.
     */
    saveModel: function(success, error) {
        var onError = _.bind(function(model, e) {
            if (e && e.status == 451) {
                // Mark the error as having been handled
                e.handled = true;
                this.enableButtons();
                app.alert.show(e.error, {
                    level: 'error',
                    autoClose: false,
                    messages: e.message
                });
            } else if (error) {
                error(model, e);
            }
        }, this);

        this._super('saveModel', [success, onError]);
    },

    /**
     * @inheritdoc
     *
     * Adds the view parameter. It must be added to `options.params` because
     * the `options.view` is only added as a parameter if the request method is
     * "read".
     */
    getCustomSaveOptions: function(options) {
        options = options || {};
        options.params = options.params || {};
        options.params.view = this.name;

        return options;
    },

    /**
     * @inheritdoc
     *
     * Sets the title of the page. Hides or shows the attachments field.
     */
    _render: function() {
        this._super('_render');

        this.setTitle(app.lang.get(this._titleLabel, this.module));
        this._hideOrShowTheAttachmentsField();

        this._resizeEditor();
    },

    /**
     * Hides the attachments field if there are no attachments and shows the
     * field if there are attachments.
     */
    _hideOrShowTheAttachmentsField: function() {
        var field = this.getField('attachments_collection');
        var $el;
        var $row;

        if (!field) {
            return;
        }

        $el = field.getFieldElement();
        $row = $el.closest('.row-fluid');

        if (field.isEmpty()) {
            $row.addClass('hidden');
            $row.removeClass('single');
        } else {
            $row.removeClass('hidden');
            $row.addClass('single');
        }
    },

    /**
     * @inheritdoc
     *
     * Builds the appropriate success message for saving an archived email.
     */
    buildSuccessMessage: function() {
        return app.lang.get('LBL_EMAIL_ARCHIVED', this.module);
    },

    /**
     * Resize the editor based on the height of the layout container.
     *
     * @private
     */
    _resizeEditor: function() {
        var $editor;
        var layoutHeight;
        var recordHeight;
        var showToggleHeight;
        var editorHeight;
        // The difference in height between the current editor and the actual
        // available height of the space available to it.
        var diffHeight;
        var newEditorHeight;

        if (this.disposed) {
            return;
        }

        $editor = this.$('.mce-stack-layout .mce-stack-layout-item iframe');
        // Cannot resize it if the editor is not already rendered.
        if ($editor.length === 0) {
            return;
        }

        layoutHeight = this.layout.$el.outerHeight(true);
        // This is the total height including the html editor and other
        // record fields. It does not include the show-hide toggle.
        recordHeight = this.$('.record').outerHeight(true);

        // Don't include the negative top margin on show-hide toggle because it
        // has no affect on the layout because the .record has no bottom margin
        showToggleHeight = this.$('.show-hide-toggle').outerHeight(false);
        editorHeight = $editor.height();
        // Calculate the difference between the current editor height and
        // maximum available height. Subtracts padding to prevent the scrollbar.
        diffHeight = layoutHeight - recordHeight - showToggleHeight - this.EDITOR_RESIZE_PADDING;
        // Add the space left to fill to the current height of the editor to
        // get the new height.
        newEditorHeight = editorHeight + diffHeight;

        // Don't drop below the minimum height.
        if (newEditorHeight < this.MIN_EDITOR_HEIGHT) {
            newEditorHeight = this.MIN_EDITOR_HEIGHT;
        }

        // Set the new height for the editor.
        $editor.height(newEditorHeight);
    },

    /**
     * Stop listening to the window resize event.
     * @inheritdoc
     */
    _dispose: function() {
        $(window).off('resize.' + this.cid);
        this._super('_dispose');
    }
}) },
"compose-email": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.ComposeEmailView
 * @alias SUGAR.App.view.views.BaseEmailsComposeEmailView
 * @extends View.Views.Base.Emails.CreateView
 */
({
	// Compose-email View (base) 

    extendsFrom: 'EmailsCreateView',

    /**
     * Constant representing the state of an email when it is a draft.
     *
     * @property {string}
     */
    STATE_DRAFT: 'Draft',

    /**
     * Constant representing the state of an email when it is ready to be sent.
     *
     * @property {string}
     */
    STATE_READY: 'Ready',

    /**
     * The name of the send button.
     *
     * @property {string}
     */
    sendButtonName: 'send_button',

    /**
     * Used for determining if an email's content contains variables.
     *
     * @property {RegExp}
     */
    _hasVariablesRegex: /\$[a-zA-Z]+_[a-zA-Z0-9_]+/,

    /**
     * False when the email client reports a configuration issue.
     *
     * @property {boolean}
     */
    _userHasConfiguration: true,

    /**
     * The label to be used as the title of the page.
     *
     * @property {string}
     */
    _titleLabel: 'LBL_COMPOSE_MODULE_NAME_SINGULAR',

    /**
     * @inheritdoc
     *
     * Disables the send button if email has not been configured.
     */
    initialize: function(options) {
        var loadingRequests = 0;

        this._super('initialize', [options]);

        if (this.model.isNew()) {
            this.model.set('state', this.STATE_DRAFT);
        }

        this.on('email_not_configured', function() {
            var sendButton = this.getField('send_button');

            if (sendButton) {
                sendButton.setDisabled(true);
            }

            this._userHasConfiguration = false;
        }, this);

        this.on('loading_collection_field', function() {
            loadingRequests++;
            this.toggleButtons(false);
        }, this);

        this.on('loaded_collection_field', function() {
            loadingRequests--;

            if (loadingRequests === 0) {
                this.toggleButtons(true);
            }
        }, this);

        this.on('editable:toggle_fields', function(fields, viewName) {
            var field = this.getField('recipients');

            if (field) {
                field.setMode('detail');
            }
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Renders the recipients fieldset anytime there are changes to the `to`,
     * `cc`, or `bcc` fields.
     *
     * Disables the send button if the attachments exceed the
     * max_aggregate_email_attachments_bytes configuration. Enables the send
     * button if the attachments are under the
     * max_aggregate_email_attachments_bytes configuration configuration.
     */
    bindDataChange: function() {
        var self = this;
        var renderRecipientsField = _.debounce(function() {
            var field = self.getField('recipients');

            if (field) {
                field.render();
            }
        }, 200);

        if (this.model) {
            this.listenTo(
                this.model,
                'change:to_collection change:cc_collection change:bcc_collection',
                renderRecipientsField
            );
            this.listenTo(this.model, 'attachments_collection:over_max_total_bytes', function() {
                var sendButton = this.getField(this.sendButtonName);

                if (sendButton) {
                    sendButton.setDisabled(true);
                }
            });
            this.listenTo(this.model, 'attachments_collection:under_max_total_bytes', function() {
                var sendButton = this.getField(this.sendButtonName);

                if (sendButton) {
                    sendButton.setDisabled(!this._userHasConfiguration);
                }
            });
        }

        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     *
     * Registers a handler to send the email when the send button is clicked.
     */
    delegateButtonEvents: function() {
        this._super('delegateButtonEvents');
        this.listenTo(this.context, 'button:' + this.sendButtonName + ':click', function() {
            this.send();
        });
    },

    /**
     * @inheritdoc
     *
     * The send button cannot be enabled if email is not configured for the
     * user.
     */
    toggleButtons: function(enable) {
        this._super('toggleButtons', [enable]);

        if (enable && this.buttons[this.sendButtonName] && !this._userHasConfiguration) {
            this.buttons[this.sendButtonName].setDisabled(true);
        }
    },

    /**
     * @inheritdoc
     *
     * Implements the Compose:Send shortcut to send the email.
     */
    registerShortcuts: function() {
        this._super('registerShortcuts');

        app.shortcuts.register({
            id: 'Compose:Send',
            keys: ['mod+shift+s'],
            component: this,
            description: 'LBL_SHORTCUT_EMAIL_SEND',
            callOnFocus: true,
            handler: function() {
                var $sendButton = this.$('a[name=' + this.sendButtonName + ']');

                if ($sendButton.is(':visible') && !$sendButton.hasClass('disabled')) {
                    $sendButton.get(0).click();
                }
            }
        });
    },

    /**
     * @inheritdoc
     *
     * `BaseEmailsCreateView` is used when creating new emails and editing
     * existing drafts. The model is not new when editing drafts. In those
     * cases, {@link BaseEmailsRecordView#hasUnsavedChanges} is called to use
     * logic that checks for unsaved changes for existing records instead of
     * new records.
     */
    hasUnsavedChanges: function() {
        if (this.model.isNew()) {
            return this._super('hasUnsavedChanges');
        }

        return app.view.views.BaseEmailsRecordView.prototype.hasUnsavedChanges.call(this);
    },

    /**
     * Sends the email.
     *
     * Warns the user if the subject and/or body are empty. The user may still
     * send the email after confirming.
     *
     * Alerts the user if the email does not have any recipients.
     */
    send: function() {
        var confirmationMessages = [];
        var subject = this.model.get('name') || '';
        var text = this.model.get('description') || '';
        var html = this.model.get('description_html') || '';
        var fullContent = subject + ' ' + text + ' ' + html;
        var isSubjectEmpty = _.isEmpty($.trim(subject));
        // When fetching tinyMCE content, convert to jQuery Object
        // and return only if text is not empty. By wrapping the value
        // in <div> tags we remove the error if the value contains
        // no HTML markup
        var isContentEmpty = _.isEmpty($.trim($('<div>' + html + '</div>').text()));

        var sendEmail = _.bind(function() {
            this.model.set('state', this.STATE_READY);
            this.save();
        }, this);

        this.disableButtons();

        if (this.model.get('to_collection').length === 0 &&
            this.model.get('cc_collection').length === 0 &&
            this.model.get('bcc_collection').length === 0
        ) {
            this.model.trigger('error:validation:to_collection');
            app.alert.show('send_error', {
                level: 'error',
                messages: 'LBL_EMAIL_COMPOSE_ERR_NO_RECIPIENTS'
            });
            this.enableButtons();
        } else {
            // to/cc/bcc filled out, check other fields
            if (isSubjectEmpty && isContentEmpty) {
                confirmationMessages.push(app.lang.get('LBL_NO_SUBJECT_NO_BODY_SEND_ANYWAYS', this.module));
            } else if (isSubjectEmpty) {
                confirmationMessages.push(app.lang.get('LBL_SEND_ANYWAYS', this.module));
            } else if (isContentEmpty) {
                confirmationMessages.push(app.lang.get('LBL_NO_BODY_SEND_ANYWAYS', this.module));
            }

            if (_.isEmptyValue(this.model.get('parent_id')) && this._hasVariablesRegex.test(fullContent)) {
                confirmationMessages.push(app.lang.get('LBL_NO_RELATED_TO_WITH_TEMPLATE_SEND_ANYWAYS', this.module));
            }

            if (confirmationMessages.length > 0) {
                app.alert.show('send_confirmation', {
                    level: 'confirmation',
                    messages: confirmationMessages.join('<br />'),
                    onConfirm: sendEmail,
                    onCancel: _.bind(this.enableButtons, this)
                });
            } else {
                // All checks pass, send the email
                sendEmail();
            }
        }
    },

    /**
     * @inheritdoc
     *
     * Builds the appropriate success message based on the state of the email.
     */
    buildSuccessMessage: function() {
        var successLabel = this.model.get('state') === this.STATE_DRAFT ? 'LBL_DRAFT_SAVED' : 'LBL_EMAIL_SENT';

        return app.lang.get(successLabel, this.module);
    }
}) },
"compose-addressbook-recipientscontainer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.ComposeAddressbookRecipientscontainerView
 * @alias SUGAR.App.view.views.BaseEmailsComposeAddressbookRecipientscontainerView
 * @extends View.Views.Base.RecordView
 */
({
	// Compose-addressbook-recipientscontainer View (base) 

    extendsFrom: 'RecordView',
    enableHeaderButtons: false,
    enableHeaderPane: false,
    events: {},

    /**
     * Override to remove unwanted functionality.
     *
     * @param prefill
     */
    setupDuplicateFields: function(prefill) {},

    /**
     * Override to remove unwanted functionality.
     */
    delegateButtonEvents: function() {},

    /**
     * Override to remove unwanted functionality.
     */
    _initButtons: function() {
        this.buttons = {};
    },

    /**
     * Override to remove unwanted functionality.
     */
    showPreviousNextBtnGroup: function() {},

    /**
     * Override to remove unwanted functionality.
     */
    bindDataChange: function() {},

    /**
     * Override to remove unwanted functionality.
     *
     * @param isEdit
     */
    toggleHeaderLabels: function(isEdit) {},

    /**
     * Override to remove unwanted functionality.
     *
     * @param field
     */
    toggleLabelByField: function(field) {},

    /**
     * Override to remove unwanted functionality.
     *
     * @param e
     * @param field
     */
    handleKeyDown: function(e, field) {},

    /**
     * Override to remove unwanted functionality.
     *
     * @param state
     */
    setButtonStates: function(state) {},

    /**
     * Override to remove unwanted functionality.
     *
     * @param title
     */
    setTitle: function(title) {}
}) },
"compose": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.ComposeView
 * @alias SUGAR.App.view.views.BaseEmailsComposeView
 * @extends View.Views.Base.RecordView
 * @deprecated Use {@link View.Views.Base.Emails.ComposeEmailView} instead.
 */
({
	// Compose View (base) 

    extendsFrom: 'RecordView',

    _lastSelectedSignature: null,
    ATTACH_TYPE_SUGAR_DOCUMENT: 'document',
    ATTACH_TYPE_TEMPLATE: 'template',
    MIN_EDITOR_HEIGHT: 300,
    EDITOR_RESIZE_PADDING: 5,
    ATTACHMENT_FIELD_HEIGHT: 44,
    FIELD_PANEL_BODY_SELECTOR: '.row-fluid.panel_body',

    sendButtonName: 'send_button',
    cancelButtonName: 'cancel_button',
    saveAsDraftButtonName: 'draft_button',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Views.Base.Emails.ComposeView is deprecated. Use ' +
            'View.Views.Base.Emails.ComposeEmailView instead.');

        this._super('initialize', [options]);
        this.events = _.extend({}, this.events, {
            'click [data-toggle-field]': '_handleSenderOptionClick'
        });
        this.context.on('email_attachments:file', this.launchFilePicker, this);
        this.context.on('email_attachments:document', this.documentDrawerCallback, this);
        this.context.on('attachments:updated', this.toggleAttachmentVisibility, this);
        this.context.on('tinymce:oninit', this.handleTinyMceInit, this);
        this.on('more-less:toggled', this.handleMoreLessToggled, this);
        app.drawer.on('drawer:resize', this.resizeEditor, this);

        this._lastSelectedSignature = app.user.getPreference('signature_default');
    },

    /**
     * @inheritdoc
     */
    delegateButtonEvents: function() {
        this.context.on('button:' + this.sendButtonName + ':click', this.send, this);
        this.context.on('button:' + this.saveAsDraftButtonName + ':click', this.saveAsDraft, this);
        this.context.on('button:' + this.cancelButtonName + ':click', this.cancel, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var prepopulateValues;
        var $controls;

        this._super('_render');

        $controls = this.$('.control-group:not(.hide) .control-label');
        if ($controls.length) {
            $controls.first().addClass('begin-fieldgroup');
            $controls.last().addClass('end-fieldgroup');
        }

        this.setTitle(app.lang.get('LBL_COMPOSEEMAIL', this.module));

        prepopulateValues = this.context.get('prepopulate');
        if (!_.isEmpty(prepopulateValues)) {
            this.prepopulate(prepopulateValues);
        }
        this.addSenderOptions();

        this.notifyConfigurationStatus();
    },

    /**
     * Notifies the user of configuration issues and disables send button
     */
    notifyConfigurationStatus: function() {
        var sendButton,
            emailClientPrefence = app.user.getPreference('email_client_preference');

        if (_.isObject(emailClientPrefence) && _.isObject(emailClientPrefence.error)) {
            app.alert.show('email-client-status', {
                level: 'warning',
                messages: app.lang.get(emailClientPrefence.error.message, this.module),
                autoClose: false,
                onLinkClick: function() {
                    app.alert.dismiss('email-client-status');
                }
            });

            sendButton = this.getField('send_button');
            if (sendButton) {
                sendButton.setDisabled(true);
            }
        }
    },

    /**
     * Prepopulate fields on the email compose screen that are passed in on the context when opening this view
     * TODO: Refactor once we have custom module specific models
     * @param {Object} values
     */
    prepopulate: function(values) {
        var self = this;
        _.defer(function() {
            _.each(values, function(value, fieldName) {
                switch (fieldName) {
                    case 'related':
                        self._populateForModules(value);
                        self.populateRelated(value);
                        break;
                    default:
                        self.model.set(fieldName, value);
                }
            });
        });
    },

    /**
     * Populates email compose with module specific data.
     * TODO: Refactor once we have custom module specific models
     * @param {Data.Bean} relatedModel
     */
    _populateForModules: function(relatedModel) {
        if (relatedModel.module === 'Cases') {
            this._populateForCases(relatedModel);
        }
    },


    /**
     * Populates email compose with cases specific data.
     * TODO: Refactor once we have custom module specific models
     * @param {Data.Bean} relatedModel
     */
    _populateForCases: function(relatedModel) {
        var config = app.metadata.getConfig(),
            keyMacro = '%1',
            caseMacro = config.inboundEmailCaseSubjectMacro,
            subject = caseMacro + ' ' + relatedModel.get('name');

        subject = subject.replace(keyMacro, relatedModel.get('case_number'));
        this.model.set('name', subject);
        if (!this.isFieldPopulated('to_addresses')) {
            // no addresses, attempt to populate from contacts relationship
            var contacts = relatedModel.getRelatedCollection('contacts');

            contacts.fetch({
                relate: true,
                success: _.bind(function(data) {
                    var toAddresses = _.map(data.models, function(model) {
                        return {bean: model};
                    }, this);

                    this.model.set('to_addresses', toAddresses);
                }, this),
                fields: ['id', 'full_name', 'email']
            });
        }
    },

    /**
     * Populate the parent_name (type: parent) with the related record passed in
     *
     * @param {Data.Bean} relatedModel
     */
    populateRelated: function(relatedModel) {
        var setParent = _.bind(function(model) {
            var parentNameField = this.getField('parent_name');
            if (model.module && parentNameField.isAvailableParentType(model.module)) {
                model.value = model.get('name');
                parentNameField.setValue(model);
            }
        }, this);

        if (!_.isEmpty(relatedModel.get('id')) && !_.isEmpty(relatedModel.get('name'))) {
            setParent(relatedModel);
        } else if (!_.isEmpty(relatedModel.get('id'))) {
            relatedModel.fetch({
                showAlerts: false,
                success: _.bind(function(relatedModel) {
                    setParent(relatedModel);
                }, this),
                fields: ['name']
            });
        }
    },

    /**
     * Enable/disable the page action dropdown menu based on whether email is sendable
     * @param {boolean} disabled
     */
    setMainButtonsDisabled: function(disabled) {
        this.getField('main_dropdown').setDisabled(disabled);
    },

    /**
     * Add Cc/Bcc toggle buttons
     * Initialize whether to show/hide fields and toggle show/hide buttons appropriately
     */
    addSenderOptions: function() {
        this._renderSenderOptions('to_addresses');
        this._initSenderOption('cc_addresses');
        this._initSenderOption('bcc_addresses');
    },

    /**
     * Render the sender option buttons and place them in the given container
     *
     * @param {string} container Name of field that will contain the sender option buttons
     * @private
     */
    _renderSenderOptions: function(container) {
        var field = this.getField(container),
            $panelBody,
            senderOptionTemplate;

        if (field) {
            $panelBody = field.$el.closest(this.FIELD_PANEL_BODY_SELECTOR);
            senderOptionTemplate = app.template.getView('compose-senderoptions', this.module);

            $(senderOptionTemplate({'module' : this.module}))
                .insertAfter($panelBody.find('div span.normal'));
        }
    },

    /**
     * Check if the given field has a value
     * Hide the field if there is no value prepopulated
     *
     * @param {string} fieldName Name of the field to initialize active state on
     * @private
     */
    _initSenderOption: function(fieldName) {
        var fieldValue = this.model.get(fieldName) || [];
        this.toggleSenderOption(fieldName, (fieldValue.length > 0));
    },

    /**
     * Toggle the state of the given field
     * Sets toggle button state and visibility of the field
     *
     * @param {string} fieldName Name of the field to toggle
     * @param {boolean} [active] Whether toggle button active and field shown
     */
    toggleSenderOption: function(fieldName, active) {
        var toggleButtonSelector = '[data-toggle-field="' + fieldName + '"]',
            $toggleButton = this.$(toggleButtonSelector);

        // if explicit active state not set, toggle to opposite
        if (_.isUndefined(active)) {
            active = !$toggleButton.hasClass('active');
        }

        $toggleButton.toggleClass('active', active);
        this._toggleFieldVisibility(fieldName, active);
    },

    /**
     * Event Handler for toggling the Cc/Bcc options on the page.
     *
     * @param {Event} event click event
     * @private
     */
    _handleSenderOptionClick: function(event) {
        var $toggleButton = $(event.currentTarget),
            fieldName = $toggleButton.data('toggle-field');

        this.toggleSenderOption(fieldName);
        this.resizeEditor();
    },

    /**
     * Show/hide a field section on the form
     *
     * @param {string} fieldName Name of the field to show/hide
     * @param {boolean} show Whether to show or hide the field
     * @private
     */
    _toggleFieldVisibility: function(fieldName, show) {
        var field = this.getField(fieldName);
        if (field) {
            field.$el.closest(this.FIELD_PANEL_BODY_SELECTOR).toggleClass('hide', !show);
        }
    },

    /**
     * Cancel and close the drawer
     */
    cancel: function() {
        app.drawer.close();
    },

    /**
     * Get the attachments from the model and format for the API
     *
     * @return {Array} array of attachments or empty array if none found
     */
    getAttachmentsForApi: function() {
        var attachments = this.model.get('attachments') || [];

        if (!_.isArray(attachments)) {
            attachments = [attachments];
        }

        return attachments;
    },

    /**
     * Get the individual related object fields from the model and format for the API
     *
     * @return {Object} API related argument as array with appropriate fields set
     */
    getRelatedForApi: function() {
        var related = {};
        var id = this.model.get('parent_id');
        var type;

        if (!_.isUndefined(id)) {
            id = id.toString();
            if (id.length > 0) {
                related['id'] = id;
                type = this.model.get('parent_type');
                if (!_.isUndefined(type)) {
                    type = type.toString();
                }
                related.type = type;
            }
        }

        return related;
    },

    /**
     * Get the team information from the model and format for the API
     *
     * @return {Object} API teams argument as array with appropriate fields set
     */
    getTeamsForApi: function() {
        var teamName = this.model.get('team_name') || [];
        var teams = {};
        teams.others = [];

        if (!_.isArray(teamName)) {
            teamName = [teamName];
        }

        _.each(teamName, function(team) {
            if (team.primary) {
                teams.primary = team.id.toString();
            } else if (!_.isUndefined(team.id)) {
                teams.others.push(team.id.toString());
            }
        }, this);

        if (teams.others.length == 0) {
            delete teams.others;
        }

        return teams;
    },

    /**
     * Build a backbone model that will be sent to the Mail API
     */
    initializeSendEmailModel: function() {
        var sendModel = new Backbone.Model(_.extend({}, this.model.attributes, {
            to_addresses: this.model.get('to_addresses'),
            cc_addresses: this.model.get('cc_addresses'),
            bcc_addresses: this.model.get('bcc_addresses'),
            subject: this.model.get('name'),
            html_body: this.model.get('description_html'),
            attachments: this.getAttachmentsForApi(),
            related: this.getRelatedForApi(),
            teams: this.getTeamsForApi()
        }));
        return sendModel;
    },

    /**
     * Save the email as a draft for later sending
     */
    saveAsDraft: function() {
        this.saveModel(
            'draft',
            app.lang.get('LBL_DRAFT_SAVING', this.module),
            app.lang.get('LBL_DRAFT_SAVED', this.module),
            app.lang.get('LBL_ERROR_SAVING_DRAFT', this.module)
        );
    },

    /**
     * Send the email immediately or warn if user did not provide subject or body
     */
    send: function() {
        var sendEmail = _.bind(function() {
            this.saveModel(
                'ready',
                app.lang.get('LBL_EMAIL_SENDING', this.module),
                app.lang.get('LBL_EMAIL_SENT', this.module),
                app.lang.get('LBL_ERROR_SENDING_EMAIL', this.module)
            );
        }, this);

        if (!this.isFieldPopulated('to_addresses') &&
            !this.isFieldPopulated('cc_addresses') &&
            !this.isFieldPopulated('bcc_addresses')
        ) {
            this.model.trigger('error:validation:to_addresses');
            app.alert.show('send_error', {
                level: 'error',
                messages: 'LBL_EMAIL_COMPOSE_ERR_NO_RECIPIENTS'
            });
        } else if (!this.isFieldPopulated('name') && !this.isFieldPopulated('description_html')) {
            app.alert.show('send_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_NO_SUBJECT_NO_BODY_SEND_ANYWAYS', this.module),
                onConfirm: sendEmail
            });
        } else if (!this.isFieldPopulated('name')) {
            app.alert.show('send_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_SEND_ANYWAYS', this.module),
                onConfirm: sendEmail
            });
        } else if (!this.isFieldPopulated('description_html')) {
            app.alert.show('send_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_NO_BODY_SEND_ANYWAYS', this.module),
                onConfirm: sendEmail
            });
        } else {
            sendEmail();
        }
    },

    /**
     * Build the backbone model to be sent to the Mail API with the appropriate status
     * Also display the appropriate alerts to give user indication of what is happening.
     *
     * @param {string} status (draft or ready)
     * @param {string} pendingMessage message to display while Mail API is being called
     * @param {string} successMessage message to display when a successful Mail API response has been received
     * @param {string} errorMessage message to display when Mail API call fails
     */
    saveModel: function(status, pendingMessage, successMessage, errorMessage) {
        var myURL,
            sendModel = this.initializeSendEmailModel();

        if (this._hasInvalidRecipients(sendModel)) {
            app.alert.show('mail_invalid_recipients', {
                level: 'error',
                messages: app.lang.get('ERR_INVALID_RECIPIENTS', this.module)
            });
            this.setMainButtonsDisabled(false);
            return;
        }

        this.setMainButtonsDisabled(true);
        app.alert.show('mail_call_status', {level: 'process', title: pendingMessage});

        sendModel.set('status', status);
        myURL = app.api.buildURL('Mail');
        app.api.call('create', myURL, sendModel, {
            success: function() {
                app.alert.dismiss('mail_call_status');
                app.alert.show('mail_call_status', {autoClose: true, level: 'success', messages: successMessage});
                app.drawer.close(sendModel);
            },
            error: function(error) {
                var msg = {level: 'error'};
                if (error && _.isString(error.message)) {
                    msg.messages = error.message;
                }
                app.alert.dismiss('mail_call_status');
                app.alert.show('mail_call_status', msg);
            },
            complete: _.bind(function() {
                if (!this.disposed) {
                    this.setMainButtonsDisabled(false);
                }
            }, this)
        });
    },

    /**
     * Is this field populated?
     * @param {string} fieldName
     * @return {boolean}
     */
    isFieldPopulated: function(fieldName) {
        var value = this.model.get(fieldName);

        if (value instanceof Backbone.Collection) {
            return value.length !== 0;
        } else {
            return !_.isEmpty($.trim(value));
        }
    },

    /**
     * Check if the recipients in any of the recipient fields are invalid.
     *
     * @param {Backbone.Model} model
     * @return {boolean} Return true if there are invalid recipients in any of
     *   the fields. Return false otherwise.
     * @private
     */
    _hasInvalidRecipients: function(model) {
        return _.some(['to_addresses', 'cc_addresses', 'bcc_addresses'], function(fieldName) {
            var recipients = model.get(fieldName);
            if (!recipients) {
                return false;
            }
            return _.some(recipients.models, function(recipient) {
                return recipient.get('_invalid');
            });
        }, this);
    },

    /**
     * Open the drawer with the EmailTemplates selection list layout. The callback should take the data passed to it
     * and replace the existing editor contents with the selected template.
     */
    launchTemplateDrawer: function() {
        app.drawer.open({
                layout: 'selection-list',
                context: {
                    module: 'EmailTemplates'
                }
            },
            _.bind(this.templateDrawerCallback, this)
        );
    },

    /**
     * Receives the selected template to insert and begins the process of confirming the operation and inserting the
     * template into the editor.
     *
     * @param {Data.Bean} model
     */
    templateDrawerCallback: function(model) {
        if (model) {
            var emailTemplate = app.data.createBean('EmailTemplates', { id: model.id });
            emailTemplate.fetch({
                success: _.bind(this.confirmTemplate, this),
                error: _.bind(function(model, error) {
                    this._showServerError(error);
                }, this)
            });
        }
    },

    /**
     * Presents the user with a confirmation prompt indicating that inserting the template will replace all content
     * in the editor. If the user confirms "yes" then the template will inserted.
     *
     * @param {Data.Bean} template
     */
    confirmTemplate: function(template) {
        if (this.disposed === true) return; //if view is already disposed, bail out
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_EMAILTEMPLATE_MESSAGE_SHOW_MSG', this.module),
            onConfirm: _.bind(this.insertTemplate, this, template)
        });
    },

    /**
     * Inserts the template into the editor.
     *
     * @param {Data.Bean} template
     */
    insertTemplate: function(template) {
        var subject,
            notes;

        if (_.isObject(template)) {
            subject = template.get('subject');

            if (subject) {
                this.model.set('name', subject);
            }

            //TODO: May need to move over replaces special characters.
            if (template.get('text_only') === 1) {
                this.model.set('description_html', template.get('body'));
            } else {
                this.model.set('description_html', template.get('body_html'));
            }

            notes = app.data.createBeanCollection('Notes');

            notes.fetch({
                'filter': {
                    'filter': [
                        //FIXME: email_type should be EmailTemplates
                        {'email_id': {'$equals': template.id}}
                    ]
                },
                success: _.bind(function(data) {
                    if (this.disposed === true) return; //if view is already disposed, bail out
                    if (!_.isEmpty(data.models)) {
                        this.insertTemplateAttachments(data.models);
                    }
                }, this),
                error: _.bind(function(collection, error) {
                    this._showServerError(error);
                }, this)
            });

            // currently adds the html signature even when the template is text-only
            this._updateEditorWithSignature(this._lastSelectedSignature);
        }
    },

    /**
     * Inserts attachments associated with the template by triggering an "add" event for each attachment to add to the
     * attachments field.
     *
     * @param {Array} attachments
     */
    insertTemplateAttachments: function(attachments) {
        this.context.trigger('attachments:remove-by-tag', 'template');
        _.each(attachments, function(attachment) {
            var filename = attachment.get('filename');
            this.context.trigger('attachment:add', {
                id: attachment.id,
                name: filename,
                nameForDisplay: filename,
                tag: 'template',
                type: this.ATTACH_TYPE_TEMPLATE
            });
        }, this);
    },

    /**
     * Launch the file upload picker on the attachments field.
     */
    launchFilePicker: function() {
        this.context.trigger('attachment:filepicker:launch');
    },

    /**
     * Open the drawer with the SugarDocuments attachment selection list layout. The callback should take the data
     * passed to it and add the document as an attachment.
     */
    launchDocumentDrawer: function() {
        app.drawer.open({
                layout: 'selection-list',
                context: {module: 'Documents'}
            },
            _.bind(this.documentDrawerCallback, this)
        );
    },

    /**
     * Fetches the selected SugarDocument using its ID and triggers an "add" event to add the attachment to the
     * attachments field.
     *
     * @param {Data.Bean} model
     */
    documentDrawerCallback: function(model) {
        if (model) {
            var sugarDocument = app.data.createBean('Documents', { id: model.id });
            sugarDocument.fetch({
                success: _.bind(function(model) {
                    if (this.disposed === true) return; //if view is already disposed, bail out
                    this.context.trigger('attachment:add', {
                        id: model.id,
                        name: model.get('filename'),
                        nameForDisplay: model.get('filename'),
                        type: this.ATTACH_TYPE_SUGAR_DOCUMENT
                    });
                }, this),
                error: _.bind(function(model, error) {
                    this._showServerError(error);
                }, this)
            });
        }
    },

    /**
     * Hide attachment field row if no attachments, show when added
     *
     * @param {Array} attachments
     */
    toggleAttachmentVisibility: function(attachments) {
        var $row = this.$('.attachments').closest('.row-fluid');
        if (attachments.length > 0) {
            $row.removeClass('hidden');
            $row.addClass('single');
        } else {
            $row.addClass('hidden');
            $row.removeClass('single');
        }
        this.resizeEditor();
    },

    /**
     * Open the drawer with the signature selection layout. The callback should take the data passed to it and insert
     * the signature in the correct place.
     *
     * @private
     */
    launchSignatureDrawer: function() {
        app.drawer.open(
            {
                layout: 'selection-list',
                context: {
                    module: 'UserSignatures'
                }
            },
            _.bind(this._updateEditorWithSignature, this)
        );
    },

    /**
     * Fetches the signature content using its ID and updates the editor with the content.
     *
     * @param {Data.Bean} model
     */
    _updateEditorWithSignature: function(model) {
        if (model && model.id) {
            var signature = app.data.createBean('UserSignatures', { id: model.id });

            signature.fetch({
                success: _.bind(function(model) {
                    if (this.disposed === true) return; //if view is already disposed, bail out
                    if (this._insertSignature(model)) {
                        this._lastSelectedSignature = model;
                    }
                }, this),
                error: _.bind(function(model, error) {
                    this._showServerError(error);
                }, this)
            });
        }
    },

    /**
     * Inserts the signature into the editor.
     *
     * @param {Data.Bean} signature
     * @return {Boolean}
     * @private
     */
    _insertSignature: function(signature) {
        if (_.isObject(signature) && signature.get('signature_html')) {
            var signatureContent = this._formatSignature(signature.get('signature_html')),
                emailBody = this.model.get('description_html') || '',
                signatureOpenTag = '<br class="signature-begin" />',
                signatureCloseTag = '<br class="signature-end" />',
                signatureOpenTagForRegex = '(<br\ class=[\'"]signature\-begin[\'"].*?\/?>)',
                signatureCloseTagForRegex = '(<br\ class=[\'"]signature\-end[\'"].*?\/?>)',
                signatureOpenTagMatches = emailBody.match(new RegExp(signatureOpenTagForRegex, 'gi')),
                signatureCloseTagMatches = emailBody.match(new RegExp(signatureCloseTagForRegex, 'gi')),
                regex = new RegExp(signatureOpenTagForRegex + '[\\s\\S]*?' + signatureCloseTagForRegex, 'g');

            if (signatureOpenTagMatches && !signatureCloseTagMatches) {
                // there is a signature, but no close tag; so the signature runs from open tag until EOF
                emailBody = this._insertSignatureTag(emailBody, signatureCloseTag, false); // append the close tag
            } else if (!signatureOpenTagMatches && signatureCloseTagMatches) {
                // there is a signature, but no open tag; so the signature runs from BOF until close tag
                emailBody = this._insertSignatureTag(emailBody, signatureOpenTag, true); // prepend the open tag
            } else if (!signatureOpenTagMatches && !signatureCloseTagMatches) {
                // there is no signature, so add the tag to the correct location
                emailBody = this._insertSignatureTag(
                    emailBody,
                    signatureOpenTag + signatureCloseTag, // insert both tags as one
                    (app.user.getPreference('signature_prepend') == 'true'));
            }

            this.model.set('description_html', emailBody.replace(regex, '$1' + signatureContent + '$2'));

            return true;
        }

        return false;
    },

    /**
     * Inserts a tag into the editor to surround the signature so the signature can be identified again.
     *
     * @param {string} body
     * @param {string} tag
     * @param {string} prepend
     * @return {string}
     * @private
     */
    _insertSignatureTag: function(body, tag, prepend) {
        var preSignature = '',
            postSignature = '';

        prepend = prepend || false;

        if (prepend) {
            var bodyOpenTag = '<body>',
                bodyOpenTagLoc = body.indexOf(bodyOpenTag);

            if (bodyOpenTagLoc > -1) {
                preSignature = body.substr(0, bodyOpenTagLoc + bodyOpenTag.length);
                postSignature = body.substr(bodyOpenTagLoc + bodyOpenTag.length, body.length);
            } else {
                postSignature = body;
            }
        } else {
            var bodyCloseTag = '</body>',
                bodyCloseTagLoc = body.indexOf(bodyCloseTag);

            if (bodyCloseTagLoc > -1) {
                preSignature = body.substr(0, bodyCloseTagLoc);
                postSignature = body.substr(bodyCloseTagLoc, body.length);
            } else {
                preSignature = body;
            }
        }

        return preSignature + tag + postSignature;
    },

    /**
     * Formats HTML signatures to replace select HTML-entities with their true characters.
     *
     * @param {string} signature
     */
    _formatSignature: function(signature) {
        signature = signature.replace(/&lt;/gi, '<');
        signature = signature.replace(/&gt;/gi, '>');

        return signature;
    },

    /**
     * Show a generic alert for server errors resulting from custom API calls during Email Compose workflows. Logs
     * the error message for system administrators as well.
     *
     * @param {SUGAR.HttpError} error
     * @private
     */
    _showServerError: function(error) {
        app.alert.show('server-error', {
            level: 'error',
            messages: 'ERR_GENERIC_SERVER_ERROR'
        });
        app.error.handleHttpError(error);
    },

    /**
     * When toggling to show/hide hidden panel, resize editor accordingly
     */
    handleMoreLessToggled: function() {
        this.resizeEditor();
    },

    /**
     * When TinyMCE has been completely initialized, go ahead and resize the editor
     */
    handleTinyMceInit: function() {
        this.resizeEditor();
    },

    _dispose: function() {
        if (app.drawer) {
            app.drawer.off(null, null, this);
        }
        app.alert.dismiss('email-client-status');
        this._super('_dispose');
    },

    /**
     * Register keyboard shortcuts.
     */
    registerShortcuts: function() {
        app.shortcuts.register({
            id: 'Compose:Action:More',
            keys: 'm',
            component: this,
            description: 'LBL_SHORTCUT_OPEN_MORE_ACTION',
            handler: function() {
                var $primaryDropdown = this.$('.btn-primary[data-toggle=dropdown]');
                if ($primaryDropdown.is(':visible') && !$primaryDropdown.hasClass('disabled')) {
                    $primaryDropdown.click();
                }
            }
        });
        this._super('registerShortcuts');
    },

    /**
     * Resize the html editor based on height of the drawer it is in
     *
     * @param {number} [drawerHeight] current height of the drawer or height the drawer will be after animations
     */
    resizeEditor: function(drawerHeight) {
        var $editor, headerHeight, recordHeight, showHideHeight, diffHeight, editorHeight, newEditorHeight;

        $editor = this.$('.mce-stack-layout .mce-stack-layout-item iframe');
        //if editor not already rendered, cannot resize
        if ($editor.length === 0) {
            return;
        }

        drawerHeight = drawerHeight || app.drawer.getHeight();
        headerHeight = this.$('.headerpane').outerHeight(true);
        recordHeight = this.$('.record').outerHeight(true);
        showHideHeight = this.$('.show-hide-toggle').outerHeight(true);
        editorHeight = $editor.height();

        //calculate the space left to fill - subtracting padding to prevent scrollbar
        diffHeight = drawerHeight - headerHeight - recordHeight - showHideHeight -
            this.ATTACHMENT_FIELD_HEIGHT - this.EDITOR_RESIZE_PADDING;

        //add the space left to fill to the current height of the editor to get a new height
        newEditorHeight = editorHeight + diffHeight;

        //maintain min height
        if (newEditorHeight < this.MIN_EDITOR_HEIGHT) {
            newEditorHeight = this.MIN_EDITOR_HEIGHT;
        }

        //set the new height for the editor
        $editor.height(newEditorHeight);
    },

    /**
     * Turn off logic from record view which handles clicking the cancel button
     * as it causes issues for email compose.
     *
     * TODO: Remove this when record view changes to use button events instead
     * of DOM based events
     */
    cancelClicked: $.noop
}) },
"compose-addressbook-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.ComposeAddressbookHeaderpaneView
 * @alias SUGAR.App.view.views.BaseEmailsComposeAddressbookHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Compose-addressbook-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click [name=done_button]': '_done',
        'click [name=cancel_button]': '_cancel'
    },

     /**
      * The user clicked the Done button so trigger an event to add selected recipients from the address book to the
      * target field and then close the drawer.
      *
      * @private
      */
     _done: function() {
         var recipients = this.model.get('to_collection');

         if (recipients) {
             app.drawer.close(recipients);
         } else {
             this._cancel();
         }
     },

    /**
     * Close the drawer.
     *
     * @private
     */
    _cancel: function() {
        app.drawer.close();
    }
}) },
"compose-addressbook-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.ComposeAddressbookFilterView
 * @alias SUGAR.App.view.views.BaseEmailsComposeAddressbookFilterView
 * @extends View.View
 */
({
	// Compose-addressbook-filter View (base) 

    _moduleFilterList: [],
    _allModulesId: 'All',
    _selectedModule: null,
    _currentSearch: '',
    events: {
        'keyup .search-name': 'throttledSearch',
        'paste .search-name': 'throttledSearch',
        'click .add-on.fa-times': 'clearInput'
    },

    /**
     * Converts the input field to a select2 field and adds the module filter for refining the search.
     *
     * @private
     */
    _render: function() {
        app.view.View.prototype._render.call(this);
        this.buildModuleFilterList();
        this.buildFilter();
    },

    /**
     * Builds the list of allowed modules to provide the data to the select2 field.
     */
    buildModuleFilterList: function() {
        var allowedModules = this.collection.allowed_modules;

        this._moduleFilterList = [
            {id: this._allModulesId, text: app.lang.get('LBL_MODULE_ALL')}
        ];

        _.each(allowedModules, function(module) {
            this._moduleFilterList.push({
                id: module,
                text: app.lang.getModuleName(module, {plural: true})
            });
        }, this);
    },

    /**
     * Converts the input field to a select2 field and initializes the selected module.
     */
    buildFilter: function() {
        var $filter = this.getFilterField();
        if ($filter.length > 0) {
            $filter.select2({
                data: this._moduleFilterList,
                allowClear: false,
                multiple: false,
                minimumResultsForSearch: -1,
                formatSelection: _.bind(this.formatModuleSelection, this),
                formatResult: _.bind(this.formatModuleChoice, this),
                dropdownCss: {width: 'auto'},
                dropdownCssClass: 'search-filter-dropdown',
                initSelection: _.bind(this.initSelection, this),
                escapeMarkup: function(m) { return m; },
                width: 'off'
            });
            $filter.off('change');
            $filter.on('change', _.bind(this.handleModuleSelection, this));
            this._selectedModule = this._selectedModule || this._allModulesId;
            $filter.select2('val', this._selectedModule);
        }
    },

    /**
     * Gets the filter DOM field.
     *
     * @return {jQuery} DOM Element
     */
    getFilterField: function() {
        return this.$('input.select2');
    },

    /**
     * Gets the module filter DOM field.
     *
     * @return {jQuery} DOM Element
     */
    getModuleFilter: function() {
        return this.$('span.choice-filter-label');
    },

    /**
     * Destroy the select2 plugin.
     */
    unbind: function() {
        $filter = this.getFilterField();
        if ($filter.length > 0) {
            $filter.off();
            $filter.select2('destroy');
        }
        this._super('unbind');
    },

    /**
     * Performs a search once the user has entered a term.
     */
    throttledSearch: _.debounce(function(evt) {
        var newSearch = this.$(evt.currentTarget).val();
        if (this._currentSearch !== newSearch) {
            this._currentSearch = newSearch;
            this.applyFilter();
        }
    }, 400),

    /**
     * Initialize the module selection with the value for all modules.
     *
     * @param {jQuery} el
     * @param {Function} callback
     */
    initSelection: function(el, callback) {
        if (el.is(this.getFilterField())) {
            var module = _.findWhere(this._moduleFilterList, {id: el.val()});
            callback({id: module.id, text: module.text});
        }
    },

    /**
     * Format the selected module to display its name.
     *
     * @param {Object} item
     * @return {String}
     */
    formatModuleSelection: function(item) {
        // update the text for the selected module
        this.getModuleFilter().html(item.text);
        return '<span class="select2-choice-type">' +
            app.lang.get('LBL_MODULE') +
            '<i class="fa fa-caret-down"></i></span>';
    },

    /**
     * Format the choices in the module select box.
     *
     * @param {Object} option
     * @return {String}
     */
    formatModuleChoice: function(option) {
        return '<div><span class="select2-match"></span>' + option.text + '</div>';
    },

    /**
     * Handler for when the module filter dropdown value changes, either via a click or manually calling jQuery's
     * .trigger("change") event.
     *
     * @param {Object} evt jQuery Change Event Object
     * @param {string} overrideVal (optional) ID passed in when manually changing the filter dropdown value
     */
    handleModuleSelection: function(evt, overrideVal) {
        var module = overrideVal || evt.val || this._selectedModule || this._allModulesId;
        // only perform a search if the module is in the approved list
        if (!_.isEmpty(_.findWhere(this._moduleFilterList, {id: module}))) {
            this._selectedModule = module;
            this.getFilterField().select2('val', this._selectedModule);
            this.getModuleFilter().css('cursor', 'pointer');
            this.applyFilter();
        }
    },

    /**
     * Triggers an event that makes a call to search the address book and filter the data set.
     */
    applyFilter: function() {
        var searchAllModules = (this._selectedModule === this._allModulesId),
            // pass an empty array when all modules are being searched
            module = searchAllModules ? [] : [this._selectedModule],
            // determine if the filter is dirty so the "clearQuickSearchIcon" can be added/removed appropriately
            isDirty = !_.isEmpty(this._currentSearch);
        this._toggleClearQuickSearchIcon(isDirty);
        this.context.trigger('compose:addressbook:search', module, this._currentSearch);
    },

    /**
     * Append or remove an icon to the quicksearch input so the user can clear the search easily.
     * @param {Boolean} addIt TRUE if you want to add it, FALSE to remove
     */
    _toggleClearQuickSearchIcon: function(addIt) {
        if (addIt && !this.$('.add-on.fa-times')[0]) {
            this.$('.filter-view.search').append('<i class="add-on fa fa-times"></i>');
        } else if (!addIt) {
            this.$('.add-on.fa-times').remove();
        }
    },

    /**
     * Clear input
     */
    clearInput: function() {
        var $filter = this.getFilterField();
        this._currentSearch = '';
        this._selectedModule = this._allModulesId;
        this.$('.search-name').val(this._currentSearch);
        if ($filter.length > 0) {
            $filter.select2('val', this._selectedModule);
        }
        this.applyFilter();
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.RecordView
 * @alias SUGAR.App.view.views.BaseEmailsRecordView
 * @extends View.Views.Base.RecordView
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * Constant representing the state of an email when it is a draft.
     *
     * @property {string}
     */
    STATE_DRAFT: 'Draft',

    /**
     * @inheritdoc
     *
     * Alerts the user if the email is a draft, so that user can switch to
     * composing the email instead of simply viewing it.
     */
    initialize: function(options) {
        var loadingRequests = 0;

        this._super('initialize', [options]);

        this._alertUserDraftState();

        this.on('loading_collection_field', function() {
            loadingRequests++;
            this.toggleButtons(false);
        }, this);

        this.on('loaded_collection_field', function() {
            loadingRequests--;

            if (loadingRequests === 0) {
                this.toggleButtons(true);
            }
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Alerts the user if the email becomes a draft -- most likely due to
     * asynchronous data patching -- so that user can switch to composing the
     * email instead of simply viewing it.
     *
     * Renders the recipients fieldset anytime there are changes to the From,
     * To, CC, or BCC fields.
     */
    bindDataChange: function() {
        var self = this;

        /**
         * Render the specified recipients field.
         *
         * @param {string} fieldName
         */
        function renderRecipientsField(fieldName) {
            var field = self.getField(fieldName);

            if (field) {
                field.render();
            }
        }

        if (this.model) {
            this.listenTo(this.model, 'change:state', function() {
                this._alertUserDraftState();
                this.setButtonStates(this.getCurrentButtonState());
            });

            this.listenTo(this.model, 'change:from_collection', function() {
                renderRecipientsField('from_collection');
            });
            this.listenTo(this.model, 'change:to_collection', function() {
                renderRecipientsField('to_collection');
            });
            this.listenTo(this.model, 'change:cc_collection', function() {
                renderRecipientsField('cc_collection');
            });
            this.listenTo(this.model, 'change:bcc_collection', function() {
                renderRecipientsField('bcc_collection');
            });
        }

        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     *
     * Adds the view parameter. It must be added to `options.params` because
     * the `options.view` is only added as a parameter if the request method is
     * "read".
     */
    getCustomSaveOptions: function(options) {
        options = options || {};
        options.params = options.params || {};
        options.params.view = this.name;

        return options;
    },

    /**
     * @inheritdoc
     *
     * Switches to the email compose route if the email is a draft.
     */
    editClicked: function() {
        if (this._isEditableDraft()) {
            this._navigateToEmailCompose();
        } else {
            this._super('editClicked');
        }
    },

    /**
     * @inheritdoc
     *
     * Hides the Forward, Reply, and Reply All buttons if the email is a draft.
     */
    setButtonStates: function(state) {
        var buttons;
        var buttonsToHideOnDrafts;

        /**
         * Some buttons contain other buttons, like ActiondropdownField. This
         * function recursively finds all buttons starting at the root.
         *
         * @param {Array} allButtons The set of buttons that have been found so
         * far. Begin with an empty array to prime the set.
         * @param {Object|Array} root A collection of button fields.
         * @return {Array}
         */
        function getAllButtons(allButtons, root) {
            var nestedButtons = _.flatten(_.compact(_.pluck(root, 'fields')));

            if (nestedButtons.length > 0) {
                allButtons = allButtons.concat(nestedButtons);
                allButtons = getAllButtons(allButtons, nestedButtons);
            }

            return allButtons;
        }

        this._super('setButtonStates', [state]);

        if (this.model.get('state') === this.STATE_DRAFT) {
            buttons = getAllButtons([], this.buttons);
            buttonsToHideOnDrafts = _.filter(buttons, function(field) {
                return _.contains(['reply_button', 'reply_all_button', 'forward_button'], field.name);
            });

            _.each(buttonsToHideOnDrafts, function(field) {
                field.hide();
            });
        }
    },

    /**
     * Alerts the user if a draft was opened in the record view, so the user
     * can switch to composing the email instead of simply viewing it.
     *
     * @private
     */
    _alertUserDraftState: function() {
        app.alert.dismiss('email-draft-alert');

        if (this._isEditableDraft()) {
            app.alert.show('email-draft-alert', {
                level: 'warning',
                autoClose: false,
                title: ' ',
                messages: app.lang.get('LBL_OPEN_DRAFT_ALERT', this.module, {subject: this.model.get('name')}),
                onLinkClick: _.bind(function(event) {
                    app.alert.dismiss('email-draft-alert');
                    this._navigateToEmailCompose();
                }, this)
            });
        }
    },

    /**
     * @inheritdoc
     *
     * @return {string} Returns (no subject) when the record name is empty.
     */
    _getNameForMessage: function(model) {
        var name = this._super('_getNameForMessage', [model]);

        if (_.isEmpty(name)) {
            return app.lang.get('LBL_NO_SUBJECT', this.module);
        }

        return name;
    },

    /**
     * Determines the email is a draft and the user can edit it.
     *
     * @return {boolean}
     * @private
     */
    _isEditableDraft: function() {
        return this.model.get('state') === this.STATE_DRAFT && app.acl.hasAccessToModel('edit', this.model);
    },

    /**
     * Switches to the email compose route for the email. This method should
     * only be used if the email is a draft.
     *
     * @private
     */
    _navigateToEmailCompose: function() {
        var route;

        if (this._isEditableDraft()) {
            route = '#' + app.router.buildRoute(this.model.module, this.model.get('id'), 'compose');
            app.router.navigate(route, {trigger: true});
        }
    }
}) },
"archive-email": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.ArchiveEmailView
 * @alias SUGAR.App.view.views.BaseEmailsArchiveEmailView
 * @extends View.Views.Base.Emails.ComposeView
 * @deprecated Use {@link View.Views.Base.Emails.CreateView} instead.
 */
({
	// Archive-email View (base) 

    extendsFrom: 'EmailsComposeView',

    /**
     * @inheritdoc
     *
     * Add click event handler to archive an email.
     */
    initialize: function(options) {
        app.logger.warn(
            'View.Views.Base.Emails.ArchiveEmailView is deprecated. Use View.Views.Base.Emails.CreateView instead.'
        );

        this.events = _.extend({}, this.events, {
            'click [name=archive_button]': 'archive'
        });
        this._super('initialize', [options]);

        if (!this.model.has('assigned_user_id')) {
            this.model.set('assigned_user_id', app.user.id);
            this.model.set('assigned_user_name', app.user.get('full_name'));
        }
    },

    /**
     * Set headerpane title.
     * @private
     */
    _render: function() {
        var $controls;

        this._super('_render');

        $controls = this.$('.control-group:not(.hide) .control-label');
        if ($controls.length) {
            $controls.last().addClass('end-fieldgroup');
        }

        this.setTitle(app.lang.get('LBL_ARCHIVE_EMAIL', this.module));
    },

    /**
     * Archive email if validation passes.
     */
    archive: function(event) {
        this.setMainButtonsDisabled(true);
        this.model.doValidate(this.getFieldsToValidate(), _.bind(function(isValid) {
            if (isValid) {
                this.archiveEmail();
            } else {
                this.setMainButtonsDisabled(false);
            }
        }, this));
    },

    /**
     * Get fields that needs to be validated.
     * @return {Object}
     */
    getFieldsToValidate: function() {
        var fields = {};
        _.each(this.fields, function(field) {
            fields[field.name] = field.def;
        });
        return fields;
    },

    /**
     * Call archive api.
     */
    archiveEmail: function() {
        var archiveUrl = app.api.buildURL('Mail/archive');
        var alertKey = 'mail_archive';
        var archiveEmailModel = this.initializeSendEmailModel();

        app.alert.show(alertKey, {level: 'process', title: app.lang.get('LBL_EMAIL_ARCHIVING', this.module)});

        app.api.call('create', archiveUrl, archiveEmailModel, {
            success: _.bind(function() {
                app.alert.dismiss(alertKey);
                app.alert.show(alertKey, {
                    autoClose: true,
                    level: 'success',
                    messages: app.lang.get('LBL_EMAIL_ARCHIVED', this.module)
                });
                app.drawer.close(this.model);
            }, this),
            error: function(error) {
                var msg = {level: 'error'};
                if (error && _.isString(error.message)) {
                    msg.messages = error.message;
                }
                app.alert.dismiss(alertKey);
                app.alert.show(alertKey, msg);
            },
            complete: _.bind(function() {
                if (!this.disposed) {
                    this.setMainButtonsDisabled(false);
                }
            }, this)
        });
    },

    /**
     * @inheritdoc
     */
    initializeSendEmailModel: function() {
        var model = this._super('initializeSendEmailModel');
        model.set({
            'date_sent': this.model.get('date_sent'),
            'from_address': this.model.get('from_address'),
            'status': 'archive',
            'state': 'Archived'
        });
        return model;
    },

    /**
     * Disable/enable archive button.
     * @param {boolean} disabled
     */
    setMainButtonsDisabled: function(disabled) {
        this.getField('archive_button').setDisabled(disabled);
    },

    /**
     * No need to warn of configuration status for archive email because no
     * email is being sent.
     */
    notifyConfigurationStatus: $.noop
}) },
"compose-addressbook-list-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.ComposeAddressbookListBottomView
 * @alias SUGAR.App.view.views.BaseEmailsComposeAddressbookListBottomView
 * @extends View.Views.Base.ListBottomView
 */
({
	// Compose-addressbook-list-bottom View (base) 

    extendsFrom: 'ListBottomView',

    /**
     * Assign proper label for 'show more' link.
     * Label should be "More recipients...".
     */
    setShowMoreLabel: function() {
        this.showMoreLabel = app.lang.get('LBL_SHOW_MORE_RECIPIENTS', this.module);
    }
}) },
"compose-addressbook-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Emails.ComposeAddressbookListView
 * @alias SUGAR.App.view.views.BaseEmailsComposeAddressbookListView
 * @extends View.Views.Base.FlexListView
 */
({
	// Compose-addressbook-list View (base) 

    extendsFrom: 'FlexListView',

    /**
     * Changed the address book view to use an independent mass collection
     *
     * The address book collection is not the same as the list view
     * collection and therefore we need to preserve the state of the address
     * book collection through changes to the list view collection.
     * `independentMassCollection: true` allows us to indicate that the
     * collections should not be treated as the same so that we are always
     * adding to the collection instead of resetting with completely new data.
     *
     * @property {boolean}
     */
    independentMassCollection: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var plugins = [
            'ListColumnEllipsis',
            'Pagination',
            'MassCollection'
        ];

        this.plugins = _.union(this.plugins || [], plugins);
        this._super('initialize', [options]);
    },

    /**
     * Removes the event listeners that were added to the mass collection.
     *
     * @inheritdoc
     */
    unbindData: function() {
        var massCollection = this.context.get('mass_collection');

        if (massCollection) {
            this.stopListening(massCollection);
        }

        this._super('unbindData');
    },

    /**
     * Listens for changes to the list's mass collection. Anytime new rows are
     * selected or deselected, those models are synchronized in the selected
     * recipients collection (`this.model.get('to_collection')`).
     *
     * When the user enters a search term, the list is re-rendered with the
     * results of the search. Any recipients in the result set that have
     * already been selected are checked automatically.
     *
     * @inheritdoc
     */
    _render: function() {
        var massCollection = this.context.get('mass_collection');
        var selectedRecipients;
        var selectedRecipientsInList;

        /**
         * Models in the mass collection may be beans for Contacts, Leads, etc.
         * Those beans need to be converted to EmailParticipants beans when
         * they are added to the selected recipients collection.
         *
         * @param {Data|Bean} model
         * @return {Data|Bean}
         */
        function convertModelToEmailParticipant(model) {
            return app.data.createBean('EmailParticipants', {
                _link: 'to',
                parent: {
                    _acl: model.get('_acl') || {},
                    _erased_fields: model.get('_erased_fields') || [],
                    type: model.module,
                    id: model.get('id'),
                    name: model.get('name')
                },
                parent_type: model.module,
                parent_id: model.get('id'),
                parent_name: model.get('name')
            });
        }

        this._super('_render');

        selectedRecipients = this.model.get('to_collection');

        if (massCollection) {
            // Stop listening to changes on the mass collection. Those event
            // handlers will be recreated.
            this.stopListening(massCollection);

            // A single row was checked or all rows were checked.
            this.listenTo(massCollection, 'add', function(model) {
                var ep = convertModelToEmailParticipant(model);

                selectedRecipients.add(ep);
            });

            // A single row was unchecked or all rows were unchecked.
            this.listenTo(massCollection, 'remove', function(model) {
                var existingRecipient = selectedRecipients.findWhere({parent_id: model.get('id')});

                selectedRecipients.remove(existingRecipient);
            });

            // The mass collection was cleared. Only remove the recipients from
            // the selected recipients collection that are visible in the list
            // view.
            this.listenTo(massCollection, 'reset', function(newCollection, prevCollection) {
                var resetRecipients;
                var selectedRecipientsNotInList = _.difference(prevCollection.previousModels, this.collection.models);

                newCollection.add(selectedRecipientsNotInList);
                resetRecipients = _.map(newCollection.models, convertModelToEmailParticipant);
                selectedRecipients.reset(resetRecipients);
            });

            if (selectedRecipients.length > 0) {
                // Only add, to the mass collection, recipients that are
                // visible in the list view.
                selectedRecipientsInList = this.collection.filter(function(model) {
                    return !!selectedRecipients.findWhere({parent_id: model.get('id')});
                });
                massCollection.add(selectedRecipientsInList);
            }
        }
    }
}) }
}}
,
"layouts": {
"base": {
"compose-documents": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Emails.ComposeDocumentsLayout
 * @alias SUGAR.App.view.layouts.BaseEmailsComposeDocumentsLayout
 * @extends View.Layout
 * @deprecated Use {@link View.Layouts.Base.SelectionListLayout} instead.
 */
({
	// Compose-documents Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Layouts.Base.Emails.ComposeDocumentsLayout is deprecated.');

        this._super('initialize', [options]);
    }
}) },
"records": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Emails.RecordsLayout
 * @alias SUGAR.App.view.layouts.BaseEmailsRecordsLayout
 * @extends View.Layouts.Base.RecordsLayout
 */
({
	// Records Layout (base) 

    extendsFrom: 'RecordsLayout',

    /**
     * @inheritdoc
     *
     * Remove shortcuts that do not apply to Emails module list view
     */
    initialize: function(options) {
        this.shortcuts = _.without(
            this.shortcuts,
            'List:Favorite',
            'List:Follow'
        );

        this._super('initialize', [options]);
    }
}) },
"archive-email": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Emails.ArchiveEmailLayout
 * @alias SUGAR.App.view.layouts.BaseEmailsArchiveEmailLayout
 * @extends View.Layouts.Base.Emails.CreateLayout
 * @deprecated Use {@link View.Layouts.Base.Emails.CreateLayout} instead.
 */
({
	// Archive-email Layout (base) 

    extendsFrom: 'EmailsCreateLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Layouts.Base.Emails.ArchiveEmailLayout is deprecated. ' +
            'Use View.Layouts.Base.Emails.CreateLayout instead.');

        this._super('initialize', [options]);
    }
}) },
"compose-email": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Emails.ComposeEmailLayout
 * @alias SUGAR.App.view.layouts.BaseEmailsComposeEmailLayout
 * @extends View.Layouts.Base.Emails.CreateLayout
 */
({
	// Compose-email Layout (base) 

    extendsFrom: 'EmailsCreateLayout',

    /**
     * @inheritdoc
     *
     * Enables the Compose:Send shortcut for views that implement it.
     */
    initialize: function(options) {
        this.shortcuts = _.union(this.shortcuts || [], ['Compose:Send']);
        this._super('initialize', [options]);
    }
}) },
"compose-addressbook": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Emails.ComposeAddressbookLayout
 * @alias SUGAR.App.view.layouts.BaseEmailsComposeAddressbookLayout
 * @extends View.Layout
 */
({
	// Compose-addressbook Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.view.Layout.prototype.initialize.call(this, options);
        this.collection.sync = this.sync;
        this.collection.allowed_modules = ['Accounts', 'Contacts', 'Leads', 'Prospects', 'Users'];
        this.context.on('compose:addressbook:search', this.search, this);
    },
    /**
     * Calls the custom Mail API endpoint to search for email addresses.
     *
     * @param {string} method
     * @param {Data.Bean} model
     * @param {Object} options
     */
    sync: function(method, model, options) {
        var callbacks;
        var url;
        var success;

        options = options || {};

        // only fetch from the approved modules
        if (_.isEmpty(options.module_list)) {
            options.module_list = ['all'];
        } else {
            options.module_list = _.intersection(this.allowed_modules, options.module_list);
        }

        // this is a hack to make pagination work while trying to minimize the affect on existing configurations
        // there is a bug that needs to be fixed before the correct approach (config.maxQueryResult vs. options.limit)
        // can be determined
        app.config.maxQueryResult = app.config.maxQueryResult || 20;
        options.limit = options.limit || app.config.maxQueryResult;

        // Is there already a success callback?
        if (options.success) {
            success = options.success;
        }

        // Map the response so that the email field data is packaged as an
        // array of objects. The email field component expects the data to be
        // in that format.
        options.success = function(data) {
            if (_.isArray(data)) {
                data = _.map(data, function(row) {
                    row.email = [{
                        email_address: row.email,
                        email_address_id: row.email_address_id,
                        opt_out: row.opt_out,
                        // The email address must be seen as the primary email
                        // address to be shown in a list view.
                        primary_address: true
                    }];

                    // Remove the properties that are now stored in the nested
                    // email array.
                    delete row.opt_out;
                    delete row.email_address_id;

                    return row;
                });
            }

            // Call the original success callback.
            if (success) {
                success(data);
            }
        };

        options = app.data.parseOptionsForSync(method, model, options);
        options.params.erased_fields = true;

        callbacks = app.data.getSyncCallbacks(method, model, options);
        this.trigger('data:sync:start', method, model, options);

        url = app.api.buildURL('Mail', 'recipients/find', null, options.params);
        app.api.call('read', url, null, callbacks);
    },
    /**
     * Adds the set of modules and term that should be used to search for recipients.
     *
     * @param {Array} modules
     * @param {String} term
     */
    search: function(modules, term) {
        // reset offset to 0 on a search. make sure that it resets and does not update.
        this.collection.fetch({query: term, module_list: modules, offset: 0, update: false});
    }
}) },
"compose": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Emails.ComposeLayout
 * @alias SUGAR.App.view.layouts.BaseEmailsComposeLayout
 * @extends View.Layouts.Base.Emails.CreateLayout
 * @deprecated Use {@link View.Layouts.Base.Emails.ComposeEmailLayout} instead.
 */
({
	// Compose Layout (base) 

    extendsFrom: 'EmailsCreateLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.logger.warn('View.Layouts.Base.Emails.ComposeLayout is deprecated. ' +
            'Use View.Layouts.Base.Emails.ComposeEmailLayout instead.');

        this._super('initialize', [options]);
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Emails.CreateLayout
 * @alias SUGAR.App.view.layouts.BaseEmailsCreateLayout
 * @extends View.Layouts.Base.CreateLayout
 */
({
	// Create Layout (base) 

    extendsFrom: 'CreateLayout',

    /**
     * @inheritdoc
     *
     * Enables the DragdropSelect2:SelectAll shortcut for views that implement
     * it.
     */
    initialize: function(options) {
        this.shortcuts = _.union(this.shortcuts || [], ['DragdropSelect2:SelectAll']);
        this._super('initialize', [options]);
    }
}) }
}}
,
"datas": {}

},
		"Meetings":{"fieldTemplates": {
"base": {
"launchbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Button to launch an external meeting
 *
 * @class View.Fields.Base.Meetings.LaunchbuttonField
 * @alias SUGAR.App.view.fields.BaseMeetingsLaunchbuttonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Launchbutton FieldTemplate (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
        this.isHost = (this.def.host === true);
    },

    /**
     * @inheritdoc
     *
     * Hide this button if:
     * - Status is not Planned
     * - Type is Sugar (not an external meeting type)
     * - Host button and user does not have permission to start the meeting
     */
    _render: function() {
        if (this.model.get('status') !== 'Planned' ||
            this.model.get('type') === 'Sugar' ||
            (this.isHost && !this._hasPermissionToStartMeeting())
        ) {
            this.hide();
        } else {
            this._setLabel();
            this._super('_render');
            this.show();
        }
    },

    /**
     * Check if the user has permission to host the external meeting
     * True if assigned user or an admin for Meetings
     *
     * @return {boolean}
     * @private
     */
    _hasPermissionToStartMeeting: function() {
        return (this.model.get('assigned_user_id') === app.user.id || app.acl.hasAccess('admin', 'Meetings'));
    },

    /**
     * Set the appropriate label for this field
     * Use the Start Meeting label for host
     * Use the Join Meeting label otherwise
     *
     * @private
     */
    _setLabel: function() {
        this.label = (this.isHost) ?
            this._getLabel('LBL_START_MEETING') :
            this._getLabel('LBL_JOIN_MEETING');
    },

    /**
     * Build the appropriate label based on the meeting type
     *
     * @param {string} labelName Meetings module label
     * @return {string}
     * @private
     */
    _getLabel: function(labelName) {
        var meetingTypeStrings = app.lang.getAppListStrings('eapm_list'),
            meetingType = meetingTypeStrings[this.model.get('type')] ||
                app.lang.get('LBL_MODULE_NAME_SINGULAR', this.module);

        return app.lang.get(labelName, this.module, {'meetingType': meetingType});
    },

    /**
     * Event to trigger the join/start of the meeting
     * Call the API first to get the host/join URL and determine if user has permission
     */
    rowActionSelect: function() {
        var url = app.api.buildURL('Meetings', 'external', {id: this.model.id});
        app.api.call('read', url, null, {
            success: _.bind(this._launchMeeting, this),
            error: function() {
                app.alert.show('launch_meeting_error', {
                    level: 'error',
                    messages: app.lang.get('LBL_ERROR_LAUNCH_MEETING_GENERAL', this.module)
                });
            }
        });
    },

    /**
     * Given the external meeting info retrieved from the API, launch the meeting
     * Display an error if user is not permitted to launch the meeting.
     *
     * @param {Object} externalInfo
     * @private
     */
    _launchMeeting: function(externalInfo) {
        var launchUrl = '';

        if (this.disposed) {
            return;
        }

        if (this.isHost && externalInfo.is_host_option_allowed) {
            launchUrl = externalInfo.host_url;
        } else if (!this.isHost && externalInfo.is_join_option_allowed) {
            launchUrl = externalInfo.join_url;
        } else {
            // user is not allowed to launch the external meeting
            app.alert.show('launch_meeting_error', {
                level: 'error',
                messages: app.lang.get(this.isHost ? 'LBL_EXTNOSTART_MAIN' : 'LBL_EXTNOT_MAIN', this.module)
            });
            return;
        }

        if (!_.isEmpty(launchUrl)) {
            window.open(launchUrl);
        } else {
            app.alert.show('launch_meeting_error', {
                level: 'error',
                messages: this._getLabel('LBL_EXTERNAL_MEETING_NO_URL')
            });
        }
    },

    /**
     * Re-render the join button when the model changes
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change', this.render, this);
        }
    }
}) },
"enum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Enum modifications that are specific to Meeting type field
 * These modifications are temporary until the can (hopefully) be addressed in
 * the Enum field refactoring (SC-3481)
 *
 * @class View.Fields.Base.Meetings.EnumField
 * @alias SUGAR.App.view.fields.BaseMeetingsEnumField
 * @extends View.Fields.Base.EnumField
 */
({
	// Enum FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    _render: function() {
        if (this.name === 'type') {
            this._ensureSelectedValueInItems();
        }
        this._super('_render');
    },

    /**
     * Meeting type is a special case where we want to ensure the selected
     * value is an option in the list. This can happen when User A has
     * an external meeting integration set up (ie. WebEx) and sets WebEx as
     * the type. If User B does not have WebEx set up (only needed to create
     * WebEx meetings, not to join), User B should still see WebEx selected
     * on existing meetings, but not be able to create a meeting with WebEx.
     */
    _ensureSelectedValueInItems: function() {
        var value = this.model.get(this.name),
            meetingTypeLabels;

        //if we don't have items list yet or no value previously selected - no work to do
        if (!this.items || _.isEmpty(this.items) || _.isEmpty(value)) {
            return;
        }

        //if selected value is not in the list of items, but is in the list of meeting types...
        meetingTypeLabels = app.lang.getAppListStrings('eapm_list');
        if (_.isEmpty(this.items[value]) && !_.isEmpty(meetingTypeLabels[value])) {
            //...add it to the list
            this.items[value] = meetingTypeLabels[value];
        }
    },

    /**
     * @inheritdoc
     *
     * Remove options for meeting type field which comes from the vardef - this
     * will force a retrieval of options from the server. Options is in the
     * vardef for meeting type to support mobile which does not have the ability
     * to pull dynamic enum list from the server yet.
     */
    loadEnumOptions: function(fetch, callback) {
        if (this.name === 'type') {
            this.def.options = '';
        }
        this._super('loadEnumOptions', [fetch, callback]);
    }
}) }
}}
,
"views": {
"base": {
"resolve-conflicts-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Meetings.ResolveConflictsListView
 * @alias SUGAR.App.view.views.BaseMeetingsResolveConflictsListView
 * @extends View.Views.Base.ResolveConflictsListView
 */
({
	// Resolve-conflicts-list View (base) 

    extendsFrom: 'ResolveConflictsListView',

    /**
     * @inheritdoc
     *
     * The invitees field should not be displayed on list views. It is removed
     * before comparing models so that it doesn't get included.
     */
    _buildFieldDefinitions: function(modelToSave, modelInDb) {
        modelToSave.unset('invitees');
        this._super('_buildFieldDefinitions', [modelToSave, modelInDb]);
    }
}) },
"create-nodupecheck": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Meetings.CreateNodupecheckView
 * @alias SUGAR.App.view.views.MeetingsCreateNodupecheckView
 * @extends View.Views.Base.CreateNodupecheckView
 */
({
	// Create-nodupecheck View (base) 

    extendsFrom: 'CreateNodupecheckView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['AddAsInvitee', 'ReminderTimeDefaults']);
        this._super('initialize', [options]);
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Meetings.CreateView
 * @alias SUGAR.App.view.views.MeetingsCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['AddAsInvitee', 'ReminderTimeDefaults']);
        this._super('initialize', [options]);
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Meetings.RecordView
 * @alias SUGAR.App.view.views.BaseMeetingsRecordView
 * @extends View.Views.Base.RecordView
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['EditAllRecurrences', 'AddAsInvitee']);
        this._super('initialize', [options]);
    }
}) }
}}
,
"layouts": {}
,
"datas": {
"base": {
"model": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class Model.Datas.Base.MeetingsModel
 * @alias SUGAR.App.model.datas.BaseMeetingsModel
 * @extends Model.Bean
 */
({
	// Model Data (base) 

    plugins: ['VirtualCollection']
}) }
}}

},
		"Tasks":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Calendar":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Leads":{"fieldTemplates": {
"base": {
"convertbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Leads.ConvertbuttonField
 * @alias SUGAR.App.view.fields.BaseLeadsConvertbuttonField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Convertbutton FieldTemplate (base) 

    extendsFrom: 'RowactionField',

    initialize: function (options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    _render: function () {
        var convertMeta = app.metadata.getLayout('Leads', 'convert-main');
        var missingRequiredAccess = _.some(convertMeta.modules, function (moduleMeta) {
            return (moduleMeta.required === true && !app.acl.hasAccess('create', moduleMeta.module));
        }, this);

        if (this.model.get('converted') || missingRequiredAccess) {
            this.hide();
        } else {
            this._super("_render");
        }
    },

    /**
     * Event to trigger the convert lead process for the lead
     */
    rowActionSelect: function() {
        var model = app.data.createBean(this.model.module);

        model.set(app.utils.deepCopy(this.model.attributes));
        app.drawer.open({
            layout : "convert",
            context: {
                forceNew: true,
                skipFetch: true,
                module: 'Leads',
                leadsModel: model
            }
        });
    },

    bindDataChange: function () {
        if (this.model) {
            this.model.on("change", this.render, this);
        }
    }
}) },
"status": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Leads.StatusField
 * @alias SUGAR.App.view.fields.BaseLeadsStatusField
 * @extends View.Fields.Base.EnumField
 */
({
	// Status FieldTemplate (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'enum';
    },

    /**
     * @inheritdoc
     *
     * Filter out the Converted option if the Lead is not already converted.
     */
    _filterOptions: function(options) {
        var status = this.model.get('status');
        var filteredOptions = this._super('_filterOptions', [options]);

        return (!_.isUndefined(status) && status !== 'Converted') ?
            _.omit(filteredOptions, 'Converted') :
            filteredOptions;
    }

}) },
"badge": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Leads.BadgeField
 * @alias SUGAR.App.view.fields.BaseLeadsBadgeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Badge FieldTemplate (base) 

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    events: {
        'click [data-action=convert]': 'convertLead'
    },

    /**
     * @inheritdoc
     *
     * The badge is always a readonly field.
     */
    initialize: function(options) {
        options.def.readonly = true;
        app.view.Field.prototype.initialize.call(this, options);
    },

    /**
     * Kick off convert lead process.
     */
    convertLead: function() {
        var model = app.data.createBean(this.model.module);
        model.set(app.utils.deepCopy(this.model.attributes));

        app.drawer.open({
            layout : 'convert',
            context: {
                forceNew: true,
                skipFetch: true,
                module: this.model.module,
                leadsModel: model
            }
        });
    }
}) }
}}
,
"views": {
"base": {
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Leads.CreateView
 * @alias SUGAR.App.view.views.LeadsCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    getCustomSaveOptions: function(){
        var options = {};

        if(this.context.get('prospect_id')) {
            options.params = {};
            // Needed for populating the relationship
            options.params.relate_to = 'Prospects';
            options.params.relate_id = this.context.get('prospect_id');
            this.context.unset('prospect_id');
        }

        return options;
    }
}) },
"convert-options": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Convert-options View (base) 

    /**
     * @inheritdoc
     *
     * Prevent render if transfer activities action is not move.
     */
    _render: function() {
        var transferActivitiesAction = app.metadata.getConfig().leadConvActivityOpt;
        if (transferActivitiesAction === 'move') {
            this.model.setDefault('transfer_activities', true);
            this._super('_render');
        }
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['HistoricalSummary']);
        this._super('initialize', [options]);
    },

    /**
     * Remove id, status and converted fields
     * (including associations created during conversion) when duplicating a Lead
     * @param prefill
     */
    setupDuplicateFields: function(prefill){
        var duplicateBlackList = ['id', 'status', 'converted', 'account_id', 'opportunity_id', 'contact_id'];
        _.each(duplicateBlackList, function(field){
            if(field && prefill.has(field)){
                //set blacklist field to the default value if exists
                if (!_.isUndefined(prefill.fields[field]) && !_.isUndefined(prefill.fields[field].default)) {
                    prefill.set(field, prefill.fields[field].default);
                } else {
                    prefill.unset(field);
                }
            }
        });
    }
}) },
"convert-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Convert-results View (base) 

    extendsFrom: 'ConvertResultsView',

    /**
     * Build a collection of associated models and re-render the view
     */
    populateResults: function() {
        var model;

        //only show related records if lead is converted
        if (!this.model.get('converted')) {
            return;
        }

        this.associatedModels.reset();

        model = this.buildAssociatedModel('Contacts', 'contact_id', 'contact_name');
        if (model) {
            this.associatedModels.push(model);
        }
        model = this.buildAssociatedModel('Accounts', 'account_id', 'account_name');
        if (model) {
            this.associatedModels.push(model);
        }
        model = this.buildAssociatedModel('Opportunities', 'opportunity_id', 'converted_opp_name');
        if (model) {
            this.associatedModels.push(model);
        }
        app.view.View.prototype.render.call(this);
    },

    /**
     * Build an associated model based on given id & name fields on the Lead record
     *
     * @param {String} moduleName
     * @param {String} idField
     * @param {String} nameField
     * @return {*} model or false if id field is not set on the lead
     */
    buildAssociatedModel: function(moduleName, idField, nameField) {
        var moduleSingular = app.lang.getAppListStrings('moduleListSingular'),
            model;

        if (_.isEmpty(this.model.get(idField))) {
            return false;
        }

        model = app.data.createBean(moduleName, {
            id: this.model.get(idField),
            name: this.model.get(nameField),
            row_title: moduleSingular[moduleName],
            _module: moduleName,
            target_module: moduleName
        });
        model.module = moduleName;
        return model;
    }
}) },
"convert-panel-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Convert-panel-header View (base) 

    events: {
        'click .toggle-link': 'handleToggleClick'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta.buttons = this.getButtons(options);
        app.view.View.prototype.initialize.call(this, options);
        this.layout.on('toggle:change', this.handleToggleChange, this);
        this.layout.on('lead:convert-dupecheck:pending', this.setDupeCheckPending, this);
        this.layout.on('lead:convert-dupecheck:complete', this.setDupeCheckResults, this);
        this.layout.on('lead:convert-panel:complete', this.handlePanelComplete, this);
        this.layout.on('lead:convert-panel:reset', this.handlePanelReset, this);
        this.layout.on('lead:convert:duplicate-selection:change', this.setAssociateButtonState, this);
        this.context.on('lead:convert:' + this.meta.module + ':shown', this.handlePanelShown, this);
        this.context.on('lead:convert:' + this.meta.module + ':hidden', this.handlePanelHidden, this);
        this.initializeSubTemplates();
    },

    /**
     * Return the metadata for the Associate/Reset buttons to be added to the
     * convert panel header
     *
     * @param {Object} options
     * @return {Array}
     */
    getButtons: function(options) {
        return [
            {
                name: 'associate_button',
                type: 'button',
                label: this.getLabel(
                    'LBL_CONVERT_CREATE_MODULE',
                    {'moduleName': options.meta.moduleSingular}
                ),
                css_class: 'btn-primary disabled'
            },
            {
                name: 'reset_button',
                type: 'button',
                label: 'LBL_CONVERT_RESET_PANEL',
                css_class: 'btn-invisible btn-link'
            }
        ];
    },

    /**
     * Initialize the Reset button to be hidden on render
     * @inheritdoc
     */
    _render: function() {
        app.view.View.prototype._render.call(this);
        this.getField('reset_button').hide();
    },

    /**
     * Compile data from the convert panel layout with some of the metadata to
     * be used when rendering sub-templates
     *
     * @return {Object}
     */
    getCurrentState: function() {
        var currentState = _.extend({}, this.layout.currentState, {
            create: (this.layout.currentToggle === this.layout.TOGGLE_CREATE),
            labelModule: this.module,
            moduleInfo: {'moduleName': this.meta.moduleSingular},
            required: this.meta.required
        });

        if (_.isNumber(currentState.dupeCount)) {
            currentState.duplicateCheckResult = {'duplicateCount': currentState.dupeCount};
        }

        return currentState;
    },

    /**
     * Pull in the sub-templates to be used to render & re-render pieces of the convert header
     * Pieces of the convert header change based on various states the panel is in
     */
    initializeSubTemplates: function() {
        this.tpls = {};
        this.initial = {};

        this.tpls.title = app.template.getView(this.name + '.title', this.module);
        this.initial.title = this.tpls.title(this.getCurrentState());

        this.tpls.dupecheckPending = app.template.getView(this.name + '.dupecheck-pending', this.module);
        this.tpls.dupecheckResults = app.template.getView(this.name + '.dupecheck-results', this.module);
    },

    /**
     * Toggle the subviews based on which link was clicked
     *
     * @param {Event} event The click event on the toggle link
     */
    handleToggleClick: function(event) {
        var nextToggle = this.$(event.target).data('next-toggle');
        this.layout.trigger('toggle:showcomponent', nextToggle);
        event.preventDefault();
        event.stopPropagation();
    },

    /**
     * When switching between sub-views, change the appropriate header components:
     * - Title changes to reflect New vs. Select (showing New ModuleName or just ModuleName)
     * - Dupe check results are shown/hidden based on whether dupe view is shown
     * - Change the toggle link to allow the user to toggle back to the other one
     * - Enable Associate button when on create view - Enable/Disable button based
     *   on whether dupe selected on dupe view
     *
     * @param {string} toggle Which view is now being displayed
     */
    handleToggleChange: function(toggle) {
        this.renderTitle();
        this.toggleDupeCheckResults(toggle === this.layout.TOGGLE_DUPECHECK);
        this.setSubViewToggle(toggle);
        this.setAssociateButtonState();
    },

    /**
     * When opening a panel, change the appropriate header components:
     * - Activate the header
     * - Display the subview toggle link
     * - Enable Associate button when on create view - Enable/Disable button
     *   based on whether dupe selected on dupe view
     * - Mark active indicator pointing up
     */
    handlePanelShown: function() {
        this.$('.accordion-heading').addClass('active');
        this.toggleSubViewToggle(true);
        this.setAssociateButtonState();
        this.toggleActiveIndicator(true);
    },

    /**
     * When hiding a panel, change the appropriate header components:
     * - Deactivate the header
     * - Hide the subview toggle link
     * - Disable the Associate button
     * - Mark active indicator pointing down
     */
    handlePanelHidden: function() {
        this.$('.accordion-heading').removeClass('active');
        this.toggleSubViewToggle(false);
        this.setAssociateButtonState(false);
        this.toggleActiveIndicator(false);
    },

    /**
     * When a panel has been marked complete, change the appropriate header components:
     * - Mark the step circle as check box
     * - Title changes to show the record associated
     * - Hide duplicate check results
     * - Hide the subview toggle link
     * - Switch to Reset button
     */
    handlePanelComplete: function() {
        this.setStepCircle(true);
        this.renderTitle();
        this.toggleDupeCheckResults(false);
        this.toggleSubViewToggle(false);
        this.toggleButtons(true);
    },

    /**
     * When a panel has been reset, change the appropriate header components:
     * - Mark the step circle back to step number
     * - Title changes back to incomplete (showing New ModuleName or just ModuleName)
     * - Show duplicate check count (if any found)
     * - Switch to back to Associate button
     * - Enable Associate button when on create view - Enable/Disable button
     *   based on whether dupe selected on dupe view
     */
    handlePanelReset: function() {
        this.setStepCircle(false);
        this.renderTitle();
        this.toggleDupeCheckResults(true);
        this.toggleButtons(false);
        this.setAssociateButtonState();
    },

    /**
     * Switch between check mark and step number
     *
     * @param {boolean} complete Whether to mark panel completed
     */
    setStepCircle: function(complete) {
        var $stepCircle = this.$('.step-circle');
        if (complete) {
            $stepCircle.addClass('complete');
        } else {
            $stepCircle.removeClass('complete');
        }
    },

    /**
     * Render the title based on current state Create vs DupeCheck and
     * Complete vs. Incomplete
     */
    renderTitle: function() {
        this.$('.title').html(this.tpls.title(this.getCurrentState()));
    },

    /**
     * Put up "Searching for duplicates" message
     */
    setDupeCheckPending: function() {
        this.renderDupeCheckResults('pending');
    },

    /**
     * Display duplicate results (if any found) or hide subview links if none found
     *
     * @param {number} duplicateCount Number of duplicates found
     */
    setDupeCheckResults: function(duplicateCount) {
        if (duplicateCount > 0) {
            this.renderDupeCheckResults('results');
        } else {
            this.renderDupeCheckResults('clear');
        }
        this.setSubViewToggleLabels(duplicateCount);
    },

    /**
     * Render either dupe check results or pending (or empty if no dupes found)
     *
     * @param {string} type Which message to show - `results` or `pending`
     */
    renderDupeCheckResults: function(type) {
        var results = '';
        if (type === 'results') {
            results = this.tpls.dupecheckResults(this.getCurrentState());
        } else if (type === 'pending') {
            results = this.tpls.dupecheckPending(this.getCurrentState());
        }
        this.$('.dupecheck-results').text(results);
    },

    /**
     * Show/hide dupe check results
     * If duplicate already selected, results will not be shown
     *
     * @param {boolean} show Whether to show the duplicate check results
     */
    toggleDupeCheckResults: function(show) {
        // if we are trying to show this, but we already have a dupeSelected, change the show to false
        if (show && this.layout.currentState.dupeSelected) {
            show = false;
        }
        this.$('.dupecheck-results').toggle(show);
    },

    /**
     * Show/hide the subview toggle links altogether
     * If panel is complete, the subview toggle will not be shown
     *
     * @param {boolean} show Whether to show the subview toggle
     */
    toggleSubViewToggle: function(show) {
        if (this.layout.currentState.complete) {
            show = false;
        }
        this.$('.subview-toggle').toggleClass('hide', !show);
    },

    /**
     * Show/hide appropriate toggle link for the subview being displayed
     *
     * @param {string} nextToggle Css class labeling the next toggle
     */
    setSubViewToggle: function(nextToggle) {
        _.each(['dupecheck', 'create'], function(currentToggle) {
            this.toggleSubViewLink(currentToggle, (nextToggle === currentToggle));
        }, this);
    },

    /**
     * Show/hide a single subview toggle link
     *
     * @param {string} currentToggle Css class labeling the current toggle
     * @param {boolean} show Whether to show the toggle link
     */
    toggleSubViewLink: function(currentToggle, show) {
        this.$('.subview-toggle .' + currentToggle).toggle(show);
    },

    /**
     * Switch subview toggle labels based on whether duplicates were found or not
     *
     * @param {number} duplicateCount
     */
    setSubViewToggleLabels: function(duplicateCount) {
        if (duplicateCount > 0) {
            this.setSubViewToggleLabel('dupecheck', 'LBL_CONVERT_IGNORE_DUPLICATES');
            this.setSubViewToggleLabel('create', 'LBL_CONVERT_BACK_TO_DUPLICATES');
        } else {
            this.setSubViewToggleLabel('dupecheck', 'LBL_CONVERT_SWITCH_TO_CREATE');
            this.setSubViewToggleLabel('create', 'LBL_CONVERT_SWITCH_TO_SEARCH');
        }
    },

    /**
     * Set label for given subview toggle
     *
     * @param {string} currentToggle Css class labeling the current toggle
     * @param {string} label Label to replace the toggle text with
     */
    setSubViewToggleLabel: function(currentToggle, label) {
        this.$('.subview-toggle .' + currentToggle).text(this.getLabel(label));
    },

    /**
     * Toggle between Associate and Reset buttons
     *
     * @param {boolean} complete
     */
    toggleButtons: function(complete) {
        var associateButton = 'associate_button',
            resetButton = 'reset_button';

        if (complete) {
            this.getField(associateButton).hide();
            this.getField(resetButton).show();
        } else {
            this.getField(associateButton).show();
            this.getField(resetButton).hide();
        }
    },

    /**
     * Activate/Deactivate the Associate button based on which subview is active
     * and whether the panel itself is active (keep disabled when panel not active)
     *
     * @param {boolean} [activate]
     */
    setAssociateButtonState: function(activate) {
        var $associateButton = this.$('[name="associate_button"]'),
            panelActive = this.$('.accordion-heading').hasClass('active');

        //use current state to determine activate if not explicit in call
        if (_.isUndefined(activate)) {
            if (this.layout.currentToggle === this.layout.TOGGLE_CREATE) {
                activate = true;
            } else {
                activate = this.layout.currentState.dupeSelected;
            }
        }

        this.setAssociateButtonLabel(this.layout.currentToggle === this.layout.TOGGLE_CREATE);

        //only activate if current panel is active
        if (activate && panelActive) {
            $associateButton.removeClass('disabled');
        } else {
            $associateButton.addClass('disabled');
        }
    },

    /**
     * Set the label for the Associate Button
     *
     * @param {boolean} isCreate
     */
    setAssociateButtonLabel: function(isCreate) {
        var label = 'LBL_CONVERT_SELECT_MODULE';
        if (isCreate) {
            label = 'LBL_CONVERT_CREATE_MODULE';
        }
        this.$('[name="associate_button"]').html(this.getLabel(label, {'moduleName': this.meta.moduleSingular}));
    },

    /**
     * Toggle the active indicator up/down
     *
     * @param {boolean} active
     */
    toggleActiveIndicator: function(active) {
        var $activeIndicator = this.$('.active-indicator i');
        $activeIndicator.toggleClass('fa-chevron-up', active);
        $activeIndicator.toggleClass('fa-chevron-down', !active);
    },

    /**
     * Get translated strings from the Leads module language file
     *
     * @param {string} key The app/mod string
     * @param {Object} [context] Any placeholder data to populate in the string
     * @return {string} The translated string
     */
    getLabel: function(key, context) {
        context = context || {};
        return app.lang.get(key, 'Leads', context);
    }
}) },
"convert-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Convert-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click [name=save_button]:not(".disabled")': 'initiateSave',
        'click [name=cancel_button]': 'initiateCancel'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super("initialize", [options]);
        this.context.on('lead:convert-save:toggle', this.toggleSaveButton, this);
    },

    /**
     * @override
     *
     * Grabs the lead's name and format the title such as `Convert: <name>`.
     */
    _formatTitle: function(title) {
        var leadsModel = this.context.get('leadsModel'),
            name = !_.isUndefined(leadsModel.get('name')) ?
                leadsModel.get('name') :
                leadsModel.get('first_name') + ' ' + leadsModel.get('last_name');
        return app.lang.get(title, this.module) + ': ' + name;
    },

    /**
     * When finish button is clicked, send this event down to the convert layout to wrap up
     */
    initiateSave: function() {
        this.context.trigger('lead:convert:save');
    },

    /**
     * When cancel clicked, hide the drawer
     */
    initiateCancel : function() {
        app.drawer.close();
    },

    /**
     * Enable/disable the Save button
     *
     * @param enable true to enable, false to disable
     */
    toggleSaveButton: function(enable) {
        this.$('[name=save_button]').toggleClass('disabled', !enable);
    }
}) }
}}
,
"layouts": {
"base": {
"convert-panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Convert-panel Layout (base) 

    extendsFrom: 'ToggleLayout',

    TOGGLE_DUPECHECK: 'dupecheck',
    TOGGLE_CREATE: 'create',

    availableToggles: {
        'dupecheck': {},
        'create': {}
    },

    //selectors
    accordionHeading: '.accordion-heading',
    accordionBody: '.accordion-body',

    //turned on, but could be turned into a setting later
    autoCompleteEnabled: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var convertPanelEvents;

        this.meta = options.meta;
        this._setModuleSpecificValues();

        convertPanelEvents = {};
        convertPanelEvents['click .accordion-heading.enabled'] = 'togglePanel';
        convertPanelEvents['click [name="associate_button"]'] = 'handleAssociateClick';
        convertPanelEvents['click [name="reset_button"]'] = 'handleResetClick';
        this.events = _.extend({}, this.events, convertPanelEvents);
        this.plugins = _.union(this.plugins || [], [
            'FindDuplicates'
        ]);

        this.currentState = {
            complete: false,
            dupeSelected: false
        };
        this.toggledOffDupes = false;

        this._super('initialize', [options]);

        this.addSubComponents();

        this.context.on('lead:convert:populate', this.handlePopulateRecords, this);
        this.context.on('lead:convert:' + this.meta.module + ':enable', this.handleEnablePanel, this);
        this.context.on('lead:convert:' + this.meta.moduleNumber + ':open', this.handleOpenRequest, this);
        this.context.on('lead:convert:exit', this.turnOffUnsavedChanges, this);
        this.context.on('lead:convert:' + this.meta.module + ':shown', this.handleShowComponent, this);

        //if this panel is dependent on others - listen for changes and react accordingly
        this.addDependencyListeners();

        //open the first module upon the first autocomplete check completion
        if (this.meta.moduleNumber === 1) {
            this.once('lead:autocomplete-check:complete', this.handleOpenRequest, this);
        }
    },

    /**
     * Retrieve module specific values (like modular singular name and whether
     * dupe check is enabled at a module level).
     * @private
     */
    _setModuleSpecificValues: function() {
        var module = this.meta.module;
        this.meta.modulePlural = app.lang.getAppListStrings('moduleList')[module] || module;
        this.meta.moduleSingular = app.lang.getAppListStrings('moduleListSingular')[module] ||
            this.meta.modulePlural;

        //enable or disable duplicate check
        var moduleMetadata = app.metadata.getModule(module);
        this.meta.enableDuplicateCheck = (moduleMetadata && moduleMetadata.dupCheckEnabled) ||
            this.meta.enableDuplicateCheck ||
            false;
        this.meta.duplicateCheckOnStart = this.meta.enableDuplicateCheck && this.meta.duplicateCheckOnStart;
    },

    /**
     * Used by toggle layout to determine where to place sub-components.
     *
     * @param {Object} component
     * @return {jQuery}
     */
    getContainer: function(component) {
        if (component.name === 'convert-panel-header') {
            return this.$('[data-container="header"]');
        } else {
            return this.$('[data-container="inner"]');
        }
    },

    /**
     * Add all sub-components of the panel.
     */
    addSubComponents: function() {
        this.addHeaderComponent();
        this.addDupeCheckComponent();
        this.addRecordCreateComponent();
    },

    /**
     * Add the panel header view.
     */
    addHeaderComponent: function() {
        var header = app.view.createView({
            context: this.context,
            type: 'convert-panel-header',
            layout: this,
            meta: this.meta
        });
        this.addComponent(header);
    },

    /**
     * Add the duplicate check layout along with events to listen for changes to
     * the duplicate view.
     */
    addDupeCheckComponent: function() {
        var leadsModel = this.context.get('leadsModel'),
            context = this.context.getChildContext({
                'module': this.meta.module,
                'forceNew': true,
                'skipFetch': true,
                'dupelisttype': 'dupecheck-list-select',
                'collection': this.createDuplicateCollection(leadsModel, this.meta.module),
                'layoutName': 'records',
                'dataView': 'selection-list'
            });
        context.prepare();

        this.duplicateView = app.view.createLayout({
            context: context,
            type: this.TOGGLE_DUPECHECK,
            layout: this,
            module: context.get('module')
        });
        this.duplicateView.context.on('change:selection_model', this.handleDupeSelectedChange, this);
        this.duplicateView.collection.on('reset', this.dupeCheckComplete, this);
        this.addComponent(this.duplicateView);
    },

    /**
     * Add the create view.
     */
    addRecordCreateComponent: function() {
        var context = this.context.getChildContext({
            'module': this.meta.module,
            forceNew: true,
            create: true
        });
        context.prepare();

        this.createView = app.view.createView({
            context: context,
            type: this.TOGGLE_CREATE,
            module: context.module,
            layout: this
        });

        this.createView.meta = this.removeFieldsFromMeta(this.createView.meta, this.meta);
        this.createView.enableHeaderButtons = false;
        this.addComponent(this.createView);
    },

    /**
     * Sets the listeners for changes to the dependent modules.
     */
    addDependencyListeners: function() {
        _.each(this.meta.dependentModules, function(details, module) {
            this.context.on('lead:convert:' + module + ':complete', this.updateFromDependentModuleChanges, this);
            this.context.on('lead:convert:' + module + ':reset', this.resetFromDependentModuleChanges, this);
        }, this);
    },

    /**
     * When duplicate results are received (or dupe check did not need to be
     * run) toggle to the appropriate view.
     *
     * If duplicates were found for a required module, auto select the first
     * duplicate.
     */
    dupeCheckComplete: function() {
        if (this.disposed) {
            return;
        }

        this.currentState.dupeCount = this.duplicateView.collection.length;
        this.runAutoCompleteCheck();
        if (this.currentState.dupeCount !== 0) {
            this.showComponent(this.TOGGLE_DUPECHECK);
            if (this.meta.required) {
                this.selectFirstDuplicate();
            }
        } else if (!this.toggledOffDupes) {
            this.showComponent(this.TOGGLE_CREATE);
        }

        this.toggledOffDupes = true; //flag so we only toggle once
        this.trigger('lead:convert-dupecheck:complete', this.currentState.dupeCount);
    },

    /**
     * Check to see if the panel should be automatically marked as complete
     *
     * Required panels are marked complete when there are no duplicates and
     * the create form passes validation.
     */
    runAutoCompleteCheck: function() {
        //Bail out if we've already completed the check
        if (this.autoCompleteCheckComplete) {
            return;
        }

        if (this.autoCompleteEnabled && this.meta.required && this.currentState.dupeCount === 0) {
            this.createView.once('render', this.runAutoCompleteValidation, this);
        } else {
            this.markAutoCompleteCheckComplete();
        }
    },

    /**
     * Run validation, mark panel complete if valid without any alerts
     */
    runAutoCompleteValidation: function() {
        var view = this.createView,
            model = view.model;

        model.isValidAsync(view.getFields(view.module), _.bind(function(isValid) {
            if (isValid) {
                this.markPanelComplete(model);
            }
            this.markAutoCompleteCheckComplete();
        }, this));
    },

    /**
     * Set autocomplete check complete flag and trigger event
     */
    markAutoCompleteCheckComplete: function() {
        this.autoCompleteCheckComplete = true;
        this.trigger('lead:autocomplete-check:complete');
    },

    /**
     * Select the first item in the duplicate check list.
     */
    selectFirstDuplicate: function() {
        var list = this.duplicateView.getComponent('dupecheck-list-select');
        if (list) {
            list.once('render', function() {
                var radio = this.$('input[type=radio]:first');
                if (radio) {
                    radio.prop('checked', true);
                    radio.click();
                }
            }, this);
        }
    },

    /**
     * Removes fields from the meta and replaces with empty html container
     * based on the modules config option - hiddenFields.
     *
     * Example: Account name drop-down should not be available on contact
     * and opportunity module.
     *
     * @param {Object} meta The original metadata
     * @param {Object} moduleMeta Metadata defining fields to hide
     * @return {Object} The metadata after hidden fields removed
     */
    removeFieldsFromMeta: function(meta, moduleMeta) {
        if (moduleMeta.hiddenFields) {
            _.each(meta.panels, function(panel) {
                _.each(panel.fields, function(field, index, list) {
                    if (_.isString(field)) {
                        field = {name: field};
                    }
                    if (moduleMeta.hiddenFields[field.name]) {
                        field.readonly = true;
                        field.required = false;
                        list[index] = field;
                    }
                });
            }, this);
        }
        return meta;
    },

    /**
     * Toggle the accordion body for this panel.
     */
    togglePanel: function() {
        this.$(this.accordionBody).collapse('toggle');
    },

    /**
     * When one panel is completed it notifies the next panel to open
     * This function handles that request and will...
     * - wait for auto complete check to finish before doing anything
     * - pass along request to the next if already complete or not enabled
     * - open the panel otherwise
     */
    handleOpenRequest: function() {
        if (this.autoCompleteCheckComplete !== true) {
            this.once('lead:autocomplete-check:complete', this.handleOpenRequest, this);
        } else {
            if (this.currentState.complete || !this.isPanelEnabled()) {
                this.requestNextPanelOpen();
            } else {
                this.openPanel();
            }
        }
    },

    /**
     * Check if the the current panel is enabled.
     *
     * @return {boolean}
     */
    isPanelEnabled: function() {
        return this.$(this.accordionHeading).hasClass('enabled');
    },

    /**
     * Check if the current panel is open.
     *
     * @return {boolean}
     */
    isPanelOpen: function() {
        return this.$(this.accordionBody).hasClass('in');
    },

    /**
     * Open the body of the panel if enabled (and not already open).
     */
    openPanel: function() {
        if (this.isPanelEnabled()) {
            if (this.isPanelOpen()) {
                this.context.trigger('lead:convert:' + this.meta.module + ':shown');
            } else {
                this.$(this.accordionBody).collapse('show');
            }
        }
    },

    /**
     * When showing create view, render the view, trigger duplication
     * of fields with special handling (like image fields).
     *
     * @inheritdoc
     */
    showComponent: function(name) {
        this._super('showComponent', [name]);
        if (this.currentToggle === this.TOGGLE_CREATE) {
            this.createViewRendered = true;
        }
        this.handleShowComponent();
    },

    /**
     * Render the create view.
     */
    handleShowComponent: function() {
        if (this.currentToggle === this.TOGGLE_CREATE && this.createView.meta.useTabsAndPanels && !this.createViewRendered) {
            this.createView.render();
            this.createViewRendered = true;
        }
    },

    /**
     * Close the body of the panel (if not already closed)
     */
    closePanel: function() {
        this.$(this.accordionBody).collapse('hide');
    },

    /**
     * Handle click of Associate button - running validation if on create view
     * or marking complete if on dupe view.
     *
     * @param {Event} event
     */
    handleAssociateClick: function(event) {
        //ignore clicks if button is disabled
        if (!$(event.currentTarget).hasClass('disabled')) {
            if (this.currentToggle === this.TOGGLE_CREATE) {
                this.runCreateValidation({
                    valid: _.bind(this.markPanelComplete, this),
                    invalid: _.bind(this.resetPanel, this)
                });
            } else {
                this.markPanelComplete(this.duplicateView.context.get('selection_model'));
            }
        }
        event.stopPropagation();
    },

    /**
     * Run validation on the create model and perform specified callbacks based
     * on the validity of the model.
     *
     * @param {Object} callbacks Callbacks to be run after validation is performed.
     * @param {Function} callbacks.valid Run if model is valid.
     * @param {Function} callbacks.invalid Run if model is invalid.
     */
    runCreateValidation: function(callbacks) {
        var view = this.createView,
            model = view.model;

        model.doValidate(view.getFields(view.module), _.bind(function(isValid) {
            if (isValid) {
                callbacks.valid(model);
            } else {
                callbacks.invalid(model);
            }
        }, this));
    },

    /**
     * Mark the panel as complete, close the panel body, and tell the next panel
     * to open.
     *
     * @param {Data.Bean} model
     */
    markPanelComplete: function(model) {
        this.currentState.associatedName = app.utils.getRecordName(model);
        this.currentState.complete = true;
        this.context.trigger('lead:convert-panel:complete', this.meta.module, model);
        this.trigger('lead:convert-panel:complete', this.currentState.associatedName);

        app.alert.dismissAll('error');

        //re-run validation if create model changes after completion
        if (!model.id) {
            model.on('change', this.runPostCompletionValidation, this);
        }

        //if this panel was open, close & tell the next panel to open
        if (this.isPanelOpen()) {
            this.closePanel();
            this.requestNextPanelOpen();
        }
    },

    /**
     * Re-run create model validation after a panel has been marked completed
     */
    runPostCompletionValidation: function() {
        this.runCreateValidation({
            valid: $.noop,
            invalid: _.bind(this.resetPanel, this)
        });
    },

    /**
     * Trigger event to open the next panel in the list
     */
    requestNextPanelOpen: function() {
        this.context.trigger('lead:convert:' + (this.meta.moduleNumber + 1) + ':open');
    },

    /**
     * When reset button is clicked - reset this panel and open it
     * @param {Event} event
     */
    handleResetClick: function(event) {
        this.resetPanel();
        this.openPanel();
        event.stopPropagation();
    },

    /**
     * Reset the panel back to a state the user can modify associated values
     */
    resetPanel: function() {
        this.createView.model.off('change', this.runPostCompletionValidation, this);
        this.currentState.complete = false;
        this.context.trigger('lead:convert-panel:reset', this.meta.module);
        this.trigger('lead:convert-panel:reset');
    },

    /**
     * Track when a duplicate has been selected and notify the panel so it can
     * enable the Associate button
     */
    handleDupeSelectedChange: function() {
        this.currentState.dupeSelected = this.duplicateView.context.has('selection_model');
        this.trigger('lead:convert:duplicate-selection:change');
    },

     /**
     * Wrapper to check whether to fire the duplicate check event
     */
    triggerDuplicateCheck: function() {
        if (this.shouldDupeCheckBePerformed(this.createView.model)) {
            this.trigger('lead:convert-dupecheck:pending');
            this.duplicateView.context.trigger('dupecheck:fetch:fire', this.createView.model, {
                //Show alerts for this request
                showAlerts: true
            });
        } else {
            this.dupeCheckComplete();
        }
    },

    /**
     * Check if duplicate check should be performed
     * dependent on enableDuplicateCheck setting and required dupe check fields
     * @param {Object} model
     */
    shouldDupeCheckBePerformed: function(model) {
        var performDuplicateCheck = this.meta.enableDuplicateCheck;

        if (this.meta.duplicateCheckRequiredFields) {
            _.each(this.meta.duplicateCheckRequiredFields, function(field) {
                if (_.isEmpty(model.get(field))) {
                    performDuplicateCheck = false;
                }
            });
        }
        return performDuplicateCheck;
    },

    /**
     * Populates the record view from the passed in model and then kick off the
     * dupe check
     *
     * @param {Object} model
     */
    handlePopulateRecords: function(model) {
        var fieldMapping = {};

        // if copyData is not set or false, no need to run duplicate check, bail out
        if (!this.meta.copyData) {
            this.dupeCheckComplete();
            return;
        }

        if (!_.isEmpty(this.meta.fieldMapping)) {
            fieldMapping = app.utils.deepCopy(this.meta.fieldMapping);
        }
        var sourceFields = app.metadata.getModule(model.attributes._module, 'fields');
        var targetFields = app.metadata.getModule(this.meta.module, 'fields');

        _.each(model.attributes, function(fieldValue, fieldName) {
            if (app.acl.hasAccessToModel('edit', this.createView.model, fieldName) &&
                !_.isUndefined(sourceFields[fieldName]) &&
                !_.isUndefined(targetFields[fieldName]) &&
                sourceFields[fieldName].type === targetFields[fieldName].type &&
                (_.isUndefined(sourceFields[fieldName]['duplicate_on_record_copy']) ||
                    sourceFields[fieldName]['duplicate_on_record_copy'] !== 'no') &&
                model.has(fieldName) &&
                model.get(fieldName) !== this.createView.model.get(fieldName) &&
                _.isUndefined(fieldMapping[fieldName])) {
                        fieldMapping[fieldName] = fieldName;
                    }
        }, this);

        this.populateRecords(model, fieldMapping);
        if (this.meta.duplicateCheckOnStart) {
            this.triggerDuplicateCheck();
        } else if (!this.meta.dependentModules || this.meta.dependentModules.length == 0) {
            //not waiting on other modules before running dupe check, so mark as complete
            this.dupeCheckComplete();
        }
    },

    /**
     * Use the convert metadata to determine how to map the lead fields to
     * module fields
     *
     * @param {Object} model
     * @param {Object} fieldMapping
     * @return {boolean} whether the create view model has changed
     */
    populateRecords: function(model, fieldMapping) {
        var hasChanged = false;

        _.each(fieldMapping, function(sourceField, targetField) {
            if (model.has(sourceField) && this.shouldSourceValueBeCopied(model.get(sourceField)) &&
                model.get(sourceField) !== this.createView.model.get(targetField)) {
                    this.createView.model.setDefault(targetField, model.get(sourceField));
                    this.createView.model.set(targetField, model.get(sourceField));
                    hasChanged = true;
            }
        }, this);

        //mark the model as copied so that the currency field doesn't set currency_id to user's default value
        if (hasChanged) {
            this.createView.once('render', function() {
                this.createView.model.trigger('duplicate:field', model);
            }, this);

            if (model.has('currency_id')) {
                this.createView.model.isCopied = true;
            }
        }

        return hasChanged;
    },

    /**
     * Enable the panel
     *
     * @param {boolean} isEnabled add/remove the enabled flag on the header
     */
    handleEnablePanel: function(isEnabled) {
        var $header = this.$(this.accordionHeading);
        if (isEnabled) {
            if (!this.currentState.complete) {
                this.triggerDuplicateCheck();
            }
            $header.addClass('enabled');
        } else {
            $header.removeClass('enabled');
        }
    },

    /**
     * Updates the attributes on the model based on the changes from dependent
     * modules duplicate view.
     * Uses dependentModules property - fieldMappings
     *
     * @param {string} moduleName
     * @param {Object} model
     */
    updateFromDependentModuleChanges: function(moduleName, model) {
        var dependencies = this.meta.dependentModules,
            modelChanged = false;
        if (dependencies && dependencies[moduleName] && dependencies[moduleName].fieldMapping) {
            modelChanged = this.populateRecords(model, dependencies[moduleName].fieldMapping);
            if (modelChanged) {
                this.triggerDuplicateCheck();
            }
        }
    },

    /**
     * Resets the state of the panel based on a dependent module being reset
     */
    resetFromDependentModuleChanges: function(moduleName) {
        var dependencies = this.meta.dependentModules;
        if (dependencies && dependencies[moduleName]) {
            //if dupe check has already been run, reset but don't run again yet - just update status
            if (this.currentState.dupeCount && this.currentState.dupeCount > 0) {
                this.duplicateView.collection.reset();
                this.currentState.dupeCount = 0;
            }
            //undo any dependency field mapping that was done previously
            if (dependencies && dependencies[moduleName] && dependencies[moduleName].fieldMapping) {
                _.each(dependencies[moduleName].fieldMapping, function(sourceField, targetField) {
                    this.createView.model.unset(targetField);
                }, this);
            }
            //make sure if we re-trigger dupe check again we handle as if it never happened before
            this.toggledOffDupes = false;
            this.resetPanel();
        }
    },

    /**
     * Resets the model to the default values so that unsaved warning prompt
     * will not be displayed.
     */
    turnOffUnsavedChanges: function() {
        var defaults = _.extend({}, this.createView.model._defaults, this.createView.model.getDefault());

        this.createView.model.attributes = defaults;
    },

    /**
     * Determine whether to copy the the supplied value when it appears in the Source module during conversion
     */
    shouldSourceValueBeCopied: function(val) {
        return _.isNumber(val) || _.isBoolean(val) || !_.isEmpty(val);
    },

    /**
     * Stop listening to events on duplicate view collection
     * @inheritdoc
     */
    _dispose: function() {
        this.createView.model.off('change', this.runPostCompletionValidation, this);
        this.createView.off(null, null, this);
        this.duplicateView.off(null, null, this);
        this.duplicateView.context.off(null, null, this);
        this.duplicateView.collection.off(null, null, this);
        this._super('_dispose');
    }
}) },
"convert-main": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Convert-main Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.convertPanels = {};
        this.associatedModels = {};
        this.dependentModules = {};
        this.noAccessRequiredModules = [];

        app.view.Layout.prototype.initialize.call(this, options);

        this.meta.modules = this.filterModulesByACL(this.meta.modules);

        this.initializeOptions(this.meta.modules);

        //create and place all the accordion panels
        this.initializePanels(this.meta.modules);

        //listen for panel status updates
        this.context.on('lead:convert-panel:complete', this.handlePanelComplete, this);
        this.context.on('lead:convert-panel:reset', this.handlePanelReset, this);

        //listen for Save button click in headerpane
        this.context.on('lead:convert:save', this.handleSave, this);

        this.before('render', this.checkRequiredAccess);
    },

    /**
     * Create a new object with only modules the user has create access to and
     * build list of required modules the user does not have create access to.
     *
     * @param {Object} modulesMetadata
     * @return {Object}
     */
    filterModulesByACL: function(modulesMetadata) {
        var filteredModulesMetadata = {};

        _.each(modulesMetadata, function(moduleMeta, key) {
            //strip out modules that user does not have create access to
            if (app.acl.hasAccess('create', moduleMeta.module)) {
                filteredModulesMetadata[key] = moduleMeta;
            } else if (moduleMeta.required === true) {
                this.noAccessRequiredModules.push(moduleMeta.module);
            }
        }, this);

        return filteredModulesMetadata;
    },

    /**
     * Create an options section on top of convert panels that presents options
     * when converting a lead (specifically, which modules to copy/move
     * activities to).
     *
     * @param {Object} modulesMetadata
     */
    initializeOptions: function(modulesMetadata) {
        var view,
            convertModuleList = [];

        _.each(modulesMetadata, function(moduleMeta) {
            var moduleSingular = this.getModuleSingular(moduleMeta.module);
            convertModuleList.push({
                id: moduleMeta.module,
                text: moduleSingular,
                required: moduleMeta.required
            });
        }, this);

        this.context.set('convertModuleList', convertModuleList);
        view = app.view.createView({
            context: this.context,
            layout: this,
            type: 'convert-options',
            platform: this.options.platform
        });

        this.addComponent(view);
    },

    /**
     * Iterate over the modules defined in convert-main.php
     * Create a convert panel for each module defined there
     *
     * @param {Object} modulesMetadata
     */
    initializePanels: function(modulesMetadata) {
        var moduleNumber = 1;

        _.each(modulesMetadata, function(moduleMeta) {
            moduleMeta.moduleNumber = moduleNumber++;
            var view = app.view.createLayout({
                context: this.context,
                type: 'convert-panel',
                layout: this,
                meta: moduleMeta,
                platform: this.options.platform
            });
            view.initComponents();

            //This is because backbone injects a wrapper element.
            view.$el.addClass('accordion-group');
            view.$el.data('module', moduleMeta.module);

            this.addComponent(view);
            this.convertPanels[moduleMeta.module] = view;
            if (moduleMeta.dependentModules) {
                this.dependentModules[moduleMeta.module] = moduleMeta.dependentModules;
            }
        }, this);
    },

    /**
     * Check if user is missing access to any required modules
     * @return {boolean}
     */
    checkRequiredAccess: function() {
        //user is missing access to required modules - kick them out
        if (this.noAccessRequiredModules.length > 0) {
            this.denyUserAccess(this.noAccessRequiredModules);
            return false;
        }
        return true;
    },

    /**
     * Close lead convert and notify the user that they are missing required access
     * @param {Array} noAccessRequiredModules
     */
    denyUserAccess: function(noAccessRequiredModules) {
        var translatedModuleNames = [];

        _.each(noAccessRequiredModules, function(module) {
            translatedModuleNames.push(this.getModuleSingular(module));
        }, this);

        app.alert.show('convert_access_denied', {
            level: 'error',
            messages: app.lang.get(
                'LBL_CONVERT_ACCESS_DENIED',
                this.module,
                {requiredModulesMissing: translatedModuleNames.join(', ')}
            )
        });
        app.drawer.close();
    },

    /**
     * Retrieve the translated module name
     * @param {string} module
     * @return {string}
     */
    getModuleSingular: function(module) {
        var modulePlural = app.lang.getAppListStrings('moduleList')[module] || module;
        return (app.lang.getAppListStrings('moduleListSingular')[module] || modulePlural);
    },

    _render: function() {
        app.view.Layout.prototype._render.call(this);

        //This is because backbone injects a wrapper element.
        this.$el.addClass('accordion');
        this.$el.attr('id', 'convert-accordion');

        //apply the accordion to this layout
        this.$('.collapse').collapse({toggle: false, parent: '#convert-accordion'});
        this.$('.collapse').on('shown hidden', _.bind(this.handlePanelCollapseEvent, this));

        //copy lead data down to each module when we get the lead data
        this.context.get('leadsModel').fetch({
            success: _.bind(function(model) {
                if (this.context) {
                    this.context.trigger('lead:convert:populate', model);
                }
            }, this)
        });
    },

    /**
     * Catch collapse shown/hidden events and notify the panels via the context
     * @param {Event} event
     */
    handlePanelCollapseEvent: function(event) {
        //only respond to the events directly on the collapse (was getting events from tooltip propagated up
        if (event.target !== event.currentTarget) {
            return;
        }
        var module = $(event.currentTarget).data('module');
        this.context.trigger('lead:convert:' + module + ':' + event.type);
    },

    /**
     * When a panel is complete, add the model to the associatedModels array and notify any dependent modules
     * @param {string} module that was completed
     * @param {Data.Bean} model
     */
    handlePanelComplete: function(module, model) {
        this.associatedModels[module] = model;
        this.handlePanelUpdate();
        this.context.trigger('lead:convert:' + module + ':complete', module, model);
    },

    /**
     * When a panel is reset, remove the model from the associatedModels array and notify any dependent modules
     * @param {string} module
     */
    handlePanelReset: function(module) {
        delete this.associatedModels[module];
        this.handlePanelUpdate();
        this.context.trigger('lead:convert:' + module + ':reset', module);
    },

    /**
     * When a panel has been updated, check if any module's dependencies are met
     * and/or if all required modules have been completed
     */
    handlePanelUpdate: function() {
        this.checkDependentModules();
        this.checkRequired();
    },

    /**
     * Check if each module's dependencies are met and enable the panel if they are.
     * Dependencies are defined in the convert-main.php
     */
    checkDependentModules: function() {
        _.each(this.dependentModules, function(dependencies, dependentModuleName) {
            var isEnabled = _.all(dependencies, function(module, moduleName) {
                return (this.associatedModels[moduleName]);
            }, this);
            this.context.trigger('lead:convert:' + dependentModuleName + ':enable', isEnabled);
        }, this);
    },

    /**
     * Checks if all required modules have been completed
     * Enables the Save button if all are complete
     */
    checkRequired: function() {
        var showSave = _.all(this.meta.modules, function(module) {
            if (module.required) {
                if (!this.associatedModels[module.module]) {
                    return false;
                }
            }
            return true;
        }, this);

        this.context.trigger('lead:convert-save:toggle', showSave);
    },

    /**
     * When save button is clicked, call the Lead Convert API
     */
    handleSave: function() {
        var convertModel, myURL;

        //disable the save button to prevent double click
        this.context.trigger('lead:convert-save:toggle', false);

        app.alert.show('processing_convert', {level: 'process', title: app.lang.get('LBL_SAVING')});

        convertModel = new Backbone.Model(_.extend(
            {'modules' : this.parseEditableFields(this.associatedModels)},
            this.getTransferActivitiesAttributes()
        ));

        myURL = app.api.buildURL('Leads', 'convert', {id: this.context.get('leadsModel').id});

        // Set field_duplicateBeanId for fields implementing FieldDuplicate
        _.each(this.convertPanels, function(view, module) {
            if (view && view.createView && convertModel.get('modules')[module]) {
                view.createView.model.trigger('duplicate:field:prepare:save', convertModel.get('modules')[module]);
            }
        }, this);

        app.api.call('create', myURL, convertModel, {
            success: _.bind(this.convertSuccess, this),
            error: _.bind(this.convertError, this)
        });
    },

    /**
     * Retrieve the attributes to be added to the convert model to support the
     * transfer activities functionality.
     *
     * @return {Object}
     */
    getTransferActivitiesAttributes: function() {
        var action = app.metadata.getConfig().leadConvActivityOpt,
            optedInToTransfer = this.model.get('transfer_activities');

        return {
            transfer_activities_action: (action === 'move' && optedInToTransfer) ? 'move' : 'donothing'
        };
    },

    /**
     * Returns only the fields for the models that the user is allowed to edit.
     * This method is run in the sync method of data-manager for creating records.
     *
     * @param {Object} models to get fields from.
     * @return {Object} Hash of models with editable fields.
     */
    parseEditableFields: function(models) {
        var filteredModels = {};
        _.each(models, function(associatedModel, associatedModule) {
            filteredModels[associatedModule] = app.data.getEditableFields(associatedModel);
        }, this);

        return filteredModels;
    },


    /**
     * Lead was successfully converted
     */
    convertSuccess: function() {
        this.convertComplete('success', 'LBL_CONVERTLEAD_SUCCESS', true);
    },

    /**
     * There was a problem converting the lead
     */
    convertError: function() {
        this.convertComplete('error', 'LBL_CONVERTLEAD_ERROR', false);

        if (!this.disposed) {
            this.context.trigger('lead:convert-save:toggle', true);
        }
    },

    /**
     * Based on success of lead conversion, display the appropriate messages and optionally close the drawer
     * @param {string} level
     * @param {string} message
     * @param {boolean} doClose
     */
    convertComplete: function(level, message, doClose) {
        var leadsModel = this.context.get('leadsModel');
        app.alert.dismiss('processing_convert');
        app.alert.show('convert_complete', {
            level: level,
            messages: app.lang.get(message, this.module, {leadName: app.utils.getRecordName(leadsModel)}),
            autoClose: (level === 'success')
        });
        if (!this.disposed && doClose) {
            this.context.trigger('lead:convert:exit');
            app.drawer.close();
            app.router.record('Leads', leadsModel.id);
        }
    },

    /**
     * Clean up the jquery events that were added
     * @private
     */
    _dispose: function() {
        this.$('.collapse').off();
        app.view.Layout.prototype._dispose.call(this);
    }
}) }
}}
,
"datas": {}

},
		"Currencies":{"fieldTemplates": {
"base": {
"actionmenu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Actionmenu FieldTemplate (base) 

    extendsFrom: 'ActionmenuField',

    /**
     * Binds mass collection events to a record row checkbox.
     *
     * @private
     */
    _bindModelChangeEvents: function() {
        this._super('_bindModelChangeEvents');

        this.massCollection.on('reset', function() {
            // force any disabled field to be unchecked
            var field = this.$(this.fieldTag);
            if (field.prop('disabled')) {
                field.attr('checked', false);
            }
        }, this);
    },

    /**
     * @inheritdoc
     **/
    _onMassCollectionRemoveResetAll: function() {
        // if default currency exists in collection, remove it
        _.each(this.massCollection.models, function(model, index) {
            if (model.id === '-99') {
                this.massCollection.remove(this.massCollection.models[index], {silent: true});
            }
        }, this);

        // force entire property to allow the selected row count alert to display
        if (this.massCollection.length > 0) {
            this.massCollection.entire = true;
        } else {
            this.massCollection.entire = false;
        }

        this._super('_onMassCollectionRemoveResetAll');
    },
}) },
"editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Editablelistbutton FieldTemplate (base) 

    extendsFrom: 'EditablelistbuttonField',

    /**
     * Overriding because Currencies cannot be unlinked nor deleted
     *
     * @inheritdoc
     * @override
     */
    getCustomSaveOptions: function(options) {
        options.complete = function() {};
        return options;
    }
}) }
}}
,
"views": {
"base": {
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * Currencies Record List.
 *
 * @class View.Views.Base.Currencies.RecordlistView
 * @alias SUGAR.App.view.views.BaseCurrenciesRecordlistView
 * @extends View.Views.Base.RecordlistView
 */
({
	// Recordlist View (base) 

    extendsFrom: 'RecordlistView',

    /**
     * @inheritdoc
     **/
    bindDataChange: function() {
        this.collection.on('data:sync:complete', function() {
            this.collection.each(function(model) {
                if (model.get('id') == app.currency.getBaseCurrencyId()) {
                    model.isDefault = true;
                    var defaultLang = app.lang.get('LBL_CURRENCY_DEFAULT', 'Currencies');
                    if (defaultLang) {
                        model.set('name', defaultLang);
                    }
                }
            }, this);

            this.render();
        }, this);

        // call the parent
        this._super('bindDataChange');
    },

    /**
     * @inheritdoc
     **/
    _render: function() {
        this._super('_render');

        var $tableRow = this.$('tr[name="Currencies_-99"]');
        var $rowCheckBox = $tableRow.find('input[name="check"]');
        var $rowActionDropdown = $tableRow.find('a.dropdown-toggle');
        var $defaultCurrencyLabel = $tableRow.find('[data-type="name"] div.ellipsis_inline');

        // Add the default currency class to the default currency row
        if ($defaultCurrencyLabel.length) {
            $defaultCurrencyLabel.addClass('defaultCurrencyLabel');
        }

        // disable the checkbox
        if ($rowCheckBox.length) {
            $rowCheckBox.prop('disabled', true);
        }

        // remove actions
        if ($rowActionDropdown.length) {
            $rowActionDropdown.remove();
        }
    }
}) },
"preview-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Currencies.PreviewHeaderView
 * @alias SUGAR.App.view.views.BaseCurrenciesPreviewHeaderView
 * @extends View.Views.Base.PreviewHeaderView
 */
({
	// Preview-header View (base) 

    extends: 'PreviewHeaderView',
    isBase: false,

    /**
     * @inheritdoc
     * @override
     */
    triggerEdit: function() {
        //If this isn't the base currency, go ahead and display the edit view
        if (!this.isBase) {
            this._super('triggerEdit');
        }
    },

    /**
     *
     * @inheritdoc
     * @override
     * @private
     */
    _delegateEvents: function() {
        this._super('_delegateEvents');
        app.events.on('list:preview:decorate', this.isBaseCurrency, this);
    },

    /**
     * Checks to see if the model is the base currency
     * @param model
     */
    isBaseCurrency: function(model) {
        if (model && _.isFunction(model.get) && model.get('id') === app.currency.getBaseCurrencyId()) {
            this.isBase = true;
        } else {
            this.isBase = false;
        }
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._checkIfBaseCurrency(options);
        this._super('initialize', [options]);
    },

    /**
     * Checks to see if the currency is the base currency
     * @param options
     * @private
     */
    _checkIfBaseCurrency: function(options) {
        if (options.context.get('modelId') == app.currency.getBaseCurrencyId()) {
            var mainDropdownBtn = this._findButton(options.meta.buttons, 'main_dropdown');

            //disable edit
            if (mainDropdownBtn) {
                // disable the edit button
                var editBtn = this._findButton(mainDropdownBtn.buttons, 'edit_button');
                if (editBtn) {
                    editBtn.css_class = editBtn.css_class || '';
                    editBtn.css_class += ' disabled';
                }
            }
            //set fields to read only.
            _.each(options.meta.panels, function(panel) {
                _.each(panel.fields, function(field) {
                    field.readonly = true;
                }, this);
            }, this);
        }
    },

    /**
     * Finds buttons of a given type
     *
     * @param buttons
     * @param name
     * @return {*}
     * @private
     */
    _findButton: function(buttons, name) {
        return _.find(buttons, function(btn) {
            return btn.name === name;
        });
    }

}) }
}}
,
"layouts": {
"base": {
"filterpanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Filterpanel Layout (base) 

    extendsFrom: 'FilterpanelLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {

        this._super('initialize', [options]);

        if (this.context.get('layout') === 'record') {
            this.before('render', function() {
                return false;
            }, this);

            this.template = app.template.empty;
            this.$el.html(this.template());
        }
    }
}) }
}}
,
"datas": {}

},
		"Contracts":{"fieldTemplates": {}
,
"views": {
"base": {
"filter-filter-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Filter-filter-dropdown View (base) 

    extendsFrom: 'FilterFilterDropdownView',

    /**
     * @inheritdoc
     */
    getFilterList: function() {
        var list = this._super('getFilterList').filter(function(obj) {
            if (obj.id == 'favorites') {
                return false;
            }

            return true;
        });

        return list;
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Quotes":{"fieldTemplates": {
"base": {
"quote-data-actiondropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.QuoteDataActiondropdownField
 * @alias SUGAR.App.view.fields.BaseQuotesQuoteDataActiondropdownField
 * @extends View.Fields.Base.BaseActiondropdownField
 */
({
	// Quote-data-actiondropdown FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'BaseActiondropdownField',

    /**
     * @inheritdoc
     */
    className: 'quote-data-actiondropdown'
}) },
"date": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.DateField
 * @alias SUGAR.App.view.fields.BaseQuotesDateField
 * @extends View.Fields.Base.DateField
 */
({
	// Date FieldTemplate (base) 

    extendsFrom: 'DateField',

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // FIXME: this is a bad "fix" added -- when SC-2395 gets done to upgrade bootstrap we need to remove this
        if (this._hasDatePicker && this.$(this.fieldTag).data('datepicker')) {
            $(window).off('resize', this.$(this.fieldTag).data('datepicker').place);
        }
        this._hasDatePicker = false;

        this._super('_dispose');
    }
}) },
"quote-data-actionmenu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.QuoteDataActionmenuField
 * @alias SUGAR.App.view.fields.BaseQuotesQuoteDataActionmenuField
 * @extends View.Fields.Base.BaseActionmenuField
 */
({
	// Quote-data-actionmenu FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'BaseActionmenuField',

    /**
     * Skipping ActionmenuField's override, just returning this.def.buttons
     *
     * @inheritdoc
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.buttons);
    }
}) },
"copy": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.CopyField
 * @alias SUGAR.App.view.fields.BaseQuotesCopyField
 * @extends View.Fields.Base.CopyField
 */
({
	// Copy FieldTemplate (base) 

    extendsFrom: 'CopyField',

    /**
     * If this field is on a view that is converting from a "Ship To" Subpanel
     */
    isConvertingFromShipping: undefined,

    /**
     * If this is a Quote Record Copy
     */
    isCopy: undefined,

    /**
     * Is this the first time the Copy field has run
     */
    firstRun: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.firstRun = true;
        this.isCopy = this.context.get('copy') || false;
        this.isConvertingFromShipping = this.view.isConvertFromShippingOrBilling === 'shipping';
    },

    /**
     * Extending to set Shipping Account Name field editable after copy
     *
     * @inheritdoc
     */
    sync: function(enable) {
        var shippingAcctNameField;
        var isChecked = this._isChecked();

        // do not sync field mappings if this is a quote record copy
        if (this.isCopy) {
            enable = false;
        }

        this._super('sync', [enable]);

        // do not sync field mappings if this is a quote record copy
        if (this.firstRun) {
            this.firstRun = false;
        }

        // if this is coming from a Ship To subpanel and the Copy Billing to Shipping box
        // is not checked then re-enable the Shipping Account Name field so it can be canceled
        if (!isChecked) {
            shippingAcctNameField = this.getField('shipping_account_name');
            if (shippingAcctNameField) {
                shippingAcctNameField.setDisabled(false);
            }
        }
    },

    /**
     * @inheritdoc
     * Overwriting the copy method so that the billing and shipping details are correct when a quote is created from
     * Accounts Quotes Bill-to or Ship-to subpanel
     */
    copy: function(from, to) {
        var _link = this.context.get('fromLink');
        var _fromModule = this.context.previous('parentModel') ?
            this.context.previous('parentModel').get('_module') :
            '';

        // came from Accounts Quote Bill-To
        if (_link === 'quotes' && this.firstRun === true && _fromModule === 'Accounts') {
            var billingAccounts = this.model.get('billing_accounts');

            if (!this.model.has(from)) {
                return;
            }

            if (_.isUndefined(this._initialValues[to])) {
                this._initialValues[to] = this.model.get(to);
            }

            if (to === 'shipping_account_name') {
                this.model.set(to, billingAccounts.name);
            } else if (to === 'shipping_account_id') {
                this.model.set(to, billingAccounts.id);
            } else if (app.acl.hasAccessToModel('edit', this.model, to)) {
                this.model.set(to, billingAccounts[to]);
            }

        } else if (_link === 'quotes_shipto' && this.firstRun === true && _fromModule === 'Accounts') { // came from
            // Accounts Quote Ship-To
            var shippingAccounts = this.model.get('shipping_accounts');

            if (_.isUndefined(this._initialValues[to])) {
                this._initialValues[to] = this.model.get(to);
            }

            if (to === 'shipping_account_name') {
                this.model.set(from, shippingAccounts.name);
            } else if (to === 'shipping_account_id') {
                this.model.set(from, shippingAccounts.id);
            } else if (app.acl.hasAccessToModel('edit', this.model, from)) {
                this.model.set(from, shippingAccounts[from]);
            }
        } else {
            this._super('copy', [from, to]);
        }
    },

    /**
     * Extending to add the model value condition in pre-rendered versions of the field
     *
     * @inheritdoc
     */
    toggle: function() {
        this.sync(this._isChecked());
    },

    /**
     * Pulling this out to a function that can be checked from multiple places if the field
     * is checked or if the field does not exist yet (pre-render) then use the model value
     *
     * @return {boolean} True if the field is checked or false if not
     * @private
     */
    _isChecked: function() {
        return this.$fieldTag ? this.$fieldTag.is(':checked') : this.model.get(this.name);
    },

    /**
     * Extending to check if we need to add sync events or not
     *
     * @inheritdoc
     */
    syncCopy: function(enable) {
        if ((!this.isConvertingFromShipping && !_.isUndefined(this._isChecked())) ||
            (this.isConvertingFromShipping && this._isChecked())) {
            // if this view is not coming from a Ship To convert subpanel,
            // or if it IS but the user specifically checked the Copy Billing to Shipping checkbox
            this._super('syncCopy', [enable]);
        } else {
            // set _inSync to be false so that sync() will work properly
            this._inSync = false;

            if (!enable) {
                // remove sync events from the model
                this.model.off(null, this.copyChanged, this);
                return;
            }
        }
    }
}) },
"badge": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.BadgeField
 * @alias SUGAR.App.view.fields.BaseBadgeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Badge FieldTemplate (base) 

    /**
     * Hash map of the possible labels for the badge
     */
    badgeLabelMap: undefined,

    /**
     * Hash map of the possible CSS Classes for the badge
     */
    cssClassMap: undefined,

    /**
     * The current CSS Class to add to the badge
     */
    currentCSSClass: undefined,

    /**
     * The current Label to use for the badge
     */
    currentLabel: undefined,

    /**
     * The field name to check for the badge
     */
    badgeFieldName: undefined,

    /**
     * The current state of the field
     */
    state: undefined,

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    /**
     * @inheritdoc
     *
     * The badge is always a readonly field.
     */
    initialize: function(options) {
        options.def.readonly = true;
        this._initOptionMaps(options);

        this._super('initialize', [options]);

        this._setState();
    },

    /**
     * Sets up any class hashes defined in metadata
     *
     * @param {Object} options The field def options from metadata
     * @private
     */
    _initOptionMaps: function(options) {
        this.cssClassMap = options.def.css_class_map;
        this.badgeLabelMap = options.def.badge_label_map;
    },

    /**
     * Sets the state of the field, field name, label, css classes, etc
     *
     * @private
     */
    _setState: function() {
        this.badgeFieldName = this.def.related_fields && _.first(this.def.related_fields) || this.name;

        var val = this.model.get(this.badgeFieldName);
        switch (this.def.badge_compare.comparison) {
            case 'notEq':
                this.state = val != this.def.badge_compare.value;
                break;
            case 'eq':
                this.state = val == this.def.badge_compare.value;
                break;
            case 'notEmpty':
                this.state = !_.isUndefined(val) && !_.isEmpty(val.toString());
                break;
            case 'empty':
                this.state = !_.isUndefined(val) && _.isEmpty(val.toString());
                break;
        }

        this.currentLabel = app.lang.get(this.badgeLabelMap[this.state], this.module);
        this.currentCSSClass = this.cssClassMap[this.state];
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:' + this.badgeFieldName, function() {
            if (!this.disposed) {
                this._setState();
                this.render();
            }
        }, this);
    }
}) },
"taxrate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.TaxrateField
 * @alias SUGAR.App.view.fields.BaseQuotesTaxrateField
 * @extends View.Fields.Base.EnumField
 */
({
	// Taxrate FieldTemplate (base) 

    extendsFrom: 'RelateField',

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        this.model.on('change:taxrate_value', this._onTaxRateChange, this);
    },

    /**
     * Sets a new "tax" value when the taxrate changes
     *
     * @param {Data.Bean} model The changed model
     * @param {string} taxrateValue The new taxrate value "8.25", "!0", etc
     * @private
     */
    _onTaxRateChange: function(model, taxrateValue) {
        taxrateValue = taxrateValue || '0';

        var taxratePercent = app.math.div(taxrateValue, '100');
        var newTax = app.math.mul(this.model.get('taxable_subtotal'), taxratePercent);

        this.model.set('tax', newTax);
    },

    /**
     * Extending to add taxrate_value to the id/name values
     *
     * @inheritdoc
     */
    _onSelect2Change: function(e) {
        var plugin = $(e.target).data('select2');
        var id = e.val;
        var value;
        var collection;
        var attributes = {};

        if (_.isUndefined(id)) {
            return;
        }

        value = (id) ? plugin.selection.find('span').text() : $(this).data('rname');
        collection = plugin.context;

        if (collection && !_.isEmpty(id)) {
            // if we have search results use that to set new values
            var model = collection.get(id);
            attributes.id = model.id;
            attributes.value = model.get('value');
            attributes.name = model.get('name');
            _.each(model.attributes, function(value, field) {
                if (app.acl.hasAccessToModel('view', model, field)) {
                    attributes[field] = attributes[field] || model.get(field);
                }
            });
        } else if (e.currentTarget.value && value) {
            // if we have previous values keep them
            attributes.id = value;
            attributes.name = e.currentTarget.value;
            attributes.value = value;
        } else {
            // default to empty
            attributes.id = '';
            attributes.name = '';
            attributes.value = '';
        }

        this.setValue(attributes);
    },

    /**
     * Extending to add taxrate_value to the id/name values
     *
     * @inheritdoc
     */
    setValue: function(models) {
        if (!models) {
            return;
        }
        var updateRelatedFields = true;
        var values = {
            taxrate_id: models.id,
            taxrate_name: models.name,
            taxrate_value: models.value
        };

        if (_.isArray(models)) {
            // Does not make sense to update related fields if we selected
            // multiple models
            updateRelatedFields = false;
        }

        this.model.set(values);

        if (updateRelatedFields) {
            // TODO: move this to SidecarExpressionContext
            // check if link field is currently populated
            if (this.model.get(this.fieldDefs.link)) {
                // unset values of related bean fields in order to make the model load
                // the values corresponding to the currently selected bean
                this.model.unset(this.fieldDefs.link);
            } else {
                // unsetting what is not set won't trigger "change" event,
                // we need to trigger it manually in order to notify subscribers
                // that another related bean has been chosen.
                // the actual data will then come asynchronously
                this.model.trigger('change:' + this.fieldDefs.link);
            }
        }
    }
}) },
"textarea": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.TextareaField
 * @alias SUGAR.App.view.fields.BaseQuotesTextareaField
 * @extends View.Fields.Base.TextareaField
 */
({
	// Textarea FieldTemplate (base) 

    extendsFrom: 'TextareaField',

    shortName: undefined,

    longName: undefined,

    /**
     * @inheritdoc
     *
     * Format the value to a string.
     * Return an empty string for undefined, null and object types.
     * Convert boolean to 1 or 0.
     * Convert array, int and other types to a string.
     *
     * @param {mixed} value to format
     * @return {string} the formatted value
     */
    format: function(value) {
        this.plugins = _.union(this.plugins, 'Tooltip');

        if (_.isString(value)) {
            this.shortName = value.length > 20 ? value.substr(0,20) + '...' : value;
            this.longName = value;

            return value;
        }

        if (_.isUndefined(value) ||
            _.isNull(value) ||
            (_.isObject(value) && !_.isArray(value))
        ) {
            return '';
        }

        if (_.isBoolean(value)) {
            return value === true ? '1' : '0';
        }

        return value.toString();
    },

    /**
     * @inheritdoc
     *
     * Trim whitespace from value.
     */
    unformat: function(value) {
        return value.trim();
    }
}) },
"quote-footer-currency": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.QuoteFooterCurrency
 * @alias SUGAR.App.view.fields.BaseQuotesQuoteFooterCurrency
 * @extends View.Fields.Base.CurrencyField
 */
({
	// Quote-footer-currency FieldTemplate (base) 

    extendsFrom: 'CurrencyField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var isCreate = options.context.isCreate();
        options.viewName = isCreate ? 'edit' : 'detail';

        this._super('initialize', [options]);

        if (!isCreate) {
            // only add this event on record view
            this.events = _.extend({
                'click .currency-field': '_toggleFieldToEdit'
            }, this.events);
        }

        this.model.addValidationTask(
            'isNumeric_validator_' + this.cid,
            _.bind(this._doValidateIsNumeric, this)
        );

        this.action = isCreate ? 'edit' : 'detail';

        this.context.trigger('quotes:editableFields:add', this);
    },

    /**
     * Needed to override loadTemplate to check field permissions for Quotes footer views
     *
     * @inheritdoc
     */
    _loadTemplate: function() {
        if (!this._checkAccessToAction('list')) {
            // set the action to noaccess so the field template will get the right class
            this.action = 'noaccess';
            // if this is a header or footer currency field and there's no access, show noaccess
            this.tplName = 'noaccess';
            this.template = app.template.getField('quote-footer-currency', this.tplName, this.module);
        } else {
            this._super('_loadTemplate');
        }
    },

    /**
     * Toggles the field to edit if it not in edit
     *
     * @param {jQuery.Event} evt jQuery click event
     * @private
     */
    _toggleFieldToEdit: function(evt) {
        var record;

        if (!this.$el.hasClass('edit')) {
            this.action = 'edit';
            this.tplName = 'detail';

            // if this isn't already in edit, toggle to edit
            record = this.closestComponent('record');
            if (record) {
                record.context.trigger('editable:handleEdit', evt);
            }
        }
    },

    /**
     * Validation function to check to see if a value is numeric.
     *
     * @param {Array} fields
     * @param {Array} errors
     * @param {Function} callback
     * @private
     */
    _doValidateIsNumeric: function(fields, errors, callback) {
        var value = this.model.get(this.name);
        if (!$.isNumeric(value)) {
            errors[this.name] = app.lang.get('ERROR_NUMBER');
        }
        callback(null, fields, errors);
    },

    /**
      * Extending to remove the custom validation task for this field
      *
      * @inheritdoc
      * @private
      */
    _dispose: function() {
        this.model.removeValidationTask('isNumeric_validator_' + this.cid);
        this._super('_dispose');
    }
}) },
"currency": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.CurrencyField
 * @alias SUGAR.App.view.fields.BaseQuotesCurrencyField
 * @extends View.Fields.Base.CurrencyField
 */
({
	// Currency FieldTemplate (base) 

    extendsFrom: 'CurrencyField',

    /**
     * The field's value in Percent
     */
    valuePercent: undefined,

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        if (this.name === 'deal_tot' && this.view.name === 'quote-data-grand-totals-header') {
            this.model.on('change:deal_tot_discount_percentage', function() {
                this._updateDiscountPercent();
            }, this);

            if (this.context.get('create')) {
                // if this is deal_tot and on the create view, update the discount percent
                this._updateDiscountPercent();
            }
        }
    },

    /**
     * Needed to override loadTemplate to check field permissions for Quotes header and footer views
     *
     * @inheritdoc
     */
    _loadTemplate: function() {
        var viewName = this.view.name;
        if ((viewName === 'quote-data-grand-totals-header' || viewName === 'quote-data-grand-totals-footer') &&
            !this._checkAccessToAction('list')) {
            // set the action to noaccess so the field template will get the right class
            this.action = 'noaccess';
            // if this is a header or footer currency field and there's no access, show noaccess
            this.tplName = 'noaccess-' + viewName;
            this.template = app.template.getField('currency', this.tplName, this.module);
        } else {
            this._super('_loadTemplate');
        }
    },

    /**
     * Updates `this.valuePercent` for the deal_tot field in the quote-data-grand-totals-header view.
     *
     * @private
     */
    _updateDiscountPercent: function() {
        var percent = this.model.get('deal_tot_discount_percentage');

        if (!_.isUndefined(percent)) {
            //clean up precision
            percent = app.utils.formatNumber(
                percent,
                false,
                app.user.getPreference('decimal_precision'),
                app.user.getPreference('number_grouping_separator'),
                app.user.getPreference('decimal_separator')
            );

            if (app.lang.direction === 'rtl') {
                this.valuePercent = '%' + percent;
            } else {
                this.valuePercent =  percent + '%';
            }

            // re-render after update
            this.render();
        }
    }
}) },
"convert-to-opportunity": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Fields.Base.Quotes.ConvertToOpportunity
 * @alias SUGAR.App.view.fields.BaseQuotesConvertToOpportunity
 * @extends View.Fields.Base.RowactionField
 */
({
	// Convert-to-opportunity FieldTemplate (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     *
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';

        this.context.on('button:convert_to_opportunity:click', this._onCreateOppFromQuoteClicked, this);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('sync', this._toggleDisable, this);
        this.model.on('change:opportunity_id', this._toggleDisable, this);
    },

    /**
     * Handler for when "Create Opp from Quote" is clicked
     * @private
     */
    _onCreateOppFromQuoteClicked: function() {
        var id = this.model.get('id');
        var url = app.api.buildURL('Quotes/' + id + '/opportunity');

        app.alert.show('convert_to_opp', {
            level: 'info',
            title: app.lang.get('LBL_QUOTE_TO_OPPORTUNITY_STATUS'),
            messages: ['']
        });

        app.api.call(
            'create',
            url,
            null,
            {
                success: this._onCreateOppFromQuoteCallback,
                error: this._onCreateOppFromQuoteError
            });
    },

    /**
     * Success callback for Create Opp From Quote
     * @param data Data from the server
     * @private
     */
    _onCreateOppFromQuoteCallback: function(data) {
        var id = data.record.id;
        var url = 'Opportunities/' + id;
        app.alert.dismiss('convert_to_opp');
        app.router.navigate(url, {trigger: true});
    },

    /**
     * Error callback for Create Opp From Quote
     * @param data
     * @private
     */
    _onCreateOppFromQuoteError: function(data) {
        app.alert.dismiss('convert_to_opp');
        app.alert.show('error_convert', {
            level: 'error',
            title: app.lang.get('LBL_ERROR'),
            messages: [data.message]
        });
    },

    /**
     * Reusable method for the event actions
     *
     * @private
     */
    _toggleDisable: function() {
        var opportunityId = this.model.get('opportunity_id');
        this.setDisabled(!(_.isUndefined(opportunityId) || _.isEmpty(opportunityId)));
    }
}) },
"quote-footer-input": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.QuoteFooterInputField
 * @alias SUGAR.App.view.fields.BaseQuotesQuoteFooterInputField
 * @extends View.Fields.Base.Field
 */
({
	// Quote-footer-input FieldTemplate (base) 

    /**
     * The value dollar amount
     */
    value_amount: undefined,

    /**
     * The value percent amount
     */
    value_percent: undefined,

    /**
     * @inheritdoc
     */
    format: function(value) {
        if (!value) {
            this.value_amount = app.currency.formatAmountLocale('0');
            this.value_percent = '0%';
        }
    }
}) },
"datetimecombo": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.DatetimecomboField
 * @alias SUGAR.App.view.fields.BaseQuotesDatetimecomboField
 * @extends View.Fields.Base.DatetimecomboField
 */
({
	// Datetimecombo FieldTemplate (base) 

    extendsFrom: 'DatetimecomboField',

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // FIXME: this is a bad "fix" added -- when SC-2395 gets done to upgrade bootstrap we need to remove this
        if (this._hasTimePicker) {
            this.$(this.secondaryFieldTag).timepicker('remove');
        }

        if (this._hasDatePicker && this.$(this.fieldTag).data('datepicker')) {
            $(window).off('resize', this.$(this.fieldTag).data('datepicker').place);
        }

        this._hasTimePicker = false;
        this._hasDatePicker = false;

        this._super('_dispose');
    }
}) },
"currency-type-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.CurrencyTypeDropdownField
 * @alias SUGAR.App.view.fields.BaseQuotesCurrencyTypeDropdownField
 * @extends View.Fields.Base.EnumField
 */
({
	// Currency-type-dropdown FieldTemplate (base) 

    extendsFrom: 'EnumField',

    /**
     * Holds the compiled currencies templates with symbol/iso by currencyID key
     * @type {Object}
     */
    currenciesTpls: undefined,

    /**
     * The currency ID field name to use on the model when changing currency ID
     * Defaults to 'currency_id' if no currency_field exists in metadata
     * @type {string}
     */
    currencyIdFieldName: undefined,

    /**
     * The base rate field name to use on the model
     * Defaults to 'base_rate' if no base_rate_field exists in metadata
     * @type {string}
     */
    baseRateFieldName: undefined,

    /**
     * The last known record currency id
     * @type {string}
     */
    _lastCurrencyId: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // get the currencies and run them through the template
        this.currenciesTpls = app.currency.getCurrenciesSelector(Handlebars.compile('{{symbol}} ({{iso4217}})'));

        // Type should be enum to use the enum templates
        options.def.type = 'enum';
        // update options defs the currencies templates
        options.def.options = options.def.options || this.currenciesTpls;

        // get the default field names from metadata
        this.currencyIdFieldName = options.def.currency_field || 'currency_id';
        this.baseRateFieldName = options.def.base_rate_field || 'base_rate';

        this._super('initialize', [options]);

        // check to make sure this is a new model or currency_id has not been set, and the model is not a copy
        // so we don't overwrite the models previously entered values
        if ((this.model.isNew() && !this.model.isCopy())) {
            var currencyFieldValue = app.user.getPreference('currency_id');
            var baseRateFieldValue = app.metadata.getCurrency(currencyFieldValue).conversion_rate;

            // set the currency_id to the user's preferred currency
            this.model.set(this.currencyIdFieldName, currencyFieldValue);

            // set the base_rate to the preferred currency conversion_rate
            this.model.set(this.baseRateFieldName, baseRateFieldValue);

            // if this.name is not the same as the currency ID field, also set this.name on the model
            if (this.name !== this.currencyIdFieldName) {
                this.model.set(this.name, currencyFieldValue);
            }

            // Modules such as `Forecasts` uses models that aren't `Data.Bean`
            if (_.isFunction(this.model.setDefault)) {
                var defaults = {};
                defaults[this.currencyIdFieldName] = currencyFieldValue;
                defaults[this.baseRateFieldName] = baseRateFieldValue;
                this.model.setDefault(defaults);
            }
        }

        // track the last currency id to convert the value on change
        this._lastCurrencyId = this.model.get(this.currencyIdFieldName);
    }
}) },
"tristate-checkbox": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Quotes.TristateCheckboxField
 * @alias SUGAR.App.view.fields.BaseQuotesTristateCheckboxField
 * @extends View.Fields.Base.BaseField
 */
({
	// Tristate-checkbox FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    events: {
        'click .checkbox': 'onCheckboxClicked'
    },

    /**
     * The list of possible states the field can be in
     * @type Object
     */
    statesData: undefined,

    /**
     * The previous state's state data
     * @type Object
     */
    previousState: undefined,

    /**
     * The name of the previous state
     * @type string
     */
    previousStateName: undefined,

    /**
     * The current state's state data
     * @type Object
     */
    currentState: undefined,

    /**
     * The name of the current state
     * @type string
     */
    currentStateName: undefined,

    /**
     * If the field is required by other fields
     * @type boolean
     */
    isRequired: undefined,

    /**
     * Text for the field's tooltip
     * @type string
     */
    tooltipText: undefined,

    /**
     * List of any dependent fields
     * @type Object
     */
    dependentFields: undefined,

    /**
     * Stored version of the app lang tooltip label
     */
    tooltipLabel: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.dependentFields = _.clone(this.def.dependentFields) || {};

        this.statesData = this._getStatesData();

        this.isRequired = this.def.required || false;

        this.changeState(this._getInitialState());

        this.tooltipLabel = app.lang.get('LBL_CONFIG_TOOLTIP_FIELD_REQUIRED_BY', this.module);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.context.on(
            'config:' + this.def.eventViewName + ':' + this.name + ':related:toggle',
            this._onToggleRelatedField,
            this
        );
        this.context.on('config:fields:' + this.def.eventViewName + ':reset', this._onFieldsReset, this);
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
    },

    /**
     * Handles changing from the current state to the next state
     *
     * @param {string} nextState The next state to transition to
     */
    changeState: function(nextState) {
        this.previousState = this.currentState;
        this.previousStateName = this.currentStateName;

        this.currentStateName = nextState;
        this.currentState = this.statesData[this.currentStateName];

        this.render();
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._updateTooltipText();

        this._super('render');

        if (this.currentState.isIndeterminate) {
            this.$('.checkbox').prop('indeterminate', true);
        }
    },

    /**
     * Returns if this is a required field or not
     *
     * @return {Object} If required was sent in from the field def or false
     * @protected
     */
    _getIsRequired: function() {
        return this.def.required || false;
    },

    /**
     * Returns the possible states data for the field
     *
     * @return {Object}
     * @protected
     */
    _getStatesData: function() {
        return {
            unchecked: {
                ariaState: 'false',
                checked: false,
                nextState: 'checked',
                nextStateIfRequired: 'checked', // filled
                isIndeterminate: false
            },
            checked: {
                ariaState: 'true',
                checked: true,
                nextState: 'unchecked', // filled
                nextStateIfRequired: 'filled',
                isIndeterminate: false
            },
            filled: {
                ariaState: 'mixed',
                checked: false,
                nextState: 'unchecked',
                nextStateIfRequired: 'checked',
                isIndeterminate: true
            }
        };
    },

    /**
     * Toggles field's inclusion in dependentFields to be ready for updating tooltip text
     *
     * @param {Object|Array} relatedFields Related fields that are dependent upon this field
     * @param {boolean} toggleFieldOn True if we're toggling fields on
     * @private
     */
    _onToggleRelatedField: function(relatedFields, toggleFieldOn) {
        if (!_.isArray(relatedFields)) {
            // make sure related fields is an array
            relatedFields = [relatedFields];
        }

        if (toggleFieldOn) {
            _.each(relatedFields, function(relatedField) {
                this.dependentFields[relatedField.name] = {
                    module: relatedField.def.labelModule,
                    field: relatedField.name,
                    reason: 'related_fields'
                };
            }, this);

            this.isRequired = true;

            if (this.currentStateName === 'unchecked') {
                // if we haven't changed this field from unchecked yet
                // change to the related state
                this.changeState('filled');
            }
        } else {
            _.each(relatedFields, function(relatedField) {
                delete this.dependentFields[relatedField.name];
            }, this);

            if (_.isEmpty(this.dependentFields)) {
                // Removing related fields that are not required by any displayed fields and is not checked
                if (this.currentStateName === 'filled') {
                    this.changeState('unchecked');
                }
                this.isRequired = false;
            }
        }

        // bubble up the related fields
        if (this.def.relatedFields) {
            if (toggleFieldOn ||
                (!toggleFieldOn && !this.isRequired && this.currentStateName === 'unchecked')) {
                // only add this field when we're toggling fields on,
                // or when toggling them off and this field is no longer required
                // and this field is unchecked
                relatedFields.push(this);
            }
            _.each(this.def.relatedFields, function(fieldName) {
                this.context.trigger(
                    'config:' + this.def.eventViewName + ':' + fieldName + ':related:toggle',
                    relatedFields,
                    toggleFieldOn
                );
            }, this);
        }

        this.render();
    },

    /**
     * Handles when the Restore Defaults link is clicked in config-columns
     *
     * @protected
     */
    _onFieldsReset: function(defaultFieldList) {
        // reset dependent fields back
        this.dependentFields = _.clone(this.def.dependentFields) || {};
        this.isRequired = !_.isEmpty(this.dependentFields);

        if (!_.contains(defaultFieldList, this.name)) {
            if (this.def.initialState === 'checked' && !this.isRequired) {
                this.def.initialState = 'unchecked';
            } else if (this.def.initialState === 'unchecked' && this.isRequired) {
                this.def.initialState = 'checked';
            } else if (this.def.initialState === 'checked' && this.isRequired &&
                _.intersection(defaultFieldList, this.dependentFields).length === 0) {
                this.def.initialState = 'unchecked';
                this.def.dependentFields = {};
            }
        } else {
            // Making sure default fields are checked.
            this.def.initialState = 'checked';
        }

        this.changeState(this._getInitialState());
    },

    /**
     * Handles when a user clicks on the field input
     *
     * @param {Event} evt The click event object
     */
    onCheckboxClicked: function(evt) {
        var nextState = this.isRequired ? this.currentState.nextStateIfRequired : this.currentState.nextState;
        var summaryColumns = this.view.model.get('summary_columns');
        evt.preventDefault();

        if (this.def.eventViewName === 'summary_columns' && summaryColumns && summaryColumns.length >= 6 &&
            nextState === 'checked') {
            app.alert.show('max_summaryColumns_reached', {
                level: 'warning',
                messages: app.lang.get('LBL_SUMMARY_WORKSHEET_COLUMNS_MAX_WARNING', this.module),
                autoclose: true
            }, this);

            nextState = 'unchecked';
            this._onCheckboxClicked(this.currentStateName, nextState);
            this.changeState(nextState);
        } else {
            this._onCheckboxClicked(this.currentStateName, nextState);
            this.changeState(nextState);
        }
    },

    /**
     * Handle any other events or actions that need to happen
     * when the checkbox is clicked, but before we change state.
     *
     * @param {string} currentState The name of the current state
     * @param {string} nextState The name of the next state
     * @protected
     */
    _onCheckboxClicked: function(currentState, nextState) {
        this.context.trigger(
            'config:' + this.def.eventViewName + ':field:change',
            this,
            currentState,
            nextState
        );
    },

    /**
     * @inheritdoc
     */
    _updateTooltipText: function() {
        var text;
        var isLTR = app.lang.direction === 'ltr';
        this.tooltipText = '';

        if (!_.isEmpty(this.dependentFields)) {
            this.tooltipText = '<div class="tristate-checkbox-config-tooltip">' + this.tooltipLabel + '<ul>';

            _.each(this.dependentFields, function(field) {
                text = isLTR ? field.module + ' - ' + field.field : field.field + ' - ' + field.module;
                this.tooltipText += '<li>' + text + '</li>';
            }, this);
            this.tooltipText += '</ul></div>';
        }
    },

    /**
     * Returns the initial state for the field
     *
     * @return {string} The initial state for the field
     * @protected
     */
    _getInitialState: function() {
        return this.def.initialState || 'unchecked';
    }
}) }
}}
,
"views": {
"base": {
"product-catalog": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.ProductCatalogView
 * @alias SUGAR.App.view.views.QuotesProductCatalogView
 * @extends View.View
 */
({
	// Product-catalog View (base) 

    plugins: ['CanvasDataRenderer'],

    events: {
        'keyup .product-catalog-search-term': 'onSearchTermChange'
    },

    /**
     * The JSTree Object reference
     */
    jsTree: undefined,

    /**
     * The data for the JSTree Object
     */
    jsTreeData: undefined,

    /**
     * If we are actively fetching data from the server
     */
    isFetchActive: false,

    /**
     * Holds placeholder text for the search input
     */
    searchText: undefined,

    /**
     * Holds the previous search term to prevent duplicate fetches
     */
    previousSearchTerm: undefined,

    /**
     * Keeps track of how many fetches are active
     */
    activeFetchCt: undefined,

    /**
     * Keeps track of the MouseWheel event name for phaser create and dispose
     */
    wheelEventName: undefined,

    /**
     * The PhaserIO game object reference
     */
    phaser: undefined,

    /**
     * Flag if the Phaser Lib has finished loading
     */
    phaserReady: undefined,

    /**
     * Flag if the data has finished loading
     */
    dataLoaded: undefined,

    /**
     * The current search filter term the user is searching for
     */
    currentFilterTerm: undefined,

    /**
     * The main Tree-level module to use when fetching data for the dashlet
     */
    treeModule: undefined,

    /**
     * The config settings and variables for the hierarchy tree
     */
    treeConfig: undefined,

    /**
     * The SpriteSheet object containing id, imagePath, and dataPath
     */
    spriteSheetManifest: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.activeFetchCt = 0;
        this.searchText = this.getSearchTextPlaceholder();

        this.dataLoaded = false;
        this.phaserReady = false;

        this.initializeProviderModules();
        this.treeConfig = this.getTreeStateConfigSettings();
        this.spriteSheetManifest = this.getSpriteSheetManifestObject();

        this.context.on('phaserio:ready', function() {
            this.phaserReady = true;
            this.checkBuildPhaser();
        }, this);
    },

    /**
     * Returns the placeholder string for the Search text input
     * @return {string}
     */
    getSearchTextPlaceholder: function() {
        return app.lang.get('LBL_SEARCH_CATALOG_PLACEHOLDER', 'Quotes');
    },

    /**
     * Initializes any modules needed for data fetching
     */
    initializeProviderModules: function() {
        this.treeModule = 'ProductTemplates';
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        var sidebarLayout;

        this._super('bindDataChange');

        // adding PC Dashlet just return
        if (this.isConfig) {
            return;
        }

        var viewDetails = this.closestComponent('record') ?
            this.closestComponent('record') :
            this.closestComponent('create');

        if (!_.isUndefined(viewDetails)) {
            // need to trigger on app.controller.context because of contexts changing between
            // the PCDashlet, and Opps create being in a Drawer, or as its own standalone page
            // app.controller.context is the only consistent context to use
            app.controller.context.on(viewDetails.cid + ':productCatalogDashlet:add:complete',
                this._onProductDashletAddComplete, this);
        }

        $(window).on('resize', _.bind(this._resizePhaserCanvas, this));

        sidebarLayout = this.closestComponent('sidebar');
        if (sidebarLayout) {
            sidebarLayout.on('sidebar:state:changed', this.onSidebarStateChanged, this);
        }
    },

    /**
     * Handles when the sidebar is toggled open or closed.
     *
     * @param {string} sidebarState The state of the sidebar: 'open' or 'close'
     */
    onSidebarStateChanged: function(sidebarState) {
        if (sidebarState === 'open' && this.phaser) {
            this.checkBuildPhaser();
        }
    },

    /**
     * Gets the search term from the text input
     */
    onSearchTermChange: _.debounce(function(evt) {
        var term = $(evt.target).val().trim();

        if (term !== this.previousSearchTerm) {
            this.previousSearchTerm = term;
            this.loadData({
                searchTerm: term
            });
        }
    }, 500),

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var callbacks;
        var url;
        var term = options && options.searchTerm;
        var method = 'read';
        var payload = {};

        url = this.treeModule + '/tree';

        if (term) {
            method = 'create';
            payload.filter = term;
            this.currentFilterTerm = term;
        } else {
            this.currentFilterTerm = undefined;
        }

        this.$('.product-catalog-no-results').addClass('hidden');

        url = app.api.buildURL(url, method);

        this.toggleLoading(true);

        callbacks = {
            context: this,
            success: this._onCatalogFetchSuccess,
            complete: _.bind(function() {
                if (this.disposed) {
                    return;
                }
                // when complete, remove the spinning refresh icon from the cog
                // and add back the cog icon
                this.toggleLoading(false);
            }, this)
        };

        this.activeFetchCt++;
        app.api.call(method, url, payload, null, callbacks);
    },

    /**
     * Toggles the spinning Loading icon on the header bar
     *
     * @param {boolean} startLoading If we should start the spinning icon or hide it
     */
    toggleLoading: function(startLoading) {
        if (startLoading) {
            this.$('.loading-icon').show();
        } else {
            this.$('.loading-icon').hide();
        }
    },

    /**
     * Handles the ProductTemplates/tree endpoint response
     * and parses data to be used by the tree
     *
     * @param response
     * @protected
     */
    _onCatalogFetchSuccess: function(response) {
        this.jsTreeData = response;
        this.activeFetchCt--;

        if (this.disposed) {
            return;
        }

        if (this.activeFetchCt === 0) {
            if (this.jsTreeData.records.length === 0) {
                this.$('.product-catalog-no-results').removeClass('hidden');
            } else {
                this.$('.product-catalog-no-results').addClass('hidden');
                this.$('.product-catalog-search-term').removeClass('hidden');
            }
        }

        this.dataLoaded = true;

        if (_.isUndefined(this.phaser)) {
            this.checkBuildPhaser();
        } else {
            this.phaser.events.onSetTreeData.dispatch(this.jsTreeData);
        }
    },

    /**
     * Checks if data has been loaded and Phaser is ready to be run
     */
    checkBuildPhaser: function() {
        if (this.dataLoaded && this.phaserReady) {
            this._createPhaser();
        }
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        this.checkBuildPhaser();
    },

    /**
     * When the DOM MouseEvent wheel scroll happens,
     * this function handles it and passes the delta info to Phaser
     *
     * @param {MouseEvent} mouseEvent The mouse scroll wheel event
     * @protected
     */
    _onMouseWheelChange: function(mouseEvent) {
        var delta = mouseEvent.type === 'mousewheel' ?
            mouseEvent.originalEvent.wheelDelta / 20 :
            mouseEvent.originalEvent.deltaY;

        mouseEvent.preventDefault();
        this.phaser.events.onScrollWheel.dispatch(delta);
    },

    /**
     * Event listener for when the Phaser "Tree" State triggers its onTreeReady event
     */
    onPhaserTreeReadyHandler: function() {
        this.phaser.events.onSetTreeData.dispatch(this.jsTreeData);
    },

    /**
     * Wraps getting spritesheets
     *
     * @return {{atlasJSONHash: (*|{imagePath: string, id: string, dataPath: string}[])}}
     */
    getSpriteSheetManifestObject: function() {
        return {
            atlasJSONHash: this._getSpriteSheets()
        };
    },

    /**
     * Returns an array of SpriteSheet location objects and ids for each spritesheet
     *
     * @return {{imagePath: string, id: string, dataPath: string}[]}
     * @protected
     */
    _getSpriteSheets: function() {
        return [{
            id: 'prodCatTS',
            imagePath: 'modules/Quotes/clients/base/views/product-catalog/product-catalog-ss.png',
            dataPath: 'modules/Quotes/clients/base/views/product-catalog/product-catalog-ss.json'
        }];
    },

    /**
     * Returns the Hex-value color to use for the node
     *
     * @param {string} itemType The Item type of the node
     * @param {Object} node The Phaser node we need an icon name
     * @return {string}
     * @protected
     */
    _getTreeNodeTextColor: function(itemType, node) {
        var textColor = '';
        if (itemType === 'category') {
            textColor = this.treeConfig.categoryColor;
        } else if (itemType === 'product' || itemType === 'showMore') {
            textColor = this.treeConfig.itemColor;
        }

        return textColor;
    },

    /**
     * Returns the icon name to use for the node
     *
     * @param {string} itemType The Item type of the node
     * @param {Object} node The Phaser node we need an icon name
     * @return {string}
     * @protected
     */
    _getTreeNodeIconName: function(itemType, node) {
        var iconName = '';
        if (itemType === 'category') {
            iconName = node.state === 'closed' ?
                this._getTreeIconClosedStateName() :
                this._getTreeIconOpenStateName();
        } else if (itemType === 'product') {
            iconName = 'list-alt';
        } else if (itemType === 'showMore') {
            iconName = 'empty';
        }

        return iconName;
    },

    /**
     * Returns the open icon name for the open state of a folder
     *
     * @return {string}
     * @protected
     */
    _getTreeIconOpenStateName: function() {
        return 'folder-open-o';
    },

    /**
     * Returns the closed icon name for the closed state of a folder
     *
     * @return {string}
     * @protected
     */
    _getTreeIconClosedStateName: function() {
        return 'folder';
    },

    /**
     * Extensible function to allow Icon Height to be tweaked based on the icon or node
     *
     * @param {string} iconName
     * @param {Object} node The Phaser node we need an icon height
     * @return {number}
     * @protected
     */
    _getTreeIconHeight: function(iconName, node) {
        return iconName === 'list-alt' ? 12 : this.treeConfig.iconHeight;
    },

    /**
     * Extensible function to allow Icon Height to be tweaked based on the icon or node
     *
     * @param {string} iconName
     * @param {Object} node The Phaser node we need an icon height
     * @return {number}
     * @protected
     */
    _getTreeIconWidth: function(iconName, node) {
        return this.treeConfig.iconWidth;
    },

    /**
     *
     * @param {string} itemType The Item type of the node
     * @param {string} iconName The name of the icon
     * @param {Object} node The Phaser node we need an icon name
     * @return {string} The ID of the SpriteSheet to use
     * @protected
     */
    _getTreeNodeSpriteSheetId: function(itemType, iconName, node) {
        return 'prodCatTS';
    },

    /**
     * Handles when any item on the stage is clicked.
     * This is inside the Phaser conxtext, not the view
     *
     * @param {Phaser.Image|Phaser.Text} target The Phaser text or icon that was clicked
     * @protected
     */
    _onTreeNodeItemClicked: function(target) {
        var isIcon = target instanceof Phaser.Image;

        if (target._itemType === 'category' || target._itemType === 'showMore') {
            this.game._view._onTreeNodeCategoryClicked(target, isIcon);
        } else {
            if (isIcon) {
                this.game._view._onTreeNodeIconClicked(target);
            } else {
                this.game._view._onTreeNodeNameClicked(target);
            }
        }
    },

    /**
     * Handles when a Product Category or "Show More" is clicked
     * This is the View context, not Phaser
     *
     * @param {Phaser.Image|Phaser.Text} target The Phaser text or icon that was clicked
     * @param {boolean} isIcon If the `target` is an image/icon or Text
     * @protected
     */
    _onTreeNodeCategoryClicked: function(target, isIcon) {
        var changeYDelta;
        var isVisible;
        var icon = isIcon ? target : target.parent._icon;
        var isShowMore = target._itemType === 'showMore';
        var openName = this._getTreeIconOpenStateName();
        var closedName = this._getTreeIconClosedStateName();
        var newFrameName = icon.frameName === closedName ? openName : closedName;
        var currentState = this.phaser.state.getCurrentState();

        if (isIcon) {
            icon = target;
            target = _.find(target.parent.children, function(item) {
                return item instanceof Phaser.Text && item._itemId === target._itemId;
            });
        } else {
            icon = _.find(target.parent.children, function(item) {
                return item instanceof Phaser.Image && item._itemId === target._itemId;
            });
        }

        if (target._isFetching) {
            return;
        }

        if (isShowMore || newFrameName === openName) {
            currentState._getMoreRecords(target, icon, isShowMore);
        } else {
            icon.frameName = newFrameName;
            // subtract the group height from the game world height and update
            currentState.gameWorldHeight -= target.parent.childGroup.height;
            currentState._updateGameWorldSize();
        }

        if (target.parent.childGroup) {
            isVisible = !target.parent.childGroup.visible;
            target.parent.childGroup.visible = isVisible;
            changeYDelta = target.parent.childGroup.height;

            if (!isVisible) {
                changeYDelta = -changeYDelta;
            }

            target.parent._events.onChangeY.dispatch(changeYDelta, target.parent);
        }
    },

    /**
     * When a tree item's icon gets clicked
     *
     * @param {Phaser.Image} target The icon that was clicked
     * @protected
     */
    _onTreeNodeIconClicked: function(target) {
        this._fetchRecord(target._itemId, {
            success: _.bind(this._openItemInDrawer, this)
        });
    },

    /**
     * When a tree item's name gets clicked
     *
     * @param {Phaser.Text} target The text label that was clicked
     * @protected
     */
    _onTreeNodeNameClicked: function(target) {
        this._fetchRecord(target._itemId, {
            success: _.bind(this._sendItemToRecord, this)
        });
    },

    /**
     * Returns an EventHub object containing any event Signals the tree will use
     *
     * @return {EventHub} The Event Hub to use with Phaser
     */
    getPhaserEventHub: function() {
        var EventHub = function() {};
        EventHub.prototype = {

            /**
             * Event called outside Phaser to pass tree data into Phaser for parsing/rendering
             */
            onSetTreeData: new Phaser.Signal(),

            /**
             * Event dispatched by Phaser when the Tree State has finished it's create function
             * and is ready for data
             */
            onTreeReady: new Phaser.Signal(),

            /**
             * Event called outside Phaser to pass mouse scroll wheel data into Phaser
             * to know how much to move the camera up or down
             */
            onScrollWheel: new Phaser.Signal(),

            /**
             * Event called outside Phaser to trigger re-drawing UI
             */
            onResize: new Phaser.Signal(),

            /**
             * Handles disposing any Signal events and listeners
             */
            destroy: function() {
                for (var eventName in this) {
                    if (this.hasOwnProperty(eventName) && _.isFunction(this[eventName].dispose)) {
                        this[eventName].dispose();
                    }
                }
            }
        };
        return EventHub;
    },

    /**
     * Returns the canvas ID name Phaser should use
     *
     * @return {string}
     * @protected
     */
    _getPhaserCanvasId: function() {
        return 'product-catalog-canvas-' + this.cid;
    },

    /**
     * Returns the Phaser game config
     *
     * @return {Object}
     */
    getPhaserGameConfig: function() {
        var elIdName = this._getPhaserCanvasId();
        var $el = this.$('#' + elIdName);
        var gameConfig = {
            height: 260,
            parent: elIdName,
            renderer: Phaser.CANVAS,
            transparent: true,
            width: $el.width()
        };

        return this._getPhaserGameConfig(gameConfig);
    },

    /**
     * Extensible function to tweak anything in the game config before sending it to Phaser
     *
     * @param {Object} gameConfig
     * @return {Object}
     * @protected
     */
    _getPhaserGameConfig: function(gameConfig) {
        return gameConfig;
    },

    /**
     * This function creates the actual PhaserIO game object
     *
     * @protected
     */
    _createPhaser: function() {
        var gameConfig = this.getPhaserGameConfig();
        var EventHub = this.getPhaserEventHub();
        var states;

        // remove the phaser console log
        window.PhaserGlobal = {
            hideBanner: true
        };

        if (this.phaser) {
            this.phaser.events.destroy();
            this.phaser.destroy();
        }

        this.phaser = new Phaser.Game(gameConfig);

        this.phaser._view = this;

        this.wheelEventName = 'onwheel' in document.createElement('div') ? 'wheel' : // Modern browsers support "wheel"
            document.onmousewheel !== undefined ? 'mousewheel' : // Webkit and IE support at least "mousewheel"
                'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox

        this.$('.product-catalog-container-' + this.cid).off(this.wheelEventName);
        this.$('.product-catalog-container-' + this.cid).on(
            this.wheelEventName,
            _.bind(this._onMouseWheelChange, this)
        );

        this.phaser.events = new EventHub();
        this.phaser.events.onTreeReady.add(this.onPhaserTreeReadyHandler, this);

        states = this.getStates();
        _.each(states, function(state, index) {
            this.phaser.state.add(index, state);
        }, this);

        this.phaser.state.start('boot');
    },

    /**
     * Gets the states needed to be added to Phaser
     *
     * @return {Object} The states to add to Phaser
     */
    getStates: function() {
        var states = {
            boot: this._getBootState(),
            load: this._getLoadState(),
            tree: this._getTreeState()
        };

        return this._getAdditionalStates(states);
    },

    /**
     * Returns the Phaser.State object for the Boot state
     *
     * @protected
     */
    _getBootState: function() {
        return {
            /**
             * Preload is called as the BootState initializes and lets us set any flags we need later.
             * This is the place for setting any Phaser variables we might need at runtime.
             */
            preload: function() {
                this.game.hasTreeData = false;
            },

            /**
             * After the BootState is done preloading, this function calls the LoadState
             */
            create: function() {
                this.game.state.start('load');
            }
        };
    },

    /**
     * Returns the Phaser.State object for the Load state
     *
     * @protected
     */
    _getLoadState: function() {
        return {
            /**
             * Preload is called as the LoadState initializes and lets us load any assets we'll use later.
             * This would also be the place to add preloading progressbar
             */
            preload: function() {
                // loop over anything in the manifest and load it
                _.each(this.game._view.spriteSheetManifest, function(itemsToLoad, key) {
                    if (!_.isEmpty(itemsToLoad)) {
                        _.each(itemsToLoad, function(item) {
                            switch (key) {
                                case 'json':
                                case 'image':
                                    this.game.load[key](item.id, item.path);
                                    break;

                                case 'atlasJSONHash':
                                case 'bitmapFont':
                                    this.game.load[key](item.id, item.imagePath, item.dataPath);
                                    break;
                            }
                        }, this);
                    }
                }, this);
            },

            /**
             * After the LoadState is done preloading assets, this function calls the TreeState
             */
            create: function() {
                this.game.state.start('tree');
            }
        };
    },

    getTreeStateConfigSettings: function() {
        var config = {
            categoryColor: '#000000',
            itemColor: '#167DE5',
            itemFont: '12px open sans',
            iconTextPadding: 5,
            iconWidth: 16,
            iconHeight: 16,
            iconWidthHalf: this.iconWidth >> 1,
            iconScale: 0.25,
            iconStartX: 5,
            iconYOffset: 8,
            itemRowYPadding: 21,
            childRowYPadding: 10,
            containerRowStartY: 0,
            showMoreNode: {
                data: app.lang.get('LBL_SHOW_MORE'),
                type: 'showMore'
            },
            showMoreNodeIconName: 'folder-open-o',
            scrollBarBkgdBorderLineSize: 1,
            scrollBarBkgdWidth: 15,
            scrollBarBkgdBorderColor: 0xE8E8E8,
            scrollBarBkgdFill: 0xFAFAFA,
            scrollBarBkgdFillIE: 0xF0F0F0,
            scrollThumbWidth: 8,
            scrollThumbHeight: 16,
            scrollThumbFillColor: 0xC1C1C1,
            scrollThumbFillHoverColor: 0x7D7D7D,
            scrollThumbTopBottomPadding: 3
        };

        return this._getTreeStateConfigSettings(config);
    },

    /**
     * Extensible function if anything needs to be added or removed from cfg
     *
     * @param cfg
     * @return {Object}
     * @protected
     */
    _getTreeStateConfigSettings: function(cfg) {
        return cfg;
    },

    /**
     * Returns the Phaser.State object for the Tree state
     *
     * @protected
     */
    _getTreeState: function() {
        var treeConfig = this.treeConfig = this.getTreeStateConfigSettings();
        var treeState = {
            isLoading: false,
            groups: undefined,
            rootGroup: undefined,
            dashletHeight: undefined,
            gameWorldHeight: undefined,
            gameWorldWidth: undefined,
            cameraY: undefined,
            GroupEventHub: undefined,
            scrollBarImg: undefined,
            scrollBarThumbImg: undefined,
            scrollThumbHoverImg: undefined,
            scrollThumbImg: undefined,
            previousScrollThumbY: 0,
            scrollPercentHeight: 0,
            scrollThumbHoverInTween: undefined,
            scrollThumbHoverOutTween: undefined,
            maxScrollY: undefined,
            useScrollbar: true,
            isLangRTL: false,

            /**
             * Preload is called as the TreeState initializes and lets us setup any vars we need for the state
             */
            preload: function() {
                var $el = this.game._view.$('#' + this.game._view._getPhaserCanvasId());

                this.groups = [];
                this.gameWorldHeight = 0;
                this.gameWorldWidth = $el.width();
                this.dashletHeight = $el.height();
                this.cameraY = 0;
                this.isLoading = false;
                this.isLangRTL = app.lang.direction === 'rtl';

                this.game.events.onSetTreeData.add(this._setTreeData, this);
                this.game.events.onScrollWheel.add(this._onScrollWheel, this);
                this.game.events.onResize.add(this._onResize, this);

                this.GroupEventHub = function() {
                    return {
                        onChangeY: new Phaser.Signal(),
                        destroy: function() {
                            for (var eventName in this) {
                                if (this.hasOwnProperty(eventName) && _.isFunction(this[eventName].dispose)) {
                                    this[eventName].dispose();
                                }
                            }
                        }
                    };
                };

                // use scrollbar as long as we're not using firefox or safari or ie
                this.useScrollbar = !(this.game.device.firefox || this.game.device.safari || this.game.device.ie);

                if (this.game.hasTreeData) {
                    this._setTreeData(this.game.treeData);
                }
            },

            /**
             * After preload is done, create runs and lets us let the Sugar.App know our tree is ready
             */
            create: function() {
                this._updateGameWorldSize();
                this.game.events.onTreeReady.dispatch();
            },

            /**
             * Handles the Mouse ScrollWheel event being passed from the DOM to Phaser.
             * The yDelta value gets added to `this.cameraY` so that the next game "tick" event
             * that happens during the state's `update` function, we can move the
             * game's camera object up or down.
             *
             * @param yDelta
             * @private
             */
            _onScrollWheel: function(yDelta) {
                // update the camera position by the yDelta
                this.game.camera.y += yDelta;

                // only need to update scrollbar if it exists
                if (this.scrollBarThumbImg) {
                    this._updateScrollThumbToCamera();
                }
            },

            /**
             * Re-orients the scroll thumb to the camera position in the world.
             * This allows the camera and thumb to stay in sync after a Show More event.
             *
             * @private
             */
            _updateScrollThumbToCamera: function() {
                var percentCameraGameHeightDiff = this.game.camera.y / this.gameWorldHeight;
                var newScrollY = percentCameraGameHeightDiff * this.dashletHeight;

                // update the scrollbar thumb
                this.scrollBarThumbImg.cameraOffset.y = newScrollY;

                // make sure we're not out of bounds
                this._checkBounds(this.scrollBarThumbImg);
            },

            /**
             * Handles the Phaser onResize event and updates the game world and scrollbar
             * @private
             */
            _onResize: function() {
                this._updateGameWorldSize();
            },

            /**
             * This event is triggered when a user clicks to expand or collapse a Group.
             * yDelta will be positive (the group needs to expand) or negative (the group is being hidden)
             *
             * @param {number} yDelta The amount to change the Y value of Groups
             * @private
             */
            _onChangeY: function(yDelta) {
                var rowIndex;
                var groups;
                var groupLen;

                if (this.parent.parent instanceof Phaser.Stage) {
                    // once we hit the "rootGroup" group level
                    // just return and break out of this event loop
                    return;
                }

                // we need to move all groups that come after this group
                // get the next index for any items we need to move after this group
                rowIndex = this._rowIndex + 1;

                // get all of the Phaser.Groups at "this" level (this.parent.children)
                groups = _.filter(this.parent.children, function(child) {
                    return child instanceof Phaser.Group;
                });

                // get the length of the groups
                groupLen = groups.length;

                // loop over each group after "this" group and move it up/down by the yDelta
                for (rowIndex; rowIndex < groupLen; rowIndex++) {
                    groups[rowIndex].y += yDelta;
                }

                // update the parent group with the correct yOffset to apply to its children
                this.parent._yOffset += yDelta;

                // cause the event to "bubble" up to the next level
                this.parent._events.onChangeY.dispatch(yDelta, this);
            },

            /**
             * Sets the main tree data and starts building the levels and nodes.
             * This is called when the page loads and when a user types in to search for data.
             *
             * @param treeData
             * @private
             */
            _setTreeData: function(treeData) {
                var groupIndex = 0;
                var elIdName = this.game._view._getPhaserCanvasId();
                var $el = this.game._view.$('#' + elIdName);

                this.dashletHeight = $el.height();
                this.gameWorldWidth = $el.width();
                this.gameWorldHeight = 0;
                this.cameraY = 0;
                this.game.camera.y = 0;

                if (this.rootGroup) {
                    if (this.rootGroup.childGroup) {
                        this.rootGroup.childGroup._events.destroy();
                        this.rootGroup.childGroup.destroy();
                    }

                    this.rootGroup._events.destroy();
                    this.rootGroup.destroy();
                }

                this.rootGroup = this.game.add.group();
                this.rootGroup.name = 'rootGroup';
                this.rootGroup._groupIndex = -1;
                this.rootGroup._events = new this.GroupEventHub();
                this.rootGroup._events.onChangeY.add(this._onChangeY, this.rootGroup);
                this.rootGroup.childGroup = this._createGroupObject(-1, 0);

                _.each(treeData.records, function(node, index) {
                    this._createLevel(this.rootGroup.childGroup, node, groupIndex, index);
                }, this);

                if (treeData.next_offset !== -1) {
                    this._createLevel(this.rootGroup.childGroup, this.showMoreNode, groupIndex, treeData.next_offset);
                }

                this._updateGameWorldSize();
                // reset the camera back to the top 0 position
                this.game.camera.y = 0;
            },

            /**
             * Creates a Phaser.Group and sets some default properties
             *
             * @private
             * @return {Phaser.Group} group The newly created group
             */
            _createGroupObject: function(groupIndex, rowIndex) {
                var group = this.game.add.group();

                // set the group's name and some other indexes to help keep track
                // of where this group exists in its parents hierarchy
                group.name = 'group-' + groupIndex + '-' + rowIndex;
                group._groupIndex = groupIndex;
                group._rowIndex = rowIndex;
                group._yOffset = 0;

                // add an Events hub on this group to pass events
                group._events = new this.GroupEventHub();
                group._events.onChangeY.add(this._onChangeY, group);

                return group;
            },

            /**
             * Creates a "level" including category and any children
             *
             * @param {Phaser.Group} parentGroup The parent group to add this category and children to
             * @param {Object} node The JSON Object data from the tree for this node level
             * @param {number} groupIndex The Group level index from rootGroup
             * @param {number} rowIndex The specific row level index of this node inside its Group
             *                  groups pushing this group down
             * @private
             */
            _createLevel: function(parentGroup, node, groupIndex, rowIndex) {
                var group = this._createGroupObject(groupIndex, rowIndex);
                var groupYOffset = parentGroup._yOffset || 0;

                // create the group's icon and text label
                this._createNode(group, node, groupIndex, rowIndex);

                // update the overall game world height
                this.gameWorldHeight += this.itemRowYPadding;

                // add this new group to the parent
                parentGroup.add(group);

                if (parentGroup._groupIndex !== -1 && parentGroup.parent._groupIndex !== -1) {
                    group.parentGroup = parentGroup.parent;
                } else {
                    group.parentGroup = parentGroup;
                }

                if (node.type === 'showMore') {
                    group.parentGroup._nextOffset = rowIndex;
                }

                if (this.isLangRTL) {
                    group.x = 0;
                } else {
                    group.x = groupIndex === 0 ? 0 : this.iconWidth + this.iconStartX;
                }
                group.y = this.containerRowStartY + (this.itemRowYPadding * rowIndex) + groupYOffset;
            },

            /**
             * This function creates the actual Icon and Text label and adds them to the Group
             *
             * @param {Phaser.Group} group
             * @param {Object} node The JSON Object data from the tree for this node level
             * @param {number} groupIndex The Group level index from rootGroup
             * @param {number} rowIndex The specific row level index of this node inside its Group
             * @private
             */
            _createNode: function(group, node, groupIndex, rowIndex) {
                var icon;
                var text;
                var iconName;
                var textColor;
                var itemType = node.type;
                var itemId = node.id;
                var itemName = node.data;
                var startX;
                var startY;
                var gameView = this.game._view;
                var iconSpriteSheetId;

                textColor = gameView._getTreeNodeTextColor(itemType, node);
                iconName = gameView._getTreeNodeIconName(itemType, node);
                iconSpriteSheetId = gameView._getTreeNodeSpriteSheetId(itemType, iconName, node);

                startX = this.iconStartX + 8;
                startY = this.iconYOffset;

                if (this.isLangRTL) {
                    startX = this.gameWorldWidth - (startX * (groupIndex + 1)) - (this.iconWidthHalf * groupIndex);
                }

                // create the icon
                icon = this.game.add.image(
                    startX,
                    startY,
                    iconSpriteSheetId,
                    iconName
                );
                icon.height = gameView._getTreeIconHeight(iconName, node);
                icon.width = gameView._getTreeIconWidth(iconName, node);
                icon.anchor.setTo(0.5, 0.5);
                icon._itemName = itemName;
                icon._itemId = itemId;
                icon._itemType = itemType;
                icon._tween = this.game.add.tween(icon).to({
                    angle: 360
                }, 3600, null, false, 0, -1);

                icon.inputEnabled = true;
                icon.events.onInputDown.add(gameView._onTreeNodeItemClicked, this);
                icon.input.useHandCursor = true;

                if (this.isLangRTL) {
                    startX -= this.iconWidth - this.iconTextPadding;
                } else {
                    startX = this.iconStartX + this.iconWidth + this.iconTextPadding;
                }

                text = this.game.add.text(
                    startX,
                    0,
                    node.data,
                    {
                        font: this.itemFont,
                        fill: textColor
                    }
                );

                if (this.isLangRTL) {
                    text.anchor.setTo(1, 0);
                }

                text._itemName = itemName;
                text._itemId = itemId;
                text._itemType = itemType;

                text.inputEnabled = true;
                text.events.onInputDown.add(gameView._onTreeNodeItemClicked, this);
                text.input.useHandCursor = true;

                group.name = group.name + '-' + itemName;
                group._itemName = itemName;
                group._itemId = itemId;
                group._itemType = itemType;
                group._icon = icon;
                group._text = text;
                group.add(icon);
                group.add(text);
            },

            /**
             * Handles fetching more records for the target root item
             *
             * @param {Phaser.Image|Phaser.Text} target The Phaser text or icon that was clicked
             * @param {Phaser.Image} icon The icon image object for the clicked item
             * @private
             */
            _getMoreRecords: function(target, icon, isShowMore) {
                var offset;
                var itemId = target._itemId;

                if (isShowMore && target.parent.parentGroup && target.parent.parentGroup._nextOffset !== -1) {
                    offset = target.parent.parentGroup._nextOffset;
                    itemId = target.parent.parentGroup._itemId;
                }

                if (_.isUndefined(target.parent.childGroup) || (!_.isUndefined(offset) && offset !== -1)) {
                    icon.frameName = 'refresh';
                    icon._tween.start();
                    target._isFetching = true;
                    icon._isFetching = true;

                    this.game._view._fetchMoreRecords(
                        itemId,
                        offset,
                        isShowMore,
                        _.bind(this._setMoreRecordsData, this, target, icon, isShowMore)
                    );
                } else {
                    icon.frameName = this.game._view._getTreeIconOpenStateName();
                    // add the group height to the game world height and update
                    this.gameWorldHeight += target.parent.childGroup.height;
                    this._updateGameWorldSize();
                }
            },

            /**
             * Updates Phaser's bounds and world size with the current gameWorldHeight
             *
             * @private
             */
            _updateGameWorldSize: function() {
                var $el = this.game._view.$('#product-catalog-canvas-' + this.game._view.cid);

                this.dashletHeight = $el.height();
                this.gameWorldWidth = $el.width();

                this.scrollPercentHeight = this.dashletHeight / this.gameWorldHeight;

                this.game.world.setBounds(0, 0, this.gameWorldWidth, this.gameWorldHeight);
                this.game.world.resize(this.gameWorldWidth, this.gameWorldHeight);
                this.game.camera.setBoundsToWorld();

                this.scrollThumbHeight = Math.floor(this.scrollPercentHeight * this.dashletHeight);

                if (this.useScrollbar) {
                    // only need to worry about this stuff if we're using scrollbar
                    if (this.scrollPercentHeight < 1) {
                        // the gameWorldHeight is greater than dashletHeight so we need a scrollbar
                        this.drawScrollbar();

                        this.scrollCheckTimerEvent = this.game.time.events.repeat(500, 40, this._checkScrollbar, this);
                    } else if (this.scrollBarThumbImg) {
                        // we no longer need a scrollbar, and this.scrollBarImg exists, so we need to remove it
                        this.scrollBarImg.destroy();
                        this.scrollThumbImg.destroy();
                        this.scrollBarThumbImg.destroy();
                    }
                }
            },

            /**
             * TimerEvent handler to check and see if the game world width has changed since last time
             * @private
             */
            _checkScrollbar: function() {
                var $el;

                if (this.game._view.disposed) {
                    this.game.time.events.remove(this.scrollCheckTimerEvent);
                    this.scrollCheckTimerEvent = null;
                    return;
                }

                $el = this.game._view.$('#product-catalog-canvas-' + this.game._view.cid);
                if ($el.width() !== this.gameWorldWidth) {
                    this.game.time.events.remove(this.scrollCheckTimerEvent);
                    this.scrollCheckTimerEvent = null;

                    this._updateGameWorldSize();
                }
            },

            /**
             * Draws the Scrollbar line and rectangle
             */
            drawScrollbar: function() {
                var scrollX = this.isLangRTL ? this.scrollBarBkgdWidth : this.gameWorldWidth - this.scrollBarBkgdWidth;
                var xOffset = this.game.device.ie ? 0 : 4;

                if (this.scrollBarImg) {
                    this.scrollBarImg.destroy();
                    this.scrollThumbImg.destroy();
                    this.scrollBarThumbImg.destroy();
                }

                // draw the scrollbar background image
                this.scrollBarImg = this.game.add.image(scrollX, 0, this._drawScrollBkgdBar());
                this.scrollBarImg.fixedToCamera = true;

                // draw the parent scroll thumb container
                this.scrollBarThumbImg = this.game.add.image(scrollX + xOffset, 0);

                // draw the scroll thumb image
                this.scrollThumbImg = this.game.add.image(
                    0,
                    this.scrollThumbTopBottomPadding,
                    this._drawScrollThumb(this.scrollThumbFillColor)
                );

                // draw the scroll thumb hover image
                this.scrollThumbHoverImg = this.game.add.image(
                    0,
                    this.scrollThumbTopBottomPadding,
                    this._drawScrollThumb(this.scrollThumbFillHoverColor)
                );

                // add the scroll thumb and hover image to the main scrollbar thumb
                this.scrollBarThumbImg.addChild(this.scrollThumbImg);
                this.scrollBarThumbImg.addChild(this.scrollThumbHoverImg);

                this.scrollThumbHoverInTween = this.game.add.tween(this.scrollThumbHoverImg).to({alpha: 1}, 100);
                this.scrollThumbHoverOutTween = this.game.add.tween(this.scrollThumbHoverImg).to({alpha: 0}, 100);

                this.scrollThumbHoverImg.alpha = 0;

                this.scrollBarThumbImg.inputEnabled = true;
                this.scrollBarThumbImg.input.enableDrag();
                // only allow the thumb vertical drag
                this.scrollBarThumbImg.input.allowHorizontalDrag = false;
                this.scrollBarThumbImg.events.onDragStart.add(this._checkDragThumbBounds, this);
                this.scrollBarThumbImg.events.onDragUpdate.add(this._checkDragThumbBounds, this);
                this.scrollBarThumbImg.events.onDragStop.add(this._checkDragThumbBounds, this);
                this.scrollBarThumbImg.fixedToCamera = true;

                this.scrollBarThumbImg.events.onInputOver.add(function() {
                    this.scrollThumbHoverInTween.start();
                }, this);
                this.scrollBarThumbImg.events.onInputOut.add(function() {
                    this.scrollThumbHoverOutTween.start();
                }, this);

                this.maxScrollY = this.dashletHeight - this.scrollThumbHeight;

                if (this.game.camera.y !== 0) {
                    this._updateScrollThumbToCamera();
                }
            },

            /**
             * Draws the scrollbar background well
             *
             * @return {Phaser.Texture}
             * @private
             */
            _drawScrollBkgdBar: function() {
                var bar = this.game.make.graphics();
                var bkgdFill = this.game.device.ie ? this.scrollBarBkgdFillIE : this.scrollBarBkgdFill;

                bar.lineStyle(this.scrollBarBkgdBorderLineSize, this.scrollBarBkgdBorderColor, 1);
                bar.beginFill(bkgdFill, 1);
                bar.drawRect(0, 0, this.scrollBarBkgdWidth, this.dashletHeight);
                return bar.generateTexture();
            },

            /**
             * Draws the actual scrollbar thumb
             *
             * @return {Phaser.Texture}
             * @private
             */
            _drawScrollThumb: function(fillColor) {
                var thumb = this.game.make.graphics();
                thumb.lineStyle(0);
                thumb.beginFill(fillColor, 1);

                if (this.game.device.ie) {
                    thumb.drawRect(0, 0, this.scrollBarBkgdWidth, this.scrollThumbHeight);
                } else {
                    thumb.drawRoundedRect(
                        0,
                        0,
                        this.scrollThumbWidth,
                        this.scrollThumbHeight - this.scrollThumbTopBottomPadding - this.scrollThumbTopBottomPadding,
                        5
                    );
                }

                return thumb.generateTexture();
            },

            /**
             * Checks the bounds of `sprite` to make sure the Y value
             * is between 0 and the height of the dashlet
             *
             * @param {Phaser.Image} image The Phaser Image to check bounds
             * @private
             */
            _checkBounds: function(image) {
                if (image.cameraOffset.y < 0) {
                    image.cameraOffset.y = 0;
                }
                if (image.cameraOffset.y > this.maxScrollY) {
                    image.cameraOffset.y = this.maxScrollY;
                }
            },

            /**
             * Handles checking bounds of the scrollbar thumb
             * @param image
             * @private
             */
            _checkDragThumbBounds: function(image) {
                var scrollbarDashletDiff;

                this._checkBounds(image);

                if (this.previousScrollThumbY !== image.cameraOffset.y) {
                    // only update camera if scroll thumb changed Y pos

                    // get the percent difference between how far down the scrollbar has moved
                    // and the height of the dashlet
                    scrollbarDashletDiff = image.cameraOffset.y / this.dashletHeight;
                    // multiply that percent diff by the total game world height
                    this.game.camera.y = scrollbarDashletDiff * this.gameWorldHeight;

                    // set the previous to the current camera offset
                    this.previousScrollThumbY = image.cameraOffset.y;
                }
            },

            /**
             * Handles when a user clicks a new category or Show More
             *
             * @param {Phaser.Image|Phaser.Text} target The Phaser text or icon that was clicked
             * @param {Phaser.Image} icon The icon image object for the clicked item
             * @param {boolean} isIcon If the `target` is an image/icon or Text
             * @param {Object} data The server data with records and offset
             * @private
             */
            _setMoreRecordsData: function(target, icon, isShowMore, data) {
                var childGroup;
                var triggerParent;
                var groupIndex = target.parent._groupIndex;
                var isVisible;
                var changeYDelta;
                var nextRowIndex = 0;

                target._isFetching = false;
                icon._isFetching = false;

                if (isShowMore) {
                    // in the case where a user searches for a term, the root group is the parentGroup
                    // and there is no childGroup on that parentGroup
                    childGroup = target.parent.parentGroup.childGroup || target.parent.parentGroup;
                    // set the next row index to whatever the offset is
                    nextRowIndex = target.parent.parentGroup._nextOffset;
                    // the correct parent to trigger changeY on
                    triggerParent = target.parent.parentGroup;
                } else {
                    childGroup = target.parent.childGroup;
                    // only increment the group's index if this is not a "Show More" group situation
                    groupIndex++;
                    // the correct parent to trigger changeY on
                    triggerParent = target.parent;
                }

                if (!childGroup) {
                    childGroup = this._createGroupObject(groupIndex, 0);

                    target.parent.childGroup = childGroup;
                    target.parent.add(childGroup);
                }

                childGroup._previousHeight = childGroup.height;

                _.each(data.records, function(node, index) {
                    this._createLevel(childGroup, node, groupIndex, nextRowIndex + index);
                }, this);

                if (data.next_offset !== -1) {
                    this._createLevel(childGroup, this.showMoreNode, groupIndex, data.next_offset);
                }

                icon.frameName = this.showMoreNodeIconName;
                icon.angle = 0;
                icon._tween.stop();

                if (isShowMore) {
                    // shrink game world as we remove Show More later
                    this.gameWorldHeight -= this.itemRowYPadding;

                    // remove the parent container for the text from its parent
                    target.parent.parent.remove(target.parent);
                    // remove the icon and text from the parent
                    target.parent.remove(icon);
                    target.parent.remove(target);
                    icon.destroy();
                    target.destroy();
                } else {
                    childGroup.y = this.itemRowYPadding;
                    childGroup._nextOffset = data.next_offset;
                }

                isVisible = childGroup.visible;
                changeYDelta = childGroup.height - childGroup._previousHeight;

                if (!isVisible) {
                    changeYDelta = -changeYDelta;
                }

                triggerParent._events.onChangeY.dispatch(changeYDelta, triggerParent);

                this._updateGameWorldSize();
            },
        };

        return $.extend({}, treeConfig, treeState);
    },

    /**
     * Extensible function to add any additional states needed
     *
     * @param {Object} states
     * @return {Object}
     * @protected
     */
    _getAdditionalStates: function(states) {
        return states;
    },

    /**
     * Fetches additional records from the database for a given node id and offset
     *
     * @param {string} id The parent hash id for the record
     * @param {int} offset
     * @param callback
     * @protected
     */
    _fetchMoreRecords: function(id, offset, isShowMore, callback) {
        var callbacks;
        var method = 'create';
        var url = app.api.buildURL(this.treeModule + '/tree', method);
        var payload = {};

        if (!_.isUndefined(id)) {
            payload.root = id;
        }

        if (!_.isUndefined(offset)) {
            payload.offset = offset;
        }

        if (isShowMore && !_.isUndefined(this.currentFilterTerm)) {
            payload.filter = this.currentFilterTerm;
        }

        this.toggleLoading(true);

        callbacks = {
            context: this,
            success: callback,
            complete: _.bind(function() {
                this.activeFetchCt--;
                // when complete, remove the spinning refresh icon from the cog
                // and add back the cog icon
                this.toggleLoading(false);
            }, this)
        };

        this.activeFetchCt++;
        app.api.call(method, url, payload, null, callbacks);
    },

    /**
     * Fetchs a Record given the ID, and sends the response data to `callbacks.success`
     *
     * @param {string} id The ProductTemplate ID Hash to fetch
     * @param {Object} callbacks The callback object with any success/error/complete handler functions
     * @protected
     */
    _fetchRecord: function(id, callbacks) {
        var module = this.getFetchRecordModule();
        var url = app.api.buildURL(module + '/' + id, 'read');
        app.api.call('read', url, null, null, callbacks);
    },

    /**
     * Returns the module name to use for fetching records
     * before sending them to the drawer or record
     *
     * @return {string}
     */
    getFetchRecordModule: function() {
        return this.treeModule;
    },

    /**
     * Sends the ProductTemplate data item to the Quote
     *
     * @param {Object} data The ProductTemplate data
     * @protected
     */
    _sendItemToRecord: function(data) {
        this._massageDataBeforeSendingToRecord(data);

        var viewDetails = this.closestComponent('record') ?
            this.closestComponent('record') :
            this.closestComponent('create');
        // need to trigger on app.controller.context because of contexts changing between
        // the PCDashlet, and Opps create being in a Drawer, or as its own standalone page
        // app.controller.context is the only consistent context to use
        if (!_.isUndefined(viewDetails)) {
            app.controller.context.trigger(viewDetails.cid + ':productCatalogDashlet:add', data);
        }
    },

    /**
     * Allows `data` to be manipulated and updated before sending to the record
     *
     * @param {Object} data The data we're sending to the Record
     * @protected
     */
    _massageDataBeforeSendingToRecord: function(data) {
        data.position = 0;
        data._forcePosition = true;

        // copy Template's id and name to where the QLI expects them
        data.product_template_id = data.id;
        data.product_template_name = data.name;

        // remove ID/etc since we dont want Template ID to be the record id
        delete data.id;
        delete data.status;
        delete data.date_entered;
        delete data.date_modified;
        delete data.pricing_formula;
    },

    /**
     * Sends the ProductTemplate data item to a Drawer layout
     *
     * @param {Object} data The ProductTemplate data
     * @protected
     */
    _openItemInDrawer: function(data) {
        var model = app.data.createBean('ProductTemplates', data);
        var viewDetails = this.closestComponent('record') ?
            this.closestComponent('record').cid :
            this.closestComponent('create').cid;

        model.viewId = viewDetails;
        app.drawer.open({
            layout: 'product-catalog-dashlet-drawer-record',
            context: {
                module: 'ProductTemplates',
                model: model
            }
        });
    },

    /**
     * Handles when sending ProductTemplate data has been complete and we can enable the tree again
     *
     * @protected
     */
    _onProductDashletAddComplete: function() {
        this.isFetchActive = false;
        this.$('#product-catalog-container-' + this.cid).removeClass('disabled');
    },

    /**
     * Resizes the Phaser Canvas width and height when the window is resized
     *
     * @protected
     */
    _resizePhaserCanvas: function() {
        var $el = this.$('.product-catalog-container-' + this.cid);

        if (this.phaser && $el.length && this.phaser.scale) {
            this.phaser.scale.setGameSize($el.width(), $el.height());
            this.phaser.events.onResize.dispatch();
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var sidebarLayout = this.closestComponent('sidebar');
        if (sidebarLayout) {
            sidebarLayout.off('sidebar:state:changed', null, this);
        }
        this.context.off('phaserio:ready', null, this);

        // If Phaser exists, destroy it
        if (this.phaser) {
            this.phaser.events.destroy();
            // async the phaser destroy event so it
            // has a chance to finish its update before destroy
            _.delay(_.bind(function() {
                this.phaser.destroy();
            }, this), 25);

        }

        // any cleanup
        this.$('.product-catalog-container-' + this.cid).off(this.wheelEventName);
        // remove window resize event
        $(window).off('resize');
        if (app.controller && app.controller.context) {
            if (this.isConfig) {
                this._super('_dispose');
                return;
            }

            var viewDetails = this.closestComponent('record') ?
                this.closestComponent('record') :
                this.closestComponent('create');

            if (!_.isUndefined(viewDetails)) {
                app.controller.context.off(viewDetails.cid + ':productCatalogDashlet:add:complete', null, this);
            }
        }
        this._super('_dispose');
    }
}) },
"quote-data-grand-totals-footer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.QuoteDataGrandTotalsFooterView
 * @alias SUGAR.App.view.views.BaseQuotesQuoteDataGrandTotalsFooterView
 * @extends View.Views.Base.View
 */
({
	// Quote-data-grand-totals-footer View (base) 

    /**
     * @inheritdoc
     */
    className: 'quote-data-grand-totals-footer'
}) },
"config-totals-footer-rows": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.ConfigTotalsFooterRowsView
 * @alias SUGAR.App.view.views.BaseQuotesConfigTotalsFooterRowsView
 * @extends View.Views.Base.View
 */
({
	// Config-totals-footer-rows View (base) 

    /**
     * CSS Class for Totals fields
     */
    sortableFieldsContainerClass: 'totals-fields',

    /**
     * CSS Class for Grand Totals fields
     */
    sortableGrandTotalFieldsContainerClass: 'grand-total-fields',

    /**
     * Array to hold the Totals fields objects
     */
    footerFields: undefined,

    /**
     * Array to hold the Grand Totals fields objects
     */
    footerGrandTotalFields: undefined,

    /**
     * Data attribute key to use for Totals fields
     */
    fieldTotalKey: 'total',

    /**
     * Data attribute key to use for Grand Totals fields
     */
    fieldGrandTotalKey: 'grand-total',

    /**
     * Array to hold the server synced fields objects
     */
    syncedFields: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.footerFields = [];
        this.footerGrandTotalFields = [];
        this.syncedFields = [];
    },

    /**
     * Sets an array of fields into the footer rows
     *
     * @param {Array} footerFields The array of footer fields to set in the footer rows view
     */
    setFooterRowFields: function(footerFields) {
        this.syncedFields = _.clone(footerFields);
        this.footerFields = [];
        this.footerGrandTotalFields = [];

        this.model.set(this.options.eventViewName, this.syncedFields);

        _.each(this.syncedFields, function(field) {
            field.syncedType = field.type;
            field.type = 'currency';

            field.syncedCssClass = field.syncedCssClass || field.css_class || '';
            field.css_class = '';

            if (field.syncedCssClass.indexOf('grand-total') === -1) {
                this.footerFields.push(field);
            } else {
                this.footerGrandTotalFields.push(field);
            }
        }, this);

        this.render();
    },

    /**
     * Adds a field to the list of footer rows
     *
     * @param {Object} field The field defs of the field to add
     */
    addFooterRowField: function(field) {
        var newFieldsArr;

        // add field to top of footerFields
        this.footerFields.unshift(field);

        // rebuild the fields array for the model
        newFieldsArr = this._parseFieldsForModel();

        // save and render the new fields state
        this.model.set(this.options.eventViewName, newFieldsArr);
        this.render();
    },

    /**
     * Removes a field from the list of footer rows
     *
     * @param {Object} field The field defs of the field to remove
     */
    removeFooterRowField: function(field) {
        var newFieldsArr;

        // remove field from wherever it exists
        this.footerFields = _.reject(this.footerFields, function(f) {
            return f.name === field.name;
        });

        this.footerGrandTotalFields = _.reject(this.footerGrandTotalFields, function(f) {
            return f.name === field.name;
        });

        // rebuild the fields array for the model
        newFieldsArr = this._parseFieldsForModel();

        // save and render the new fields state
        this.model.set(this.options.eventViewName, newFieldsArr);
        this.render();
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        this.$('.connected-containers').sortable({
            // the items to make sortable
            items: '.sortable-item',
            // make the "helper" row (the row the user actually drags around) a clone of the original row
            helper: 'clone',
            // adds a slow animation when "dropping" a group, removing this causes the row
            // to immediately snap into place wherever it's sorted
            revert: true,
            // connect all connected-containers with each other
            connectWith: '.connected-containers',
            // allow drag to only go in Y axis direction
            axis: 'y',
            // the CSS class to apply to the placeholder underneath the helper clone the user is dragging
            placeholder: 'ui-state-highlight',
            // the cursor to use when dragging
            cursor: 'move',
            // handler for when dragging stops; the "drop" event
            stop: _.bind(this._onDragStop, this)
        }).disableSelection();

        this.$('.connected-containers').droppable({
            accept: '.sortable-item',
            stop: _.bind(this._onDragStop, this)
        });
    },

    /**
     * Handles when a user drops a dragged item into a sortable/droppable container
     *
     * @param {jQuery.Event} evt The jQuery drag stop event
     * @param {Object} ui The jQuery Sortable UI Object
     * @private
     */
    _onDragStop: function(evt, ui) {
        var $el = $(ui.item || ui.draggable);
        var fieldName = $el.data('fieldName');
        var fieldType = $el.data('fieldType');
        var groupType = $el.parent().data('groupType');
        var sortableTotalItemsCssSelector = '.' + this.sortableFieldsContainerClass + ' .sortable-item';
        var sortableGrandTotalItemsCssSelector = '.' + this.sortableGrandTotalFieldsContainerClass + ' .sortable-item';
        var newFieldsArr;

        if (fieldType !== groupType) {
            // the field has changed groups
            if (fieldType === this.fieldTotalKey && groupType === this.fieldGrandTotalKey) {
                // was total, now grand-total

                this._moveFieldToNewPosition(
                    fieldName,
                    this.footerFields,
                    this.footerGrandTotalFields,
                    sortableGrandTotalItemsCssSelector
                );

            } else if (fieldType === this.fieldGrandTotalKey && groupType === this.fieldTotalKey) {
                // was grand-total, now total

                this._moveFieldToNewPosition(
                    fieldName,
                    this.footerGrandTotalFields,
                    this.footerFields,
                    sortableTotalItemsCssSelector
                );
            }

            // set the new group type onto the field
            $el.data('fieldType', groupType);
        } else {
            // field stayed in same group

            if (groupType === 'total') {
                this._moveFieldToNewPosition(
                    fieldName,
                    this.footerFields,
                    this.footerFields,
                    sortableTotalItemsCssSelector
                );
            } else {
                this._moveFieldToNewPosition(
                    fieldName,
                    this.footerGrandTotalFields,
                    this.footerGrandTotalFields,
                    sortableGrandTotalItemsCssSelector
                );
            }
        }

        newFieldsArr = this._parseFieldsForModel();

        this.model.set(this.options.eventViewName, newFieldsArr);

        this.render();
    },

    /**
     * Parses footerFields and footerGrandTotalFields cleaning up CSS classes and merging them into one array
     *
     * @return {Array} The merged, processed array from footerFields and footerGrandTotalFields
     * @private
     */
    _parseFieldsForModel: function() {
        var newFieldsArr = [];
        var cssArr;
        var tmpField;

        _.each(this.footerFields, function(field) {
            cssArr = [];
            tmpField = _.clone(field);

            if (tmpField.syncedCssClass) {
                cssArr = cssArr.concat(tmpField.syncedCssClass.split(' '));
            }
            if (tmpField.css_class) {
                cssArr = cssArr.concat(tmpField.css_class.split(' '));
            }
            if (tmpField.syncedType) {
                tmpField.type = tmpField.syncedType;
            }
            if (cssArr.length) {
                cssArr = _.chain(cssArr)
                // only unique classes
                    .uniq()
                    // remove any grand-total css class since this is not in the grand total section
                    .without(this.fieldGrandTotalKey)
                    .value();
                tmpField.css_class = cssArr.join(' ');
            }
            newFieldsArr.push(_.pick(tmpField, 'name', 'type', 'label', 'css_class', 'default'));
        }, this);

        _.each(this.footerGrandTotalFields, function(field) {
            cssArr = [];
            tmpField = _.clone(field);

            if (tmpField.syncedCssClass) {
                cssArr = cssArr.concat(tmpField.syncedCssClass.split(' '));
            }
            if (tmpField.css_class) {
                cssArr = cssArr.concat(tmpField.css_class.split(' '));
            }
            if (tmpField.syncedType) {
                tmpField.type = tmpField.syncedType;
            }

            // make sure the grand total items have the grand total class
            cssArr.push(this.fieldGrandTotalKey);

            if (cssArr.length) {
                tmpField.css_class = _.uniq(cssArr).join(' ');
            }
            newFieldsArr.push(_.pick(tmpField, 'name', 'type', 'label', 'css_class', 'default'));
        }, this);

        return newFieldsArr;
    },

    /**
     * Moves a field to a new group and position if oldGroup and newGroup are different.
     * If oldGroup and newGroup are the same, it just moves a field to a new position
     * inside the same group.
     *
     * @param {string} fieldName The name of the field being moved
     * @param {Array} oldGroup The old group's array of fields
     * @param {Array} newGroup The new group's array of fields
     * @param {string} newGroupSelector The css selector for the new group
     * @private
     */
    _moveFieldToNewPosition: function(fieldName, oldGroup, newGroup, newGroupSelector) {
        var tmpField;
        var tmpFieldIndex;
        var $newGroupElements;

        // find the index of the item in the old group
        tmpFieldIndex = _.findIndex(oldGroup, function(row) {
            return row.name === fieldName;
        }, this);

        // remove the field from the old group
        tmpField = oldGroup.splice(tmpFieldIndex, 1)[0];

        // get the elements inside the new group
        $newGroupElements = this.$(newGroupSelector);

        // get the index of the field in the new group
        tmpFieldIndex = _.findIndex($newGroupElements, function(el) {
            return $(el).data('fieldName') === fieldName;
        }, this);

        // add the moved field into the new group
        newGroup.splice(tmpFieldIndex, 0, tmpField);
    }
}) },
"quote-data-list-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.QuoteDataListHeaderView
 * @alias SUGAR.App.view.views.BaseQuotesQuoteDataListHeaderView
 * @extends View.Views.Base.View
 */
({
	// Quote-data-list-header View (base) 

    /**
     * @inheritdoc
     */
    events: {
        'click [name="group_button"]': '_onCreateGroupBtnClicked',
        'click [name="massdelete_button"]': '_onDeleteBtnClicked',
        'click [data-check=all]': 'checkAll'
    },

    /**
     * @inheritdoc
     */
    plugins: [
        'MassCollection',
        'QuotesLineNumHelper'
    ],

    /**
     * @inheritdoc
     */
    tagName: 'thead',

    /**
     * @inheritdoc
     */
    className: 'quote-data-list-header',

    /**
     * Array of left column fields
     */
    leftColumns: undefined,

    /**
     * Array of fields to use in the template
     */
    _fields: undefined,

    /**
     * If this view is currently in the /create view or not
     */
    isCreateView: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.leftColumns = [];

        var qliListMetadata = app.metadata.getView('Products', 'quote-data-group-list');
        if (qliListMetadata && qliListMetadata.panels) {
            this.meta.panels = qliListMetadata.panels;
        }

        _.each(this.meta.panels, function(panel) {
            _.each(panel.fields, function(field) {
                if (!field.labelModule) {
                    field.labelModule = 'Quotes';
                }
            }, this);
        }, this);

        this.isCreateView = this.context.get('create') || false;

        if (this.layout.isCreateView) {
            this.leftColumns.push({
                'type': 'fieldset',
                'fields': [],
                'value': false,
                'sortable': false
            });
        } else {
            this.addMultiSelectionAction();
        }

        this._fields = _.flatten(_.pluck(this.meta.panels, 'fields'));
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        var bundles;

        this._super('bindDataChange');

        if (!this.isCreateView) {
            bundles = this.model.get('bundles');
            if (bundles) {
                bundles.on('change', this._checkMassActions, this);
            }
        }

        // massCollection has the Quote record as its only model,
        // reset this during initialization so it's empty
        if (this.massCollection) {
            this.massCollection.on('add remove reset', this._massCollectionChange, this);
        }
    },

    /**
     * Called when items are added or removed from the massCollection. Handles checking or
     * unchecking the CheckAll checkbox as well as calls _checkMassActions to set button states
     *
     * @param {Data.Bean} model The model that was added or removed
     * @param {Data.MixedBeanCollection} massCollection The mass collection on the context
     * @private
     */
    _massCollectionChange: function(model, massCollection) {
        var $checkAllField = this.$('[data-check=all]');

        if (massCollection.length === 0 && $checkAllField.length) {
            // uncheck the check-all box if there are no more items
            $checkAllField.prop('checked', false);
        }

        // check to see if we need mass actions available as well
        _.delay(_.bind(this._checkMassActions, this), 25);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (this.massCollection) {
            // remove any Quotes models from the massCollectio
            this.massCollection.models = _.filter(this.massCollection.models, function(model) {
                return model.module !== 'Quotes';
            });
        }

        this._checkMassActions();
    },

    /**
     * Handles checking and unchecking all items in the quote data list
     *
     * @param {jQuery.Event} event The click event from the input checkbox
     */
    checkAll: function(event) {
        var $checkbox = $(event.currentTarget);

        if ($(event.target).hasClass('checkall') || event.type === 'keydown') {
            $checkbox.prop('checked', !$checkbox.is(':checked'));
        }

        if ($checkbox.is(':checked')) {
            this.context.trigger('quotes:collections:all:checked');
        } else {
            this.context.trigger('quotes:collections:not:all:checked');
        }
    },

    /**
     * Checks if bundles are empty and sets mass actions disabled if empty
     *
     * @private
     */
    _checkMassActions: function() {
        var massActionsField;
        var groupBtn;
        var massDeleteBtn;
        var disableMassActions;
        var quoteModel;

        if (this.disposed) {
            return;
        }

        massActionsField = this.getField('quote-data-mass-actions');
        groupBtn = this.getField('group_button');
        massDeleteBtn = this.getField('massdelete_button');
        disableMassActions = false;

        quoteModel = _.find(this.massCollection.models, function(model) {
            return model.get('_module') === 'Quotes';
        });

        if (quoteModel) {
            // get rid of any Quotes models from the mass collection
            this.massCollection.remove(quoteModel, {silent: true});
        }

        if (this._bundlesAreEmpty()) {
            if (massActionsField) {
                massActionsField.setDisabled(true);
            }
        } else {
            // qlis exist
            if (massActionsField) {
                massActionsField.setDisabled(false);
            }

            disableMassActions = this.massCollection.models.length === 0;

            if (groupBtn) {
                groupBtn.setDisabled(disableMassActions);
            }
            if (massDeleteBtn) {
                massDeleteBtn.setDisabled(disableMassActions);
            }
        }
    },

    /**
     * Returns if the bundles are empty or not
     *
     * @return {boolean} True if bundles are empty, false if any bundle contains an item
     * @private
     */
    _bundlesAreEmpty: function() {
        var bundlesHaveItems = false;
        var bundles = this.model.get('bundles');

        if (bundles) {
            bundlesHaveItems = bundles.every(function(bundle) {
                return bundle.get('product_bundle_items').length === 0;
            });
        }

        return bundlesHaveItems;
    },

    /**
     * Adds the left column fields
     */
    addMultiSelectionAction: function() {
        var _generateMeta = function(buttons, disableSelectAllAlert) {
            return {
                name: 'quote-data-mass-actions',
                type: 'fieldset',
                fields: [
                    {
                        type: 'quote-data-actionmenu',
                        buttons: buttons || [],
                        disable_select_all_alert: !!disableSelectAllAlert
                    }
                ],
                value: false,
                sortable: false
            };
        };
        var buttons = this.meta.selection.actions;
        var disableSelectAllAlert = !!this.meta.selection.disable_select_all_alert;
        this.leftColumns.push(_generateMeta(buttons, disableSelectAllAlert));
    },

    /**
     * Handles when the create Group button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onCreateGroupBtnClicked: function(evt) {
        if (this.massCollection.length) {
            this.context.on('quotes:group:create:success', this._onNewGroupedItemsCreateSuccess, this);
            this.context.trigger('quotes:group:create');
        } else {
            app.alert.show('quote_grouping_message', {
                level: 'error',
                title: '',
                messages: [
                    app.lang.get('LBL_GROUP_NOTHING_SELECTED', this.module)
                ]
            });
        }
    },

    /**
     * Called when the group in which any selected items are to be grouped has
     * successfully been saved. Clears app alerts and removes the context listener
     * for the create success event
     *
     * @param {Object} newGroupData The new ProductBundle to add selected items into
     * @private
     */
    _onNewGroupedItemsCreateSuccess: function(newGroupData) {
        this.context.off('quotes:group:create:success', this._onNewGroupedItemsCreateSuccess);
        this.layout.moveMassCollectionItemsToNewGroup(newGroupData);
    },

    /**
     * Handles when the Delete button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onDeleteBtnClicked: function(evt) {
        var deleteConfirmMsg = 'LBL_ALERT_CONFIRM_DELETE';
        if (this.massCollection.length) {
            if (this.massCollection.length > 1) {
                deleteConfirmMsg += '_PLURAL';
            }

            app.alert.show('confirm_delete', {
                level: 'confirmation',
                title: app.lang.get('LBL_ALERT_TITLE_WARNING') + ':',
                messages: [app.lang.get(deleteConfirmMsg, '')],
                onConfirm: _.bind(function() {
                    app.alert.show('deleting_line_item', {
                        level: 'info',
                        messages: [app.lang.get('LBL_ALERT_DELETING_ITEM', 'ProductBundles')]
                    });
                    this.context.trigger('quotes:selected:delete', this.massCollection);
                }, this)
            });
        } else {
            app.alert.show('quote_grouping_message', {
                level: 'error',
                title: '',
                messages: [
                    app.lang.get('LBL_DELETE_NOTHING_SELECTED', this.module)
                ]
            });
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var bundles;
        if (!this.isCreateView) {
            bundles = this.model.get('bundles');
            bundles.off('change', null, this);
        }

        // in case something weird happens where this view gets
        // disposed between adding the listener and removing,
        // go ahead and remove it on dispose if it exists
        this.context.off('quotes:group:create:success', null, this);

        if (this.massCollection) {
            this.massCollection.off('add remove reset', null, this);
        }

        this._super('_dispose');
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.CreateView
 * @alias SUGAR.App.view.views.BaseQuotesCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    /**
     * Holds the ProductBundles/Products/ProductBundleNotes fields meta for different views
     */
    moduleFieldsMeta: undefined,

    /**
     * Field map for where Opp/RLI fields (values) should map to Quote fields (keys)
     */
    convertToQuoteFieldMap: {
        Opportunities: {
            opportunity_id: 'id',
            opportunity_name: 'name'
        },
        RevenueLineItems: {
            name: 'name',
            opportunity_id: 'opportunity_id',
            opportunity_name: 'opportunity_name'
        },
        defaultBilling: {
            billing_account_id: 'account_id',
            billing_account_name: 'account_name'
        },
        defaultShipping: {
            shipping_account_id: 'account_id',
            shipping_account_name: 'account_name'
        }
    },

    /**
     * A list of billing field names to pull from the Account model to the Quote model
     */
    acctBillingToQuoteConvertFields: [
        'billing_address_city',
        'billing_address_country',
        'billing_address_postalcode',
        'billing_address_state',
        'billing_address_street'
    ],

    /**
     * A list of shiping field names to pull from the Account model to the Quote model
     */
    acctShippingToQuoteConvertFields: [
        'shipping_address_city',
        'shipping_address_country',
        'shipping_address_postalcode',
        'shipping_address_state',
        'shipping_address_street'
    ],

    /**
     * If this Create view is from converting items from other modules to Quotes, is this
     * converting from a 'shipping' or 'billing' subpanel, or undefined if neither.
     */
    isConvertFromShippingOrBilling: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['QuotesViewSaveHelper', 'LinkedModel']);
        var fromSubpanel = options.context.get('fromSubpanel');

        this._super('initialize', [options]);
        if (options.context.get('convert') && !fromSubpanel) {
            this._prepopulateQuote(options);
        } else if (fromSubpanel) {
            options.context.get('model').link = options.context.get('subpanelLink');
        }

        this.moduleFieldsMeta = {};

        this._buildMeta('ProductBundleNotes', 'quote-data-group-list');
        this._buildMeta('ProductBundles', 'quote-data-group-header');
        this._buildMeta('Products', 'quote-data-group-list');

        // gets the name of any field where calculated is true
        this.calculatedFields = _.chain(this.model.fields)
            .where({calculated: true})
            .pluck('name')
            .value();

        // Set the bundles as a separate model validation task so the Quote Record can validate by itself
        // then it calls the bundles validation
        this.model.addValidationTask('quote_bundles_' + this.cid, _.bind(this.validateBundleModels, this));
    },

    /**
     * Prepopulates the Quote context model with related module fields
     *
     * @param {Object} options The initialize options Object
     * @protected
     */
    _prepopulateQuote: function(options) {
        var parentModel = options.context.get('parentModel');
        var ctxModel = options.context.get('model');
        var parentModule = parentModel.module;
        var parentModelAcctIdFieldName = parentModule === 'Accounts' ? 'id' : 'account_id';
        var linkModel;
        var quoteData = {};
        var fieldMap;

        this.isConvertFromShippingOrBilling = undefined;

        if (ctxModel && parentModel) {
            linkModel = this.createLinkModel(parentModel, options.context.get('fromLink'));
            // get the JSON attributes of the linked model
            quoteData = linkModel.toJSON();

            // create a field map from the default fields and module-specific fields
            fieldMap = _.extend({}, this.convertToQuoteFieldMap[parentModule]);

            if (quoteData.shipping_account_id || quoteData.shipping_contact_id) {
                // if the linked model had any shipping_ fields, set it to 'shipping'
                this.isConvertFromShippingOrBilling = 'shipping';
                quoteData.copy = false;
            } else if (quoteData.billing_account_id || quoteData.billing_contact_id) {
                // if the linked model had any billing_ fields, set it to 'billing'
                this.isConvertFromShippingOrBilling = 'billing';
            }

            if (parentModule !== 'Accounts') {
                // since its not from an Acct shipping/billing link, add in the default Acct field mappings
                if (this.isConvertFromShippingOrBilling === 'shipping') {
                    fieldMap = _.extend(fieldMap, this.convertToQuoteFieldMap.defaultShipping);
                } else if (this.isConvertFromShippingOrBilling === 'billing') {
                    fieldMap = _.extend(fieldMap, this.convertToQuoteFieldMap.defaultBilling);
                } else {
                    fieldMap = _.extend(
                        fieldMap,
                        this.convertToQuoteFieldMap.defaultShipping,
                        this.convertToQuoteFieldMap.defaultBilling
                    );
                }
            }

            // copy field data from the parentModel to the quoteData object
            _.each(fieldMap, function(otherModuleField, quoteField) {
                quoteData[quoteField] = parentModel.get(otherModuleField);
            }, this);

            // make an api call to get related Account data
            app.api.call('read', app.api.buildURL('Accounts/' + parentModel.get(parentModelAcctIdFieldName)), null, {
                success: _.bind(this._setAccountInfo, this)
            });

            // set new quoteData attributes onto the create model
            ctxModel.set(quoteData);
        }
    },

    /**
     * Sets the related Account info on the Quote bean
     *
     * @param {Object} accountInfoData The Account info returned from the Accounts/:id endpoint
     * @protected
     */
    _setAccountInfo: function(accountInfoData) {
        var acctData = {};
        var fields = [];

        if (this.isConvertFromShippingOrBilling === 'shipping') {
            // if this is a shipping conversion, set the Account shipping fields
            fields = this.acctShippingToQuoteConvertFields;
        } else if (this.isConvertFromShippingOrBilling === 'billing') {
            // if this is a billing conversion, set the Account billing fields
            fields = this.acctBillingToQuoteConvertFields;
        } else {
            // if this is neither a shipping nor billing conversion,
            // set both Account shipping & billing fields
            fields = fields.concat(
                this.acctBillingToQuoteConvertFields,
                this.acctShippingToQuoteConvertFields
            );
        }

        _.each(fields, function(fieldName) {
            acctData[fieldName] = accountInfoData[fieldName];
        }, this);

        this.model.set(acctData);
    },

    /**
     * Builds the `this.moduleFieldsMeta` object
     *
     * @param {string} moduleName The module name to get meta for
     * @param {string} viewName The view name from the module to get view defs for
     * @private
     */
    _buildMeta: function(moduleName, viewName) {
        var viewMeta;
        var modMeta;
        var metaFields = {};
        var modMetaField;

        modMeta = app.metadata.getModule(moduleName);
        viewMeta = app.metadata.getView(moduleName, viewName);

        if (modMeta && viewMeta) {
            _.each(viewMeta.panels, function(panel) {
                _.each(panel.fields, function(field) {
                    modMetaField = modMeta.fields[field.name];
                    metaFields[field.name] = _.extend({}, modMetaField, field);
                }, this);
            }, this);

            this.moduleFieldsMeta[moduleName] = metaFields;
        }
    },

    /**
     * Validates the models in the Quote's ProductBundles
     *
     * @param {Object} fields The list of fields to validate.
     * @param {Object} recordErrors The errors object during this validation task.
     * @param {Function} callback The callback function to continue validation.
     */
    validateBundleModels: function(fields, recordErrors, callback) {
        var returnCt = 0;
        var totalItemsToValidate = 0;
        var bundles = this.model.get('bundles');
        var productBundleItems;
        var pbModelsAsyncCt = 0;

        recordErrors = recordErrors || {};

        if (bundles && bundles.length) {
            //Check to see if we have only the default group
            if (bundles.length === 1) {
                productBundleItems = bundles.models[0].get('product_bundle_items');
                //check to see if that group is empty, if so, return the valid status of the parent.
                if (productBundleItems.length === 0) {
                    callback(null, fields, recordErrors);
                    return;
                }
            }

            totalItemsToValidate += bundles.length;

            // get the count of items
            totalItemsToValidate = _.reduce(bundles.models, function(memo, bundle) {
                return memo + bundle.get('product_bundle_items').length;
            }, totalItemsToValidate);

            // loop through each ProductBundles bean
            _.each(bundles.models, function(bundleModel) {
                // call validate on the ProductBundle model (if group name were required or some other field)
                bundleModel.isValidAsync(this.moduleFieldsMeta[bundleModel.module], _.bind(function(isValid, errors) {
                    // increment the validate count
                    returnCt++;

                    // get the bundle items for this bundle to validate later
                    productBundleItems = bundleModel.get('product_bundle_items');

                    // add any errors returned to the main record errors
                    recordErrors = _.extend(recordErrors, errors);

                    if (!isValid) {
                        // if the bundleModel has bad fields,
                        // trigger the error on the bundle model
                        bundleModel.trigger('error:validation');
                    }

                    // add any product bundle items to the async count
                    pbModelsAsyncCt += productBundleItems.length;

                    if (productBundleItems.length === 0) {
                        // only try to use the callback here if this bundle is empty and
                        // there are no other bundle items async waiting to validate
                        if (pbModelsAsyncCt === 0 && returnCt === totalItemsToValidate) {
                            // if we've validated the correct number of models, call the callback fn
                            callback(null, fields, recordErrors);
                        }
                    }

                    // loop through each product_bundle_items Products/ProductBundleNotes bean
                    _.each(productBundleItems.models, function(pbModel) {
                        // call validate on the Product/ProductBundleNote model
                        pbModel.isValidAsync(this.moduleFieldsMeta[pbModel.module], _.bind(function(isValid, errors) {
                            // increment the validate count
                            returnCt++;
                            pbModelsAsyncCt--;

                            // add any errors returned to the main record errors
                            recordErrors = _.extend(recordErrors, errors);

                            if (!isValid) {
                                // if the qli/pbn has bad fields,
                                // trigger the error on the bundle model
                                pbModel.trigger('error:validation');
                            }

                            // trigger validation complete and process the errors for this model
                            pbModel.trigger('validation:complete', pbModel._processValidationErrors(errors));

                            if (errors.description) {
                                // if this is a ProductBundleNotes model where "description" field is required
                                // we have already triggered to process validation errors on the PBN model to show
                                // description is required, now we need to delete it off the error object
                                // so that the Quote record "description" field doesn't show as required since
                                // they have the same field name. So if errors.description (specifically checking
                                // if this model validation threw the error) then remove it off the recordErrors
                                // object that we're passing back
                                delete recordErrors.description;
                            }

                            if (returnCt === totalItemsToValidate) {
                                // if we've validated the correct number of models, call the callback fn
                                callback(null, fields, recordErrors);
                            }
                        }, this));
                    }, this);

                    bundleModel.trigger('validation:complete', bundleModel._processValidationErrors(errors));
                }, this));
            }, this);
        } else {
            // if there are no bundles to validate then just return
            callback(null, fields, recordErrors);
        }
    },

    /**
     * Overriding to make the router go back to previous view, not Quotes module list
     *
     * @inheritdoc
     */
    cancel: function() {
        //Clear unsaved changes on cancel.
        app.events.trigger('create:model:changed', false);
        this.$el.off();

        app.router.goBack();
    },

    /**
     * @inheritdoc
     */
    hasUnsavedChanges: function() {
        return this.hasUnsavedQuoteChanges();
    },

    /**
     * @inheritdoc
     */
    getCustomSaveOptions: function(options) {
        var parentSuccessCallback;
        var config = app.metadata.getModule('Opportunities', 'config');
        var bundles = this.model.get('bundles');
        var isConvert = this.context.get('convert');
        var hasItems = 0;
        var userId = app.user.id;

        _.each(bundles.models, function(bundle) {
            var pbItems = bundle.get('product_bundle_items');
            _.each(pbItems.models, function(itemModel) {
                // set assigned user id on product so user doesn't get notification when they create one
                itemModel.set('assigned_user_id', userId);

                if (isConvert && itemModel.module === 'Products' && itemModel.get('revenuelineitem_id')) {
                    hasItems++;
                }
            }, this);
            bundle.set({
                product_bundle_items: pbItems,
                assigned_user_id: userId
            });
        }, this);

        this.model.set('assigned_user_id', userId);

        if (config && config.opps_view_by === 'RevenueLineItems' && isConvert && hasItems) {
            parentSuccessCallback = options.success;
            options.success = _.bind(this._customQuotesCreateSave, this, parentSuccessCallback);
        }

        return options;
    },

    /**
     * Checks all Products in bundles to make sure each Product has quote_id set
     * then calls the main success function that was passed in from base Create view
     *
     * @private
     */
    _customQuotesCreateSave: function(parentSuccessCallback, model) {
        var quoteId = model.get('id');
        var bundles = model.get('bundles');
        var rliId;
        var pbItems;
        var bulkRequest;
        var bulkUrl;
        var bulkCalls = [];

        _.each(bundles.models, function(pbModel) {
            pbItems = pbModel.get('product_bundle_items');

            _.each(pbItems.models, function(itemModel) {
                if (itemModel.module === 'Products') {
                    rliId = itemModel.get('revenuelineitem_id');

                    if (rliId) {
                        bulkUrl = app.api.buildURL('RevenueLineItems/' + rliId + '/link/quotes/' + quoteId);
                        bulkRequest = {
                            url: bulkUrl.substr(4),
                            method: 'POST',
                            data: {
                                id: rliId,
                                link: 'quotes',
                                relatedId: quoteId,
                                related: {
                                    quote_id: quoteId
                                }
                            }
                        };
                        bulkCalls.push(bulkRequest);
                    }
                }
            }, this);
        }, this);

        if (bulkCalls.length) {
            app.api.call('create', app.api.buildURL(null, 'bulk'), {
                requests: bulkCalls
            }, {
                success: parentSuccessCallback
            });
        }
    }
}) },
"config-header-buttons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.ConfigHeaderButtonsView
 * @alias SUGAR.App.view.views.BaseQuotesConfigHeaderButtonsView
 * @extends  View.View.Base.ConfigHeaderButtonsView
 */
({
	// Config-header-buttons View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'BaseConfigHeaderButtonsView',

    /**
     * @inheritdoc
     */
    _getSaveConfigAttributes: function() {
        var saveObj = this.model.toJSON();
        var lineNum;
        var footerRows = [];
        var quotesMeta = app.metadata.getModule('Quotes', 'fields');
        // make sure related_fields contains description, currency_id, base_rate, quote_id, name, and
        // product_template_name & _id fields
        var requiredRelatedFields = [
            'description',
            'currency_id',
            'base_rate',
            'quote_id',
            'name',
            'position',
            'product_template_id',
            'product_template_name'
        ];
        // make sure line_num field exists in worksheet_columns
        lineNum = _.find(saveObj.worksheet_columns, function(col) {
            return col.name === 'line_num';
        }, this);

        if (!lineNum) {
            saveObj.worksheet_columns.unshift({
                name: 'line_num',
                label: null,
                widthClass: 'cell-xsmall',
                css_class: 'line_num tcenter',
                type: 'line-num',
                readonly: true
            });
        }

        // tweak any worksheet columns fields
        _.each(saveObj.worksheet_columns, function(col) {
            if (col.name === 'product_template_name') {
                // force product_template_name to be required if it exists
                col.required = true;
            }

            if (col.type === 'image') {
                col.readonly = true;
            }

            if (col.label === 'LBL_DISCOUNT_AMOUNT' && col.name === 'discount_amount') {
                col.label = 'LBL_DISCOUNT_AMOUNT_VALUE';
            }

            if (col.type === 'relate') {
                requiredRelatedFields.push(col.id_name);
            }
            if (col.type === 'parent') {
                requiredRelatedFields.push(col.id_name);
                requiredRelatedFields.push(col.type_name);
            }
        }, this);

        _.each(requiredRelatedFields, function(field) {
            if (!_.contains(saveObj.worksheet_columns_related_fields, field)) {
                saveObj.worksheet_columns_related_fields.push(field);
            }
        });

        _.each(saveObj.footer_rows, function(row) {
            var obj = {
                name: row.name,
                type: row.syncedType || row.type
            };
            if (row.syncedCssClass || row.css_class) {
                obj.css_class = row.syncedCssClass || row.css_class;
            }
            if (row.hasOwnProperty('default')) {
                obj.default = row.default;
            }
            if (quotesMeta[row.name] && !quotesMeta[row.name].formula) {
                obj.type = 'quote-footer-currency';
                obj.default = '0.00';
                if (!obj.css_class || (row.css_class && row.css_class.indexOf('quote-footer-currency') === -1)) {
                    obj.css_class = 'quote-footer-currency';
                }
            }

            footerRows.push(obj);
        }, this);

        saveObj.footer_rows = footerRows;

        return saveObj;
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.RecordView
 * @alias SUGAR.App.view.views.BaseQuotesRecordView
 * @extends View.Views.Base.RecordView
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * Track the calculated fields from the model to be used when checking for unsaved changes
     *
     * @type {Array}
     */
    calculatedFields: [],

    /**
     * registers additional editable fields from supporting quotes views
     */
    additionalEditableFields: [],

    /**
     * Track the number of items in edit mode.
     * @type {number}
     */
    editCount: 0,

    /**
     * Hashtable to keep track of id's in edit mode
     * @type {Object}
     */
    editIds: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['HistoricalSummary', 'QuotesViewSaveHelper']);
        this._super('initialize', [options]);

        // get all the calculated fields from the model
        this.calculatedFields = _.chain(this.model.fields)
            .where({calculated: true})
            .pluck('name')
            .value();
        this.additionalEditableFields = [];
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        this.context.on('editable:handleEdit', this._handleEditShippingField, this);

        this.context.on('quotes:editableFields:add', function(field) {
            this.additionalEditableFields.push(field);
            this.editableFields.push(field);
        }, this);

        this.context.on('quotes:item:toggle', this._handleItemToggled, this);
    },

    /**
     * @inheritdoc
     */
    setEditableFields: function() {
        this._super('setEditableFields');

        if (this.editableFields) {
            _.each(this.additionalEditableFields, function(field) {
                this.editableFields.push(field);
            }, this);
        }
    },

    /**
     * @inheritdoc
     *
     * Overrides the existing record duplicateClicked to handle the unique
     * Quotes->ProductBundles->Products|ProductBundleNotes data structure
     */
    duplicateClicked: function() {
        var bundles;
        var loadViewObj;
        var bundleModels = [];
        // create an empty Quote Bean
        var quoteModelCopy;
        var quoteContextCollection;
        var mainDropdownBtn;
        var copyItemCount = 0;

        if (this.editCount) {
            app.alert.show('quotes_qli_editmode', {
                level: 'error',
                title: '',
                messages: [app.lang.get('LBL_COPY_LINE_ITEMS', 'Quotes')]
            });

            return;
        }

        // get the Edit dropdown button
        mainDropdownBtn = this.getField('main_dropdown');
        // close the dropdown menu
        mainDropdownBtn.$el.removeClass('open');

        bundles = this.model.get('bundles');
        quoteModelCopy = app.data.createBean(this.model.module);
        quoteContextCollection = this.context.get('collection');

        quoteModelCopy.copy(this.model);

        _.each(bundles.models, function(bundle) {
            var items = [];
            var bundleData = bundle.toJSON();
            var pbItems = bundle.get('product_bundle_items');

            // re-set pbItems (if it exists and if pbItems.models exists) to be pbItems.models
            pbItems = pbItems && pbItems.models;

            // loop over the product bundle items
            _.each(pbItems, function(pbItem) {
                var tmpItem = pbItem.toJSON();
                var newBean;

                // get rid of an item's id and quote_id
                delete tmpItem.id;
                delete tmpItem.quote_id;

                if (_.isEmpty(tmpItem.product_template_name)) {
                    // if product_template_name is empty, use the QLI's name
                    tmpItem.product_template_name = tmpItem.name;
                } else {
                    // if product_template_name is not empty, set that to the QLI's name
                    tmpItem.name = tmpItem.product_template_name;
                }

                newBean = app.data.createBean(tmpItem._module, tmpItem);

                // set isCopied on the bean for currency fields to be set properly
                newBean.isCopied = true;

                copyItemCount++;

                // creates a Bean and pushes the individual Products|ProductBundleNotes to the array
                items.push(newBean);
            }, this);

            // remove any id or sugarlogic entries from the bundle data
            delete bundleData.id;
            delete bundleData['_products-rel_exp_values'];
            // remove any leftover create/delete arrays
            delete bundleData.products;

            // set items array onto the bundleData
            bundleData.product_bundle_items = items;

            bundleModels.push(bundleData);
        }, this);

        // get rid of the existing bundles data on the model
        quoteModelCopy.unset('bundles');

        // set the model onto the context->collection
        quoteContextCollection.reset(quoteModelCopy);

        loadViewObj = {
            action: 'edit',
            collection: quoteContextCollection,
            copy: true,
            create: true,
            layout: 'create',
            model: quoteModelCopy,
            module: 'Quotes',
            relatedRecords: bundleModels,
            copyItemCount: copyItemCount
        };

        // lead the Quotes create layout
        app.controller.loadView(loadViewObj);
        // update the browser URL with the proper
        app.router.navigate('#Quotes/create', {trigger: false});
    },

    /**
     * handles keeping track how many items are in edit mode.
     * @param {boolean} isEdit
     * @param {number} id id of the row being toggled
     * @private
     */
    _handleItemToggled: function(isEdit, id) {
        if (isEdit) {
            if (_.isUndefined(this.editIds[id])) {
                this.editIds[id] = true;
                this.editCount++;
            }
        } else if (!isEdit && this.editCount > 0) {
            delete this.editIds[id];
            this.editCount--;
        }
    },

    /**
     * Override the save clicked function to check if things are in edit mode before saving.
     *
     * @inheritdoc
     */
    saveClicked: function() {
        //if we don't have any qlis in edit mode, save.  If we do, show a warning.
        if (this.editCount == 0) {
            this._super('saveClicked');
        } else {
            app.alert.show('quotes_qli_editmode', {
                level: 'error',
                title: '',
                messages: [app.lang.get('LBL_SAVE_LINE_ITEMS', 'Quotes')]
            });
        }

    },

    /**
     * Override the cancel clicked function to retrigger sugarlogic.
     *
     * @inheritdoc
     */
    cancelClicked: function() {
        this._super('cancelClicked');
        this.context.trigger('list:editrow:fire');
    },

    /**
     * This is only when the Shipping field is clicked to handle toggling
     * it to Edit mode since it's outside of this view's element. This is
     * exactly the same as record.handleEdit except it grabs the jQuery
     * event target from the full page instead of this.el and also uses the
     * `this.editableFields` instead of this.getField to find the shipping field.
     *
     * @param {jQuery.Event} e The jQuery Click Event
     * @private
     */
    _handleEditShippingField: function(e) {
        var $target;
        var cellData;
        var field;
        var cell;

        if (e) {
            // having to open this to full page $ instead of this.$
            $target = $(e.target);
            cell = $target.parents('.record-cell');
        }

        cellData = cell.data();
        field = _.find(this.editableFields, function(field) {
            return field.name === cellData.name;
        });

        // Set Editing mode to on.
        this.inlineEditMode = true;

        this.setButtonStates(this.STATE.EDIT);

        this.toggleField(field);

        if (cell.closest('.headerpane').length > 0) {
            this.toggleViewButtons(true);
            this.adjustHeaderpaneFields();
        }
    },

    /**
     * @inheritdoc
     */
    getCustomSaveOptions: function(options) {
        options = options || {};
        var returnObject = {};

        // get the value that the server sent back
        var syncedValue = this.model.getSynced('currency_id');

        // has the currency_id changed?
        if (this.model.get('currency_id') !== syncedValue) {
            // make copy of original function we are extending
            var origSuccess = options.success;
            // only do this if the currency_id field actually changes
            returnObject = {
                success: _.bind(function() {
                    if (_.isFunction(origSuccess)) {
                        origSuccess.apply(this, arguments);
                    }
                    // create the payload
                    var bulkSaveRequests = this._createBulkBundlesPayload();
                    // send the payload
                    this._sendBulkBundlesUpdate(bulkSaveRequests);
                }, this)
            };
        }

        // FIXME: Quotes renders duplicate QLI's if it encounters collection resets for bundles
        // Ensure that we do not pass view or fields in params as a result to ensure PUT requests
        // do not get bundles in the response
        if (options.params) {
            var params = _.clone(options.params);
            params.view = null; // don't just delete; specifically null it out to ensure we overwrite it
            params.fields = null;
            returnObject.params = params;
        }

        return returnObject;
    },

    /**
     * Utility method to create the payload that will be send to the server via the bulk api call
     * to update all the product bundles currencies
     * @private
     */
    _createBulkBundlesPayload: function() {
        // loop over all the bundles and create the requests
        var bundles = this.model.get('bundles');
        var bulkSaveRequests = [];
        var url;
        bundles.each(function(bundle) {
            // if the bundle is new, don't try and save it
            if (!bundle.isNew()) {
                // create the update url
                url = app.api.buildURL(bundle.module, 'update', {
                    id: bundle.get('id')
                });

                // save the request with the two fields that need to be updated
                // on the product bundle
                bulkSaveRequests.unshift({
                    url: url.substr(4),
                    method: 'PUT',
                    data: {
                        currency_id: bundle.get('currency_id'),
                        base_rate: bundle.get('base_rate')
                    }
                });
            }
        });

        return bulkSaveRequests;
    },

    /**
     * Send the payload via the bulk api
     * @param {Array} bulkSaveRequests
     * @private
     */
    _sendBulkBundlesUpdate: function(bulkSaveRequests) {
        if (!_.isEmpty(bulkSaveRequests)) {
            app.api.call(
                'create',
                app.api.buildURL(null, 'bulk'),
                {
                    requests: bulkSaveRequests
                },
                {
                    success: _.bind(this._onBulkBundlesUpdateSuccess, this)
                }
            );
        }
    },

    /**
     * Update the bundles when the results from the bulk api call
     * @param {Array} bulkResponses
     * @private
     */
    _onBulkBundlesUpdateSuccess: function(bulkResponses) {
        var bundles = this.model.get('bundles');
        var bundle;
        _.each(bulkResponses, function(record) {
            bundle = bundles.get(record.contents.id);
            if (bundle) {
                bundle.setSyncedAttributes(record.contents);
                bundle.set(record.contents);
            }
        }, this);
    },

    /**
     * @inheritdoc
     */
    hasUnsavedChanges: function() {
        return this.hasUnsavedQuoteChanges();
    }
}) },
"quote-data-grand-totals-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.QuoteDataGrandTotalsHeaderView
 * @alias SUGAR.App.view.views.BaseQuotesQuoteDataGrandTotalsHeaderView
 * @extends View.Views.Base.View
 */
({
	// Quote-data-grand-totals-header View (base) 

    /**
     * @inheritdoc
     */
    events: {
        'click [name="create_qli_button"]': '_onCreateQLIBtnClicked',
        'click [name="create_comment_button"]': '_onCreateCommentBtnClicked',
        'click [name="create_group_button"]': '_onCreateGroupBtnClicked'
    },

    /**
     * @inheritdoc
     */
    className: 'quote-data-grand-totals-header-wrapper quote-totals-row',

    /**
     * Handles when the create Quoted Line Item button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onCreateQLIBtnClicked: function(evt) {
        this.context.trigger('quotes:defaultGroup:create', 'qli');
    },

    /**
     * Handles when the create Comment button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onCreateCommentBtnClicked: function(evt) {
        this.context.trigger('quotes:defaultGroup:create', 'note');
    },

    /**
     * Handles when the create Group button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onCreateGroupBtnClicked: function(evt) {
        this.context.trigger('quotes:group:create');
    }
}) },
"config-summary": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.ConfigSummaryView
 * @alias SUGAR.App.view.views.BaseQuotesConfigSummaryView
 * @extends View.Views.Base.Quotes.ConfigPanelView
 */
({
	// Config-summary View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'QuotesConfigPanelView',

    /**
     * @inheritdoc
     */
    events: {
        'click .restore-defaults-btn': 'onClickRestoreDefaultsBtn'
    },

    /**
     * The default list of field names for the Quotes summary columns
     */
    listDefaultFieldNames: [
        'deal_tot',
        'new_sub',
        'tax',
        'shipping',
        'total'
    ],

    /**
     * The Label names from each of the default fields
     */
    listDefaultFieldNameLabels: undefined,

    /**
     * The list header view
     * @type {View.Views.Base.Quotes.ConfigListHeaderColumnsView}
     */
    listHeaderView: undefined,

    /**
     * Contains an array of all the default fields to reset the list header
     */
    defaultFields: undefined,

    /**
     * Contains an array of all the current fields in the list header
     */
    listHeaderFields: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var namesLen = this.listDefaultFieldNames.length;
        var quoteGrandTotalHeaderListMeta = app.metadata.getView('Quotes', 'quote-data-grand-totals-header');
        var field;
        var fieldLabels = [];
        var fieldLabel;
        var fieldLabelModule;
        var tmpField;

        this._super('initialize', [options]);

        this.quotesFieldMeta = app.metadata.getModule('Quotes', 'fields');

        this.defaultFields = [];

        // pluck all the fields arrays from panels and flatten into one array
        this.listHeaderFields = _.flatten(_.pluck(quoteGrandTotalHeaderListMeta.panels, 'fields'));

        _.each(this.listHeaderFields, function(field) {
            field.labelModule = this._getFieldLabelModule(field);
        }, this);

        // build the list header labels and defaultFields
        this.listDefaultFieldNameLabels = [];
        for (var i = 0; i < namesLen; i++) {
            // try to get view defs from the quote-data-group-list meta
            field = _.find(this.listHeaderFields, function(headerField) {
                return this.listDefaultFieldNames[i] === headerField.name;
            }, this);

            if (!field) {
                // if the field didn't exist in the group list meta, use the field vardef
                field = this.quotesFieldMeta[this.listDefaultFieldNames[i]];
            }

            // use either label (viewdefs) or vname (vardefs)
            if (field && (field.label || field.vname)) {
                fieldLabel = field.label || field.vname;

                // check Products strings first
                fieldLabel = app.lang.get(fieldLabel, 'Quotes');
                fieldLabelModule = 'Quotes';

                fieldLabels.push(fieldLabel);

                tmpField = {
                    name: field.name,
                    label: fieldLabel,
                    labelModule: fieldLabelModule,
                    widthClass: field.widthClass,
                    css_class: field.css_class || field.cssClass || ''
                };

                // push the fieldDefs to default fields
                this.defaultFields.push(tmpField);
            }
        }

        this.listDefaultFieldNameLabels = fieldLabels.join(', ');

        this.model.set(this.eventViewName, this.listHeaderFields);
    },

    /**
     * @inheritdoc
     */
    _getEventViewName: function() {
        return 'summary_columns';
    },

    /**
     * Returns the module to use for the label if no label module is given
     *
     * @param {Object} field
     * @return {string}
     * @private
     */
    _getFieldLabelModule: function(field) {
        return field.labelModule || 'Quotes';
    },

    /**
     * @inheritdoc
     */
    _getPanelFields: function() {
        var fields = [];
        _.each(this.context.get('quotesFields'), function(f, key) {
            if (f.type !== 'collection' && key.indexOf('_id') === -1) {
                fields.push(_.extend({
                    name: key
                }, f));
            }
        }, this);

        return fields;
    },

    /**
     * @inheritdoc
     */
    _getPanelFieldsModule: function() {
        return 'Quotes';
    },

    /**
     * @inheritdoc
     */
    onConfigPanelShow: function() {
        if (this.dependentFields) {
            this.context.trigger('config:fields:change', this.eventViewName, this.panelFields);
        }
    },

    /**
     * @inheritdoc
     */
    _onDependentFieldsChange: function(context, fieldDeps) {
        var pFieldDeps;
        var pRelatedFields;
        var pRelatedField;
        var pDependentField;
        var tmpRelatedFields;
        var relatedFieldsList = [];
        var tmpField;

        this._super('_onDependentFieldsChange', [context, fieldDeps]);

        pFieldDeps = this.dependentFields.Quotes;
        pRelatedFields = this.relatedFields.Quotes;

        _.each(this.panelFields, function(field) {
            pDependentField = pFieldDeps[field.name];
            pRelatedField = pRelatedFields[field.name];

            if (pDependentField) {
                tmpRelatedFields = _.extend({}, pDependentField.locked, pDependentField.related);

                if (!_.isEmpty(tmpRelatedFields)) {
                    field.dependentFields = tmpRelatedFields;
                    field.required = true;
                }

                if (field.required && !field.initialState) {
                    field.initialState = 'filled';
                    relatedFieldsList.push(field.name);
                }
            }

            if (pRelatedField) {
                tmpRelatedFields = _.extend({}, pRelatedField.locked, pRelatedField.related);

                if (!_.isEmpty(tmpRelatedFields)) {
                    field.relatedFields = field.relatedFields || [];

                    _.each(tmpRelatedFields, function(relField, relFieldName) {
                        field.relatedFields.push(relFieldName);
                    }, this);
                }
            }

            tmpField = _.find(this.listHeaderFields, function(headerField) {
                return headerField.name === field.name;
            });
            if (tmpField) {
                // if this panelField exists in listHeaderFields, set to visible
                field.initialState = 'checked';
            }
        }, this);

        this.model.set(this.eventViewName + '_related_fields', relatedFieldsList);

        // trigger to render the fields on config page load
        this.context.trigger('config:fields:change', this.eventViewName, this.panelFields);
    },

    /**
     * @inheritdoc
     */
    _onConfigFieldChange: function(field, oldState, newState) {
        var fieldVarDef = this.quotesFieldMeta[field.name];
        var fieldViewDef;
        var wasVisible = oldState === 'checked';
        var isNowVisible = newState === 'checked';
        var isUnchecked = newState === 'unchecked';
        var columnChanged = false;
        var toggleRelatedFields;

        if (!wasVisible && isNowVisible) {
            // field was not visible, but now is visible
            fieldViewDef = {
                name: fieldVarDef.name,
                type: fieldVarDef.type,
                label: fieldVarDef.vname || fieldVarDef.label
            };
            fieldViewDef.labelModule = this._getFieldLabelModule(field);

            // add the column to header fields
            this.listHeaderView.addColumnHeaderField(fieldViewDef);

            toggleRelatedFields = true;
            columnChanged = true;
        } else if (wasVisible && !isNowVisible) {
            // field was visible, but now is not visible, so remove from columns
            // remove the column from header fields
            this.listHeaderView.removeColumnHeaderField(fieldVarDef);

            toggleRelatedFields = false;
            columnChanged = true;
        } else if (!wasVisible && !isNowVisible && isUnchecked) {
            columnChanged = true;
            toggleRelatedFields = false;
        }

        if (columnChanged) {
            if (!_.isUndefined(toggleRelatedFields) && field.def.relatedFields) {
                _.each(field.def.relatedFields, function(fieldName) {
                    this.context.trigger(
                        'config:' + this.eventViewName + ':' + fieldName + ':related:toggle',
                        field,
                        toggleRelatedFields
                    );
                }, this);
            }
        }
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        this.listHeaderView = app.view.createView({
            context: this.context,
            eventViewName: this.eventViewName,
            type: 'config-list-header-columns',
            layout: this,
            model: this.model
        });

        this.$('.quote-summary-data-list-table').append(this.listHeaderView.el);

        // set the column header fields and render
        this.listHeaderView.setColumnHeaderFields(this.listHeaderFields);
    },

    /**
     * @inheritdoc
     */
    _customFieldDef: function(def) {
        def.eventViewName = this.eventViewName;

        return def;
    },

    /**
     * Handles the click event when user clicks to Restore Default fields
     * @param evt
     */
    onClickRestoreDefaultsBtn: function(evt) {
        var fieldList = _.pluck(this.defaultFields, 'name');
        this.listHeaderView.setColumnHeaderFields(this.defaultFields);
        this.context.trigger('config:fields:' + this.eventViewName + ':reset', fieldList);
    }
}) },
"config-columns": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.ConfigColumnsView
 * @alias SUGAR.App.view.views.BaseQuotesConfigColumnsView
 * @extends View.Views.Base.Quotes.ConfigPanelView
 */
({
	// Config-columns View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'QuotesConfigPanelView',

    /**
     * @inheritdoc
     */
    events: {
        'click .restore-defaults-btn': 'onClickRestoreDefaultsBtn'
    },

    /**
     * The default list of field names for the Quotes worksheet columns
     */
    listDefaultFieldNames: [
        'quantity',
        'product_template_name',
        'mft_part_num',
        'discount_price',
        'discount',
        'total_amount'
    ],

    /**
     * The Label names from each of the default fields
     */
    listDefaultFieldNameLabels: undefined,

    /**
     * The list header view
     * @type {View.Views.Base.Quotes.ConfigListHeaderColumnsView}
     */
    listHeaderView: undefined,

    /**
     * Contains an array of all the default fields to reset the list header
     */
    defaultFields: undefined,

    /**
     * Contains an array of all the current fields in the list header
     */
    listHeaderFields: undefined,

    /**
     * Products Module vardefs
     */
    productsFieldMeta: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var productListMeta = app.metadata.getView('Products', 'quote-data-group-list');

        this._super('initialize', [options]);

        this.productsFieldMeta = app.metadata.getModule('Products', 'fields');

        this.defaultFields = [];

        // pluck all the fields arrays from panels and flatten into one array
        this.listHeaderFields = _.flatten(_.pluck(productListMeta.panels, 'fields'));
        // exclude the line_num field
        this.listHeaderFields = _.reject(this.listHeaderFields, function(field) {
            return field.name === 'line_num';
        });

        _.each(this.listHeaderFields, function(field) {
            field.labelModule = this._getFieldLabelModule(field);
        }, this);

        this.model.set(this.eventViewName, this.listHeaderFields);
    },

    /**
     * @inheritdoc
     */
    _getEventViewName: function() {
        return 'worksheet_columns';
    },

    /**
     * Returns the module to use for the label if no label module is given
     *
     * @param {Object} field
     * @return {string}
     * @private
     */
    _getFieldLabelModule: function(field) {
        var label = field.label || field.vname;
        var labelModule = field.labelModule || 'Products';
        var tmpLabel = app.lang.get(label, labelModule);

        if (tmpLabel.indexOf('LBL_') !== -1) {
            labelModule = 'Quotes';
        }

        return labelModule;
    },

    /**
     * @inheritdoc
     */
    _onDependentFieldsChange: function(context, fieldDeps) {
        var pFieldDeps;
        var pRelatedFields;
        var pRelatedField;
        var pDependentField;
        var tmpRelatedFields;
        var relatedFieldsList = [];
        var tmpField;

        this._super('_onDependentFieldsChange', [context, fieldDeps]);

        pFieldDeps = this.dependentFields.Products;
        pRelatedFields = this.relatedFields.Products;

        // build default fields
        var defaultWorksheetColumns = this.context.get('defaultWorksheetColumns');

        // pluck all the fields arrays from panels and flatten into one array
        this.defaultFields = _.flatten(_.pluck(defaultWorksheetColumns.panels, 'fields'));
        // exclude the line_num field
        this.defaultFields = _.reject(this.defaultFields, function(field) {
            return field.name === 'line_num';
        });

        // building Default Fields
        this.buildDefaultFields();

        _.each(this.panelFields, function(field) {
            pDependentField = pFieldDeps[field.name];
            pRelatedField = pRelatedFields[field.name];

            if (pDependentField) {
                tmpRelatedFields = _.extend({}, pDependentField.locked, pDependentField.related);

                if (!_.isEmpty(tmpRelatedFields)) {
                    field.dependentFields = tmpRelatedFields;
                    field.required = true;
                }

                if (field.required && !field.initialState) {
                    field.initialState = 'filled';
                    relatedFieldsList.push(field.name);
                }
            }

            if (pRelatedField) {
                tmpRelatedFields = _.extend({}, pRelatedField.locked, pRelatedField.related);

                if (!_.isEmpty(tmpRelatedFields)) {
                    field.relatedFields = field.relatedFields || [];

                    _.each(tmpRelatedFields, function(relField, relFieldName) {
                        field.relatedFields.push(relFieldName);
                    }, this);
                }
            }

            tmpField = _.find(this.listHeaderFields, function(headerField) {
                return headerField.name === field.name;
            });
            if (tmpField) {
                // if this panelField exists in listHeaderFields, set to visible
                field.initialState = 'checked';
            }
        }, this);

        this.model.set(this.eventViewName + '_related_fields', relatedFieldsList);
    },

    /**
     *
     */
    buildDefaultFields: function() {
        var field;
        var fieldLabel;
        var fieldLabels = [];
        var fieldLabelModule;
        var tmpField;
        var _defaultFields = this.defaultFields;

        this.listDefaultFieldNameLabels = _.pluck(_defaultFields, 'name');
        var namesLen = this.listDefaultFieldNameLabels.length;

        // build the list header labels and defaultFields
        this.listDefaultFieldNameLabels = [];
        this.defaultFields = [];

        for (var i = 0; i < namesLen; i++) {
            // try to get view defs from the quote-data-group-list meta
            field = _.find(this.listHeaderFields, function(headerField) {
                return this.listDefaultFieldNames[i] === headerField.name;
            }, this);

            if (!field) {
                // if the field didn't exist in the group list meta, use the field vardef
                field = _.find(_defaultFields, {name: this.listDefaultFieldNames[i]}) ||
                this.productsFieldMeta[this.listDefaultFieldNames[i]];
            }

            // use either label (viewdefs) or vname (vardefs)
            if (field && (field.label || field.vname)) {
                fieldLabel = field.label || field.vname;

                // check Products strings first
                fieldLabel = app.lang.get(fieldLabel, 'Products');
                fieldLabelModule = 'Products';

                if (fieldLabel.indexOf('LBL_') !== -1) {
                    // if Products label just returned LBL_ string, check Quotes
                    fieldLabel = app.lang.get(fieldLabel, 'Quotes');
                    fieldLabelModule = 'Quotes';
                }

                fieldLabels.push(fieldLabel);

                tmpField = {
                    name: field.name,
                    label: fieldLabel,
                    labelModule: fieldLabelModule,
                    widthClass: field.widthClass,
                    css_class: field.css_class || field.cssClass || ''
                };
                if (field.name === 'product_template_name') {
                    tmpField.type = 'quote-data-relate';
                    tmpField.required = true;
                }
                if (field.type === 'currency') {
                    tmpField.convertToBase = true;
                    tmpField.showTransactionalAmount = true;
                    tmpField.related_fields = ['currency_id', 'base_rate'];
                }
                if (field.name === 'discount') {
                    tmpField.type = 'fieldset';
                    tmpField.css_class += ' quote-discount-percent';
                    tmpField.fields = [{
                        name: 'discount_amount',
                        label: 'LBL_DISCOUNT_AMOUNT',
                        type: 'discount',
                        convertToBase: true,
                        showTransactionalAmount: true
                    }, {
                        name: 'discount_select',
                        type: 'discount-select',
                        no_default_action: true,
                        buttons: [{
                            name: 'select_discount_amount_button',
                            type: 'rowaction',
                            label: 'LBL_DISCOUNT_AMOUNT',
                            event: 'button:discount_select_change:click'
                        }, {
                            name: 'select_discount_percent_button',
                            type: 'rowaction',
                            label: 'LBL_DISCOUNT_PERCENT',
                            event: 'button:discount_select_change:click'
                        }]
                    }];
                }

                // push the fieldDefs to default fields
                this.defaultFields.push(tmpField);
            }
        }

        this.listDefaultFieldNameLabels = fieldLabels.join(', ');
    },

    /**
     * @inheritdoc
     */
    _onConfigFieldChange: function(field, oldState, newState) {
        var fieldVarDef = _.find(this.defaultFields, {name: field.name}) ?
            _.find(this.defaultFields, {name: field.name}) :
            this.productsFieldMeta[field.name];
        var fieldViewDef;
        var wasVisible = oldState === 'checked';
        var isNowVisible = newState === 'checked';
        var isUnchecked = newState === 'unchecked';
        var columnChanged = false;
        var toggleRelatedFields;

        if (!wasVisible && isNowVisible) {
            // field was not visible, but now is visible
            fieldViewDef = {
                name: fieldVarDef.name,
                type: fieldVarDef.type,
                label: fieldVarDef.vname || fieldVarDef.label
            };

            if (fieldVarDef.type === 'relate') {
                fieldViewDef.id_name = fieldVarDef.id_name;
            }
            if (fieldVarDef.type === 'parent') {
                fieldViewDef.id_name = fieldVarDef.id_name;
                fieldViewDef.type_name = fieldVarDef.type_name;
            }

            fieldViewDef.name === 'discount_amount' ?
                (fieldViewDef.label = app.lang.get('LBL_DISCOUNT_AMOUNT_VALUE', 'Products')) :
                fieldViewDef.label;

            if (fieldViewDef.name === 'discount') {
                fieldViewDef = fieldVarDef;
            }

            fieldViewDef.labelModule = this._getFieldLabelModule(field);

            // add the column to header fields
            this.listHeaderView.addColumnHeaderField(fieldViewDef);

            toggleRelatedFields = true;
            columnChanged = true;
        } else if (wasVisible && !isNowVisible) {
            // field was visible, but now is not visible, so remove from columns
            // remove the column from header fields
            this.listHeaderView.removeColumnHeaderField(fieldVarDef);

            toggleRelatedFields = false;
            columnChanged = true;
        } else if (!wasVisible && !isNowVisible && isUnchecked) {
            columnChanged = true;
            toggleRelatedFields = false;
        }

        if (columnChanged) {
            if (!_.isUndefined(toggleRelatedFields) && field.def.relatedFields) {
                _.each(field.def.relatedFields, function(fieldName) {
                    this.context.trigger(
                        'config:' + this.eventViewName + ':' + fieldName + ':related:toggle',
                        field,
                        toggleRelatedFields
                    );
                }, this);
            }
        }
    },

    /**
     * @inheritdoc
     */
    _getPanelFields: function() {
        return this.context.get('productsFields');
    },

    /**
     * @inheritdoc
     */
    _getPanelFieldsModule: function() {
        return 'Products';
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        this.listHeaderView = app.view.createView({
            context: this.context,
            eventViewName: this.eventViewName,
            type: 'config-list-header-columns',
            layout: this,
            model: this.model
        });

        this.$('.quote-data-list-table').append(this.listHeaderView.el);

        // set the column header fields and render
        this.listHeaderView.setColumnHeaderFields(this.listHeaderFields);
    },

    /**
     * Handles the click event when user clicks to Restore Default fields
     * @param evt
     */
    onClickRestoreDefaultsBtn: function(evt) {
        var fieldList = _.pluck(this.defaultFields, 'name');
        this.listHeaderView.setColumnHeaderFields(this.defaultFields);
        this.context.trigger('config:fields:' + this.eventViewName + ':reset', fieldList);
    },

    /**
     * @inheritdoc
     */
    onConfigPanelShow: function() {
        if (this.dependentFields) {
            this.context.trigger('config:fields:change', this.eventViewName, this.panelFields);
        }
    },

    /**
     * @inheritdoc
     */
    _customFieldDef: function(def) {
        def.name === 'discount_amount' ?
            (def.label = app.lang.get('LBL_DISCOUNT_AMOUNT_VALUE', 'Products')) :
            def.label;
        def.eventViewName = this.eventViewName;

        return def;
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.listHeaderView) {
            this.listHeaderView.dispose();
            this.listHeaderView = null;
        }

        this._super('_dispose');
    }
}) },
"config-footer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.ConfigFooterView
 * @alias SUGAR.App.view.views.BaseQuotesConfigFooterView
 * @extends View.Views.Base.Quotes.ConfigFooterView
 */
({
	// Config-footer View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'QuotesConfigPanelView',

    /**
     * @inheritdoc
     */
    events: {
        'click .restore-defaults-btn': 'onClickRestoreDefaultsBtn'
    },

    /**
     * The default list of field names for the Quotes worksheet columns
     */
    listDefaultFieldNames: [
        'new_sub',
        'tax',
        'shipping',
        'total'
    ],

    /**
     * The Label names from each of the default fields
     */
    listDefaultFieldNameLabels: undefined,

    /**
     * The list header view
     * @type {View.Views.Base.Quotes.ConfigTotalsFooterRowsView}
     */
    footerRowsView: undefined,

    /**
     * Contains an array of all the default fields to reset the list header
     */
    defaultFields: [{
        name: 'new_sub',
        type: 'currency'
    }, {
        name: 'tax',
        type: 'currency',
        related_fields: ['taxrate_value']
    }, {
        name: 'shipping',
        type: 'quote-footer-currency',
        css_class: 'quote-footer-currency',
        default: '0.00'
    }, {
        name: 'total',
        label: 'LBL_LIST_GRAND_TOTAL',
        type: 'currency',
        css_class: 'grand-total'
    }],

    /**
     * Contains an array of all the current fields in the list header
     */
    footerRowFields: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var namesLen = this.listDefaultFieldNames.length;
        var quoteGrandTotalFooterListMeta = app.metadata.getView('Quotes', 'quote-data-grand-totals-footer');
        var field;
        var fieldLabels = [];
        var fieldLabel;
        var fieldLabelModule;

        this._super('initialize', [options]);

        this.quotesFieldMeta = app.metadata.getModule('Quotes', 'fields');

        // pluck all the fields arrays from panels and flatten into one array
        this.footerRowFields = _.flatten(_.pluck(quoteGrandTotalFooterListMeta.panels, 'fields'));

        _.each(this.footerRowFields, function(field) {
            field.labelModule = this._getFieldLabelModule(field);
        }, this);

        // build the list header labels and defaultFields
        this.listDefaultFieldNameLabels = [];
        for (var i = 0; i < namesLen; i++) {
            // try to get view defs from the quote-data-group-list meta
            field = _.find(this.footerRowFields, function(headerField) {
                return this.listDefaultFieldNames[i] === headerField.name;
            }, this);

            if (!field) {
                // if the field didn't exist in the group list meta, use the field vardef
                field = this.quotesFieldMeta[this.listDefaultFieldNames[i]];
            }

            // use either label (viewdefs) or vname (vardefs)
            if (field && (field.label || field.vname)) {
                fieldLabel = field.label || field.vname;
                fieldLabelModule = 'Quotes';

                fieldLabels.push(app.lang.get(fieldLabel, fieldLabelModule));
            }
        }

        this.listDefaultFieldNameLabels = fieldLabels.join(', ');
    },

    /**
     * @inheritdoc
     */
    _getEventViewName: function() {
        return 'footer_rows';
    },

    /**
     * Returns the module to use for the label if no label module is given
     *
     * @param {Object} field
     * @return {string}
     * @private
     */
    _getFieldLabelModule: function(field) {
        return field.labelModule || 'Quotes';
    },

    /**
     * @inheritdoc
     *
     * Only return currency type fields from the Quotes module for the Footer view
     */
    _getPanelFields: function() {
        var fields = [];
        _.each(this.context.get('quotesFields'), function(f, key) {
            if (f.type === 'currency') {
                fields.push(_.extend({
                    name: key
                }, f));
            }
        }, this);

        return fields;
    },

    /**
     * @inheritdoc
     */
    _getPanelFieldsModule: function() {
        return 'Quotes';
    },

    /**
     * @inheritdoc
     */
    onConfigPanelShow: function() {
        if (this.dependentFields) {
            this.context.trigger('config:fields:change', this.eventViewName, this.panelFields);
        }
    },

    /**
     * @inheritdoc
     */
    _onDependentFieldsChange: function(context, fieldDeps) {
        var pFieldDeps;
        var pRelatedFields;
        var pRelatedField;
        var pDependentField;
        var tmpRelatedFields;
        var relatedFieldsList = [];
        var tmpField;

        this._super('_onDependentFieldsChange', [context, fieldDeps]);

        pFieldDeps = this.dependentFields.Quotes;
        pRelatedFields = this.relatedFields.Quotes;

        _.each(this.panelFields, function(field) {
            pDependentField = pFieldDeps[field.name];
            pRelatedField = pRelatedFields[field.name];

            if (pDependentField) {
                tmpRelatedFields = _.extend({}, pDependentField.locked, pDependentField.related);

                if (!_.isEmpty(tmpRelatedFields)) {
                    field.dependentFields = tmpRelatedFields;
                    field.required = true;
                }

                if (field.required && !field.initialState) {
                    field.initialState = 'filled';
                    relatedFieldsList.push(field.name);
                }
            }

            if (pRelatedField) {
                tmpRelatedFields = _.extend({}, pRelatedField.locked, pRelatedField.related);

                if (!_.isEmpty(tmpRelatedFields)) {
                    field.relatedFields = field.relatedFields || [];

                    _.each(tmpRelatedFields, function(relField, relFieldName) {
                        field.relatedFields.push(relFieldName);
                    }, this);
                }
            }

            tmpField = _.find(this.footerRowFields, function(headerField) {
                return headerField.name === field.name;
            });
            if (tmpField) {
                // if this panelField exists in footerRowFields, set to visible
                field.initialState = 'checked';
            }
        }, this);

        this.model.set(this.eventViewName + '_related_fields', relatedFieldsList);
    },

    /**
     * @inheritdoc
     */
    _onConfigFieldChange: function(field, oldState, newState) {
        var fieldVarDef = this.quotesFieldMeta[field.name];
        var fieldViewDef;
        var wasVisible = oldState === 'checked';
        var isNowVisible = newState === 'checked';
        var isUnchecked = newState === 'unchecked';
        var columnChanged = false;
        var toggleRelatedFields;

        if (!wasVisible && isNowVisible) {
            // field was not visible, but now is visible
            fieldViewDef = {
                name: fieldVarDef.name,
                type: fieldVarDef.type,
                label: fieldVarDef.vname || fieldVarDef.label
            };
            fieldViewDef.labelModule = this._getFieldLabelModule(field);

            // add the column to header fields
            this.footerRowsView.addFooterRowField(fieldViewDef);

            toggleRelatedFields = true;
            columnChanged = true;
        } else if (wasVisible && !isNowVisible) {
            // field was visible, but now is not visible, so remove from columns
            // remove the column from header fields
            this.footerRowsView.removeFooterRowField(fieldVarDef);

            toggleRelatedFields = false;
            columnChanged = true;
        } else if (!wasVisible && !isNowVisible && isUnchecked) {
            columnChanged = true;
            toggleRelatedFields = false;
        }

        if (columnChanged) {
            if (!_.isUndefined(toggleRelatedFields) && field.def.relatedFields) {
                _.each(field.def.relatedFields, function(fieldName) {
                    this.context.trigger(
                        'config:' + this.eventViewName + ':' + fieldName + ':related:toggle',
                        field,
                        toggleRelatedFields
                    );
                }, this);
            }
        }
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        this.footerRowsView = app.view.createView({
            context: this.context,
            eventViewName: this.eventViewName,
            type: 'config-totals-footer-rows',
            layout: this,
            model: this.model
        });

        this.$('.quote-footer-rows').append(this.footerRowsView.el);

        // set the column header fields and render
        this.footerRowsView.setFooterRowFields(this.footerRowFields);
    },

    /**
     * @inheritdoc
     */
    _customFieldDef: function(def) {
        def.eventViewName = this.eventViewName;

        return def;
    },

    /**
     * Handles the click event when user clicks to Restore Default fields
     *
     * @param {jQuery.Event} evt The jQuery click event
     */
    onClickRestoreDefaultsBtn: function(evt) {
        var fieldList = _.pluck(this.defaultFields, 'name');
        this.footerRowsView.setFooterRowFields(this.defaultFields);
        this.context.trigger('config:fields:' + this.eventViewName + ':reset', fieldList);
    }
}) },
"config-list-header-columns": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.ConfigListHeaderColumnsView
 * @alias SUGAR.App.view.views.BaseQuotesConfigListHeaderColumnsView
 * @extends View.Views.Base.FlexListView
 */
({
	// Config-list-header-columns View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'FlexListView',

    /**
     * @inheritdoc
     */
    plugins: [
        'MassCollection',
        'ReorderableColumns'
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.massCollection = this.collection;
        this.leftColumns = [];

        this.addMultiSelectionAction();
        this.template = app.template.getView('config-list-header-columns', 'Quotes');
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        this.on('list:reorder:columns', this.onSheetColumnsOrderChanged, this);
    },

    /**
     * Handles when there's a change in the order of list header columns
     *
     * @param {Object} fields The fields object sent from ReorderableColumns plugin
     * @param {Array} newFieldNameOrder The new order of field names
     */
    onSheetColumnsOrderChanged: function(fields, newFieldNameOrder) {
        var newFieldOrder = [];
        var headerFields = this.model.get(this.options.eventViewName);

        _.each(newFieldNameOrder, function(fieldName) {
            newFieldOrder.push(_.find(headerFields, function(field) {
                return field.name === fieldName;
            }));
        }, this);

        this.model.set(this.options.eventViewName, newFieldOrder);
    },

    /**
     * Add multi selection field to left column using Quote data fields
     *
     * @override
     */
    addMultiSelectionAction: function() {
        var buttons = [];
        var disableSelectAllAlert = !!this.meta.selection.disable_select_all_alert;

        if (this.layout && this.layout.name === 'config-summary') {
            var _generateMeta = function(buttons, disableSelectAllAlert) {
                return {
                    name: '',
                    type: 'button',
                    icon: 'fa-plus',
                    value: false,
                    sortable: false
                };
            };

            this.leftColumns.push(_generateMeta(buttons, disableSelectAllAlert));
        } else {
            var _generateMeta = function(buttons, disableSelectAllAlert) {
                return {
                    name: 'quote-data-mass-actions',
                    type: 'fieldset',
                    fields: [
                        {
                            type: 'quote-data-actionmenu',
                            buttons: buttons || [],
                            disable_select_all_alert: !!disableSelectAllAlert
                        }
                    ],
                    value: false,
                    sortable: false
                };
            };

            buttons = this.meta.selection.actions;
            this.leftColumns.push(_generateMeta(buttons, disableSelectAllAlert));
        }
    },

    /**
     * @inheritdoc
     */
    render: function() {
        var groupBtn;
        var massDeleteBtn;

        this._super('render');

        groupBtn = _.find(this.nestedFields, function(field) {
            return field.name === 'group_button';
        });
        massDeleteBtn = _.find(this.nestedFields, function(field) {
            return field.name === 'massdelete_button';
        });

        if (groupBtn) {
            groupBtn.setDisabled(true);
        }
        if (massDeleteBtn) {
            massDeleteBtn.setDisabled(true);
        }
    },

    /**
     * Sets the List Header column field names and re-renders
     *
     * @param {Array} headerFieldList The list of field
     */
    setColumnHeaderFields: function(headerFieldList) {
        headerFieldList = _.clone(headerFieldList);
        this.meta.panels = [
            {
                fields: headerFieldList
            }];
        this.model.set(this.options.eventViewName, headerFieldList);

        this._fields = this.parseFields();

        this.render();
    },

    /**
     * Adds a column header to the list columns
     *
     * @param {Object} field The field defs of the field to add
     */
    addColumnHeaderField: function(field) {
        var columns = this.model.get(this.options.eventViewName);
        columns.unshift(field);

        this.meta.panels[0].fields = columns;
        this.model.set(this.options.eventViewName, columns);
        this._fields = this.parseFields();

        this.render();
    },

    /**
     * Removes a column header from the list columns
     *
     * @param {Object} field The field defs of the field to remove
     */
    removeColumnHeaderField: function(field) {
        var fields = this.meta.panels[0].fields;
        fields = _.reject(fields, function(headerField) {
            return headerField.name === field.name;
        });
        this.meta.panels[0].fields = fields;

        this.model.set(this.options.eventViewName, fields);
        this._fields = this.parseFields();

        this.render();
    }
}) },
"product-catalog-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.ProductCatalogDashletView
 * @alias SUGAR.App.view.views.QuotesProductCatalogDashletView
 * @extends View.View
 */
({
	// Product-catalog-dashlet View (base) 


    extendsFrom: 'QuotesProductCatalogView',

    plugins: [
        'CanvasDataRenderer',
        'Dashlet'
    ],

    /**
     * Boolean if this is the dashlet config view or not
     */
    isConfig: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.isConfig = !!this.meta.config;
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        if (this.isConfig) {
            return;
        }
        this._super('loadData', [options]);
    },

    /**
     * @inheritdoc
     */
    toggleLoading: function(startLoading, showPhaserLoading) {
        if (this.layout.disposed === true) {
            return;
        }
        var $el = this.layout.$('i[data-action=loading]');
        if (startLoading) {
            $el.removeClass('fa-cog');
            $el.addClass('fa-refresh fa-spin');
        } else {
            $el.removeClass('fa-refresh fa-spin');
            $el.addClass('fa-cog');
        }
    }
}) },
"panel-top": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Panel-top View (base) 

    extendsFrom: 'PanelTopView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['MassQuote']);
        this._super('initialize', [options]);
    },

    /**
     * Overriding to create a Quote from a Subpanel using the Quotes create view not a drawer
     *
     * @inheritdoc
     */
    createRelatedClicked: function(event) {
        var massCollection = this.context.get('mass_collection');
        var module = this.context.parent.get('module');
        if (!massCollection) {
            massCollection = this.context.get('collection').clone();
            if (!_.contains(['Accounts', 'Opportunities', 'Contacts'], module)) {
                massCollection.fromSubpanel = true;
            }
            this.context.set('mass_collection', massCollection);
        }
        this.layout.trigger('list:massquote:fire');
    }
}) },
"config-panel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.ConfigPanelView
 * @alias SUGAR.App.view.views.BaseQuotesConfigPanelView
 * @extends View.Views.Base.ConfigPanelView
 */
({
	// Config-panel View (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'BaseConfigPanelView',

    /**
     * Holds an array of field names for the panel
     */
    panelFieldNameList: undefined,

    /**
     * Holds an array of field viewdefs for the panel
     */
    panelFields: undefined,

    /**
     * Contains the map of all related field dependencies
     */
    dependentFields: undefined,

    /**
     * Contains the map of all dependencies for each field
     */
    relatedFields: undefined,

    /**
     * The view name ID to use in events
     */
    eventViewName: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.eventViewName = this._getEventViewName();

        this.getPanelFieldNamesList();

        var helpUrl = {
            more_info_url: '<a href="' + app.help.getMoreInfoHelpURL('config', 'QuotesConfig') + '" target="_blank">',
            more_info_url_close: '</a>',
        };
        var viewQuotesObj = app.help.get('Quotes', 'config_opps', helpUrl);
        this.quotesDocumentation = app.template.getView('config-panel.help', this.module)(viewQuotesObj);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        this.context.once('change:dependentFields', this._onDependentFieldsChange, this);
        this.context.on('config:' + this.eventViewName + ':field:change', this._onConfigFieldChange, this);
    },

    /**
     * Returns the event and view name for this config panel.
     * Should be overridden by child views.
     *
     * @return {string}
     * @private
     */
    _getEventViewName: function() {
        return 'config_panel';
    },

    /**
     * Handles when the field dependencies list comes back from the config endpoint.
     * Should be extended in child classes to include anything specific views need to do
     * with the field dependencies list.
     *
     * @param {Core.Context} context
     * @param {Object} fieldDeps Dependent Fields
     * @protected
     */
    _onDependentFieldsChange: function(context, fieldDeps) {
        this.dependentFields = _.clone(fieldDeps);
        this.relatedFields = _.clone(this.context.get('relatedFields'));
        this.panelFields = this._buildPanelFieldsList();
    },

    /**
     * Handles when a checkbox on the RHS gets toggled
     *
     * @param {View.Fields.Base.TristateCheckboxField} field The field that was toggled
     * @param {string} oldState The old state for the field
     * @param {string} newState The new state for the field
     * @protected
     */
    _onConfigFieldChange: function(field, oldState, newState) {
    },

    /**
     * Returns an Array of field names to be used by the panel fields
     *
     * @return {Array}
     */
    getPanelFieldNamesList: function() {
        this.panelFieldNameList = [];
    },

    /**
     * Returns an Array of field names to be used by the panel fields
     *
     * @param {Array} fields The array of fields to use for panelFields
     * @return {Array}
     * @protected
     */
    _buildPanelFieldsList: function() {
        var fields = this._getPanelFields();
        var moduleName = this._getPanelFieldsModule();

        // convert fieldsObj to an array then sort the array by name
        if (!_.isArray(fields)) {
            var tmpArray = [];
            _.each(fields, function(value, key) {
                tmpArray.push(_.extend(value, {
                    name: key
                }));
            }, this);
            fields = tmpArray;
        }

        // apply any additional sorting to the fields
        fields = this._customFieldsSorting(fields);

        // return an array of the objects that pass the criteria
        fields = this._customFieldsProcessing(fields);

        fields = _.map(fields, function(field) {
            var def = {
                name: field.name,
                label: app.lang.get(field.label, moduleName),
                type: 'tristate-checkbox',
                labelModule: moduleName,
                locked: field.locked,
                related: field.related
            };

            return this._customFieldDef(def);
        }, this);

        return fields;
    },

    /**
     * Extensible function to get the fields array to be used in buildPanelFieldsList
     *
     * @private
     */
    _getPanelFields: function() {
        return [];
    },

    /**
     * Extensible function to get the module name for the buildPanelFieldsList
     *
     * @private
     */
    _getPanelFieldsModule: function() {
        return this.module;
    },

    /**
     * Handles any custom changes to the field defs a child view might need to make
     *
     * @param {Object} def The field def
     * @return {Object}
     * @protected
     */
    _customFieldDef: function(def) {
        return def;
    },

    /**
     * Handles any custom field sorting that child classes might need to do.
     * By default, sort by the name field
     *
     * @param {Array} arr The fields array
     * @return {Array}
     * @protected
     */
    _customFieldsSorting: function(arr) {
        return _.sortBy(arr, 'name');
    },

    /**
     * Handles any custom field processing, array manipulation, or changes
     * that child classes might need to do
     *
     * @param {Array} arr The fields array
     * @return {Array}
     * @protected
     */
    _customFieldsProcessing: function(arr) {
        return arr;
    }
}) },
"config-drawer-howto": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Quotes.ConfigDrawerHowtoView
 * @alias SUGAR.App.view.views.BaseQuotesConfigDrawerHowtoView
 * @extends View.Views.Base.BaseConfigDrawerHowtoView
 */
({
	// Config-drawer-howto View (base) 

    extendsFrom: 'BaseConfigDrawerHowtoView',

    /**
     * @inheritdoc
     */
    events: {
        'keyup .searchbox': 'onSearchFilterChanged'
    },

    /**
     * List of field defs for the left column of the howto area
     */
    fieldsListLeft: undefined,

    /**
     * List of field defs for the right column of the howto area
     */
    fieldsListRight: undefined,

    /**
     * Contains all fields hidden by search
     */
    hiddenFields: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.fieldsListLeft = [];
        this.fieldsListRight = [];
        this.hiddenFields = [];
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.context.on('config:fields:change', this.onFieldsChange, this);
    },

    /**
     * Handles when the list of fields changes for the howto panel
     *
     * @param {string} eventName The name of the event
     * @param {Array} fieldsList The list of fields to add to the view
     */
    onFieldsChange: function(eventName, fieldsList) {
        var len = fieldsList.length;
        var listRightIndex = len >> 1;
        var listLeftIndex = len - listRightIndex;

        this.hiddenFields = [];
        this.fieldsListLeft = _.initial(fieldsList, listLeftIndex);
        this.fieldsListRight = _.rest(fieldsList, listRightIndex);

        this.render();
    },

    /**
     * Handles when search term is changed, hides and shows fields
     */
    onSearchFilterChanged: _.debounce(function(evt) {
        var searchTerm = $(evt.currentTarget).val();
        var lowerName;
        var lowerLabel;

        if (searchTerm) {
            searchTerm = searchTerm.toLowerCase();
        }

        // re-show all fields
        _.each(this.hiddenFields, function(field) {
            field.show();
        }, this);

        // reset hidden fields
        this.hiddenFields = [];

        _.each(this.fields, function(field) {
            if (field.name) {
                lowerName = field.name.toLowerCase();
            }

            if (field.label) {
                lowerLabel = field.label.toLowerCase();
            }

            if ((lowerName && lowerName.indexOf(searchTerm) === -1) &&
                (lowerLabel && lowerLabel.indexOf(searchTerm) === -1)) {
                // the field name AND label DO NOT CONTAIN the search term,
                // hide the field
                field.hide();
                this.hiddenFields.push(field);
            }
        }, this);
    }, 400),

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        // set the indeterminate checkbox input
        this.$('.indeterminate').prop('indeterminate', true);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // get rid of any field references
        this.fieldsListLeft = [];
        this.fieldsListRight = [];
        this.hiddenFields = [];

        this._super('_dispose');
    }
}) }
}}
,
"layouts": {
"base": {
"extra-info": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Quotes.ExtraInfoLayout
 * @alias SUGAR.App.view.layouts.BaseQuotesExtraInfoLayout
 * @extends View.Views.Base.Layout
 */
({
	// Extra-info Layout (base) 

    /**
     * @inheritdoc
     */
    className: 'quote-data-container'
}) },
"config-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Quotes.ConfigDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseQuotesConfigDrawerLayout
 * @extends View.Layouts.Base.ConfigDrawerLayout
 */
({
	// Config-drawer Layout (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'BaseConfigDrawerLayout',

    /**
     * Checks Quotes ACLs to see if the User is a system admin, admin,
     * or if the user has a developer role for the Quotes module
     *
     * @inheritdoc
     */
    _checkModuleAccess: function() {
        var acls = app.user.getAcls().Quotes;
        var isSysAdmin = (app.user.get('type') === 'admin');
        var isAdmin = !_.has(acls, 'admin');
        var isDev = !_.has(acls, 'developer');

        return (isSysAdmin || isAdmin || isDev);
    },

    /**
     * Checks if there's actually config in the metadata for the current module
     * todo: remove this function once config data is actually in the application.
     *
     * @return {boolean}
     * @private
     */
    _checkConfigMetadata: function() {
        //todo: remove this function once config data is actually in the application.
        return true;
    },

    /**
     * @inheritdoc
     */
    loadData: function() {
        if (this._checkModuleAccess()) {
            app.api.call(
                'read',
                app.api.buildURL('Quotes', 'config'),
                null,
                {
                    success: _.bind(this.onConfigSuccess, this)
                }
            );
        }
    },

    /**
     * Success handler for when loadData returns
     *
     * @param {Object} data The server response
     */
    onConfigSuccess: function(data) {
        this.context.set(data);
    }
}) },
"quote-data-list-groups": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Quotes.QuoteDataListGroupsLayout
 * @alias SUGAR.App.view.layouts.BaseQuotesQuoteDataListGroupsLayout
 * @extends View.Views.Base.Layout
 */
({
	// Quote-data-list-groups Layout (base) 

    /**
     * @inheritdoc
     */
    tagName: 'table',

    /**
     * @inheritdoc
     */
    className: 'table dataTable quote-data-list-table',

    /**
     * Array of records from the Quote data
     */
    records: undefined,

    /**
     * An Array of ProductBundle IDs currently in the Quote
     */
    groupIds: undefined,

    /**
     * Holds the layout metadata for ProductBundlesQuoteDataGroupLayout
     */
    quoteDataGroupMeta: undefined,

    /**
     * The Element tag to apply jQuery.Sortable on
     */
    sortableTag: 'tbody',

    /**
     * The ID of the default group
     */
    defaultGroupId: undefined,

    /**
     * If this layout is currently in the /create view or not
     */
    isCreateView: undefined,

    /**
     * Contains any current bulk save requests being processed
     */
    currentBulkSaveRequests: undefined,

    /**
     * Counter for how many bundles are being saved
     */
    bundlesBeingSavedCt: undefined,

    /**
     * Array that holds any current api requests
     */
    saveQueue: undefined,

    /**
     * If this is initializing from a Quote's "Copy" functionality
     */
    isCopy: undefined,

    /**
     * Keeps track of the number of items to be copied during a Quote's "Copy" functionality
     */
    copyItemCount: undefined,

    /**
     * Keeps track of the number of bundles to be copied during a Quote's "Copy" functionality
     */
    copyBundleCount: undefined,

    /**
     * Keeps track of the copyBundle functionality
     */
    copyBundleCompleted: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.saveQueue = [];
        this.groupIds = [];
        this.currentBulkSaveRequests = [];
        this.quoteDataGroupMeta = app.metadata.getLayout('ProductBundles', 'quote-data-group');
        this.bundlesBeingSavedCt = 0;
        this.isCreateView = this.context.get('create') || false;
        this.isCopy = this.context.get('copy') || false;
        this.copyItemCount = 0;
        this.copyBundleCount = 0;

        //Setup the neccesary child context before data is populated so that child views/layouts are correctly linked
        var pbContext = this.context.getChildContext({link: 'product_bundles'});
        pbContext.set('create', this.isCreateView);
        pbContext.prepare(false, true);

        this.before('render', this.beforeRender, this);
        this.on('list:scrollLock', this._scrollLock, this);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        var userACLs = app.user.getAcls();

        this.model.on('change:show_line_nums', this._onShowLineNumsChanged, this);
        this.model.on('change:bundles', this._onProductBundleChange, this);
        this.context.on('quotes:group:create', this._onCreateQuoteGroup, this);
        this.context.on('quotes:group:delete', this._onDeleteQuoteGroup, this);
        this.context.on('quotes:selected:delete', this._onDeleteSelectedItems, this);
        this.context.on('quotes:defaultGroup:create', this._onCreateDefaultQuoteGroup, this);
        this.context.on('quotes:defaultGroup:save', this._onSaveDefaultQuoteGroup, this);

        if (!(_.has(userACLs.Quotes, 'edit') ||
            _.has(userACLs.Products, 'access') ||
            _.has(userACLs.Products, 'edit'))) {
            // only listen for PCDashlet if this is Quotes and user has access
            // to both Quotes and Products
            // need to trigger on app.controller.context because of contexts changing between
            // the PCDashlet, and Opps create being in a Drawer, or as its own standalone page
            // app.controller.context is the only consistent context to use

            var viewDetails = this.closestComponent('record') ?
                this.closestComponent('record') :
                this.closestComponent('create');
            if (!_.isUndefined(viewDetails)) {
                app.controller.context.on(viewDetails.cid + ':productCatalogDashlet:add',
                    this._onProductCatalogDashletAddItem,
                    this);
            }
        }

        // check if this is create mode, in which case add an empty array to bundles
        if (this.isCreateView) {
            this._onProductBundleChange(this.model.get('bundles'));

            if (this.isCopy) {
                this.copyItemCount = this.context.get('copyItemCount');

                if (this.copyItemCount) {
                    this.toggleCopyAlert(true);
                }

                // set this function to happen async after the alert has been displayed
                _.delay(_.bind(function() {
                    this._setCopyQuoteData();
                }, this), 250);
            }
        } else {
            this.model.once('sync', function(model) {
                var bundles = this.model.get('bundles');
                this._checkProductsQuoteLink();

                if (bundles.length === 0) {
                    this._onProductBundleChange(bundles);
                }
            }, this);
        }
    },

    /**
     * Toggles showing and hiding the "Copying QLI" alert when using the Copy functionality
     *
     * @param {boolean} showAlert True if we need to show alert, false if we need to dismiss it
     */
    toggleCopyAlert: function(showAlert) {
        var alertId = 'quotes_copy_alert';
        var titleLabel;

        if (showAlert) {
            titleLabel = this.copyItemCount > 8 ?
                'LBL_QUOTE_COPY_ALERT_MESSAGE_LONG_TIME' :
                'LBL_QUOTE_COPY_ALERT_MESSAGE';

            app.alert.show(alertId, {
                level: 'process',
                closeable: false,
                autoClose: false,
                title: app.lang.get(titleLabel, 'Quotes')
            });
        } else {
            app.alert.dismiss(alertId);
        }
    },

    /**
     * Handles decrementing the total copy item count and
     * checks if we need to dismiss the copy alert, or
     * decrements the copy bundle count and checks if we need to render
     *
     * @param {boolean} bundleComplete True if we're completing a bundle
     */
    completedCopyItem: function(bundleComplete) {
        this.copyItemCount--;
        if (this.copyItemCount === 0) {
            this.toggleCopyAlert(false);
        }

        if (bundleComplete) {
            this.copyBundleCount--;
            if (this.copyBundleCount === 0) {
                this.copyBundleCompleted = true;
                this.render();
            }
        }
    },

    /**
     * Handles grabbing the relatedRecords passed in from the context, creating the ProductBundle groups,
     * and adding items into those groups
     *
     * @private
     */
    _setCopyQuoteData: function() {
        var relatedRecords = this.context.get('relatedRecords');
        var defaultGroup = this._getComponentByGroupId(this.defaultGroupId);

        this.copyBundleCount = relatedRecords.length;

        // loop over the bundles
        _.each(relatedRecords, function(record) {
            // check if this record is the "default group"
            if (record.default_group) {
                _.each(record.product_bundle_items, function(pbItem) {
                    // set the item to use the edit template for quote-data-editablelistbutton
                    pbItem.modelView = 'edit';

                    // add this model to the toggledModels for edit view
                    defaultGroup.quoteDataGroupList.toggledModels[pbItem.cid] = pbItem;

                    // update the copy item number
                    this.completedCopyItem();
                }, this);

                // add the whole collection of PBItems to the list collection at once
                defaultGroup.quoteDataGroupList.collection.add(record.product_bundle_items);

                // update the existing default group
                this._updateDefaultGroupWithNewData(defaultGroup, record);

                // update the copy bundle number
                this.completedCopyItem(true);
            } else {
                // listen for a new group being created during the _onCreateQuoteGroup function
                this.context.once(
                    'quotes:group:create:success',
                    _.bind(this._onCopyQuoteDataNewGroupedCreateSuccess, this, record),
                    this
                );

                // create a new quote group
                this._onCreateQuoteGroup();
            }
        }, this);
    },

    /**
     * Called during a Quote record "Copy" to set a group's record data on the model
     * and adds any items to the group's collection
     *
     * @param {Object} record The ProductBundle JSON data to set on the model
     * @param {Data.Bean} pbModel The ProductBundle Model
     * @private
     */
    _onCopyQuoteDataNewGroupedCreateSuccess: function(record, pbModel) {
        var group = this._getComponentByGroupId(pbModel.cid);

        // set the group's name on the model
        group.model.set({
            name: record.name
        });

        // loop over each product bundle item and add it to the group rows
        _.each(record.product_bundle_items, function(pbItem) {
            // set the item to use the edit template for quote-data-editablelistbutton
            pbItem.modelView = 'edit';

            // add this model to the toggledModels for edit view
            group.quoteDataGroupList.toggledModels[pbItem.cid] = pbItem;

            // update the copy item number
            this.completedCopyItem();
        }, this);

        // add the whole collection of PBItems to the list collection at once
        group.quoteDataGroupList.collection.add(record.product_bundle_items);

        // update the copy bundle number
        this.completedCopyItem(true);

        // update the group line number counts
        group.trigger('quotes:line_nums:reset');
    },

    /**
     * Listens for the Product Catalog Dashlet to sent ProductTemplate data
     *
     * @param {Object} productData The ProductTemplate data to convert to a QLI
     * @private
     */
    _onProductCatalogDashletAddItem: function(productData) {
        var defaultGroup = this._getComponentByGroupId(this.defaultGroupId);

        if (defaultGroup) {
            // trigger event on default group to add the product data
            defaultGroup.trigger('quotes:group:create:qli', 'products', productData);
        }

        // trigger event on the context to let dashlet know this is done adding the product
        var viewDetails = this.closestComponent('record') ?
            this.closestComponent('record') :
            this.closestComponent('create');

        if (!_.isUndefined(viewDetails)) {
            app.controller.context.trigger(viewDetails.cid + ':productCatalogDashlet:add:complete');
        }
    },

    /**
     * Checks all Products in bundles to make sure each Product has quote_id set
     *
     * @private
     */
    _checkProductsQuoteLink: function() {
        var quoteId = this.model.get('id');
        var bundles = this.model.get('bundles');
        var prodId;
        var pbItems;
        var bulkRequest;
        var bulkUrl;
        var bulkCalls = [];

        _.each(bundles.models, function(pbModel) {
            pbItems = pbModel.get('product_bundle_items');

            _.each(pbItems.models, function(itemModel) {
                if (itemModel.module === 'Products') {
                    prodId = itemModel.get('id');

                    // if the product exists but doesn't have a quote ID saved, save it
                    if (prodId && _.isEmpty(itemModel.get('quote_id'))) {
                        bulkUrl = app.api.buildURL('Products/' + prodId + '/link/quotes/' + quoteId);
                        bulkRequest = {
                            url: bulkUrl.substr(4),
                            method: 'POST',
                            data: {
                                id: prodId,
                                link: 'quotes',
                                relatedId: quoteId,
                                related: {
                                    quote_id: quoteId
                                }
                            }
                        };
                        bulkCalls.push(bulkRequest);
                    }
                }
            }, this);
        }, this);

        if (bulkCalls.length) {
            app.api.call('create', app.api.buildURL(null, 'bulk'), {
                requests: bulkCalls
            }, null, {
                success: _.bind(function(bulkResponses) {
                    _.each(bulkResponses, function(response) {
                        var record = response.contents.record;
                        var relatedRecord = response.contents.related_record;
                        var bundles = this.model.get('bundles');

                        _.each(bundles.models, function(pbModel) {
                            var pbItems = pbModel.get('product_bundle_items');
                            _.each(pbItems.models, function(itemModel) {
                                if (itemModel.get('id') === record.id) {
                                    // update the product model
                                    this._updateModelWithRecord(itemModel, record);
                                }
                            }, this);
                        }, this);

                        // update the quote model
                        this._updateModelWithRecord(this.model, relatedRecord);
                    }, this);
                }, this)
            });
        }
    },

    /**
     * Handles when the show_line_nums attrib changes on the Quotes model, triggers if
     * line numbers should be shown or not
     *
     * @param {Data.Bean} model The Quotes Bean the change happened on
     * @param {boolean} showLineNums If the line nums should be shown or not
     * @private
     */
    _onShowLineNumsChanged: function(model, showLineNums) {
        this.context.trigger('quotes:show_line_nums:changed', showLineNums);
    },

    /**
     * Handles the quotes:defaultGroup:create event from a separate layout context
     * and triggers the correct create event on the default group to add a new item
     *
     * @param {string} itemType The type of item to create: 'qli' or 'note'
     * @private
     */
    _onCreateDefaultQuoteGroup: function(itemType) {
        //Ensure the default group exists
        if (!this.defaultGroupId) {
            this.model.get('bundles').add(this._getDefaultGroupModel());
        }
        var linkName = itemType == 'qli' ? 'products' : 'product_bundle_notes';
        var group = this._getComponentByGroupId(this.defaultGroupId);
        group.trigger('quotes:group:create:' + itemType, linkName);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var sortableItems;
        var cssClasses;

        this._super('_render');

        sortableItems = this.$(this.sortableTag);
        if (sortableItems.length) {
            _.each(sortableItems, function(sortableItem) {
                $(sortableItem).sortable({
                    // allow draggable items to be connected with other tbody elements
                    connectWith: 'tbody',
                    // allow drag to only go in Y axis direction
                    axis: 'y',
                    // the items to make sortable
                    items: 'tr.sortable',
                    // make the "helper" row (the row the user actually drags around) a clone of the original row
                    helper: 'clone',
                    // adds a slow animation when "dropping" a group, removing this causes the row
                    // to immediately snap into place wherever it's sorted
                    revert: true,
                    // the CSS class to apply to the placeholder underneath the helper clone the user is dragging
                    placeholder: 'ui-state-highlight',
                    // handler for when dragging starts
                    start: _.bind(this._onDragStart, this),
                    // handler for when dragging stops; the "drop" event
                    stop: _.bind(this._onDragStop, this),
                    // handler for when dragging an item into a group
                    over: _.bind(this._onGroupDragTriggerOver, this),
                    // handler for when dragging an item out of a group
                    out: _.bind(this._onGroupDragTriggerOut, this),
                    // the cursor to use when dragging
                    cursor: 'move'
                });
            }, this);
        }

        //wrap in container div for scrolling
        if (!this.$el.parent().hasClass('flex-list-view-content')) {
            cssClasses = 'flex-list-view-content';
            if (this.isCreateView) {
                cssClasses += ' create-view';
            }
            this.$el.wrap(
                '<div class="' + cssClasses + '"></div>'
            );
            this.$el.parent().wrap(
                '<div class="flex-list-view left-actions quote-data-table-scrollable"></div>'
            );
        }
    },

    /**
     * Event handler for the sortstart "drag" event
     *
     * @param {jQuery.Event} evt The jQuery sortstart event
     * @param {Object} ui The jQuery Sortable UI Object
     * @private
     */
    _onDragStart: function(evt, ui) {
        // clear the current displayed tooltip
        app.tooltip.clear();
        // disable any future tooltips from appearing until drag stop has occurred
        app.tooltip._disable();
    },

    /**
     * Event handler for the sortstop "drop" event
     *
     * @param {jQuery.Event} evt The jQuery sortstop event
     * @param {Object} ui The jQuery Sortable UI Object
     * @private
     */
    _onDragStop: function(evt, ui) {
        var $item = $(ui.item.get(0));
        var oldGroupId = $item.data('group-id');
        var newGroupId = $($item.parent()).data('group-id');
        // check if the row is in edit mode
        var isRowInEdit = $item.hasClass('tr-inline-edit');
        var triggerOldGroup = false;
        var oldGroup;
        var newGroup;
        var rowId;
        var saveDefaultGroup;
        var existingRows;
        var newPosition;

        // get the new group (may be the same group)
        newGroup = this._getComponentByGroupId(newGroupId);

        // make sure item was dropped in a different group than it started in
        if (oldGroupId !== newGroupId) {
            // since the groups are different, also trigger events for the old group
            triggerOldGroup = true;

            // get the row id from the name="Products_modelID" attrib
            rowId = $item.attr('name').split('_')[1];

            // get if we need to save the new default group list or not
            saveDefaultGroup = newGroup.model.isNew() || false;

            // get the old and new quote-data-group components
            oldGroup = this._getComponentByGroupId(oldGroupId);

            existingRows = newGroup.$('tr.quote-data-group-list:not(:hidden):not(.empty-row)');
            newPosition = _.findIndex(existingRows, function(item) {
                return ($(item).attr('name') == $item.attr('name'));
            });

            this._moveItemToNewGroup(oldGroupId, newGroupId, rowId, isRowInEdit, newPosition, true, true);
        } else {
            // get the requests from updated rows
            this.currentBulkSaveRequests = this.currentBulkSaveRequests.concat(this._updateRowPositions(newGroup));
        }

        // only make the bulk call if there are actual requests, if user drags row
        // but puts it in same place there should be no updates
        if (!this.isCreateView && !_.isEmpty(this.currentBulkSaveRequests)) {
            if (triggerOldGroup) {
                // trigger group changed for old group to check themselves
                oldGroup.trigger('quotes:group:changed');
                // trigger save start for the old group
                oldGroup.trigger('quotes:group:save:start');
                // trigger the group to reset it's line numbers
                oldGroup.trigger('quotes:line_nums:reset', oldGroup.groupId, oldGroup.collection);
            }

            // trigger group changed for new group to check themselves
            newGroup.trigger('quotes:group:changed');
            // trigger save start for the new group
            newGroup.trigger('quotes:group:save:start');
            // trigger the group to reset it's line numbers
            newGroup.trigger('quotes:line_nums:reset', newGroup.groupId, newGroup.collection);

            if (saveDefaultGroup) {
                this._saveDefaultGroupThenCallBulk(oldGroup, newGroup, this.currentBulkSaveRequests);
            } else {
                this._callBulkRequests(_.bind(this._onSaveUpdatedGroupSuccess, this, oldGroup, newGroup));
            }
        }

        // re-enable tooltips in the app
        app.tooltip._enable();
    },

    /**
     * Temporarily overwrites the css from the .scroll-width class so that
     * row field dropdown menues aren't clipped by overflow-x property.
     */
    _scrollLock: function(lock) {
        var $content = this.$el.parent('.flex-list-view-content');
        if (lock) {
            $content.css({'overflow-y': 'visible', 'overflow-x': 'hidden'});
        } else {
            $content.removeAttr('style');
        }
        $content.toggleClass('scroll-locked', lock);
    },

    /**
     * Moves all items from mass_collection into a new group
     * based on the `newGroupData` info
     *
     * @param {Object} newGroupData The new ProductBundle to
     *      be used to move the mass_collection items into
     */
    moveMassCollectionItemsToNewGroup: function(newGroupData) {
        var newGroupId = newGroupData.related_record.id;
        var massCollection = this.context.get('mass_collection');
        var oldGroupId;
        var isRowInEdit;
        var modelCt = {};
        var updateLinkBean;
        var positionCt = 0;

        // since model.link.bean is the same exact reference to a group's model across all models
        // in a group, if multiple items in the same group are moved, we have to only update the
        // model to the new model.link.bean when it's the last model in the group being moved. If we
        // update a model.link.bean, it will change all other model.link.bean references in that group,
        // so we have to count all the models in a group, and only update the model.link.bean when it's
        // the last model we're updating for that group
        _.each(massCollection.models, function(model) {
            oldGroupId = model.link.bean.id;
            if (modelCt[oldGroupId]) {
                modelCt[oldGroupId]++;
            } else {
                modelCt[oldGroupId] = 1;
            }
        }, this);

        _.each(massCollection.models, function(model) {
            // get the old Group ID from the model link
            oldGroupId = model.link.bean.id;
            // get if the row was in Edit mode if modelView exists and is set to 'edit'
            isRowInEdit = model.modelView && model.modelView === 'edit' || false;
            // set selected to false since this model will no longer be in the mass collection
            model.selected = false;
            // decrement the model count for this group
            modelCt[oldGroupId]--;
            // updateLinkBean should only be true when this is the last model in the group (modelCt === 0)
            updateLinkBean = modelCt[oldGroupId] === 0;

            model.set('position', positionCt++);

            this._moveItemToNewGroup(oldGroupId, newGroupId, model.cid, isRowInEdit, undefined, updateLinkBean, false);
        }, this);

        // the items have all been moved on the frontend now call the BulkAPI
        // to flush out this.currentBulkSaveRequests to update the server
        this._callBulkRequests(_.bind(this._onSaveUpdatedMassCollectionItemsSuccess, this));
        if (massCollection) {
            massCollection.reset();
        }
    },

    /**
     * Handles the success call from moving MassCollection items to a new group
     *
     * @param {Object} bulkResponses Response data from the bulk requests
     * @private
     */
    _onSaveUpdatedMassCollectionItemsSuccess: function(bulkResponses) {
        _.each(bulkResponses, function(data) {
            var record = data.contents.record;
            var relatedRecord = data.contents.related_record;
            var newGroup;
            var model;

            // if data.contents.record was empty but contents has an id (old group GET request)
            if (_.isUndefined(record) && (data.contents.id && data.contents.hasOwnProperty('date_modified'))) {
                // this is a GET request
                record = data.contents;
            }

            newGroup = this._getComponentByGroupId(record.id);
            if (newGroup) {
                // check if record is the one on this collection
                if (newGroup.model && record && newGroup.model.get('id') === record.id) {
                    this._updateModelWithRecord(newGroup.model, record);
                }
                if (relatedRecord) {
                    // check if the related_record is in the newGroup
                    model = newGroup.collection.get(relatedRecord.id);
                    if (model) {
                        this._updateModelWithRecord(model, relatedRecord);
                    }
                }
            }
        }, this);

        _.each(this._components, function(comp) {
            if (comp.type === 'quote-data-group') {
                _.each(comp._components, function(subComp) {
                    if (subComp.type === 'quote-data-group-list') {
                        // re-initialize the SugarLogic Context on the QuoteDataGroupList
                        subComp.slContext.initialize(
                            subComp._getSugarLogicDependenciesForModel(subComp.model)
                        );
                    }
                }, this);
            }
        }, this);
    },

    /**
     * Updates the syncedAttributes and attributes of a `model` with the `record` data
     *
     * @param {Data.Bean} model The model to be updated
     * @param {Object} record The data to set on the model
     * @private
     */
    _updateModelWithRecord: function(model, record) {
        if (model) {
            // remove any empty product_Bundle_items data
            if (record.hasOwnProperty('product_bundle_items') && _.isEmpty(record.product_bundle_items)) {
                delete record.product_bundle_items;
            }

            model.setSyncedAttributes(record);
            model.set(record);
        }
    },

    /**
     * Moves an item with `itemId` from `oldGroupId` to the `newGroupId` ProductBundle
     *
     * @param {string} oldGroupId The ID of the old ProductBundle to move the item from
     * @param {string} newGroupId The ID of the new ProductBundle to move the item to
     * @param {string} itemId The ID of the item to move
     * @param {boolean} isRowInEdit If the row to move is in edit mode or not
     * @param {number|undefined} [newPos] The new position to place the item in
     * @param {boolean} updateLinkBean If we should update the model's link bean or not
     * @param {boolean} updatePos If we should update the model's position or not
     * @private
     */
    _moveItemToNewGroup: function(oldGroupId, newGroupId, itemId, isRowInEdit, newPos, updateLinkBean, updatePos) {
        var oldGroup = this._getComponentByGroupId(oldGroupId);
        var newGroup = this._getComponentByGroupId(newGroupId);
        var rowModel = oldGroup.collection.get(itemId);
        var url;
        var linkName;
        var bulkMoveRequest;
        var oldGroupModelId = oldGroup.model.id;
        var newGroupModelId = newGroup.model.id;
        var itemModelId = rowModel.id;

        // if newPos is not passed in, make it the newGroup collection length
        newPos = _.isUndefined(newPos) ? newGroup.collection.length : newPos;

        // set the new position, so it's only set when the item is saved via the relationship change
        // and not again for the position update
        rowModel.set('position', newPos);

        // remove the rowModel from the old group
        oldGroup.removeRowModel(rowModel, isRowInEdit);

        // add rowModel to the new group
        newGroup.addRowModel(rowModel, isRowInEdit);

        if (updateLinkBean) {
            // update the link on all the models in the new group collection to be the newGroup's model
            _.each(newGroup.collection.models, function(newGroupCollectionModel) {
                newGroupCollectionModel.link = {
                    bean: newGroup.model,
                    isNew: newGroupCollectionModel.link.isNew,
                    name: newGroupCollectionModel.link.name
                };
            }, this);
        }

        if (updatePos) {
            // get the requests from updated rows for old and new group
            this.currentBulkSaveRequests = this.currentBulkSaveRequests.concat(this._updateRowPositions(oldGroup));
            this.currentBulkSaveRequests = this.currentBulkSaveRequests.concat(this._updateRowPositions(newGroup));
        }

        // move the item to the new group
        linkName = rowModel.module === 'Products' ? 'products' : 'product_bundle_notes';
        url = app.api.buildURL('ProductBundles/' + newGroupModelId + '/link/' + linkName + '/' + itemModelId);
        bulkMoveRequest = {
            url: url.substr(4),
            method: 'POST',
            data: {
                id: newGroupModelId,
                link: linkName,
                relatedId: itemModelId,
                related: {
                    position: newPos
                }
            }
        };

        // add the group switching call to the newPos element of the bulk requests
        // so position "0" will be the 0th element in currentBulkSaveRequests
        this.currentBulkSaveRequests.splice(newPos, 0, bulkMoveRequest);

        // get the new totals after everything has happened for the old group
        url = app.api.buildURL('ProductBundles/' + oldGroupModelId);
        bulkMoveRequest = {
            url: url.substr(4),
            method: 'GET'
        };
        this.currentBulkSaveRequests.push(bulkMoveRequest);

        // update the line numbers in the groups
        oldGroup.trigger('quotes:line_nums:reset', oldGroup.groupId, oldGroup.collection);
        newGroup.trigger('quotes:line_nums:reset', newGroup.groupId, newGroup.collection);
    },

    /**
     * Handles saving the default quote group when a user adds a new QLI/Note to an unsaved default group
     * and clicks the save button from the new QLI/Note row
     *
     * @param {Function} successCallback Callback function sent from the QuoteDataEditablelistField so the field
     *      knows when the group save is successful and the field can continue saving the new row model
     * @private
     */
    _onSaveDefaultQuoteGroup: function(successCallback) {
        var group = this._getComponentByGroupId(this.defaultGroupId);

        app.alert.show('saving_default_group_alert', {
            level: 'success',
            autoClose: false,
            messages: app.lang.get('LBL_SAVING_DEFAULT_GROUP_ALERT_MSG', 'Quotes')
        });

        app.api.relationships('create', 'Quotes', {
            'id': this.model.get('id'),
            'link': 'product_bundles',
            'related': {
                position: 0,
                default_group: true
            }
        }, null, {
            success: _.bind(function(group, successCallback, serverData) {
                app.alert.dismiss('saving_default_group_alert');

                this._updateDefaultGroupWithNewData(group, serverData.related_record);

                // call the callback to continue the save stuff
                successCallback();
            }, this, group, successCallback)
        });
    },

    /**
     * Updates a group with the latest server data, updates the model, groupId, and DOM elements
     *
     * @param {View.QuoteDataGroupLayout} group The QuoteDataGroupLayout to update
     * @param {Object} recordData The new record data from the server
     * @private
     */
    _updateDefaultGroupWithNewData: function(group, recordData) {
        if (this.defaultGroupId !== group.model.cid) {
            // remove the old default group ID from groupIds
            this.groupIds = _.without(this.groupIds, this.defaultGroupId);
            // add the new group ID so we dont add the default group twice
            this.groupIds.push(group.model.cid);
        }
        // update defaultGroupId with new id
        this.defaultGroupId = group.model.cid;
        // set the new data on the group model
        group.model.set(recordData);
        // update groupId with new id
        group.groupId = this.defaultGroupId;
        // update the group's dom tbody el with the correct group id
        group.$el.attr('data-group-id', this.defaultGroupId);
        // update the tr's inside the group's dom tbody el with the correct group id
        group.$('tr').attr('data-group-id', this.defaultGroupId);
    },

    /**
     * Handles saving the default quote data group if it has not been saved yet,
     * then when that save success returns, it calls save on all the bulk requests
     * with the new proper group ID
     *
     * @param {View.QuoteDataGroupLayout} oldGroup The old QuoteDataGroupLayout
     * @param {View.QuoteDataGroupLayout} newGroup The new QuoteDataGroupLayout - default group that needs saving
     * @param {Array} bulkSaveRequests The array of bulk save requests
     * @private
     */
    _saveDefaultGroupThenCallBulk: function(oldGroup, newGroup, bulkSaveRequests) {
        var newGroupOldId = newGroup.model.get('id');

        app.alert.show('saving_default_group_alert', {
            level: 'success',
            autoClose: false,
            messages: app.lang.get('LBL_SAVING_DEFAULT_GROUP_ALERT_MSG', 'Quotes')
        });

        app.api.relationships('create', 'Quotes', {
            'id': this.model.get('id'),
            'link': 'product_bundles',
            'related': _.extend({
                position: 0
            }, newGroup.model.toJSON())
        }, null, {
            success: _.bind(this._onDefaultGroupSaveSuccess, this, oldGroup, newGroup, bulkSaveRequests, newGroupOldId)
        });
    },

    /**
     * Called when the default group has been saved successfully and we have the new proper group id. It
     * updates all the bulk requests replacing the old "fake" group ID with the new proper DB-saved group ID,
     * updates newGroup with the new data and group ID and calls the save on the remaining bulk requests
     *
     * @param {View.QuoteDataGroupLayout} oldGroup The old QuoteDataGroupLayout
     * @param {View.QuoteDataGroupLayout} newGroup The new QuoteDataGroupLayout
     * @param {Array} bulkSaveRequests The array of bulk save requests
     * @param {string} newGroupOldId The previous "fake" group ID for newGroup
     * @param {Object} serverData The server response from saving the newGroup
     * @private
     */
    _onDefaultGroupSaveSuccess: function(oldGroup, newGroup, bulkSaveRequests, newGroupOldId, serverData) {
        var newId = serverData.related_record.id;
        app.alert.dismiss('saving_default_group_alert');

        // update all the bulk save requests that have the old newGroup ID with the newly saved group ID
        _.each(bulkSaveRequests, function(req) {
            req.url = req.url.replace(newGroupOldId, newId);
        }, this);

        this._updateDefaultGroupWithNewData(newGroup, serverData.related_record);

        // call the remaining bulk requests
        this._callBulkRequests(_.bind(this._onSaveUpdatedGroupSuccess, this, oldGroup, newGroup));
    },

    /**
     * Calls the bulk request endpoint with an array of requests
     *
     * @param {Function} [successCallback] The success callback function
     * @private
     */
    _callBulkRequests: function(successCallback) {
        var successWrapper = {
            success: _.bind(this.handleSaveQueueSuccess, this, successCallback)
        };
        var apiCall = app.api.call('create', app.api.buildURL(null, 'bulk'), {
            requests: this.currentBulkSaveRequests
        }, successWrapper);
        var saveQueueObj = {
            callReturned: false,
            customSuccess: {},
            request: apiCall,
            responseData: {}
        };

        this.saveQueue.push(saveQueueObj);

        // reset currentBulkSaveRequests
        this.currentBulkSaveRequests = [];
    },

    /**
     * Handles all responses that are returned by the save queue
     *
     * @param {Function|undefined} customSuccess The custom success handler function that should be called next
     * @param {Object} responseData The response returned by the server for a call
     * @param {HttpRequest} httpRequest The HTTP Request that is returning from the api call
     */
    handleSaveQueueSuccess: function(customSuccess, responseData, httpRequest) {
        if (this.saveQueue.length && this.saveQueue[0].request === httpRequest) {
            // there are items in the save queue and the httpRequest
            // that was returned exactly matches the next item in the saveQueue

            // removes this.saveQueue[0] from the array, since the request being
            // processed is the current top of the saveQueue, we don't need to do
            // anything with it just shift it off the array
            this.saveQueue.shift();

            if (_.isFunction(customSuccess)) {
                // if this has been returned in the proper order
                customSuccess(responseData);
            }

            // now that the latest request has been processed, check if other
            // items in the saveQueue need to be processed or not
            this._processSaveQueue();
        } else {
            // the httpRequest being returned does not match the next request that
            // should be processed, so save it for later
            _.some(this.saveQueue, function(queueObj) {
                if (queueObj.request === httpRequest) {
                    queueObj.callReturned = true;
                    queueObj.customSuccess = customSuccess;
                    queueObj.responseData = responseData;
                    return true;
                }
                return false;
            }, this);
        }
    },

    /**
     * Handles checking if more items in `this.saveQueue` need to be processed and then processes them
     * calling itself again to make sure any remaining items get checked and processed.
     *
     * @private
     */
    _processSaveQueue: function() {
        var saveQueueObj;

        // check if the next first request in the saveQueue has returned
        // and needs to be processed or not
        if (this.saveQueue.length && this.saveQueue[0].callReturned) {
            // there are api calls still in the saveQueue and now
            // the first one already has response data that needs to be handled

            // removes this.saveQueue[0] from the array and places it into saveQueueObj
            saveQueueObj = this.saveQueue.shift();

            if (_.isFunction(saveQueueObj.customSuccess)) {
                // check if this had previously been returned out of order and
                // is now the first item in saveQueue it will have customSuccess saved
                saveQueueObj.customSuccess(saveQueueObj.responseData);
            }

            this._processSaveQueue();
        }
    },

    /**
     * The success event handler for when a user reorders or moves an item to a different group
     *
     * @param {View.QuoteDataGroupLayout} oldGroup The old QuoteDataGroupLayout
     * @param {View.QuoteDataGroupLayout} newGroup The new QuoteDataGroupLayout
     * @param {Array} bulkResponses The responses from each of the bulk requests
     * @protected
     */
    _onSaveUpdatedGroupSuccess: function(oldGroup, newGroup, bulkResponses) {
        var deleteResponse = _.find(bulkResponses, function(resp) {
            return resp.contents.id && !resp.contents.hasOwnProperty('date_modified');
        });
        var deletedGroupId = deleteResponse && deleteResponse.contents.id;
        var deletedGroup;
        var newGroupBundle;
        var deletedGroupBundle;
        var bundles;

        if (oldGroup) {
            oldGroup.trigger('quotes:group:save:stop');
        }
        newGroup.trigger('quotes:group:save:stop');

        // remove the deleted group if it exists
        if (deletedGroupId) {
            app.alert.dismiss('deleting_bundle_alert');
            app.alert.show('deleted_bundle_alert', {
                level: 'success',
                autoClose: true,
                messages: app.lang.get('LBL_DELETED_BUNDLE_SUCCESS_MSG', 'Quotes')
            });

            // get the deleted group
            deletedGroup = this._getComponentByGroupId(deletedGroupId);
            // get the bundle for the deleted group
            deletedGroupBundle = deletedGroup.model.get('product_bundle_items');
            // get the bundle for the new group
            newGroupBundle = newGroup.model.get('product_bundle_items');
            // add the deleted group's models to the new group
            _.each(deletedGroupBundle.models, function(model) {
                newGroupBundle.add(model);
                model.link = {
                    bean: newGroup.model,
                    isNew: model.link.isNew,
                    name: model.link.name
                };
            }, this);
        }

        _.each(bulkResponses, _.bind(function(oldGroup, newGroup, data) {
            var record = data.contents.record;
            var relatedRecord = data.contents.related_record;
            var model;
            var isGetRequest = false;
            // remove position and line_num fields if they exist
            relatedRecord = _.omit(relatedRecord, 'position', 'line_num');

            // if data.contents.record was empty but contents has an id (DELETE and GET) and date_modified (only GET)
            if (_.isUndefined(record) && (data.contents.id && data.contents.hasOwnProperty('date_modified'))) {
                // this is a GET request
                isGetRequest = true;
                record = data.contents;
            }

            // on DELETE record and relatedRecord will both be missing
            // on GET ProductBundles relatedRecord will not exist but isGetRequest should be set above
            // on any other request, relatedRecord will be set
            if (record && (relatedRecord || isGetRequest)) {
                // only update if there are new records to update with
                if (oldGroup && !oldGroup.disposed) {
                    // check if record is the one on this collection
                    if (oldGroup.model && record && oldGroup.model.get('id') === record.id) {
                        this._updateModelWithRecord(oldGroup.model, record);
                    }
                    // if oldGroup exists, check if the related_record is in the oldGroup
                    model = oldGroup.collection.get(relatedRecord.id);
                    if (model) {
                        this._updateModelWithRecord(model, relatedRecord);
                    }
                }
                if (newGroup) {
                    // check if record is the one on this collection
                    if (newGroup.model && record && newGroup.model.get('id') === record.id) {
                        this._updateModelWithRecord(newGroup.model, record);
                    }
                    // check if the related_record is in the newGroup
                    model = newGroup.collection.get(relatedRecord.id);
                    if (model) {
                        this._updateModelWithRecord(model, relatedRecord);
                    }
                }
            }
        }, this, oldGroup, newGroup), this);

        if (deletedGroupId) {
            // remove the deleted group ID from the main groupIds
            this.groupIds = _.without(this.groupIds, deletedGroupId);
            // get the main bundles collection
            bundles = this.model.get('bundles');
            // remove the deleted group's model from the main bundles
            bundles.remove(deletedGroup.model);

            if (bundles._linkedCollections &&
                bundles._linkedCollections.product_bundles &&
                bundles._linkedCollections.product_bundles._delete &&
                bundles._linkedCollections.product_bundles._delete.length) {
                // clear out the bundles linkedCollections delete
                var del = bundles._linkedCollections.product_bundles._delete;
                bundles._linkedCollections.product_bundles._delete = _.reject(del, function(model) {
                    return model.cid === deletedGroup.model.cid;
                });
            }

            // dispose the group
            deletedGroup.dispose();
            // remove the component from the layout
            this.removeComponent(deletedGroup);

            // once new items are added to the default group, update the group's line numbers
            newGroup.trigger('quotes:line_nums:reset', newGroup.groupId, newGroup.collection);
        }
    },

    /**
     * Iterates through all rows in a group and updates the positions for the rows if necessary
     *
     * @param {View.QuoteDataGroupLayout} dataGroup The group component
     * @return {Array}
     * @protected
     */
    _updateRowPositions: function(dataGroup) {
        var retCalls = [];
        var rows = dataGroup.$('tr.quote-data-group-list:not(:hidden):not(.empty-row)');
        var $row;
        var rowNameSplit;
        var rowId;
        var rowModule;
        var rowModel;
        var url;
        var linkName;
        var dataGroupModelId;
        var itemModelId;

        _.each(rows, _.bind(function(dataGroup, retObj, row, index) {
            $row = $(row);
            rowNameSplit = $row.attr('name').split('_');
            rowModule = rowNameSplit[0];
            rowId = rowNameSplit[1];

            rowModel = dataGroup.collection.get(rowId);
            if (rowModel.get('position') != index && !rowModel.isNew()) {
                dataGroupModelId = dataGroup.model.id;
                itemModelId = rowModel.id;
                linkName = rowModule === 'Products' ? 'products' : 'product_bundle_notes';
                url = app.api.buildURL('ProductBundles/' + dataGroupModelId + '/link/' + linkName + '/' + itemModelId);
                retCalls.push({
                    url: url.substr(4),
                    method: 'PUT',
                    data: {
                        position: index
                    }
                });

                rowModel.set('position', index);
            }
        }, this, dataGroup, retCalls), this);

        if (retCalls.length) {
            // if items have changed positions, sort the collection
            // using the collection.comparator compare function
            dataGroup.collection.sort();
        }
        return retCalls;
    },

    /**
     * Gets a quote-data-group component by the group ID
     *
     * @param {string} groupId The group's id
     * @protected
     */
    _getComponentByGroupId: function(groupId) {
        // since groupId could be the cid or the model.id we should check both places
        return _.find(this._components, function(group) {
            return group.name === 'quote-data-group' &&
                (group.groupId === groupId || (group.model && group.model.id === groupId));
        });
    },

    /**
     * Handles when user drags an item into/over a group
     *
     * @param {jQuery.Event} evt The jQuery sortover event
     * @param {Object} ui The jQuery Sortable UI Object
     * @protected
     */
    _onGroupDragTriggerOver: function(evt, ui) {
        var groupId = $(evt.target).data('group-id');
        var group = this._getComponentByGroupId(groupId);
        if (group) {
            group.trigger('quotes:sortable:over', evt, ui);
        }
    },

    /**
     * Handles when user drags an item out of a group
     *
     * @param {jQuery.Event} evt The jQuery sortout event
     * @param {Object} ui The jQuery Sortable UI Object
     * @private
     */
    _onGroupDragTriggerOut: function(evt, ui) {
        var groupId = $(evt.target).data('group-id');
        var group = this._getComponentByGroupId(groupId);
        if (group) {
            group.trigger('quotes:sortable:out', evt, ui);
        }
    },

    /**
     * Removes the sortable plugin from any rows that have the plugin added
     * so we don't add plugin multiple times and for dispose cleanup
     */
    beforeRender: function() {
        var groups = this.$(this.sortableTag);
        if (groups.length) {
            _.each(groups, function(group) {
                if ($(group).hasClass('ui-sortable')) {
                    $(group).sortable('destroy');
                }
            }, this);
        }
    },

    /**
     * Creates the default ProductBundles Bean with default group ID
     *
     * @return {Data.Bean}
     * @protected
     */
    _getDefaultGroupModel: function() {
        var defaultGroup = this._createNewProductBundleBean(null, 0, true);
        // if there is not a default group yet, add one
        this.defaultGroupId = defaultGroup.cid;
        return defaultGroup;
    },

    /**
     * Creates a new ProductBundle Bean
     *
     * @param {String) groupId The groupId to use, if not passed in, will generate a new UUID
     * @param {number) newPosition The position to use for the group
     * @param {boolean) isDefaultGroup If this group is the default group or not
     * @return {Data.Bean}
     * @protected
     */
    _createNewProductBundleBean: function(groupId, newPosition, isDefaultGroup) {
        newPosition = newPosition || 0;
        isDefaultGroup = isDefaultGroup || false;
        return app.data.createBean('ProductBundles', {
            _module: 'ProductBundles',
            _action: 'create',
            _link: 'product_bundles',
            default_group: isDefaultGroup,
            currency_id: this.model.get('currency_id'),
            base_rate: this.model.get('base_rate'),
            product_bundle_items: [],
            product_bundle_notes: [],
            position: newPosition
        });
    },

    /**
     * Handler for when quote_data changes on the model
     *
     * @param {Backbone.Model|Data.MixedBeanCollection} productBundles The quote_data object that changed
     * @protected
     */
    _onProductBundleChange: function(productBundles) {
        var hasDefaultGroup = false;
        var defaultGroupModel;

        // after adding and deleting models, the change event is like its change for the model, where the
        // model is the first param and not the actual value it's self.
        if (productBundles instanceof Backbone.Model) {
            productBundles = productBundles.get('bundles');
        }

        // check to see if there's a default group in the bundle
        if (productBundles && productBundles.length > 0) {
            hasDefaultGroup = _.some(productBundles.models, function(bundle) {
                return bundle.get('default_group');
            });
        }

        if (!hasDefaultGroup) {
            defaultGroupModel = this._getDefaultGroupModel();
            // calling unshift on the collection with silent so it doesn't
            // cause this function to be triggered again halfway thru
            productBundles.unshift(defaultGroupModel);
        } else {
            // default group exists, get the ID
            defaultGroupModel = _.find(productBundles.models, function(bundle) {
                return bundle.get('default_group');
            });
            this.defaultGroupId = defaultGroupModel.cid;
        }

        productBundles.each(function(bundle) {
            if (!_.contains(this.groupIds, bundle.cid)) {
                this.groupIds.push(bundle.cid);
                this._addQuoteGroupToLayout(bundle);
            }
        }, this);

        if (!this.isCopy) {
            this.render();
        } else if (this.copyBundleCount === 0 && this.copyBundleCompleted) {
            // Rendering when user tries to create a group in Quote Copy Mode.
            this.render();
        }
    },

    /**
     * Adds the actual quote-data-group layout component to this layout
     *
     * @param {Object} [bundle] The ProductBundle data object
     * @private
     */
    _addQuoteGroupToLayout: function(bundle) {
        var pbContext = this.context.getChildContext({link: 'product_bundles'});
        var groupLayout = app.view.createLayout({
            context: pbContext,
            meta: this.quoteDataGroupMeta,
            type: 'quote-data-group',
            layout: this,
            module: 'ProductBundles',
            model: bundle
        });

        groupLayout.initComponents(undefined, pbContext, 'ProductBundles');
        this.addComponent(groupLayout);
    },

    /**
     * Handles the quotes:group:create event
     * Creates a new empty quote data group and renders the groups
     *
     * @private
     */
    _onCreateQuoteGroup: function() {
        var bundles = this.model.get('bundles');
        var nextPosition = 0;
        var highestPositionBundle = bundles.max(function(bundle) {
            return bundle.get('position');
        });
        var newBundle;

        this.bundlesBeingSavedCt++;
        // handle on the off chance that no bundles exist on the quote.
        if (!_.isEmpty(highestPositionBundle)) {
            nextPosition = parseInt(highestPositionBundle.get('position')) + this.bundlesBeingSavedCt;
        }

        if (this.isCreateView) {
            // do not perform saves on create view
            newBundle = this._createNewProductBundleBean(undefined, nextPosition, false);
            // set the _justSaved flag so the new bundle header starts in edit mode
            newBundle.set('_justSaved', true);
            // ignore preferred currency so that we keep the selected currency.
            newBundle.ignoreUserPrefCurrency = true;
            // add the new bundle which will add it to the layout and groupIds
            bundles.add(newBundle);
            // trigger that the group create was successful and pass the new group data
            this.context.trigger('quotes:group:create:success', newBundle);
        } else {
            app.alert.show('adding_bundle_alert', {
                level: 'info',
                autoClose: false,
                messages: app.lang.get('LBL_ADDING_BUNDLE_ALERT_MSG', 'Quotes')
            });

            app.api.relationships('create', 'Quotes', {
                'id': this.model.get('id'),
                'link': 'product_bundles',
                'related': {
                    currency_id: this.model.get('currency_id'),
                    base_rate: this.model.get('base_rate'),
                    position: nextPosition
                }
            }, null, {
                success: _.bind(this._onCreateQuoteGroupSuccess, this)
            });
        }
    },

    /**
     * Success callback handler for when a quote group is created
     *
     * @param {Object} newBundleData The new Quote group data
     * @private
     */
    _onCreateQuoteGroupSuccess: function(newBundleData) {
        this.bundlesBeingSavedCt--;
        app.alert.dismiss('adding_bundle_alert');

        app.alert.show('added_bundle_alert', {
            level: 'success',
            autoClose: true,
            messages: app.lang.get('LBL_ADDED_BUNDLE_SUCCESS_MSG', 'Quotes')
        });

        var bundles = this.model.get('bundles');
        // make sure that the product_bundle_items array is there
        if (_.isUndefined(newBundleData.related_record.product_bundle_items)) {
            newBundleData.related_record.product_bundle_items = [];
        }
        newBundleData.related_record._justSaved = true;
        // now add the new record to the bundles collection
        bundles.add(newBundleData.related_record);

        if (this.model.get('show_line_nums')) {
            // if show_line_nums is true, trigger the event so the new group will add the line_num field
            this.context.trigger('quotes:show_line_nums:changed', true);
        }

        // trigger that the group create was successful and pass the new group data
        this.context.trigger('quotes:group:create:success', newBundleData);
    },

    /**
     * Called when line items have been selected and user has clicked Delete Selected.
     * It prepares the group lists and models to be deleted and adds GET requests
     * for each group after the deletes
     *
     * @param {Data.MixedBeanCollection} massCollection The mass_collection from the quote data list
     * @private
     */
    _onDeleteSelectedItems: function(massCollection) {
        var bulkRequests = [];
        var groupsToUpdate = [];
        var rowId;
        var groupId;
        var groupLayout;
        var url;

        _.each(massCollection.models, function(model) {
            if (model.link) {
                groupId = model.link.bean.id;
                rowId = model.get('id');

                // add the group ID to update the group later
                groupsToUpdate.push(groupId);

                // get the QuoteDataGroupLayout component
                groupLayout = this._getComponentByGroupId(groupId);

                // remove this row from the list's toggledModels if it exists
                delete groupLayout.quoteDataGroupList.toggledModels[rowId];

                url = app.api.buildURL(model.module + '/' + rowId);
                bulkRequests.push({
                    url: url.substr(4),
                    method: 'DELETE'
                });
            }
        }, this);

        // make sure the groups are only in here once
        groupsToUpdate = _.uniq(groupsToUpdate);

        _.each(groupsToUpdate, function(groupIdToUpdate) {
            url = app.api.buildURL('ProductBundles' + '/' + groupIdToUpdate);
            bulkRequests.push({
                url: url.substr(4),
                method: 'GET'
            });
        }, this);

        if (bulkRequests.length) {
            this.currentBulkSaveRequests = bulkRequests;
            this._callBulkRequests(_.bind(this._onDeleteSelectedItemsSuccess, this, massCollection));
        }
    },

    /**
     * Called on success after _onDeleteSelectedItems sets up models to be deleted. This function
     * removes deleted models from the MassCollection and the group's layout, and updates group
     * models with updated data.
     *
     * @param {Data.MixedBeanCollection} massCollection The mass_collection from the quote data list
     * @param {Array} bulkRequests The results from the BulkAPI calls
     * @private
     */
    _onDeleteSelectedItemsSuccess: function(massCollection, bulkRequests) {
        var model;
        var groupId;
        var groupLayout;
        var $checkAllCheckbox = this.$('.checkall input').first();

        if ($checkAllCheckbox.length) {
            // uncheck the CheckAll box after items are deleted
            $checkAllCheckbox.attr('checked', false);
        }

        app.alert.dismiss('deleting_line_item');
        app.alert.show('deleted_line_item', {
            level: 'success',
            autoClose: true,
            messages: [
                app.lang.get('LBL_DELETED_ITEMS_SUCCESS_MSG', this.module)
            ]
        });
        _.each(bulkRequests, function(request) {
            model = massCollection.get(request.contents.id);

            if (model) {
                // the request was for a model in the massCollection
                groupId = model.link.bean.id;
                // get the QuoteDataGroupLayout component
                groupLayout = this._getComponentByGroupId(groupId);
                // remove the model from the group layout
                groupLayout.collection.remove(model);
                // remove the model from the massCollection
                massCollection.remove(model);
            } else {
                // the request was to update a Bundle group
                groupId = request.contents.id;
                // get the QuoteDataGroupLayout component
                groupLayout = this._getComponentByGroupId(groupId);
                // update the group's model with the latest contents data
                this._updateModelWithRecord(groupLayout.model, request.contents);
                // trigger the line nums to be recalculated
                groupLayout.trigger('quotes:line_nums:reset', groupLayout.groupId, groupLayout.collection);
            }
        }, this);
    },

    /**
     * Deletes the passed in ProductBundle
     *
     * @param {ProductBundlesQuoteDataGroupLayout} groupToDelete The group layout to delete
     * @private
     */
    _onDeleteQuoteGroup: function(groupToDelete) {
        var groupId = groupToDelete.model.id;
        var groupName = groupToDelete.model.get('name') || '';

        app.alert.show('confirm_delete_bundle', {
            level: 'confirmation',
            autoClose: false,
            messages: app.lang.get('LBL_DELETING_BUNDLE_CONFIRM_MSG', 'Quotes', {
                groupName: groupName
            }),
            onConfirm: _.bind(this._onDeleteQuoteGroupConfirm, this, groupId, groupName, groupToDelete)
        });
    },

    /**
     * Handler for when the delete quote group confirm box is confirmed
     *
     * @param {string} groupId The model ID of the deleted group
     * @param {string} groupName The model name of the deleted group
     * @param {View.Layout} groupToDelete The Layout for the deleted group
     * @private
     */
    _onDeleteQuoteGroupConfirm: function(groupId, groupName, groupToDelete) {
        var defaultGroup = this._getComponentByGroupId(this.defaultGroupId);
        var bulkRequests = [];
        var bundleItems;
        var positionStart;
        var linkName;
        var url;

        app.alert.show('deleting_bundle_alert', {
            level: 'info',
            autoClose: false,
            messages: app.lang.get('LBL_DELETING_BUNDLE_ALERT_MSG', 'Quotes', {
                groupName: groupName
            })
        });

        if (this.isCreateView) {
            this._removeGroupFromLayout(groupId, groupToDelete);
        } else {
            if (groupToDelete.model && groupToDelete.model.has('product_bundle_items')) {
                bundleItems = groupToDelete.model.get('product_bundle_items');
            }

            // remove any unsaved models
            _.each(bundleItems.models, _.bind(function(bundleItems, groupToDelete, model, key, list) {
                // in _.each, if list is an object, model becomes undefined and list becomes
                // an array with the last model
                model = model || list[0];
                if (model.isNew()) {
                    delete groupToDelete.quoteDataGroupList.toggledModels[model.cid];
                    bundleItems.remove(model);
                }
            }, this, bundleItems, groupToDelete), this);

            if (defaultGroup.model && defaultGroup.model.has('product_bundle_items')) {
                positionStart = defaultGroup.model.get('product_bundle_items').length;
            }

            if (bundleItems && bundleItems.length > 0) {
                _.each(bundleItems.models, _.bind(function(groupId, bulkRequests, posStart, model, index, list) {
                    linkName = (model.module === 'Products' ? 'products' : 'product_bundle_notes');
                    url = app.api.buildURL('ProductBundles/' + groupId + '/link/' +
                        linkName + '/' + model.id);

                    posStart += index;
                    model.set('position', posStart);

                    bulkRequests.push({
                        url: url.substr(4),
                        method: 'POST',
                        data: {
                            id: groupId,
                            link: linkName,
                            relatedId: model.id,
                            related: {
                                position: posStart
                            }
                        }
                    });
                }, this, defaultGroup.model.id, bulkRequests, positionStart));
            }

            url = app.api.buildURL('ProductBundles/' + groupId);

            bulkRequests.push({
                url: url.substr(4),
                method: 'DELETE'
            });

            this.currentBulkSaveRequests = bulkRequests;
            if (defaultGroup.model.isNew()) {
                this._saveDefaultGroupThenCallBulk(groupToDelete, defaultGroup, bulkRequests);
            } else {
                this._callBulkRequests(_.bind(this._onSaveUpdatedGroupSuccess, this, groupToDelete, defaultGroup));
            }
        }
    },

    /**
     * Removes a group from the layout
     *
     * @param {string} groupId The model ID of the deleted group
     * @param {View.Layout} groupToDelete The Layout for the deleted group
     * @private
     */
    _removeGroupFromLayout: function(groupId, groupToDelete) {
        app.alert.dismiss('deleting_bundle_alert');

        var bundles = this.model.get('bundles');
        bundles.remove(groupToDelete.model);

        this.groupIds = _.without(this.groupIds, groupId);

        // dispose the group
        groupToDelete.dispose();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.beforeRender();
        if (app.controller && app.controller.context) {
            var viewDetails = this.closestComponent('record') ?
                this.closestComponent('record') :
                this.closestComponent('create');
            if (!_.isUndefined(viewDetails)) {
                app.controller.context.off(viewDetails.cid + ':productCatalogDashlet:add', null, this);
            }
        }
        this._super('_dispose');
    }
}) },
"config-drawer-content": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Quotes.ConfigDrawerContentLayout
 * @alias SUGAR.App.view.layouts.BaseQuotesConfigDrawerContentLayout
 * @extends View.Layouts.Base.ConfigDrawerContentLayout
 */
({
	// Config-drawer-content Layout (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'BaseConfigDrawerContentLayout',

    /**
     * @inheritdoc
     */
    _switchHowToData: function(helpId) {
        switch (helpId) {
            case 'config-columns':
            case 'config-summary':
            case 'config-footer':
                this.currentHowToData.title = app.lang.get('LBL_CONFIG_FIELD_SELECTOR', this.module, {
                    moduleName: app.lang.get('LBL_MODULE_NAME', this.module)
                });
                this.currentHowToData.text = '';
                break;
        }
    }
}) }
}}
,
"datas": {}

},
		"Products":{"fieldTemplates": {
"base": {
"quote-data-editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Products.EditablelistbuttonField
 * @alias SUGAR.App.view.fields.BaseProductsEditablelistbuttonField
 * @extends View.Fields.Base.BaseEditablelistbuttonField
 */
({
	// Quote-data-editablelistbutton FieldTemplate (base) 

    extendsFrom: 'BaseEditablelistbuttonField',

    /**
     * Overriding EditablelistbuttonField's Events with mousedown instead of click
     */
    events: {
        'mousedown [name=inline-save]': 'saveClicked',
        'mousedown [name=inline-cancel]': 'cancelClicked'
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (_.isUndefined(this.changed) && this.model.isNew()) {
            // when adding additional items to the list, causing additional renders,
            // this.changed gets set undefined on re-initialize, so we need to make sure
            // if this is an unsaved model and this.changed is undefined, that we set changed true
            this.changed = true;
        }

        if (this.tplName === 'edit') {
            this.$el.closest('.left-column-save-cancel').addClass('higher');
        } else {
            this.$el.closest('.left-column-save-cancel').removeClass('higher');
        }
    },

    /**
     * Overriding and not calling parent _loadTemplate as those are based off view/actions and we
     * specifically need it based off the modelView set by the parent layout for this row model
     *
     * @inheritdoc
     */
    _loadTemplate: function() {
        this.tplName = this.model.modelView || 'list';

        if (this.view.action === 'list' && _.indexOf(['edit', 'disabled'], this.action) < 0) {
            this.template = app.template.empty;
        } else {
            this.template = app.template.getField(this.type, this.tplName, this.module);
        }
    },

    /**
     * @inheritdoc
     */
    cancelEdit: function() {
        if (this.isDisabled()) {
            this.setDisabled(false);
        }
        this.changed = false;
        this.model.revertAttributes();
        this.view.clearValidationErrors();

        // this is the only line I had to change
        this.view.toggleRow(this.model.module, this.model.cid, false);

        // trigger a cancel event across the view layout so listening components
        // know the changes made in this row are being reverted
        if (this.view.layout) {
            this.view.layout.trigger('editablelist:' + this.view.name + ':cancel', this.model);
        }
    },

    /**
     * @inheritdoc
     */
    saveClicked: function(evt) {
        // If name exists but product_template_name is empty,
        // copy name to product_template_name so the field validates
        if (!_.isEmpty(this.model.get('name')) && _.isEmpty(this.model.get('product_template_name'))) {
            this.model.set('product_template_name', this.model.get('name'), {silent: true});
        }

        this._super('saveClicked', [evt]);
    },

    /**
     * Called after the save button is clicked and all the fields have been validated,
     * triggers an event for
     *
     * @inheritdoc
     */
    _save: function() {
        this.view.layout.trigger('editablelist:' + this.view.name + ':saving', true, this.model.cid);

        if (this.view.model.isNew()) {
            this.view.context.parent.trigger('quotes:defaultGroup:save', _.bind(this._saveRowModel, this));
        } else {
            this._saveRowModel();
        }
    },

    /**
     * Saves the row's model
     *
     * @private
     */
    _saveRowModel: function() {
        var self = this;
        var oldModelId = this.model.id || this.model.cid;

        var successCallback = function(model) {
            self.changed = false;
            self.model.modelView = 'list';
            if (self.view.layout) {
                self.view.layout.trigger('editablelist:' + self.view.name + ':save', self.model, oldModelId);
                // trigger event for QuotesLineNumHelper plugin to re-number the lines
                self.view.layout.trigger('quotes:line_nums:reset');
            }

            if (model.collection._resavePositions) {
                delete model.collection._resavePositions;
                var bulkSaveRequests = [];
                var bulkUrl;
                var bulkRequest;
                var linkName;
                var itemModelId;
                var collectionId = model.link.bean.id;

                _.each(model.collection.models, function(mdl) {
                    itemModelId = mdl.id;
                    linkName = mdl.module === 'Products' ? 'products' : 'product_bundle_notes';
                    bulkUrl = app.api.buildURL('ProductBundles/' + collectionId + '/link/' +
                        linkName + '/' + itemModelId);
                    bulkRequest = {
                        url: bulkUrl.substr(4),
                        method: 'PUT',
                        data: {
                            position: mdl.get('position')
                        }
                    };

                    bulkSaveRequests.push(bulkRequest);
                }, this);

                app.api.call('create', app.api.buildURL(null, 'bulk'), {
                    requests: bulkSaveRequests
                });
            }
        };
        var options = {
            success: successCallback,
            error: function(error) {
                if (error.status === 409) {
                    app.utils.resolve409Conflict(error, self.model, function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                successCallback(model);
                            } else {
                                self._save();
                            }
                        }
                    });
                }
            },
            complete: function() {
                // remove this model from the list if it has been unlinked
                if (self.model.get('_unlinked')) {
                    self.collection.remove(self.model, {silent: true});
                    self.collection.trigger('reset');
                    self.view.render();
                } else {
                    self.setDisabled(false);
                }
            },
            lastModified: self.model.get('date_modified'),
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: app.lang.get('LBL_RECORD_SAVED', self.module)
                }
            },
            relate: this.model.link ? true : false
        };

        options = _.extend({}, options, this.getCustomSaveOptions(options));
        this.model.save({}, options);
    },

    /**
     * @inheritdoc
     */
    _validationComplete: function(isValid) {
        if (!isValid) {
            this.setDisabled(false);
            return;
        }
        // also need to make sure the model.changed is empty as well
        if (!this.changed && !this.model.changed) {
            this.cancelEdit();
            return;
        }

        this._save();
    }
}) },
"discount-select": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Products.DiscountSelectField
 * @alias SUGAR.App.view.fields.BaseProductsDiscountSelectField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Discount-select FieldTemplate (base) 

    extendsFrom: 'BaseActiondropdownField',

    /**
     * The current currency object
     */
    currentCurrency: undefined,

    /**
     * The current symbol to use in place of the caret dropdown icon
     */
    currentDropdownSymbol: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.events = _.extend({}, this.events, {
            'shown.bs.dropdown': 'toggleDropdown',
            'hidden.bs.dropdown': 'toggleDropdown'
        });
        this.updateCurrencyStrings();
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        this.context.on('button:discount_select_change:click', this.onDiscountChanged, this);
        this.context.on('record:cancel:clicked', this.onRecordCancel, this);

        this.model.on('change:currency_id', this.updateCurrencyStrings, this);
    },

    /**
     * Handles setting the field back to synced values when the record is canceled
     */
    onRecordCancel: function() {
        var changedAttributes = this.model.changedAttributes(this.model.getSynced());
        this.model.set(changedAttributes, {
            revert: true
        });

        this.updateDropdownSymbol();
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var $dropdown;

        this._super('_render');

        $dropdown = this.$('.fa');
        $dropdown.removeClass(this.caretIcon);
        $dropdown.text(this.currentDropdownSymbol);
    },

    /**
     * Called when a user clicks the Amount or Percent dropdown buttons
     *
     * @param {Data.Bean} model The model of the row that was changed
     * @param {View.Field} field The field that triggered the event
     * @param {Event} evt The click event
     */
    onDiscountChanged: function(model, field, evt) {
        var isPercent = false;
        if (this.model === model) {
            // only update for the row the event was triggered in
            if (field.name === 'select_discount_percent_button') {
                isPercent = true;
            }
            this.model.set(this.name, isPercent);

            this.view.context.trigger('editable:record:toggleEdit');

            this.updateDropdownSymbol();
        }
    },

    /**
     * Updates the dropdown icon symbol
     */
    updateDropdownSymbol: function() {
        var val = this.model.get(this.name);

        if (_.isUndefined(val) || val === false) {
            this.currentDropdownSymbol = this.currentCurrency.symbol;
        } else {
            this.currentDropdownSymbol = '%';
        }

        this.render();
    },

    /**
     * Gets the current row model's currency_id and updates the labels for the buttons
     */
    updateCurrencyStrings: function() {
        var btn;
        var currentCurrencyLabel;

        if (this.model.has('currency_id')) {
            this.currentCurrency = app.metadata.getCurrency(this.model.get('currency_id'));
            currentCurrencyLabel = this.currentCurrency.symbol + ' ' + this.currentCurrency.name;

            if (app.lang.direction !== 'ltr') {
                currentCurrencyLabel = this.currentCurrency.name + ' ' + this.currentCurrency.symbol;
            }

            btn = _.find(this.def.buttons, function(button) {
                return button.name === 'select_discount_amount_button';
            });

            // update the button field def label to the current row currency
            btn.label = currentCurrencyLabel;

            btn = _.find(this.dropdownFields, function(button) {
                return button.name === 'select_discount_amount_button';
            });

            if (btn) {
                // if the button has already been rendered into dropdownFields
                // update the actual button field label, not just the defs
                btn.label = currentCurrencyLabel;
            }

            // make sure the dropdown symbol is updated
            this.updateDropdownSymbol();
        }
    },

    /**
     * Sets a button accessibility class 'aria-expanded' to true or false
     * depending on if the dropdown menu is open or closed.
     *
     * @private
     */
    toggleDropdown: function(evt) {
        var state = evt.type ? evt.type !== 'hidden' : this.$el.hasClass('open');
        var flexView = this.closestComponent('quote-data-list-groups');
        var $fieldSet = this.$el.parents('.quote-discount-percent');
        var $tableCell = $fieldSet.parent();
        var scrollOffset = $fieldSet.offset().left;
        var scrollWidth = $tableCell.width();

        // on record view flexView doesn't exist
        if (flexView) {
            flexView.trigger('list:scrollLock', state);
        }
        $fieldSet.css('left', state ? scrollOffset : 'auto');
        $fieldSet.css('width', state ? scrollWidth : '100%');

        this._toggleAria();
    }
}) },
"discount": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Products.DiscountField
 * @alias SUGAR.App.view.fields.BaseProductsDiscountField
 * @extends View.Fields.Base.Products.CurrencyField
 */
({
	// Discount FieldTemplate (base) 

    extendsFrom: 'ProductsCurrencyField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var validationTaskName = 'isNumeric_validator_' + this.cid;

        // removing the validation task if it exists already for this field
        this.model.removeValidationTask(validationTaskName);
        this.model.addValidationTask(validationTaskName, _.bind(this._validateAsNumber, this));
    },

    /**
     * Overriding to add the custom validation handler to the dom change event
     *
     * @inheritdoc
     */
    bindDomChange: function() {
        if (!(this.model instanceof Backbone.Model)) {
            return;
        }

        var $el = this.$(this.fieldTag);
        if ($el.length) {
            $el.on('change', _.bind(function(evt) {
                var val = evt.currentTarget.value;

                this.clearErrorDecoration();
                this.model.set(this.name, this.unformat(val));
                this.model.doValidate(this.name, _.bind(this._validationComplete, this));
            }, this));
        }
    },

    /**
     * Callback for after validation runs.
     * @param {bool} isValid flag determining if the validation is correct
     * @private
     */
    _validationComplete: function(isValid) {
        if (isValid) {
            app.alert.dismiss('invalid-data');
        }
    },

    /**
     * @inheritdoc
     *
     * Listen for the discount_select field to change, when it does, re-render the field
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        // if discount select changes, we need to re-render this field
        this.model.on('change:discount_select', this.render, this);
    },

    /**
     * @inheritdoc
     *
     * Special handling of the templates, if we are displaying it as a percent, then use the _super call,
     * otherwise get the templates from the currency field.
     */
    _loadTemplate: function() {
        if (this.model.get('discount_select') == true) {
            this._super('_loadTemplate');
        } else {
            this.template = app.template.getField('currency', this.action || this.view.action, this.module) ||
                app.template.empty;
            this.tplName = this.action || this.view.action;
        }
    },

    /**
     * @inheritdoc
     *
     * Special handling for the format, if we are in a percent, use the decimal field to handle the percent, otherwise
     * use the format according to the currency field
     */
    format: function(value) {
        if (this.model.get('discount_select') == true) {
            return app.utils.formatNumberLocale(value);
        } else {
            //In edit mode hide the currency dropdown for the discount field
            this.hideCurrencyDropdown = this.tplName === 'edit' ? true : false;
            return this._super('format', [value]);
        }
    },

    /**
     * @inheritdoc
     *
     * Special handling for the unformat, if we are in a percent, use the decimal field to handle the percent,
     * otherwise use the format according to the currency field
     */
    unformat: function(value) {
        if (this.model.get('discount_select') == true) {
            var unformattedValue = app.utils.unformatNumberStringLocale(value, true);
            // if unformat failed, return original value
            return _.isFinite(unformattedValue) ? unformattedValue : value;
        } else {
            return this._super('unformat', [value]);
        }
    },

    /**
     * Validate the discount field as a number - do not allow letters
     *
     * @param {Object} fields The list of field names and their definitions.
     * @param {Object} errors The list of field names and their errors.
     * @param {Function} callback Async.js waterfall callback.
     * @private
     */
     _validateAsNumber: function(fields, errors, callback) {
        var value = this.model.get(this.name);

        if (!_.isFinite(value)) {
            errors[this.name] = {'number': value};
        }

        callback(null, fields, errors);
    },

    /**
     * Extending to remove the custom validation task for this field
     *
     * @inheritdoc
     * @private
     */
    _dispose: function() {
        var validationTaskName = 'isNumeric_validator_' + this.cid;
        this.model.removeValidationTask(validationTaskName);

        this._super('_dispose');
    }
}) },
"textarea": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Products.TextareaField
 * @alias SUGAR.App.view.fields.BaseProductsTextareaField
 * @extends View.Fields.Base.BaseTextareaField
 */
({
	// Textarea FieldTemplate (base) 

    extendsFrom: 'BaseTextareaField',
    /**
     * Making the textarea editable for the Quotes Line items
     * @inheritdoc
     */
    setMode: function(name) {
        if (this.view.name === 'quote-data-group-list' && this.tplName === 'list') {
            app.view.Field.prototype.setMode.call(this, name);
        } else {
            this._super('setMode', [name]);
        }
    }
}) },
"quote-data-actionmenu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Products.QuoteDataActionmenuField
 * @alias SUGAR.App.view.fields.BaseProductsQuoteDataActionmenuField
 * @extends View.Fields.Base.ActionmenuField
 */
({
	// Quote-data-actionmenu FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'BaseActionmenuField',

    /**
     * Skipping ActionmenuField's override, just returning this.def.buttons
     *
     * @inheritdoc
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.buttons);
    },

    /**
     * Triggers massCollection events to the context.parent
     *
     * @inheritdoc
     */
    toggleSelect: function(checked) {
        var event = !!checked ? 'mass_collection:add' : 'mass_collection:remove';
        this.model.selected = !!checked;
        this.context.parent.trigger(event, this.model);
    }
}) },
"image": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Image FieldTemplate (base) 

    extendsFrom: 'BaseImageField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // if this image exists in the Quotes QLI quote data section, force it
        // to use a detail template and don't allow the image field to be editable
        if (this.view.module === 'ProductBundles') {
            this.action = 'detail';
            this.options.viewName = 'detail';
            this.def.width = 16;
            this.def.height = 16;
        }
    }
}) },
"currency": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Products.CurrencyField
 * @alias SUGAR.App.view.fields.BaseProductsCurrencyField
 * @extends View.Fields.Base.CurrencyField
 */
({
	// Currency FieldTemplate (base) 

    extendsFrom: 'BaseCurrencyField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // Enabling currency dropdown on Qli ist views
        this.hideCurrencyDropdown = false;
    },

    /**
     * @inheritdoc
     */
    format: function(value) {
        // Skipping the core currencyField call
        // app.view.Field.prototype.format.call(this, value);
        this._super('format', [value]);

        //Check if in 'Edit' mode
        if (this.tplName === 'edit') {
            //Display just currency value without currency symbol when entering edit mode for the first time
            //We want the correct value in input field corresponding to the currency in the dropdown
            //Example: Dropdown has Euro then display '100.00' instead of '$111.11'
            return app.utils.formatNumberLocale(value);
        }

        var transactionalCurrencyId = this.model.get(this.def.currency_field || 'currency_id');
        var convertedCurrencyId = transactionalCurrencyId;
        var origTransactionValue = value;

        // convert value to Quote preferred currency
        var context = this.context.parent || this.context;
        var quotePreferredCurrencyId = context.get('model').get('currency_id');
        if (quotePreferredCurrencyId !== transactionalCurrencyId) {
            convertedCurrencyId = quotePreferredCurrencyId;

            this.transactionValue = app.currency.formatAmountLocale(
                this.model.get(this.name) || 0,
                transactionalCurrencyId
            );

            value = app.currency.convertWithRate(
                value,
                this.model.get('base_rate'),
                app.metadata.getCurrency(quotePreferredCurrencyId).conversion_rate
            );
        } else {
            // user preferred same as transactional, no conversion required
            this.transactionValue = '';
            convertedCurrencyId = transactionalCurrencyId;
            value = origTransactionValue;
        }
        return app.currency.formatAmountLocale(value, convertedCurrencyId);
    },


    /**
     * @inheritdoc
     */
    updateModelWithValue: function(model, currencyId, val) {
        // Convert the discount amount value only if it is not in %
        // Other values will be converted as usual
        if (val && !(this.name === 'discount_amount' && this.model.get('discount_select'))) {
            this._super('updateModelWithValue',[model, currencyId, val]);
        }
    }
}) },
"line-num": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Products.LineNumField
 * @alias SUGAR.App.view.fields.BaseProductsLineNumField
 * @extends View.Fields.Base.IntField
 */
({
	// Line-num FieldTemplate (base) 

    extendsFrom: 'IntField'
}) },
"quote-data-relate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Products.QuoteDataRelateField
 * @alias SUGAR.App.view.fields.BaseProductsQuoteDataRelateField
 * @extends View.Fields.Base.BaseRelateField
 */
({
	// Quote-data-relate FieldTemplate (base) 

    extendsFrom: 'BaseRelateField',

    /**
     * The temporary "(New QLI}" string to add if users type in their own product name
     * @type {string}
     */
    createNewLabel: undefined,

    /**
     * The temporary ID to user for newly created QLI names
     * @type {string}
     */
    newQLIId: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.createNewLabel = app.lang.get('LBL_CREATE_NEW_QLI_IN_DROPDOWN', 'Products');
        this.newQLIId = 'newQLIId';

        this._super('initialize', [options]);
    },

    /**
     * Overriding because getSearchModule needs to return Products for this metadata
     *
     * @inheritdoc
     */
    _getPopulateMetadata: function() {
        return app.metadata.getModule('Products');
    },

    /**
     * Overridden select2 change handler for the custom case of being able to add new unlinked Products
     * @param evt
     * @private
     */
    _onSelect2Change: function(evt) {
        var $select2 = $(evt.target).data('select2');
        var id = evt.val;
        var value = id ? $select2.selection.find('span').text() : $(evt.target).data('rname');
        var collection = $select2.context;
        var model;
        var attributes = {
            id: '',
            value: ''
        };

        if (value && value.indexOf(this.createNewLabel)) {
            // if value had new QLI label, remove it
            value = value.replace(this.createNewLabel, '');
        }

        value = value ? value.trim() : value;

        // default to given id/value or empty strings, cleans up logic significantly
        attributes.id = id || '';
        attributes.value = value || '';

        if (collection && id) {
            // if we have search results use that to set new values
            model = collection.get(id);
            if (model) {
                attributes.id = model.id;
                attributes.value = model.get('name');
                _.each(model.attributes, function(value, field) {
                    if (app.acl.hasAccessToModel('view', model, field)) {
                        attributes[field] = attributes[field] || model.get(field);
                    }
                });
            }
        } else if (evt.currentTarget.value && value) {
            // if we have previous values keep them
            attributes.id = value;
            attributes.value = evt.currentTarget.value;
        }

        // set the attribute values
        this.setValue(attributes);

        if (id === this.newQLIId) {
            // if this is a new QLI
            this.model.set({
                product_template_id: '',
                product_template_name: value,
                name: value
            });
            // update the select2 label
            this.$(this.fieldTag).select2('val', value);
        }

        return;
    },

    /**
     * Extending to add the custom createSearchChoice option
     *
     * @inheritdoc
     */
    _getSelect2Options: function() {
        return _.extend(this._super('_getSelect2Options'), {
            createSearchChoice: _.bind(this._createSearchChoice, this)
        });
    },

    /**
     * Extending to also check models' product_template_name/name and product_template_id/id
     *
     * @inheritdoc
     */
    format: function(value) {
        var idList;
        value = value || this.model.get(this.name) || this.model.get('name');

        this._super('format', [value]);

        // If value is not set (new row item) then the select2 will show the ID and we dont want that
        if (value) {
            idList = this.model.get(this.def.id_name) || this.model.get('id');
            if (_.isArray(value)) {
                this.formattedIds = idList.join(this._separator);
            } else {
                this.formattedIds = idList;
            }

            if (_.isEmpty(this.formattedIds)) {
                this.formattedIds = value;
            }
        }

        return value;
    },

    /**
     * Overriding if there's no product_template_id or name, use the Products module and record ID
     *
     * @inheritdoc
     */
    _buildRoute: function() {
        this.buildRoute(this.model.module, this.model.get('id'));
    },

    /**
     * Overriding as should default to the model's ID then if empty go to the link id
     *
     * @inheritdoc
     */
    _getRelateId: function() {
        return this.model.get(this.def.id_name) || this.model.get('id') ;
    },

    /**
     * Add a new search choice for the user's text
     *
     * @param {string} term The text the user is searching for
     * @return {{id: (*|string), text: *}}
     * @private
     */
    _createSearchChoice: function(term) {
        return {
            id: this.newQLIId,
            text: term + this.createNewLabel
        };
    }
}) }
}}
,
"views": {
"base": {
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Products.RecordView
 * @alias SUGAR.App.view.views.BaseProductsRecordView
 * @extends View.Views.Base.RecordView
 */
({
	// Record View (base) 

    extendsFrom: 'BaseRecordView',

    /**
     * @inheritdoc
     */
    delegateButtonEvents: function() {
        this.context.on('button:convert_to_quote:click', this.convertToQuote, this);
        this.context.on('editable:record:toggleEdit', this._toggleRecordEdit, this);

        this._super('delegateButtonEvents');
    },

    /**
     * @inheritdoc
     */
    _toggleRecordEdit: function() {
        this.setButtonStates(this.STATE.EDIT);
    },

    /**
     * @inheritdoc
     */
    cancelClicked: function() {
        this.context.trigger('record:cancel:clicked');
        this._super('cancelClicked');
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"WebLogicHooks":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"ProductCategories":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"ProductTypes":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"ProductTemplates":{"fieldTemplates": {
"base": {
"pricing-formula": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Field that computes the logic for the pricing factor field
 *
 * @class View.Fields.Base.ProductTemplates.PricingFormulaField
 * @alias SUGAR.App.view.fields.BaseProductTemplatesPricingFormulaField
 * @extends View.Fields.Base.EnumField
 */
({
	// Pricing-formula FieldTemplate (base) 

    /**
     * Where the core logic is at
     */
    extendsFrom: 'EnumField',

    /**
     * Should we show the factor field on the front end
     */
    showFactorField: false,

    /**
     * Valid formulas that we should show the factor field for.
     */
    validFactorFieldFormulas: [
        'ProfitMargin',
        'PercentageMarkup',
        'PercentageDiscount'
    ],

    /**
     * Label for the factor field
     */
    factorFieldLabel: '',

    /**
     * Value of the factor field
     */
    factorValue: 0,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.before('render', function() {
            this.showFactorField = this.checkShouldShowFactorField();
            this.factorFieldLabel = this.getFactorFieldLabel();
            this.disableDiscountField();
            this.factorValue = this.model.get('pricing_factor');
        }, this);

        this.listenTo(this, 'render', function() {
            // only setup the formulas when the action is edit
            if (this.action == 'edit') {
                    if (this.showFactorField) {
                    // put the cursor int he factor field once this is rendered
                    this.$el.find('.pricing-factor').focus();
                }
                this.setupPricingFormula();
            }
        });
    },

    /**
     * Listen for this field to change it's value, and when it does, we should re-render the field as it could have
     * the pricing_factor field visible
     */
    bindDataChange: function() {
        this.listenTo(this.model, 'change:' + this.name, function() {
            // when it's changed, we need to re-render just in case we need to show the factor field
            if (!this.disposed) {
                this.render();
            }
        });
    },

    /**
     * Override to remove default DOM change listener so we can listen for the pricing factor change if it's visible
     *
     * @inheritdoc
     */
    bindDomChange: function() {
        if (this.showFactorField) {
            var $el = this.$('.pricing-factor');
            $el.on('change', _.bind(function() {
                this.model.set('pricing_factor', $el.val());
            }, this));
        }

        // call the super just in case something ever gets put there
        this._super('bindDomChange');
    },

    /**
     * Override so we can stop listening to the pricing factor field if it's visible
     *
     * @inheritdoc
     */
    unbindDom: function() {
        if (this.showFactorField) {
            this.$('.pricing-factor').off();
        }

        // call the super
        this._super('unbindDom');
    },

    /**
     * Utility Method to check if we should show the factor field or not
     * @return {*|boolean}
     */
    checkShouldShowFactorField: function() {
        return (this.model.has(this.name) && _.contains(this.validFactorFieldFormulas, this.model.get(this.name)));
    },

    /**
     * Get the correct label for the field type
     */
    getFactorFieldLabel: function() {
        if (this.model.has(this.name)) {
            switch (this.model.get(this.name)) {
                case 'ProfitMargin':
                    return (this.action === 'edit' && this.view.action === 'list') ? 'LBL_POINTS_ABBR' : 'LBL_POINTS';
                case 'PercentageMarkup':
                case 'PercentageDiscount':
                    return (this.action === 'edit' && this.view.action === 'list') ? '%' : 'LBL_PERCENTAGE';
            }
        }

        return '';
    },

    /**
     * Figure out which formula to setup based off the value from the model.
     */
    setupPricingFormula: function() {
        if (this.model.has(this.name)) {
            switch (this.model.get(this.name)) {
                case 'ProfitMargin':
                    this._setupProfitMarginFormula();
                    break;
                case 'PercentageMarkup':
                    this._setupPercentageMarkupFormula();
                    break;
                case 'PercentageDiscount':
                    this._setupPercentageDiscountFormula();
                    break;
                case 'IsList':
                    this._setupIsListFormula();
                    break;
                default:
                    var oldPrice = this.model.get('discount_price');
                    if (_.isUndefined(oldPrice) || _.isNaN(oldPrice)) {
                        this.model.set('discount_price', '');
                    }
                    break;
            }
        }
    },

    /**
     * Profit Margin Formula
     *
     * ($cost_price * 100)/(100 - $points)
     *
     * @private
     */
    _setupProfitMarginFormula: function() {
        var formula = function(cost_price, points) {
            return app.math.div(app.math.mul(cost_price, 100), app.math.sub(100, points));
        };

        this._costPriceFormula(formula);
    },

    /**
     * Percent Markup
     *
     * $cost_price * (1 + ($percentage/100))
     *
     * @private
     */
    _setupPercentageMarkupFormula: function() {
        var formula = function(cost_price, percentage) {
            return app.math.mul(cost_price, app.math.add(1, app.math.div(percentage, 100)));
        };

        this._costPriceFormula(formula);
    },

    /**
     * Percent Discount from List Price
     *
     * $list_price - ($list_price * ($percentage/100))
     *
     * @private
     */
    _setupPercentageDiscountFormula: function() {
        var formula = function(list_price, percentage) {
            return app.math.sub(list_price, app.math.mul(list_price, app.math.div(percentage, 100)));
        };

        this._costPriceFormula(formula, 'list_price');
    },

    /**
     * Utility Method to handle multiple formulas using the same listener for cost_price, just pass in a function
     * that handles the formula and accepts two params, cost_price and the pricing factor.
     * @param {Function} formula
     * @param {String} [field]      What field to use in the listenTo, if undefined, it will default to cost_price
     * @private
     */
    _costPriceFormula: function(formula, field) {
        field = field || 'cost_price'
        this.listenTo(this.model, 'change:' + field, function(model, price) {
            model.set('discount_price', formula(price, model.get('pricing_factor')));
        });

        this.listenTo(this.model, 'change:pricing_factor', function(model, pricing_factor) {
            model.set('discount_price', formula(model.get(field), pricing_factor));
        });

        // run this now just to make sure if default values are already set
        this.model.set('discount_price', formula(this.model.get(field), this.model.get('pricing_factor')));
    },

    /**
     * Code to handle when the pricing formula is IsList where discount_price is the same as list_price
     *
     * @private
     */
    _setupIsListFormula: function() {
        this.listenTo(this.model, 'change:list_price', function(model, value) {
            model.set('discount_price', value);
        });

        this.model.set('discount_price', this.model.get('list_price'));
    },

    /**
     * Method to handle when the discount_price field should be disable or not.
     */
    disableDiscountField: function() {
        if (this.model.has(this.name)) {
            var field = this.view.getField('discount_price');
            if (field) {
                switch (this.model.get(this.name)) {
                    case 'ProfitMargin':
                    case 'PercentageMarkup':
                    case 'PercentageDiscount':
                    case 'IsList':
                        field.setDisabled(true);
                        break;
                    default:
                        field.setDisabled(false);
                        break;
                }
            }
        }
    }
}) }
}}
,
"views": {
"base": {
"product-catalog-dashlet-drawer-record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Product-catalog-dashlet-drawer-record View (base) 

    extendsFrom: 'BaseRecordView',

    /**
     * If this is initialized inside a create view
     */
    isCreateView: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var i;
        var j;
        var panel;
        var field;
        var moduleName;
        var addBtn = _.find(options.meta.buttons, function(btn) {
            return btn.name === 'add_to_quote_button';
        });
        var removeAddBtn = false;
        var userACLs;
        var oppsConfig;
        var secondaryModule;
        var showOnModules = _.keys(addBtn.showOnModules);
        var showOnViews;
        var layoutName;
        var routerFrags;

        // need to use router because if we're on Home or another module and use the megamenu
        // to create an Opp or Quote, it shows the previous module we're in, not the current.
        routerFrags = app.router.getFragment().split('/');
        moduleName = routerFrags[0];

        this.isCreateView = routerFrags[1] === 'create';

        // check to see if there's an add button and if this module is not in the list
        // to show the add button
        if (addBtn) {
            // only the list 'records' layout is empty
            layoutName = routerFrags[1] || 'records';
            showOnViews = addBtn.showOnModules[moduleName];

            if (!_.contains(showOnModules, moduleName)) {
                // if this module is not in the list of metadata 'showOnModules' array, remove it
                removeAddBtn = true;
            }

            if (!removeAddBtn) {
                if (!_.contains(showOnViews, layoutName)) {
                    // if this view is not in the list of metadata 'showOnModules' views doublecheck
                    // if layoutName is 36 characters long and we show on record then allow the add button,
                    // otherwise remove it
                    if (!(layoutName.length === 36 && _.contains(showOnViews, 'record'))) {
                        // if this layoutName is an actual record ID hash
                        removeAddBtn = true;
                    }
                }
            }

            if (!removeAddBtn) {
                // we need to check other conditions to remove the add button
                oppsConfig = app.metadata.getModule('Opportunities', 'config');
                userACLs = app.user.getAcls();

                if (moduleName === 'Opportunities') {
                    if (oppsConfig.opps_view_by === 'RevenueLineItems') {
                        // if Opps+RLI mode, check ACLs on RLIs not Opps
                        secondaryModule = 'RevenueLineItems';
                    } else {
                        // if in Opps only mode, remove the add button
                        removeAddBtn = true;
                    }
                } else if (moduleName === 'Quotes') {
                    secondaryModule = 'Products';
                }

                if (_.has(userACLs[moduleName], 'edit') ||
                    _.has(userACLs[secondaryModule], 'access') ||
                    _.has(userACLs[secondaryModule], 'edit')) {
                    // if the user doesn't have access to edit Opps or Quotes,
                    // or user doesn't have access or edit priveleges for RLIs/QLIs, remove the add button
                    removeAddBtn = true;
                }
            }

            if (removeAddBtn) {
                options.meta.buttons = _.without(options.meta.buttons, addBtn);
            }
        }
        options.name = 'record';

        for (i = 0; i < options.meta.panels.length; i++) {
            panel = options.meta.panels[i];
            for (j = 0; j < panel.fields.length; j++) {
                field = panel.fields[j];
                field.readonly = true;
            }
        }

        this._super('initialize', [options]);
    },

    /**
     * Overriding this function to just listen to the buttons on the record
     *
     * @inheritdoc
     */
    delegateButtonEvents: function() {
        this.context.on('button:cancel_button:click', this._drawerCancelClicked, this);
        this.context.on('button:add_to_quote_button:click', this._drawerAddToQuoteClicked, this);
    },

    /**
     * Handles when the Cancel button is clicked in the ProductCatalogDashlet drawer.
     * It just triggers the event that the tree should re-enable, and closes the drawer.
     *
     * @private
     */
    _drawerCancelClicked: function() {
        app.controller.context.trigger(this.model.viewId + ':productCatalogDashlet:add:complete');
        app.drawer.close();
    },

    /**
     * Handles when the Add To Quote button is clicked in the ProductCatalogDashlet drawer.
     * It strips out unnecessary ProductTemplate fields and sends the data to the context.
     *
     * @private
     */
    _drawerAddToQuoteClicked: function() {
        var data = this.model.toJSON();

        data.position = 0;
        data._forcePosition = true;

        // copy Template's id and name to where the QLI expects them
        data.product_template_id = data.id;
        data.product_template_name = data.name;

        // remove ID/etc since we dont want Template ID to be the record id
        delete data.id;
        delete data.date_entered;
        delete data.date_modified;
        delete data.my_favorite;

        // close this drawer first, then trigger event
        app.drawer.close();

        // need to trigger on app.controller.context because of contexts changing between
        // the PCDashlet, and Opps create being in a Drawer, or as its own standalone page
        // app.controller.context is the only consistent context to use
        if (this.isCreateView) {
            // immediately send event
            app.controller.context.trigger(this.model.viewId + ':productCatalogDashlet:add', data);
        } else {
            // any other view we need to wait for the drawer to close, then trigger the event
            _.delay(function(viewId) {
                app.controller.context.trigger(viewId + ':productCatalogDashlet:add', data);
            }, 750, this.model.viewId);
        }
    }
}) }
}}
,
"layouts": {
"base": {
"filterpanel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Filterpanel Layout (base) 

    extendsFrom: 'FilterpanelLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {

        this._super('initialize', [options]);

        if (this.context.get('layout') === 'record') {
            var hasSubpanels = false,
                layouts = app.metadata.getModule(options.module, 'layouts');
            if (layouts && layouts.subpanels && layouts.subpanels.meta) {
                hasSubpanels = (layouts.subpanels.meta.components.length > 0);
            }

            if (!hasSubpanels) {
                this.before('render', function() {
                    return false;
                }, this);

                this.template = app.template.empty;
                this.$el.html(this.template());
            }
        }
    }
}) }
}}
,
"datas": {}

},
		"ProductBundles":{"fieldTemplates": {
"base": {
"quote-data-actiondropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ProductBundles.QuoteDataActiondropdownField
 * @alias SUGAR.App.view.fields.BaseProductBundlesQuoteDataActiondropdownField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Quote-data-actiondropdown FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'BaseActiondropdownField',

    /**
     * @inheritdoc
     */
    className: 'quote-data-actiondropdown',

    /**
     * Skipping ActionmenuField's override, just returning this.def.buttons
     *
     * @inheritdoc
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.buttons);
    },

    /**
     * Overriding for quote-data-group-header in create view to display a specific template
     *
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if (this.view.name === 'quote-data-group-header' && this.view.isCreateView) {
            this.template = app.template.getField('quote-data-actiondropdown', 'list', this.model.module);
        }
    }
}) },
"quote-group-title": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ProductBundles.QuoteGroupTitleField
 * @alias SUGAR.App.view.fields.BaseProductBundlesQuoteGroupTitleField
 * @extends View.Fields.Base.Field
 */
({
	// Quote-group-title FieldTemplate (base) 

    /**
     * Any additional CSS classes that need to be applied to the field
     */
    css_class: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.css_class = options.def.css_class || '';
        this._super('initialize', [options]);
    }
}) },
"quote-data-editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ProductBundles.EditablelistbuttonField
 * @alias SUGAR.App.view.fields.BaseProductBundlesEditablelistbuttonField
 * @extends View.Fields.Base.BaseEditablelistbuttonField
 */
({
	// Quote-data-editablelistbutton FieldTemplate (base) 

    extendsFrom: 'BaseEditablelistbuttonField',

    /**
     * @inheritdoc
     */
    _render: function() {
        var syncedName;

        if (this.name === 'inline-save') {
            syncedName = this.model.getSynced('name');
            if (this.model.get('name') !== syncedName) {
                this.changed = true;
            }
        }

        this._super('_render');

        if (this.tplName === 'edit') {
            this.$el.closest('.left-column-save-cancel').addClass('higher');
        } else {
            this.$el.closest('.left-column-save-cancel').removeClass('higher');
        }
    },

    /**
     * Overriding and not calling parent _loadTemplate as those are based off view/actions and we
     * specifically need it based off the modelView set by the parent layout for this row model
     *
     * @inheritdoc
     */
    _loadTemplate: function() {
        this.tplName = this.model.modelView || 'list';

        if (this.view.action === 'list' && _.indexOf(['edit', 'disabled'], this.action) < 0) {
            this.template = app.template.empty;
        } else {
            this.template = app.template.getField(this.type, this.tplName, this.module);
        }
    },

    /**
     * Overriding cancelEdit so we can update the group name if this is coming from
     * the quote data group header
     *
     * @inheritdoc
     */
    cancelEdit: function() {
        var modelModule = this.model.module;
        var modelId = this.model.cid;
        var syncedAttribs = this.model.getSynced();
        if (this.isDisabled()) {
            this.setDisabled(false);
        }

        this.changed = false;

        if (this.view.name === 'quote-data-group-header') {
            // for cancel on group-header, revertAttributes doesn't reset the model
            if (this.model.get('name') !== syncedAttribs.name) {
                if (_.isUndefined(syncedAttribs.name)) {
                    // if name was undefined, unset name
                    this.model.unset('name');
                } else {
                    // if name was defined or '', set back to that
                    this.model.set('name', syncedAttribs.name);
                }
            }
        } else {
            this.model.revertAttributes();
        }

        this.view.clearValidationErrors();

        this.view.toggleRow(modelModule, modelId, false);

        // trigger a cancel event across the view layout so listening components
        // know the changes made in this row are being reverted
        if (this.view.layout) {
            this.view.layout.trigger('editablelist:' + this.view.name + ':cancel', this.model);
        }
    },

    /**
     * Overriding cancelClicked to trigger an event if this is a
     * create view or the group was just saved
     *
     * @inheritdoc
     */
    cancelClicked: function() {
        var syncedAttribs = this.model.getSynced();
        var itemsInGroup = this.model.get('product_bundle_items');

        if (itemsInGroup) {
            itemsInGroup = itemsInGroup.length;
        }

        if (this.view.isCreateView || (syncedAttribs._justSaved && itemsInGroup === 0)) {
            this.view.layout.trigger('editablelist:' + this.view.name + ':create:cancel', this.model);
        } else {
            this.cancelEdit();
        }
    },

    /**
     * Called after the save button is clicked and all the fields have been validated,
     * triggers an event for
     *
     * @inheritdoc
     */
    _save: function() {
        this.view.layout.trigger('editablelist:' + this.view.name + ':saving', true);
        this._saveRowModel();
    },

    /**
     * Saves the row's model
     *
     * @private
     */
    _saveRowModel: function() {
        var self = this;
        var oldModelId = this.model.cid;
        var quoteModel = this.context.get('parentModel');
        var successCallback = function(data, request) {
            self.changed = false;
            self.model.modelView = 'list';

            if (!_.isEmpty(data.related_record)) {
                self.model.setSyncedAttributes(data.related_record);
                self.model.set(data.related_record);
            }

            if (self.view.layout) {
                self.view.layout.trigger('editablelist:' + self.view.name + ':save', self.model, oldModelId);
            }
        };
        var options = {
            success: successCallback,
            error: function(error) {
                if (error.status === 409) {
                    app.utils.resolve409Conflict(error, self.model, function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                successCallback(model);
                            } else {
                                self._save();
                            }
                        }
                    });
                }
            },
            complete: function() {
                // remove this model from the list if it has been unlinked
                if (self.model.get('_unlinked')) {
                    self.collection.remove(self.model, {silent: true});
                    self.collection.trigger('reset');
                    self.view.render();
                } else {
                    self.setDisabled(false);
                }
            },
            lastModified: self.model.get('date_modified'),
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: app.lang.get('LBL_RECORD_SAVED', self.module)
                }
            },
            relate: this.model.link ? true : false
        };

        options = _.extend({}, options, this.getCustomSaveOptions(options));

        app.api.relationships('update', 'Quotes', {
            id: quoteModel.get('id'),
            link: 'product_bundles',
            relatedId: this.model.get('id'),
            related: {
                name: this.model.get('name')
            }
        }, null, options);
    }
}) },
"quote-footer-input": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ProductBundles.QuoteFooterInputField
 * @alias SUGAR.App.view.fields.BaseProductBundlesQuoteFooterInputField
 * @extends View.Fields.Base.Field
 */
({
	// Quote-footer-input FieldTemplate (base) 

    /**
     * The value dollar amount
     */
    value_amount: undefined,

    /**
     * The value percent amount
     */
    value_percent: undefined,

    /**
     * @inheritdoc
     */
    format: function(value) {
        if (!value) {
            this.value_amount = app.currency.formatAmountLocale('0');
            this.value_percent = '0%';
        }
    }
}) }
}}
,
"views": {
"base": {
"quote-data-group-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ProductBundles.QuoteDataGroupListView
 * @alias SUGAR.App.view.views.BaseProductBundlesQuoteDataGroupListView
 * @extends View.Views.Base.View
 */
({
	// Quote-data-group-list View (base) 

    /**
     * @inheritdoc
     */
    events: {
        'click [name="edit_row_button"]': '_onEditRowBtnClicked',
        'click [name="delete_row_button"]': '_onDeleteRowBtnClicked'
    },

    /**
     * @inheritdoc
     */
    plugins: [
        'Editable',
        'ErrorDecoration',
        'MassCollection',
        'SugarLogic',
        'QuotesLineNumHelper'
    ],

    /**
     * @inheritdoc
     */
    className: 'quote-data-group-list',

    /**
     * Array of fields to use in the template
     */
    _fields: undefined,

    /**
     * The colspan value for the list
     */
    listColSpan: 0,

    /**
     * The colspan value for empty rows listColSpan + 1 since no left column
     */
    emptyListColSpan: 0,

    /**
     * Array of left column fields
     */
    leftColumns: undefined,

    /**
     * Array of left column fields
     */
    leftSaveCancelColumn: undefined,

    /**
     * List of current inline edit models.
     */
    toggledModels: null,

    /**
     * Object containing the row's fields
     */
    rowFields: {},

    /**
     * ProductBundleNotes QuoteDataGroupList metadata
     */
    pbnListMetadata: undefined,

    /**
     * QuotedLineItems QuoteDataGroupList metadata
     */
    qliListMetadata: undefined,

    /**
     * ProductBundleNotes Description field metadata
     */
    pbnDescriptionMetadata: undefined,

    /**
     * Track all the SugarLogic Contexts that we create for each record in bundle
     *
     * @type {Object}
     */
    sugarLogicContexts: {},

    /**
     * Track the module dependencies for the line item, so we dont have to fetch them every time
     *
     * @type {Object}
     */
    moduleDependencies: {},

    /**
     * If this QuoteDataGroupList is the default group list view, or regular header/footer group view
     */
    isDefaultGroupList: undefined,

    /**
     * If this view is currently in the /create view or not
     */
    isCreateView: undefined,

    /**
     * If this view is in the /create view coming from Opportunities Convert to Quote
     */
    isOppsConvert: undefined,

    /**
     * In Convert to Quote, if the RLI models have been added to the Quote yet
     */
    addedConvertModels: undefined,

    /**
     * CSS Classes for sortable rows
     */
    sortableCSSClass: 'sortable ui-sortable',

    /**
     * CSS Classes for non-sortable rows
     */
    nonSortableCSSClass: 'not-sortable',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var parentModelModule;
        this.pbnListMetadata = app.metadata.getView('ProductBundleNotes', 'quote-data-group-list');
        this.qliListMetadata = app.metadata.getView('Products', 'quote-data-group-list');

        this.pbnDescriptionMetadata = _.find(this.pbnListMetadata.panels[0].fields, function(field) {
            return field.name === 'description';
        }, this);

        // make sure we're using the layout's model
        options.model = options.model || options.layout.model;
        // get the product_bundle_items collection from the model
        options.collection = options.model.get('product_bundle_items');

        // use the same massCollection from the Quotes QuoteDataListHeaderView
        var quoteDataListHeaderComp;
        if (options.layout && options.layout.layout) {
            quoteDataListHeaderComp =  options.layout.layout.getComponent('quote-data-list-header');
            if (quoteDataListHeaderComp) {
                options.context.set('mass_collection', quoteDataListHeaderComp.massCollection);
            }
        }

        this.listColSpan = options.layout.listColSpan;
        this.emptyListColSpan = this.listColSpan + 1;

        this._super('initialize', [options]);

        this.isDefaultGroupList = this.model.get('default_group');

        this.isCreateView = this.context.parent.get('create') || false;

        parentModelModule = this.context.parent.get('parentModel') ?
            this.context.parent.get('parentModel').get('_module') : '';

        this.isOppsConvert = this.isCreateView &&
            this.context.parent.get('convert') &&
            (parentModelModule == 'RevenueLineItems' ||
            parentModelModule == 'Opportunities') &&
            this.context.parent.get('fromLink') != 'quotes';

        this.addedConvertModels = this.context.parent.get('addedConvertModels') || false;

        this.action = 'list';
        this.viewName = this.isCreateView ? 'edit' : 'list';

        // combine qliListMetadata's panels into this.meta
        this.meta = _.extend(this.meta, this.qliListMetadata);
        this._fields = _.flatten(_.pluck(this.qliListMetadata.panels, 'fields'));

        this.toggledModels = {};
        this.leftColumns = [];
        this.leftSaveCancelColumn = [];
        this.addMultiSelectionAction();

        this.events = _.extend({
            'hidden.bs.dropdown .actions': 'resetDropdownDelegate',
            'shown.bs.dropdown .actions': 'delegateDropdown'
        }, this.events);

        /**
         * Due to BackboneJS, this view would have a wrapper tag around it e.g. QuoteDataGroupHeader.tagName "tr"
         * so this would have also been wrapped in div/tr whatever the tagName was for the view.
         * I am setting this.el to be the Layout's el (QuoteDataGroupLayout) which is a tbody element.
         * In the render function I am then manually appending this list of records template
         * after the group header tr row
         */
        this.el = this.layout.el;
        this.setElement(this.el);

        this.isEmptyGroup = this.collection.length === 0;

        // for each item in the collection, setup SugarLogic
        var collections = this.model.fields['product_bundle_items'].links;
        _.each(collections, function(link) {
            var collection = this.model.getRelatedCollection(link);
            if (collection) {
                this.setupSugarLogicForModelOrCollection(collection);
            }
        }, this);

        // listen directly on the parent QuoteDataGroupLayout
        this.layout.on('quotes:group:create:qli', this.onAddNewItemToGroup, this);
        this.layout.on('quotes:group:create:note', this.onAddNewItemToGroup, this);
        this.layout.on('quotes:sortable:over', this._onSortableGroupOver, this);
        this.layout.on('quotes:sortable:out', this._onSortableGroupOut, this);
        this.layout.on('editablelist:' + this.name + ':cancel', this.onCancelRowEdit, this);
        this.layout.on('editablelist:' + this.name + ':save', this.onSaveRowEdit, this);
        this.layout.on('editablelist:' + this.name + ':saving', this.onSavingRow, this);

        this.context.parent.on('quotes:collections:all:checked', this.onAllChecked, this);
        this.context.parent.on('quotes:collections:not:all:checked', this.onNotAllChecked, this);

        this.collection.on('add remove', this.onNewItemChanged, this);
    },

    /**
     * handler for when the select all checkbox is checked
     */
    onAllChecked: function() {
        //iterate over all of the masscollection checkboxes and check the ones that are unchecked.
        _.each(this.$('div.checkall input'), function(item) {
            var $item = $(item);
            //only trigger if the item isn't checked.
            if (!$item.prop('checked')) {
                $item.trigger('click');
            }
        });
    },

    /**
     * handler for when the select all checkbox is unchecked
     */
    onNotAllChecked: function() {
        //iterate over all of the masscollection checkboxes and uncheck the ones that are checked.
        _.each(this.$('div.checkall input'), function(item) {
            var $item = $(item);
            //only trigger if the item IS checked.
            if ($item.prop('checked')) {
                $item.trigger('click');
            }
        });
    },

    /**
     * Resets the dropdown css
     * @param e
     */
    resetDropdownDelegate: function(e) {
        var $b = this.$(e.currentTarget).first();
        $b.parent().closest('.action-button-wrapper').removeClass('open');
    },

    /**
     * Fixes z-index for dropdown
     * @param e
     */
    delegateDropdown: function(e) {
        var $buttonGroup = this.$(e.currentTarget).first();
        // add open class to parent list to elevate absolute z-index for iOS
        $buttonGroup.parent().closest('.action-button-wrapper').addClass('open');
    },

    /**
     * Load and cache SugarLogic dependencies for a module
     *
     * @param {Data.Bean} model
     * @return {Array}
     * @private
     */
    _getSugarLogicDependenciesForModel: function(model) {
        var module = model.module;
        if (_.isUndefined(this.moduleDependencies[module])) {
            var dependencies;
            var moduleMetadata;
            //TODO: These dependencies would normally be filtered by view action. Need to make that logic
            // external from the Sugarlogic plugin. Probably somewhere in the SidecarExpressionContext class...
            // first get the module from the metadata
            moduleMetadata = app.metadata.getModule(module) || {};
            // load any dependencies found there
            dependencies = moduleMetadata.dependencies || [];
            // now lets check the record view to see if it has any local ones on it.
            if (moduleMetadata.views && moduleMetadata.views.record) {
                var recordMetadata = moduleMetadata.views.record.meta;
                if (!_.isUndefined(recordMetadata.dependencies)) {
                    dependencies = dependencies.concat(recordMetadata.dependencies);
                }
            }

            // cache the results so we don't have to do this expensive lookup any more
            this.moduleDependencies[module] = dependencies;
        }

        return this.moduleDependencies[module];
    },

    /**
     * Setup dependencies for a specific model.
     *
     * @param {Data.Bean} model
     * @param {Data.Collection} collection
     * @param {Object} options
     */
    setupSugarLogicForModelOrCollection: function(modelOrCollection) {
        var slContext;
        var isCollection = (modelOrCollection instanceof app.data.beanCollection);
        var dependencies = this._getSugarLogicDependenciesForModel(modelOrCollection);
        if (_.size(dependencies) > 0) {
            slContext = new SUGAR.expressions.SidecarExpressionContext(
                this,
                isCollection ? new modelOrCollection.model() : modelOrCollection,
                isCollection ? modelOrCollection : false
            );
            slContext.initialize(dependencies);
            var id = isCollection ? modelOrCollection.module : modelOrCollection.get('id') || modelOrCollection.cid;
            this.sugarLogicContexts[id] = slContext;
        }
    },

    /**
     * Handler for when a new QLI/Note row has been added and then canceled
     *
     * @param {Data.Bean} rowModel The row collection model that was created and now canceled
     */
    onCancelRowEdit: function(rowModel) {
        var rowId;

        if (rowModel.isNew()) {
            rowId = rowModel.cid;
            this.collection.remove(rowModel);

            if (!_.isUndefined(this.sugarLogicContexts[rowId])) {
                // cleanup any sugarlogic contexts
                this.sugarLogicContexts[rowId].dispose();
            }

            // if we're showing line numbers, and the model we canceled was a Product
            if (this.showLineNums && rowModel.module === 'Products') {
                // reset the line_num count on the collection from QuotesLineNumHelper plugin
                this.resetGroupLineNumbers(this.model.cid, this.collection);
            }
        }

        this.onNewItemChanged();
    },

    /**
     * Handles when a row is saved. Since newly added (but not saved) rows have temporary
     * id's assigned to them, this is needed to go back and fix row id html attributes and
     * also resets the rowFields with the new model's ID so rows toggle properly
     *
     * @param {Data.Bean} rowModel
     */
    onSaveRowEdit: function(rowModel) {
        var modelId = rowModel.cid;
        var modelModule = rowModel.module;
        var quoteId = rowModel.get('quote_id');
        var productId = rowModel.get('id');
        var quoteModel;

        this.toggleCancelButton(false, rowModel.cid);
        this.toggleRow(modelModule, modelId, false);
        this.onNewItemChanged();

        // when a new row is added if it does not have quote_id already, set it
        if (rowModel.module === 'Products' && _.isUndefined(quoteId)) {
            quoteModel = this.context.get('parentModel');

            if (quoteModel) {
                quoteId = quoteModel.get('id');

                app.api.relationships('create', 'Products', {
                    id: productId,
                    link: 'quotes',
                    relatedId: quoteId,
                    related: {
                        quote_id: quoteId
                    }
                }, null, {
                    success: _.bind(function(response) {
                        var record = response.record;
                        var relatedRecord = response.related_record;
                        var pbItems = this.model.get('product_bundle_items');
                        var quoteModel = this.context.get('parentModel');

                        _.each(pbItems.models, function(itemModel) {
                            if (itemModel.get('id') === record.id) {
                                itemModel.setSyncedAttributes(record);
                                itemModel.set(record);
                            }
                        }, this);

                        if (quoteModel) {
                            quoteModel.setSyncedAttributes(relatedRecord);
                            quoteModel.set(relatedRecord);
                        }

                    }, this)
                });
            }
        }
    },

    /**
     * Handles when the row is being saved but has not been saved fully yet
     *
     * @param {boolean} disableCancelBtn If we should disable the button or not
     * @param {string} rowModelCid The model.cid of the row that is saving
     */
    onSavingRow: function(disableCancelBtn, rowModelCid) {
        // todo: SFA-4541 needs to add code in here to toggle fields to readonly
        this.toggleCancelButton(disableCancelBtn, rowModelCid);
    },

    /**
     * Toggles the cancel button disabled or not
     *
     * @param {boolean} disable If we should disable the button or not
     * @param {string} rowModelCid The model.cid of the row that needs its cancel button toggled
     */
    toggleCancelButton: function(disable, rowModelCid) {
        var cancelBtn = _.find(this.fields, function(field) {
            return field.name == 'inline-cancel' && field.model.cid === rowModelCid;
        });
        if (cancelBtn) {
            cancelBtn.setDisabled(disable);
        }
    },

    /**
     * Called when a group's Create QLI or Create Note button is clicked
     *
     * @param {Data.Bean} groupModel The ProductBundle model
     * @param {Object} prepopulateData Any data to prepopulate the model with - coming from Opps Convert
     * @param {string} linkName The link name of the new item to create: products or product_bundle_notes
     */
    onAddNewItemToGroup: function(linkName, prepopulateData) {
        var relatedModel = app.data.createRelatedBean(this.model, null, linkName);
        var quoteModel = this.context.get('parentModel');
        var maxPositionModel;
        var position = 0;
        var $relatedRow;
        var moduleName = linkName === 'products' ? 'Products' : 'ProductBundleNotes';
        var modelData = {};
        var groupLineNumObj;
        // these quoteModel values will be overwritten if prepopulateData
        // already has currency_id or base_rate already set
        var currencyId = quoteModel.get('currency_id');
        var baseRate = quoteModel.get('base_rate');
        var newLineNum;

        prepopulateData = prepopulateData || {};

        if (this.collection.length) {
            // get the model with the highest position
            maxPositionModel = _.max(this.collection.models, function(model) {
                return +model.get('position');
            });

            // get the position of the highest model's position and add one to it
            position = +maxPositionModel.get('position') + 1;
        }

        // if the data has a _module, remove it
        if (!_.isEmpty(prepopulateData)) {
            delete prepopulateData._module;

            if (moduleName === 'Products' && prepopulateData.product_template_id) {
                var metadataFields = app.metadata.getModule('Products', 'fields');

                // getting the fields from metadata of the module and mapping them to prepopulateData
                if (metadataFields && metadataFields.product_template_name &&
                    metadataFields.product_template_name.populate_list) {
                    _.each(metadataFields.product_template_name.populate_list, function(val, key) {
                        prepopulateData[val] = prepopulateData[key];
                    }, this);
                }
            }

        }

        if (prepopulateData && prepopulateData._forcePosition) {
            // initialize new line_num to 0
            newLineNum = 0;

            // increment the new line number to 1 and set that on prepopulateData
            prepopulateData.line_num = ++newLineNum;

            // since we're forcing a new position, we need to update all models in the collection with
            // a new position and new line_num
            _.each(this.collection.models, function(model) {
                var pos = model.get('position');
                // if an existing model's position is >= prepopulateData's position,
                // we want to move all those positions up one so prepopulateData can fit
                if (pos >= prepopulateData.position) {
                    // increment the position by one and set on the model
                    model.set('position', ++pos);
                    this.collection._resavePositions = true;
                }
                if (this.showLineNums && model.module === 'Products') {
                    // if this is also a Product row, update the line_num for the row
                    model.set('line_num', ++newLineNum);
                }
            }, this);

            // set position to be the prepopulateData position for later
            position = prepopulateData.position;

            // remove this property
            delete prepopulateData._forcePosition;
        } else {
            // if there's no propopulate data nor _forcePosition
            if (this.showLineNums && relatedModel.module === 'Products') {
                // get the line_num count object from QuotesLineNumHelper plugin
                groupLineNumObj = this.getGroupLineNumCount(this.model.cid);
                // add the new line number to the model
                modelData.line_num = groupLineNumObj.ct++;
            }
        }

        // defers to prepopulateData
        modelData = _.extend({
            _module: moduleName,
            _link: linkName,
            position: position,
            currency_id: currencyId,
            base_rate: baseRate,
            quote_id: quoteModel.get('id')
        }, prepopulateData);

        relatedModel.module = moduleName;

        // set a few items on the model
        relatedModel.set(modelData);

        // tell the currency field, not to set the default currency
        relatedModel.ignoreUserPrefCurrency = true;

        // this model's fields should be set to render
        relatedModel.modelView = 'edit';

        // add model to toggledModels to be toggled next render
        this.toggledModels[relatedModel.cid] = relatedModel;

        // adding to the collection will trigger the render
        this.collection.add(relatedModel);

        $relatedRow = this.$('tr[name="' + relatedModel.module + '_' + relatedModel.id + '"]');
        if ($relatedRow.length) {
            if (this.isCreateView) {
                $relatedRow.addClass(this.sortableCSSClass);
            } else {
                $relatedRow.addClass(this.nonSortableCSSClass);
            }
        }

        this.onNewItemChanged();
    },

    /**
     * Handles updating if we should show the empty row when QLI/Notes have
     * been created or canceled before saving
     */
    onNewItemChanged: function() {
        this.isEmptyGroup = this.collection.length === 0;
        this.toggleEmptyRow(this.isEmptyGroup);
    },

    /**
     * Handles when this group receives a sortover event that the user
     * has dragged an item into this group
     *
     * @param {jQuery.Event} evt The jQuery sortover event
     * @param {Object} ui The jQuery Sortable UI Object
     * @private
     */
    _onSortableGroupOver: function(evt, ui) {
        // When entering a new group, always hide the empty row
        this.toggleEmptyRow(false);
    },

    /**
     * Handles when this group receives a sortout event that the user has
     * dragged an item out of this group
     *
     * @param {jQuery.Event} evt The jQuery sortout event
     * @param {Object} ui The jQuery Sortable UI Object
     * @private
     */
    _onSortableGroupOut: function(evt, ui) {
        var isSenderNull = _.isNull(ui.sender);
        var isSenderSameGroup = isSenderNull ||
            ui.sender.length && ui.sender.get(0) === this.el;

        // if the group was originally empty, show the empty row
        // if the group was not empty and had more than one row in it, hide the empty row
        var showEmptyRow = this.isEmptyGroup;

        // if there is only one item in this group, and the out event happens on a group that is the line item's
        // original group, and the existing single row is currently hidden,
        // set showEmptyRow = true so we show the Click + message
        if (this.collection.length === 1 &&
            isSenderSameGroup && $(ui.item.get(0)).css('display') === 'none') {
            showEmptyRow = true;
        }

        this.toggleEmptyRow(showEmptyRow);
    },

    /**
     * Toggles showing and hiding the empty-row message row
     *
     * @param {boolean} showEmptyRow True to show the empty row, false to hide it
     */
    toggleEmptyRow: function(showEmptyRow) {
        if (showEmptyRow) {
            this.$('.empty-row').removeClass('hidden');
        } else {
            this.$('.empty-row').addClass('hidden');
        }
    },

    /**
     * @inheritdoc
     */
    render: function() {
        this._super('render');

        // update isEmptyGroup after render and make sure we toggle the row properly
        this.isEmptyGroup = this.collection.length === 0;
        this.toggleEmptyRow(this.isEmptyGroup);
    },

    /**
     * Overriding _renderHtml to specifically place this template after the
     * quote data group header
     *
     * @inheritdoc
     */
    _renderHtml: function() {
        var $el = this.$('tr.quote-data-group-header');
        var $trs;
        if ($el.length) {
            $trs = this.$('tr.quote-data-group-list');
            if ($trs.length) {
                // if there are already quote-data-group-list table rows remove them
                $trs.remove();
            }
            $el.after(this.template(this));
        } else {
            this.$el.html(this.template(this));
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var qliModels;

        this._super('_render');

        // set row fields after rendering to prep if we need to toggle rows
        this._setRowFields();

        // if this is the create view, and we're coming from Opps convert to Quote,
        // and we have not added the RLI models
        if (this.isCreateView && this.isOppsConvert && !this.addedConvertModels) {
            qliModels = this.context.parent.get('relatedRecords');

            _.each(qliModels, function(qliModel) {
                this.onAddNewItemToGroup('products', qliModel.toJSON());
            }, this);

            //be sure to set this on the parent as well so new groups don't try to do this.
            this.context.parent.set('addedConvertModels', true);
            this.addedConvertModels = true;
        }

        if (!_.isEmpty(this.toggledModels)) {
            _.each(this.toggledModels, function(model, modelId) {
                this.toggleRow(model.module, modelId, true);
            }, this);
        }
    },

    /**
     * Handles when the Delete button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onEditRowBtnClicked: function(evt) {
        var row = this.isolateRowParams(evt);

        if (!row.id || !row.module) {
            return false;
        }

        this.toggleRow(row.module, row.id, true);
    },

    /**
     * Handles when the Delete button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onDeleteRowBtnClicked: function(evt) {
        var row = this.isolateRowParams(evt);

        if (!row.id || !row.module) {
            return false;
        }

        app.alert.show('confirm_delete', {
            level: 'confirmation',
            title: app.lang.get('LBL_ALERT_TITLE_WARNING') + ':',
            messages: [app.lang.get('LBL_ALERT_CONFIRM_DELETE')],
            onConfirm: _.bind(function() {
                app.alert.show('deleting_line_item', {
                    level: 'info',
                    messages: [app.lang.get('LBL_ALERT_DELETING_ITEM', 'ProductBundles')]
                });
                this._onDeleteRowModelFromList(this.collection.get(row.id));
            }, this)
        });
    },

    /**
     * Called when deleting a row is confirmed, this removes the model
     * from the collection and resets the group's line numbers
     *
     * @param {Data.Bean} deletedRowModel The model being deleted
     * @private
     */
    _onDeleteRowModelFromList: function(deletedRowModel) {
        deletedRowModel.destroy({
            success: _.bind(function() {
                app.alert.dismiss('deleting_line_item');
                app.alert.show('deleted_line_item', {
                    level: 'success',
                    autoClose: true,
                    messages: app.lang.get('LBL_DELETED_LINE_ITEM_SUCCESS_MSG', 'ProductBundles')
                });
            }, this)
        });
        this.layout.trigger('quotes:line_nums:reset', this.layout.groupId, this.layout.collection);
    },

    /**
     * Parse out a row module and ID
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    isolateRowParams: function(evt) {
        var $ulEl = $(evt.target).closest('ul');
        var rowParams = {};

        if ($ulEl.length) {
            rowParams.module = $ulEl.data('row-module');
            rowParams.id = $ulEl.data('row-model-id');
        }

        return rowParams;
    },

    /**
     * Toggle editable selected row's model fields.
     *
     * @param {string} rowModule The row model's module.
     * @param {string} rowModelId The row model's ID
     * @param {boolean} isEdit True for edit mode, otherwise toggle back to list mode.
     */
    toggleRow: function(rowModule, rowModelId, isEdit) {
        var toggleModel;
        var $row;

        this.context.parent.trigger('quotes:item:toggle', isEdit, rowModelId);
        toggleModel = this.collection.find(function(model) {
            return (model.cid == rowModelId || model.id == rowModelId);
        });

        if (isEdit) {
            if (_.isUndefined(toggleModel)) {
                // its not there any more, so remove it from the toggledModels and return out from this method
                delete this.toggledModels[rowModelId];
                return;
            } else {
                toggleModel.modelView = 'edit';
                this.toggledModels[rowModelId] = toggleModel;
            }
        } else {
            if (this.toggledModels[rowModelId]) {
                this.toggledModels[rowModelId].modelView = 'list';
            }
            delete this.toggledModels[rowModelId];
        }

        $row = this.$('tr[name=' + rowModule + '_' + rowModelId + ']');
        $row.toggleClass('tr-inline-edit', isEdit);
        this.toggleFields(this.rowFields[rowModelId], isEdit);

        if (isEdit) {
            //disable drag/drop for this row
            $row.addClass('not-sortable');
            $row.parent().sortable({
                cancel: '.not-sortable'
            });
            $row.removeClass('ui-sortable');

            //trigger sugarlogic
            this.context.trigger('list:editrow:fire', toggleModel);
        } else if ($row.hasClass('not-sortable')) {
            // if this is not edit mode and row still has not-sortable (from being a brand new row)
            // then remove the not-sortable and add the sortable classes
            $row.removeClass('not-sortable');
            $row.addClass('sortable ui-sortable');

            //since this is a new row, we also need to set the record-id attribute on the row
            $row.attr('record-id', toggleModel.get('id'));
        }
    },

    /**
     * Set, or reset, the collection of fields that contains each row.
     *
     * This function is invoked when the view renders. It will update the row
     * fields once the `Pagination` plugin successfully fetches new records.
     *
     * @private
     */
    _setRowFields: function() {
        this.rowFields = {};
        _.each(this.fields, function(field) {
            if (field.model && field.model.cid && _.isUndefined(field.parent)) {
                this.rowFields[field.model.cid] = this.rowFields[field.model.cid] || [];
                this.rowFields[field.model.cid].push(field);
            }
        }, this);
    },

    /**
     * Overriding to allow panels to come from whichever module was passed in
     *
     * @inheritdoc
     */
    getFieldNames: function(module) {
        var fields = [];
        var panels;
        module = module || this.context.get('module');

        if (module === 'Quotes' || module === 'Products') {
            panels = _.clone(this.qliListMetadata.panels);
        } else if (module === 'ProductBundleNotes') {
            panels = _.clone(this.pbnListMetadata.panels);
        }

        if (panels) {
            fields = _.reduce(_.map(panels, function(panel) {
                var nestedFields = _.flatten(_.compact(_.pluck(panel.fields, 'fields')));
                return _.pluck(panel.fields, 'name').concat(
                    _.pluck(nestedFields, 'name')).concat(
                    _.flatten(_.compact(_.pluck(panel.fields, 'related_fields'))));
            }), function(memo, field) {
                return memo.concat(field);
            }, []);
        }

        fields = _.compact(_.uniq(fields));

        var fieldMetadata = app.metadata.getModule(module, 'fields');
        if (fieldMetadata) {
            // Filter out all fields that are not actual bean fields
            fields = _.reject(fields, function(name) {
                return _.isUndefined(fieldMetadata[name]);
            });

            // we need to find the relates and add the actual id fields
            var relates = [];
            _.each(fields, function(name) {
                if (fieldMetadata[name].type == 'relate') {
                    relates.push(fieldMetadata[name].id_name);
                } else if (fieldMetadata[name].type == 'parent') {
                    relates.push(fieldMetadata[name].id_name);
                    relates.push(fieldMetadata[name].type_name);
                }
                if (_.isArray(fieldMetadata[name].fields)) {
                    relates = relates.concat(fieldMetadata[name].fields);
                }
            });

            fields = _.union(fields, relates);
        }

        return fields;
    },

    /**
     * Adds the left column fields
     */
    addMultiSelectionAction: function() {
        var _generateMeta = function(buttons, disableSelectAllAlert) {
            return {
                'type': 'fieldset',
                'fields': [
                    {
                        'type': 'quote-data-actionmenu',
                        'buttons': buttons || [],
                        'disable_select_all_alert': !!disableSelectAllAlert
                    }
                ],
                'value': false,
                'sortable': false
            };
        };
        var buttons = this.meta.selection.actions;
        var disableSelectAllAlert = !!this.meta.selection.disable_select_all_alert;
        this.leftColumns.push(_generateMeta(buttons, disableSelectAllAlert));

        this.leftSaveCancelColumn.push({
            'type': 'fieldset',
            'label': '',
            'sortable': false,
            'fields': [{
                type: 'quote-data-editablelistbutton',
                label: '',
                tooltip: 'LBL_CANCEL_BUTTON_LABEL',
                name: 'inline-cancel',
                icon: 'fa-close',
                css_class: 'btn-invisible inline-cancel ellipsis_inline'
            }]
        });

        // if this is the create view, do not add a save button
        if (!this.isCreateView) {
            this.leftSaveCancelColumn[0].fields.push({
                type: 'quote-data-editablelistbutton',
                label: '',
                tooltip: 'LBL_SAVE_BUTTON_LABEL',
                name: 'inline-save',
                icon: 'fa-check-circle',
                css_class: 'btn-invisible inline-save ellipsis_inline'
            });
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this.context && this.context.parent) {
            this.context.parent.off('quotes:collections:all:checked', null, this);
            this.context.parent.off('quotes:collections:not:all:checked', null, this);
        }

        _.each(this.sugarLogicContexts, function(slContext) {
            slContext.dispose();
        });
        this._super('_dispose');
        this.rowFields = null;
        this.sugarLogicContexts = {};
        this.moduleDependencies = {};
    }
}) },
"quote-data-group-footer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ProductBundles.QuoteDataGroupFooterView
 * @alias SUGAR.App.view.views.BaseProductBundlesQuoteDataGroupFooterView
 * @extends View.Views.Base.View
 */
({
	// Quote-data-group-footer View (base) 

    /**
     * The colspan value for the list
     */
    listColSpan: 0,

    /**
     * Array of fields to use in the template
     */
    _fields: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var groupId;

        options.model = options.model || options.layout.model;

        // +1 to colspan since there are no leftColumns in the footer
        this.listColSpan = options.layout.listColSpan + 1;

        this._super('initialize', [options]);

        this._fields = _.flatten(_.pluck(this.meta.panels, 'fields'));

        // ninjastuff
        this.el = this.layout.el;
        this.setElement(this.el);
    },

    /**
     * Overriding _renderHtml to specifically place this template after the
     * quote data group list rows
     *
     * @inheritdoc
     */
    _renderHtml: function() {
        var $els = this.$('tr.quote-data-group-list');
        if ($els.length) {
            // get the last table row with class quote-data-group-list and place
            // this template after it  quote-data-group-header
            $(_.last($els)).after(this.template(this));
        } else {
            // the list is empty so just add the footer after the header
            $(this.$('tr.quote-data-group-header')).after(this.template(this));
        }
    }
}) },
"quote-data-group-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ProductBundles.QuoteDataGroupHeaderView
 * @alias SUGAR.App.view.views.BaseProductBundlesQuoteDataGroupHeaderView
 * @extends View.Views.Base.View
 */
({
	// Quote-data-group-header View (base) 

    /**
     * @inheritdoc
     */
    events: {
        'click [name="create_qli_button"]': '_onCreateQLIBtnClicked',
        'click [name="create_comment_button"]': '_onCreateCommentBtnClicked',
        'click [name="edit_bundle_button"]': '_onEditBundleBtnClicked',
        'click [name="delete_bundle_button"]': '_onDeleteBundleBtnClicked'
    },

    /**
     * @inheritdoc
     */
    plugins: [
        'MassCollection',
        'Editable',
        'ErrorDecoration'
    ],

    /**
     * Array of fields to use in the template
     */
    _fields: undefined,

    /**
     * The colspan value for the list
     */
    listColSpan: 0,

    /**
     * The CSS class for the save icon
     */
    saveIconCssClass: '.group-loading-icon',

    /**
     * How many times the group has been called to start or stop saving
     */
    groupSaveCt: undefined,

    /**
     * Object containing the row's fields
     */
    rowFields: {},

    /**
     * Array of left column fields
     */
    leftColumns: undefined,

    /**
     * Array of left column fields
     */
    leftSaveCancelColumn: undefined,

    /**
     * If this is the first time the view has rendered or not
     */
    isFirstRender: undefined,

    /**
     * If this layout is currently in the /create view or not
     */
    isCreateView: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // make sure we're using the layout's model
        options.model = options.model || options.layout.model;

        this.listColSpan = options.layout.listColSpan;

        // use the same massCollection from the Quotes QuoteDataListHeaderView
        var quoteDataListHeaderComp;
        if (options.layout && options.layout.layout) {
            quoteDataListHeaderComp =  options.layout.layout.getComponent('quote-data-list-header');
            if (quoteDataListHeaderComp) {
                options.context.set('mass_collection', quoteDataListHeaderComp.massCollection);
            }
        }

        this._super('initialize', [options]);

        this.isCreateView = this.context.parent.get('create') || false;

        this.isFirstRender = true;

        this.viewName = 'list';
        this.action = 'list';
        this._fields = _.flatten(_.pluck(this.meta.panels, 'fields'));

        this.toggledModels = {};
        this.leftColumns = [];
        this.leftSaveCancelColumn = [];
        this.addMultiSelectionAction();

        // ninjastuff
        this.el = this.layout.el;
        this.setElement(this.el);

        this.groupSaveCt = 0;
        this.layout.on('quotes:group:save:start', this._onGroupSaveStart, this);
        this.layout.on('quotes:group:save:stop', this._onGroupSaveStop, this);
        this.layout.on('editablelist:' + this.name + ':save', this.onSaveRowEdit, this);
        this.layout.on('editablelist:' + this.name + ':saving', this.onSavingRow, this);
        this.layout.on('editablelist:' + this.name + ':create:cancel', this._onDeleteBundleBtnClicked, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // set row fields after rendering to prep if we need to toggle rows
        this._setRowFields();

        if (!_.isEmpty(this.toggledModels)) {
            _.each(this.toggledModels, function(model, modelId) {
                this.toggleRow(model.module, modelId, true);
            }, this);
        }

        // on the first header row render, if this model was _justSaved
        // we want to toggle the row to edit mode adding this to toggledModels
        if (this.isFirstRender && this.model.has('_justSaved')) {
            this.model.unset('_justSaved');
            this.isFirstRender = false;
            this.toggleRow(this.model.module, this.model.cid, true);
        }
    },

    /**
     * Handles displaying the loading icon when a group starts saving
     *
     * @private
     */
    _onGroupSaveStart: function() {
        this.groupSaveCt++;
        this.$(this.saveIconCssClass).show();
    },

    /**
     * Handles hiding the loading icon when a group save is complete
     *
     * @private
     */
    _onGroupSaveStop: function() {
        this.groupSaveCt--;
        if (this.groupSaveCt === 0) {
            this.$(this.saveIconCssClass).hide();
        }

        if (this.groupSaveCt < 0) {
            this.groupSaveCt = 0;
        }
    },

    /**
     * Handles when the create Quoted Line Item button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onCreateQLIBtnClicked: function(evt) {
        this.layout.trigger('quotes:group:create:qli', 'products');
    },

    /**
     * Handles when the create Comment button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onCreateCommentBtnClicked: function(evt) {
        this.layout.trigger('quotes:group:create:note', 'product_bundle_notes');
    },

    /**
     * Handles when the edit Group button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onEditBundleBtnClicked: function(evt) {
        var $tbodyEl = $(evt.target).closest('tbody');
        var bundleId = $tbodyEl.data('group-id');

        this.toggleRow(this.model.module, bundleId, true);
    },

    /**
     * Handles when the delete Group button is clicked
     *
     * @param {MouseEvent} evt The mouse click event
     * @private
     */
    _onDeleteBundleBtnClicked: function(evt) {
        this.context.parent.trigger('quotes:group:delete', this.layout);
    },

    /**
     * Toggle editable selected row's model fields.
     *
     * @param {string} rowModule The row model's module.
     * @param {string} rowModelId The row model's ID
     * @param {boolean} isEdit True for edit mode, otherwise toggle back to list mode.
     */
    toggleRow: function(rowModule, rowModelId, isEdit) {
        var toggleModel;
        var row;
        if (isEdit) {
            toggleModel = this.model;
            toggleModel.modelView = 'edit';
            this.toggledModels[rowModelId] = toggleModel;
        } else {
            if (this.toggledModels[rowModelId]) {
                this.toggledModels[rowModelId].modelView = 'list';
            }
            delete this.toggledModels[rowModelId];
        }

        row = this.$('tr[name=' + rowModule + '_' + rowModelId + ']');
        row.toggleClass('tr-inline-edit', isEdit);
        this.toggleFields(this.rowFields[rowModelId], isEdit);

        if (isEdit) {
            // make sure row is not sortable on edit
            row
                .addClass('not-sortable')
                .removeClass('sortable ui-sortable');

            this.context.trigger('list:editgroup:fire');
        }
    },

    /**
     * Set, or reset, the collection of fields that contains each row.
     *
     * This function is invoked when the view renders. It will update the row
     * fields once the `Pagination` plugin successfully fetches new records.
     *
     * @private
     */
    _setRowFields: function() {
        this.rowFields = {};
        _.each(this.fields, function(field) {
            if (field.model && field.model.cid && _.isUndefined(field.parent)) {
                this.rowFields[field.model.cid] = this.rowFields[field.model.cid] || [];
                this.rowFields[field.model.cid].push(field);
            }
        }, this);
    },

    /**
     * Adds the left column fields
     */
    addMultiSelectionAction: function() {
        _.each(this.meta.buttons, function(button) {
            this.leftColumns.push(button);
        }, this);

        this.leftSaveCancelColumn.push({
            'type': 'fieldset',
            'label': '',
            'sortable': false,
            'fields': [{
                type: 'quote-data-editablelistbutton',
                label: '',
                tooltip: 'LBL_CANCEL_BUTTON_LABEL',
                name: 'inline-cancel',
                icon: 'fa-close',
                css_class: 'btn-link btn-invisible inline-cancel ellipsis_inline'
            }]
        });

        // if this is the create view, do not add a save button
        if (this.isCreateView) {
            this.leftSaveCancelColumn[0].fields.push({
                type: 'quote-data-actiondropdown',
                label: '',
                tooltip: 'LBL_SAVE_BUTTON_LABEL',
                name: 'create-dropdown-editmode',
                icon: 'fa-plus',
                css_class: 'ellipsis_inline',
                no_default_action: true,
                buttons: [{
                    type: 'button',
                    icon: 'fa-plus',
                    name: 'create_qli_button',
                    label: 'LBL_CREATE_QLI_BUTTON_LABEL',
                    acl_action: 'create',
                    tooltip: 'LBL_CREATE_QLI_BUTTON_TOOLTIP'
                }, {
                    type: 'button',
                    icon: 'fa-plus',
                    name: 'create_comment_button',
                    label: 'LBL_CREATE_COMMENT_BUTTON_LABEL',
                    acl_action: 'create',
                    tooltip: 'LBL_CREATE_COMMENT_BUTTON_TOOLTIP'
                }]
            });
        } else {
            this.leftSaveCancelColumn[0].fields.push({
                type: 'quote-data-editablelistbutton',
                label: '',
                tooltip: 'LBL_SAVE_BUTTON_LABEL',
                name: 'inline-save',
                icon: 'fa-check-circle',
                css_class: 'btn-link btn-invisible inline-save ellipsis_inline'
            });
        }
    },

    /**
     * Handles when a row is saved.
     *
     * @param {Data.Bean} rowModel
     */
    onSaveRowEdit: function(rowModel) {
        // Quote groups always use the cid of the model
        var modelId = rowModel.cid;
        var modelModule = rowModel.module;

        this.toggleCancelButton(false);
        this.toggleRow(modelModule, modelId, false);
    },

    /**
     * Toggles the cancel button disabled or not
     *
     * @param {boolean} disable If we should disable the button or not
     */
    toggleCancelButton: function(disable) {
        var cancelBtn = _.find(this.fields, function(field) {
            return field.name == 'inline-cancel';
        });
        if (cancelBtn) {
            cancelBtn.setDisabled(disable);
        }
    },

    /**
     * Handles when the row is being saved but has not been saved fully yet
     *
     * @param {boolean} disableCancelBtn If we should disable the button or not
     */
    onSavingRow: function(disableCancelBtn) {
        // todo: SFA-4541 needs to add code in here to toggle fields to readonly
        this.toggleCancelButton(disableCancelBtn);
    }
}) }
}}
,
"layouts": {
"base": {
"quote-data-group": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ProductBundles.QuoteDataGroupLayout
 * @alias SUGAR.App.view.layouts.BaseProductBundlesQuoteDataGroupLayout
 * @extends View.Views.Base.Layout
 */
({
	// Quote-data-group Layout (base) 

    /**
     * @inheritdoc
     */
    tagName: 'tbody',

    /**
     * @inheritdoc
     */
    className: 'quote-data-group',

    /**
     * The colspan value for the list
     */
    listColSpan: 0,

    /**
     * This is the ProductBundle ID from the model set here on the component
     * for easier access by parent layouts
     */
    groupId: undefined,

    /**
     * The Quote Data Group List view added to this layout
     * @type View.Views.Base.ProductBundles.QuoteDataGroupListView
     */
    quoteDataGroupList: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        if (options.model.get('default_group')) {
            // for the default group, we only want the quote-data-group-list component
            options.meta = _.clone(options.meta);
            options.meta.components = [{
                view: 'quote-data-group-list'
            }];
        }

        this._super('initialize', [options]);

        // set the groupID to the model ID
        this.groupId = this.model.cid;
        // set this collection to the product_bundle_items collection
        this.collection = this.model.get('product_bundle_items');
        // add comparator so the collection can sort
        this.collection.comparator = function(model) {
            return model.get('position');
        };
        // sort the collection by model position
        this.collection.sort();

        var listMeta = app.metadata.getView('Products', 'quote-data-group-list');
        if (listMeta && listMeta.panels && listMeta.panels[0].fields) {
            this.listColSpan = listMeta.panels[0].fields.length;
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:product_bundle_items', this.render, this);
        // listen for the currency id to change on the parent record
        this.context.parent.get('model').on('change:currency_id', function(model, value, options) {
            this.model.set({
                currency_id: model.get('currency_id'),
                base_rate: model.get('base_rate')
            });
            this._render();
        }, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // add the group id to the bundle level tbody
        this.$el.attr('data-group-id', this.groupId);
        this.$el.attr('data-record-id', this.model.id);

        // set the product bundle ID on all the QLI/Notes rows
        this.$('tr.quote-data-group-list').attr('data-group-id', this.groupId);
    },

    /**
     * Adds a row model to this layout's collection and, if the row is in edit mode, it adds
     * the row model to the QuoteDataGroupListView's toggledModels object
     *
     * @param {Data.Bean} model The row model that needs to be added to the collection
     * @param {boolean} isRowInEdit Is the row currently in edit mode?
     */
    addRowModel: function(model, isRowInEdit) {
        if (isRowInEdit) {
            this.quoteDataGroupList.toggledModels[model.cid] = model;
        }

        this.collection.add(model, {
            at: model.get('position')
        });
    },

    /**
     * Removes a row model from this layout's collection and, if the row is in edit mode, it removes
     * the row model from the QuoteDataGroupListView's toggledModels object
     *
     * @param {Data.Bean} model The row model that needs to be removed from the collection
     * @param {boolean} isRowInEdit Is the row currently in edit mode?
     */
    removeRowModel: function(model, isRowInEdit) {
        var modelId;

        if (isRowInEdit) {
            modelId = model.get('id');
            if (this.quoteDataGroupList.toggledModels[modelId]) {
                delete this.quoteDataGroupList.toggledModels[modelId];
            }
            if (this.quoteDataGroupList.toggledModels[model.cid]) {
                delete this.quoteDataGroupList.toggledModels[model.cid];
            }
        }

        this.collection.remove(model);
    },

    /**
     * Gets a reference to the QuoteDataGroupList being added to the layout
     *
     * @inheritdoc
     */
    addComponent: function(component, def) {
        this._super('addComponent', [component, def]);

        if (component.name === 'quote-data-group-list') {
            this.quoteDataGroupList = component;
        }
    },

    /**
     * Unsets a reference to the QuoteDataGroupList being removed from the layout
     *
     * @inheritdoc
     */
    removeComponent: function(component) {
        this._super('removeComponent', [component]);

        if (component.name === 'quote-data-group-list') {
            this.quoteDataGroupList = null;
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var model;
        this.quoteDataGroupList = null;

        if (this.context && this.context.parent && this.context.parent.has('model')) {
            model = this.context.parent.get('model');
            model.off('change:currency_id', null, this);
        }

        this._super('_dispose');
    }
}) }
}}
,
"datas": {}

},
		"ProductBundleNotes":{"fieldTemplates": {
"base": {
"quote-data-editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ProductBundleNotes.EditablelistbuttonField
 * @alias SUGAR.App.view.fields.BaseProductBundleNotesEditablelistbuttonField
 * @extends View.Fields.Base.BaseEditablelistbuttonField
 */
({
	// Quote-data-editablelistbutton FieldTemplate (base) 

    extendsFrom: 'BaseEditablelistbuttonField',

    /**
     * Overriding EditablelistbuttonField's Events with mousedown instead of click
     */
    events: {
        'mousedown [name=inline-save]': 'saveClicked',
        'mousedown [name=inline-cancel]': 'cancelClicked'
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        if (_.isUndefined(this.changed) && this.model.isNew()) {
            // when adding additional items to the list, causing additional renders,
            // this.changed gets set undefined on re-initialize, so we need to make sure
            // if this is an unsaved model and this.changed is undefined, that we set changed true
            this.changed = true;
        }

        if (this.tplName === 'edit') {
            this.$el.closest('.left-column-save-cancel').addClass('higher');
        } else {
            this.$el.closest('.left-column-save-cancel').removeClass('higher');
        }
    },

    /**
     * Overriding and not calling parent _loadTemplate as those are based off view/actions and we
     * specifically need it based off the modelView set by the parent layout for this row model
     *
     * @inheritdoc
     */
    _loadTemplate: function() {
        this.tplName = this.model.modelView || 'list';

        if (this.view.action === 'list' && _.indexOf(['edit', 'disabled'], this.action) < 0) {
            this.template = app.template.empty;
        } else {
            this.template = app.template.getField(this.type, this.tplName, this.module);
        }
    },

    /**
     * @inheritdoc
     */
    cancelEdit: function() {
        if (this.isDisabled()) {
            this.setDisabled(false);
        }
        this.changed = false;
        this.model.revertAttributes();
        this.view.clearValidationErrors();

        // this is the only line I had to change
        this.view.toggleRow(this.model.module, this.model.cid, false);

        // trigger a cancel event across the view layout so listening components
        // know the changes made in this row are being reverted
        if (this.view.layout) {
            this.view.layout.trigger('editablelist:' + this.view.name + ':cancel', this.model);
        }
    },

    /**
     * Called after the save button is clicked and all the fields have been validated,
     * triggers an event for
     *
     * @inheritdoc
     */
    _save: function() {
        this.view.layout.trigger('editablelist:' + this.view.name + ':saving', true, this.model.cid);

        if (this.view.model.isNew()) {
            this.view.context.parent.trigger('quotes:defaultGroup:save', _.bind(this._saveRowModel, this));
        } else {
            this._saveRowModel();
        }
    },

    /**
     * Saves the row's model
     *
     * @private
     */
    _saveRowModel: function() {
        var self = this;
        var oldModelId = this.model.id || this.model.cid;

        var successCallback = function(model) {
            self.changed = false;
            model.modelView = 'list';
            if (self.view.layout) {
                self.view.layout.trigger('editablelist:' + self.view.name + ':save', model, oldModelId);
            }
        };
        var options = {
            success: successCallback,
            error: function(error) {
                if (error.status === 409) {
                    app.utils.resolve409Conflict(error, self.model, function(model, isDatabaseData) {
                        if (model) {
                            if (isDatabaseData) {
                                successCallback(model);
                            } else {
                                self._save();
                            }
                        }
                    });
                }
            },
            complete: function() {
                // remove this model from the list if it has been unlinked
                if (self.model.get('_unlinked')) {
                    self.collection.remove(self.model, {silent: true});
                    self.collection.trigger('reset');
                    self.view.render();
                } else {
                    self.setDisabled(false);
                }
            },
            lastModified: self.model.get('date_modified'),
            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: app.lang.get('LBL_RECORD_SAVED', self.module)
                }
            },
            relate: this.model.link ? true : false
        };

        options = _.extend({}, options, this.getCustomSaveOptions(options));
        this.model.save({}, options);
    },

    /**
     * @inheritdoc
     */
    _validationComplete: function(isValid) {
        if (!isValid) {
            this.setDisabled(false);
            return;
        }
        // also need to make sure the model.changed is empty as well
        if (!this.changed && !this.model.changed) {
            this.cancelEdit();
            return;
        }

        this._save();
    }
}) },
"quote-data-actionmenu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ProductBundleNotes.QuoteDataActionmenuField
 * @alias SUGAR.App.view.fields.BaseProductBundleNotesQuoteDataActionmenuField
 * @extends View.Fields.Base.ActionmenuField
 */
({
	// Quote-data-actionmenu FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'ActionmenuField',

    /**
     * Skipping ActionmenuField's override, just returning this.def.buttons
     *
     * @inheritdoc
     */
    _getChildFieldsMeta: function() {
        return app.utils.deepCopy(this.def.buttons);
    },

    /**
     * Triggers massCollection events to the context.parent
     *
     * @inheritdoc
     */
    toggleSelect: function(checked) {
        var event = !!checked ? 'mass_collection:add' : 'mass_collection:remove';
        this.model.selected = !!checked;
        this.context.parent.trigger(event, this.model);
    }
}) },
"textarea": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ProductBundleNotes.TextareaField
 * @alias SUGAR.App.view.fields.BaseProductBundleNotesTextareaField
 * @extends View.Fields.Base.BaseTextareaField
 */
({
	// Textarea FieldTemplate (base) 

    extendsFrom: 'BaseTextareaField',

    /**
     * Having to override because we do want it to go to edit in the list
     * contrary to everywhere else in the app
     *
     * @inheritdoc
     */
    setMode: function(name) {
        // skip textarea's setMode and call straight to Field.setMode
        app.view.Field.prototype.setMode.call(this, name);
    }
}) }
}}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Reports":{"fieldTemplates": {
"base": {
"drillthrough-collection-count": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * DrillthroughCollectionCountField is a field for Reports to set total in drillthrough drawer headerpane.
 *
 * @class View.Fields.Base.Reports.DrillthroughCollectionCountField
 * @alias SUGAR.App.view.fields.BaseReportsDrillthroughCollectionCountField
 * @extends View.Fields.Base.CollectionCountField
 */
({
	// Drillthrough-collection-count FieldTemplate (base) 

    extendsFrom: 'CollectionCountField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'collection-count';
    },

    /**
     * @inheritdoc
     *
     * Calls ReportsApi to get collection count.
     */
    fetchCount: function() {
        if (_.isNull(this.collection.total)) {
            app.alert.show('fetch_count', {
                level: 'process',
                title: app.lang.get('LBL_LOADING'),
                autoClose: false
            });
        }
        var filterDef = this.context.get('filterDef');
        var useSavedFilters = this.context.get('useSavedFilters') || false;
        var params = {group_filters: filterDef, use_saved_filters: useSavedFilters};
        var reportId = this.context.get('reportId');
        var url = app.api.buildURL('Reports', 'record_count', {id: reportId}, params);
        app.api.call('read', url, null, {
            success: _.bind(function(data) {
                this.collection.total = parseInt(data.record_count, 10);
                if (!this.disposed) {
                    this.updateCount();
                }
            }, this),
            complete: function() {
                app.alert.dismiss('fetch_count');
            }
        });
    },
}) },
"drillthrough-labels": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Reports.DrillthroughLabelsField
 * @alias SUGAR.App.view.fields.BaseReportsDrillthroughLabelsField
 * @extends View.Fields.Base.BaseField
 */
({
	// Drillthrough-labels FieldTemplate (base) 


    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.on('refresh:drill:labels', this.render, this);
    },

    /**
     * @override We want to grab the data from the context, not the model
     */
    format: function(value) {
        var params = this.context.get('dashConfig');
        var reportDef = this.context.get('reportData');
        var chartModule = this.context.get('chartModule');
        var filterDef = this.context.get('filterDef');
        var filterFields = _.flatten(_.map(filterDef, function(filter) {
            return _.keys(filter);
        }));
        var groupDefs = _.filter(reportDef.group_defs, function(groupDef) {
            var groupField = groupDef.table_key + ':' + groupDef.name;
            return _.contains(filterFields, groupField);
        });
        if (groupDefs.length > 0) {
            var group = SUGAR.charts.getFieldDef(groupDefs[0], reportDef);
            var module = group.custom_module || group.module || chartModule;
            this.groupName = app.lang.get(group.vname, module) + ': ';
            this.groupValue = params.groupLabel;
        }
        if (groupDefs.length > 1) {
            var series = SUGAR.charts.getFieldDef(groupDefs[1], reportDef);
            var module = series.custom_module || series.module || chartModule;
            this.seriesName = app.lang.get(series.vname, module) + ': ';
            this.seriesValue = params.seriesLabel;
        }

        // returns nothing
        return value;
    }
}) },
"chart-type": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Reports.ChartTypeField
 * @alias SUGAR.App.view.fields.BaseReportsChartTypeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Chart-type FieldTemplate (base) 


    extendsFrom: 'BaseField',

    /**
     * The mapping for each of the chart types
     */
    mapping: {
        none: 'LBL_NO_CHART',
        hBarF: 'LBL_HORIZ_BAR',
        hGBarF: 'LBL_HORIZ_GBAR',
        vBarF: 'LBL_VERT_BAR',
        vGBarF: 'LBL_VERT_GBAR',
        pieF: 'LBL_PIE',
        funnelF: 'LBL_FUNNEL',
        lineF: 'LBL_LINE',
    },

    /**
     * Gets the correct mapping for the DB value
     *
     * @param {string} value The value from the server
     * @return {string} The mapped and translated value
     */
    format: function(value) {
        return app.lang.get(this.mapping[value], this.module);
    }
}) }
}}
,
"views": {
"base": {
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Reports.RecordlistView
 * @alias SUGAR.App.view.views.BaseReportsRecordlistView
 * @extends View.Views.Base.RecordListView
 */
({
	// Recordlist View (base) 

    extendsFrom: 'RecordListView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.contextEvents = _.extend({}, this.contextEvents, {
            'list:editreport:fire': 'editReport',
            'list:schedulereport:fire': 'scheduleReport',
            'list:viewschedules:fire': 'viewSchedules'
        });
        this._super('initialize', [options]);
    },

    /**
     * Go to the Reports Wizard Edit page
     *
     * @param {Data.Bean} model Selected row's model.
     * @param {RowActionField} field
     */
    editReport: function(model, field) {
        var route = app.bwc.buildRoute('Reports', model.id, 'ReportsWizard');
        app.router.navigate(route, {trigger: true});
    },

    /**
     * Open schedule report drawer
     * @param model
     * @param field
     */
    scheduleReport: function(model, field) {
        var newModel = app.data.createBean('ReportSchedules');
        newModel.set({
            report_id: model.get('id'),
            report_name: model.get('name')
        });
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: 'ReportSchedules',
                model: newModel
            }
        });
    },

    /**
     * View report schedules
     * @param model
     * @param field
     */
    viewSchedules: function(model, field) {
        var filterOptions = new app.utils.FilterOptions().config({
            initial_filter_label: model.get('name'),
            initial_filter: 'by_report',
            filter_populate: {
                'report_id': [model.get('id')]
            }
        });
        app.controller.loadView({
            module: 'ReportSchedules',
            layout: 'records',
            filterOptions: filterOptions.format()
        });
    }
}) },
"drillthrough-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Reports.DrillthroughHeaderpaneView
 * @alias SUGAR.App.view.views.BaseReportsDrillthroughHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Drillthrough-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        this._super('_renderHtml');

        this.layout.once('drillthrough:closedrawer:fire', _.bind(function() {
            this.$el.off();
            app.drawer.close();
        }, this));
    },

    /**
     * @inheritdoc
     */
    _formatTitle: function(title) {
        var chartModule = this.context.get('chartModule');
        return app.lang.get('LBL_MODULE_NAME', chartModule);
    }
}) },
"filter-rows": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Reports.FilterRowsView
 * @alias SUGAR.App.view.views.BaseReportsFilterRowsView
 * @extends View.Views.Base.FilterRowsView
 */
({
	// Filter-rows View (base) 

    extendsFrom: 'FilterRowsView',

    /**
     * @inheritdoc
     */
    loadFilterFields: function(module) {
        this._super('loadFilterFields', [module]);
        // last_run_date is a related datetime fields and shouldn't rely on its id_name
        if (this.fieldList && this.fieldList.last_run_date) {
            delete this.fieldList.last_run_date.id_name;
        }
    }
}) }
}}
,
"layouts": {
"base": {
"drillthrough-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Reports.DrillthroughListLayout
 * @alias SUGAR.App.view.layouts.BaseReportsDrillthroughListLayout
 * @extends View.Views.Base.ListLayout
 */
({
	// Drillthrough-list Layout (base) 

    extendsFrom: 'ListLayout',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // from this level down we should use target module instead of Reports
        // model needs to be a target module bean so some list level operations can work
        // for different module
        // for example, the function _filterMeta relies on the correct model
        var chartModule = options.context.get('chartModule');
        options.context.set('model', app.data.createBean(chartModule));
        options.context.set('collection', app.data.createBeanCollection(chartModule));

        options.module = chartModule;
        options = this._removeFieldSorting(options);
        this._super('initialize', [options]);
    },

    /**
     * Set the sortable property to false for all fields
     * We don't want to sort in the drill-through drawer
     *
     * @param {Object} options Backbone view options
     * @return {Object} options with the fields' sortable property set to false
     * @private
     */
    _removeFieldSorting: function(options) {
        var listMeta = app.metadata.getView(options.module, 'list');
        var fields = _.first(listMeta.panels).fields;
        var unsortableFields = _.each(fields, function(field) {
            field.sortable = false;
        });

        var panels = [{fields: unsortableFields}];
        options.meta.components[2].xmeta.panels = panels;
        return options;
    }
}) },
"drillthrough-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Reports.DrillthroughDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseReportsDrillthroughDrawerLayout
 * @extends View.Layout
 */
({
	// Drillthrough-drawer Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle',
        'List:Headerpane:Create',
        'List:Select:Down',
        'List:Select:Up',
        'List:Scroll:Left',
        'List:Scroll:Right',
        'List:Select:Open',
        'List:Inline:Edit',
        'List:Delete',
        'List:Inline:Cancel',
        'List:Inline:Save',
        'List:Favorite',
        'List:Follow',
        'List:Preview',
        'List:Select',
        'SelectAll:Checkbox',
        'SelectAll:Dropdown',
        'Filter:Search',
        'Filter:Create',
        'Filter:Edit',
        'Filter:Show'
    ],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * Cache for enum and enum like values
         */
        this.enums = {};
    },

    /**
     * Override the default loadData method to allow for manually constructing
     * context for each component in layout. We are loading data from the
     * ReportAPI in public method updateList. We need to first get any enum data
     * so that we can translate to english
     *
     * @override
     */
    loadData: function() {
        var enumsToFetch = this.context.get('enumsToFetch');
        // Make requests for any enums here so they can happen while the drawer is still rendering
        if (!_.isEmpty(enumsToFetch) && _.isEmpty(this.enums)) {
            this._loadEnumOptions(enumsToFetch);
        } else {
            this.updateList();
        }
    },
    /**
     * Make a request for each enum like field so we can reverse lookup values later
     *
     * @param enumsToFetch
     * @private
     */
    _loadEnumOptions: function(enumsToFetch) {
        var reportDef = this.context.get('reportData');
        var count = enumsToFetch.length;

        var enumSuccess = function(key, data) {
            count--;

            // cache the values inverted to help with reverse lookup
            this.enums[key] = _.invert(data);

            // I love that I have to simulate Promise.all but anyways, once
            // we have all our enum data, then make the record list request
            if (count === 0) {
                this.updateList();
            }
        };
        _.each(enumsToFetch, function(field) {
            var module = reportDef.full_table_list[field.table_key].module;
            var key = field.table_key + ':' + field.name;
            app.api.enumOptions(module, field.name, {
                success: _.bind(enumSuccess, this, key)
            });
        }, this);
    },

    /**
     * Fetch report related records based on drawer context as defined in
     * saved-reports-chart dashlet or Report detail view with context containing
     * a filter definition based on a chart click event. This method will also
     * render the list component in layout after data is fetched.
     */
    updateList: function() {
        var chartModule = this.context.get('chartModule');
        var reportId = this.context.get('reportId');
        var reportDef = this.context.get('reportData');
        var params = this.context.get('dashConfig');

        // At this point, we should have finished all translations and requests for translations so
        // we can finally build the filter in english
        var filterDef = SUGAR.charts.buildFilter(reportDef, params, this.enums);
        this.context.set('filterDef', filterDef);
        var useSavedFilters = this.context.get('useSavedFilters') || false;

        var endpoint = function(method, model, options, callbacks) {
            var params = _.extend(options.params || {},
                {view: 'list', group_filters: filterDef, use_saved_filters: useSavedFilters});
            var url = app.api.buildURL('Reports', 'records', {id: reportId}, params);
            return app.api.call('read', url, null, callbacks);
        };
        var callbacks = {
            success: _.bind(function(data) {
                if (this.disposed) {
                    return;
                }
                this.context.trigger('refresh:count');
                this.context.trigger('refresh:drill:labels');
            }, this),
            error: function(o) {
                app.alert.show('listfromreport_loading', {
                    level: 'error',
                    messages: app.lang.get('ERROR_RETRIEVING_DRILLTHRU_DATA', 'Reports')
                });
            },
            complete: function(data) {
                app.alert.dismiss('listfromreport_loading');
            }
        };
        var collection = this.context.get('collection');
        collection.module = chartModule;
        collection.model = app.data.getBeanClass(chartModule);
        collection.setOption('endpoint', endpoint);
        collection.setOption('fields', this.context.get('fields'));
        collection.fetch(callbacks);
        var massCollection = this.context.get('mass_collection');
        if (massCollection) {
            massCollection.setOption('endpoint', endpoint);
        }
    }
}) },
"drillthrough-pane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Reports.DrillthroughPaneLayout
 * @alias SUGAR.App.view.layouts.ReportsDrillthroughPaneLayout
 * @extends View.Layout
 */
({
	// Drillthrough-pane Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // configuration from clicked dashlet
        var config = this.context.get('dashConfig');

        var metadata = {
                component: 'saved-reports-chart',
                name: 'saved-reports-chart',
                type: 'saved-reports-chart',
                label: config.label || app.lang.get('LBL_DASHLET_SAVED_REPORTS_CHART', 'Reports'),
                description: 'LBL_DASHLET_SAVED_REPORTS_CHART_DESC',
                // module: this.context.get('module'), // this breaks Dashlet plugin at context.parent
                module: null,
                config: [],
                preview: []
            };

        var field = {
                type: 'chart',
                name: 'chart',
                label: 'LBL_CHART',
                view: 'detail',
                module: metadata.module
            };

        var component = {
                name: metadata.component,
                type: metadata.type,
                preview: true,
                context: this.context,
                module: metadata.module,
                custom_toolbar: 'no',
                chart: field
            };

        component.view = _.extend({module: metadata.module}, metadata.preview, component);

        this.initComponents([{
            layout: {
                type: 'dashlet',
                css_class: 'dashlets',
                config: false,
                preview: false,
                label: metadata.label,
                module: metadata.module,
                context: this.context,
                components: [
                    component
                ]
            }
        }], this.context);
        this.on('click:refresh_list_chart', this.refreshListChart, this);
    },

    /**
     * @inheritdoc
     */
    render: function() {
        var config = this.context.get('dashConfig');
        // Set the title of the side pane
        // label coming out of BWC html enoded, decode it first
        this.model.setDefault('title', $('<div/>').html(config.label).text());
        this._super('render');

        var dashlet = this.getComponent('dashlet').getComponent('saved-reports-chart');
        var config = this.context.get('dashConfig');
        var chartData = this.context.get('chartData');
        var reportData = this.context.get('reportData');
        var chartLabels = {groupLabel: config.groupLabel, seriesLabel: config.seriesLabel};
        this.context.set('chartLabels', chartLabels);
        var title = dashlet.$('.dashlet-title');

        // This will allow scrolling when drilling thru from Report detail view
        // but will respect the dashlet setting when drilling thru from SRC
        config.allowScroll = true;

        dashlet.settings.set(config);
        dashlet.reportData.set('rawChartParams', config);
        dashlet.reportData.set('rawReportData', reportData);
        // set reportData's rawChartData to the chartData from the source chart
        // this will trigger chart.js' change:rawChartData and the chart will update
        dashlet.reportData.set('rawChartData', chartData);

        return this;
    },

    /**
     * Refresh list and chart
     */
    refreshListChart: function() {
        var drawer = this.closestComponent('drawer').getComponent('drillthrough-drawer');
        drawer.updateList();
        var dashlet = this.getComponent('dashlet').getComponent('saved-reports-chart');
        dashlet.loadData();
    }
}) }
}}
,
"datas": {}

},
		"Forecasts":{"fieldTemplates": {
"base": {
"assignquota": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Forecasts.AssignQuotaField
 * @alias SUGAR.App.view.fields.BaseForecastsAssignQuotaField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Assignquota FieldTemplate (base) 

    extendsFrom: 'RowactionField',

    /**
     * Should be this disabled if it's not rendered?
     */
    disableButton: true,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.context.on('forecasts:worksheet:quota_changed', function() {
            this.disableButton = false;
            if (!this.disposed) {
                this.render();
            }
        }, this);

        this.context.on('forecasts:worksheet:committed', function() {
            this.disableButton = true;
            if (!this.disposed) {
                this.render();
            }
        }, this);

        this.context.on('forecasts:assign_quota', this.assignQuota, this);
    },

    /**
     * We override this so we can always disable the field
     *
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        // only set field as disabled if it's actually rendered into the dom
        // otherwise it will cause problems and not show correctly when disabled
        if (this.getFieldElement().length > 0) {
            this.setDisabled(this.disableButton);
        }
    },

    /**
     * Only show this if the current user is a manager and we are on their manager view
     *
     * @inheritdoc
     */
    hasAccess: function() {
        var su = (this.context.get('selectedUser')) || app.user.toJSON(),
            isManager = su.is_manager || false,
            showOpps = su.showOpps || false;
        return (su.id === app.user.get('id') && isManager && showOpps === false);
    },

    /**
     * Run the XHR Request to Assign the Quotas
     *
     * @param {string} worksheetType            What worksheet are we on
     * @param {object} selectedUser             What user is calling the assign quota
     * @param {string} selectedTimeperiod        Which timeperiod are we assigning quotas for
     */
    assignQuota: function(worksheetType, selectedUser, selectedTimeperiod) {
        app.api.call('create', app.api.buildURL('ForecastManagerWorksheets/assignQuota'), {
            'user_id': selectedUser.id,
            'timeperiod_id': selectedTimeperiod
        }, {
            success: _.bind(function(o) {
                app.alert.dismiss('saving_quota');
                app.alert.show('success', {
                    level: 'success',
                    autoClose: true,
                    autoCloseDelay: 10000,
                    title: app.lang.get("LBL_FORECASTS_WIZARD_SUCCESS_TITLE", "Forecasts") + ":",
                    messages: [app.lang.get('LBL_QUOTA_ASSIGNED', 'Forecasts')]
                });
                this.disableButton = true;
                this.context.trigger('forecasts:quota_assigned');
                if (!this.disposed) {
                    this.render();
                }
            }, this)
        });
    }
}) },
"commitlog": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Forecasts.CommitlogField
 * @alias SUGAR.App.view.fields.BaseForecastsCommitlogField
 * @extends View.Fields.Base.BaseField
 */
({
	// Commitlog FieldTemplate (base) 

    /**
     * Stores the historical log of the Forecast entries
     */
    commitLog: [],

    /**
     * Previous committed date value to display in the view
     */
    previousDateEntered: '',

    initialize: function(options) {
        app.view.Field.prototype.initialize.call(this, options);

        this.on('show', function() {
            if (!this.disposed) {
                this.render();
            }
        }, this);
    },

    bindDataChange: function() {
        this.collection.on('reset', function() {
            this.hide();
            this.buildCommitLog();
        }, this);

        this.context.on('forecast:commit_log:trigger', function() {
            if(!this.isVisible()) {
                this.show();
            } else {
                this.hide();
            }
        }, this);
    },

    /**
     * Does the heavy lifting of looping through models to build the commit history
     */
    buildCommitLog: function() {
        //Reset the history log
        this.commitLog = [];

        if(_.isEmpty(this.collection.models)) {
            return;
        }

        // get the first model so we can get the previous date entered
        var previousModel = _.first(this.collection.models);

        // parse out the previous date entered
        var dateEntered = new Date(Date.parse(previousModel.get('date_modified')));
        if (dateEntered == 'Invalid Date') {
            dateEntered = previousModel.get('date_modified');
        }
        // set the previous date entered in the users format
        this.previousDateEntered = app.date.format(dateEntered, app.user.getPreference('datepref') + ' ' + app.user.getPreference('timepref'));

        //loop through from oldest to newest to build the log correctly
        var loopPreviousModel = '',
            models = _.clone(this.collection.models).reverse(),
            selectedUser = this.view.context.get('selectedUser'),
            forecastType = app.utils.getForecastType(selectedUser.is_manager, selectedUser.showOpps);
        _.each(models, function(model) {
            this.commitLog.push(app.utils.createHistoryLog(loopPreviousModel, model, forecastType === 'Direct'));
            loopPreviousModel = model;
        }, this);

        //reset the order of the history log for display
        this.commitLog.reverse();
    }
}) },
"date": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Forecasts.DateField
 * @alias SUGAR.App.view.fields.BaseForecastsDateField
 * @extends View.Fields.Base.DateField
 */
({
	// Date FieldTemplate (base) 

    extendsFrom: 'DateField',

    /**
     * @inheritdoc
     *
     * Add `ClickToEdit` plugin to the list of required plugins.
     */
    _initPlugins: function() {
        this._super('_initPlugins');

        if (this.options && this.options.def && this.options.def.click_to_edit) {
            this.plugins = _.union(this.plugins, [
                'ClickToEdit'
            ]);
        }

        return this;
    }
}) },
"lastcommit": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Forecasts.LastcommitField
 * @alias SUGAR.App.view.fields.BaseForecastsLastcommitField
 * @extends View.Fields.Base.BaseField
 */
({
	// Lastcommit FieldTemplate (base) 


    commit_date: undefined,

    data_points: [],

    points: [],

    events: {
        'click': 'triggerHistoryLog'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.points = [];
        this.data_points = [];

        // map what points we should display
        _.each(options.def.datapoints, function(point) {
            if (app.utils.getColumnVisFromKeyMap(point, 'forecastsWorksheet')) {
                this.points.push(point);
            }
        }, this);
    },

    /**
     * Toggles the commit history log
     */
    triggerHistoryLog: function() {
        this.$('i').toggleClass('fa-caret-down fa-caret-up');
        this.context.trigger('forecast:commit_log:trigger');
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.collection.on('reset', function() {
            // get the first line
            this.data_points = [];
            var model = _.first(this.collection.models)

            if (!_.isUndefined(model)) {
                this.commit_date = model.get('date_modified');

                this.data_points = this.processDataPoints(model);
            } else {
                this.commit_date = undefined;
            }

            if (!this.disposed) {
                this.render();
            }
        }, this);
    },

    /**
     * Processes a Forecast collection's models into datapoints
     * @param {Bean} model
     * @returns {Array}
     */
    processDataPoints: function(model) {
        var points = [],
            noAccessTemplate = app.template.getField('base', 'noaccess')(this);

        _.each(this.points, function(point) {
            // make sure we can view data for this point
            var point_data = {};
            if (app.acl.hasAccess('read', 'ForecastWorksheets', app.user.get('id'), point)) {
                point_data.value = model.get(point)
            } else {
                point_data.error = noAccessTemplate;
            }
            points.push(point_data);
        }, this);

        return points;
    }
}) },
"fiscal-year": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Fiscal-year FieldTemplate (base) 

    extendsFrom: 'EnumField',

    loadEnumOptions: function(fetch, callback) {
        this._super('loadEnumOptions', [fetch, callback]);

        var startYear = this.options.def.startYear;

        _.each(this.items, function(value, key, list) {
            list[key] = list[key].replace("{{year}}", startYear++);
        }, this);
    }
}) },
"button": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Forecasts.ButtonField
 * @alias SUGAR.App.view.fields.BaseForecastsButtonField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Button FieldTemplate (base) 

    extendsFrom: 'ButtonField',

    /**
     * Override so we can have a custom hasAccess for forecast to check on the header-pane buttons
     *
     * @inheritdoc
     */
    hasAccess: function() {
        // this is a special use case for forecasts
        // currently the only buttons that set acl_action == 'current_user' are the save_draft and commit buttons
        // if it's not equal to 'current_user' then go up the prototype chain.
        if(this.def.acl_action == 'current_user') {
            var su = this.context.get('selectedUser') || app.user.toJSON();
            return su.id === app.user.get('id');
        } else {
            return this._super('hasAccess');
        }
    }
}) },
"quotapoint": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Forecasts.QuotapointField
 * @alias SUGAR.App.view.fields.BaseForecastsQuotapointField
 * @extends View.Fields.Base.BaseField
 */
({
	// Quotapoint FieldTemplate (base) 


    /**
     * The quota amount to display in the UI
     */
    quotaAmount: undefined,

    /**
     * The current selected user object
     */
    selectedUser: undefined,

    /**
     * The current selected timeperiod id
     */
    selectedTimePeriod: undefined,

    /**
     * Hang on to the user-preferred currency id for formatting
     */
    userCurrencyID: undefined,

    /**
     * Used by the resize function to wait a certain time before adjusting
     */
    resizeDetectTimer: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.view.Field.prototype.initialize.call(this, options);

        this.quotaAmount = 0.00;
        this.selectedUser = this.context.get('selectedUser');
        this.selectedTimePeriod = this.context.get('selectedTimePeriod');
        this.userCurrencyID = app.user.getPreference('currency_id');

        //if user resizes browser, adjust datapoint layout accordingly
        $(window).on('resize.datapoints', _.bind(this.resize, this));
        this.on('render', function() {
            this.resize();
            return true;
        }, this);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.context.on('change:selectedUser', function(ctx, user) {
            this.selectedUser = user;

            // reload data when the selectedTimePeriod changes
            this.loadData({});
        }, this);

        this.context.on('change:selectedTimePeriod', function(ctx, timePeriod) {
            this.selectedTimePeriod = timePeriod;

            // reload data when the selectedTimePeriod changes
            this.loadData({});
        }, this);

        this.loadData();
    },

    /**
     * If this is a top-level manager, we need to add an event listener for
     * forecasts:worksheet:totals so the top-level manager's quota can update live
     * with changes done in the manager worksheet reflected here
     *
     * @param isTopLevelManager {Boolean} if the user is a top-level manager or not
     */
    toggleTotalsListeners: function(isTopLevelManager) {
        if(isTopLevelManager) {
            this.hasListenerAdded = true;
            // Only for top-level manager whose quota can change on the fly
            this.context.on('forecasts:worksheet:totals', function(totals) {
                var quota = 0.00;
                if(_.has(totals, 'quota')) {
                    quota = totals.quota;
                } else {
                    quota = this.quotaAmount;
                }
                this.quotaAmount = quota;
                if (!this.disposed) {
                    this.render();
                }
            }, this);
            // if we're on the manager worksheet view, get the collection and calc quota
            if(!this.selectedUser.showOpps) {
                // in case this gets added after the totals event was dispatched
                var collection = app.utils.getSubpanelCollection(this.context, 'ForecastManagerWorksheets'),
                    quota = 0.00;

                _.each(collection.models, function(model) {
                    quota = app.math.add(quota, model.get('quota'));
                }, this);
                this.quotaAmount = quota;
                this.render();
            }
        } else if(this.hasListenerAdded) {
            this.hasListenerAdded = false;
            this.context.off('forecasts:worksheet:totals', null, this);
        }
    },

    /**
     * Builds widget url
     *
     * @return {*} url to call
     */
    getQuotasURL: function() {
        var method = (this.selectedUser.is_manager && this.selectedUser.showOpps) ? 'direct' : 'rollup',
            url = 'Forecasts/' + this.selectedTimePeriod + '/quotas/' + method + '/' + this.selectedUser.id;

        return app.api.buildURL(url, 'read');
    },

    /**
     * Overrides loadData to load from a custom URL
     *
     * @inheritdoc
     */
    loadData: function(options) {
        var url = this.getQuotasURL(),
            cb = {
                context: this,
                success: this.handleQuotaData,
                complete: options ? options.complete : null
            };

        app.api.call('read', url, null, null, cb);
    },

    /**
     * Success handler for the Quotas endpoint, sets quotaAmount to returned values and updates the UI
     * @param quotaData
     */
    handleQuotaData: function(quotaData) {
        this.quotaAmount = quotaData.amount;

        // Check to see if we need to add an event listener to the context for the worksheet totals
        this.toggleTotalsListeners(quotaData.is_top_level_manager);

        // update the UI
        if (!this.disposed) {
            this.render();
        }
    },

    /**
     * Adjusts the layout
     */
    adjustDatapointLayout: function(){
        if(this.view.$el) {
            var thisView$El = this.view.$el,
                parentMarginLeft = thisView$El.find(".topline .datapoints").css("margin-left"),
                parentMarginRight = thisView$El.find(".topline .datapoints").css("margin-right"),
                timePeriodWidth = thisView$El.find(".topline .span4").outerWidth(true),
                toplineWidth = thisView$El.find(".topline ").width(),
                collection = thisView$El.find(".topline div.pull-right").children("span"),
                collectionWidth = parseInt(parentMarginLeft) + parseInt(parentMarginRight);

            collection.each(function(index){
                collectionWidth += $(this).children("div.datapoint").outerWidth(true);
            });

            //change width of datapoint div to span entire row to make room for more numbers
            if((collectionWidth+timePeriodWidth) > toplineWidth) {
                thisView$El.find(".topline div.hr").show();
                thisView$El.find(".info .last-commit").find("div.hr").show();
                thisView$El.find(".topline .datapoints").removeClass("span8").addClass("span12");
                thisView$El.find(".info .last-commit .datapoints").removeClass("span8").addClass("span12");
                thisView$El.find(".info .last-commit .commit-date").removeClass("span4").addClass("span12");

            } else {
                thisView$El.find(".topline div.hr").hide();
                thisView$El.find(".info .last-commit").find("div.hr").hide();
                thisView$El.find(".topline .datapoints").removeClass("span12").addClass("span8");
                thisView$El.find(".info .last-commit .datapoints").removeClass("span12").addClass("span8");
                thisView$El.find(".info .last-commit .commit-date").removeClass("span12").addClass("span4");
                var lastCommitHeight = thisView$El.find(".info .last-commit .commit-date").height();
                thisView$El.find(".info .last-commit .datapoints div.datapoint").height(lastCommitHeight);
            }

            //adjust height of last commit datapoints
            var index = this.$el.index() + 1,
                width = this.$el.find("div.datapoint").outerWidth(),
                datapointLength = thisView$El.find(".info .last-commit .datapoints div.datapoint").length,
                sel = thisView$El.find('.last-commit .datapoints div.datapoint:nth-child('+index+')');
            if (datapointLength > 2 && index <= 2 || datapointLength == 2 && index == 1) {
                $(sel).width(width-18);
            }  else {
                $(sel).width(width);
            }
        }
    },

    /**
     * Sets a timer to adjust the layout
     */
    resize: function() {
        //The resize event is fired many times during the resize process. We want to be sure the user has finished
        //resizing the window that's why we set a timer so the code should be executed only once
        if (this.resizeDetectTimer) {
            clearTimeout(this.resizeDetectTimer);
        }
        this.resizeDetectTimer = setTimeout(_.bind(function() {
            this.adjustDatapointLayout();
        }, this), 250);
    }
}) },
"reportingUsers": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Forecasts.ReportingUsersField
 * @alias SUGAR.App.view.fields.BaseForecastsReportingUsersField
 * @extends View.Fields.Base.BaseField
 */
({
	// ReportingUsers FieldTemplate (base) 


    /**
     * The JS Tree Object
     */
    jsTree: {},

    /**
     * The end point we need to hit
     */
    reporteesEndpoint: '',

    /**
     * Current end point hit
     */
    currentTreeUrl: '',

    /**
     * Current root It
     */
    currentRootId: '',

    /**
     * Selected User Storage
     */
    selectedUser: {},

    /**
     * Has the base init selected the proper user?  This is needed to prevent a double selectedUser change from fireing
     */
    initHasSelected: false,

    /**
     * Previous user
     */
    previousUserName: undefined,

    /**
     * Initialize the View
     *
     * @constructor
     * @param {Object} options
     */
    initialize: function(options) {
        app.view.Field.prototype.initialize.call(this, options);

        this.reporteesEndpoint = app.api.buildURL("Forecasts/reportees") + '/';

        this.selectedUser = this.context.get('selectedUser') || app.user.toJSON();
        this.currentTreeUrl = this.reporteesEndpoint + this.selectedUser.id;
        this.currentRootId = this.selectedUser.id;
    },

    /**
     * overriding _dispose to make sure custom added jsTree listener is removed
     * @private
     */
    _dispose: function() {
        if (app.user.get('is_manager') && !_.isEmpty(this.jsTree)) {
            this.jsTree.off();
        }
        app.view.Field.prototype._dispose.call(this);
    },

    /**
     * Only run the render if the user is a manager as that is the only time we want the tree to display.
     */
    render: function() {
        if (app.user.get('is_manager')) {
            app.view.Field.prototype.render.call(this);
        }
    },

    /**
     * Clean up any left over bound data to our context
     */
    unbindData: function() {
        app.view.Field.prototype.unbindData.call(this);
    },
    
    /**
     * set up event listeners
     */
    bindDataChange: function(){
        this.context.on("forecasts:user:canceled", function(){
            this.initHasSelected = false;
            this.selectJSTreeNode(this.previousUserName);
            this.initHasSelected = true;
        }, this);
    },

    /**
     * Function to give a final check before rendering to see if we really need to render
     * Any time the selectedUser changes on context we run through this function to
     * see if we should render the tree again
     *
     * @param context
     * @param selectedUser {Object} the current selectedUser on the context
     */
    checkRender: function(context, selectedUser) {
        // handle the case for user clicking MyOpportunities first
        this.selectedUser = selectedUser;
        if (selectedUser.showOpps) {
            var nodeId = (selectedUser.is_manager ? 'jstree_node_myopps_' : 'jstree_node_') + selectedUser.user_name;
            this.selectJSTreeNode(nodeId)
            // check before render if we're trying to re-render tree with a fresh root user
            // otherwise do not re-render tree
            // also make sure we're not re-rendering tree for a rep
        } else if (this.currentRootId != selectedUser.id) {
            if (selectedUser.is_manager) {
                // if user is a manager we'll be re-rendering the tree
                // no need to re-render the tree if not a manager because the dataset
                // stays the same

                this.currentRootId = selectedUser.id;
                this.currentTreeUrl = this.reporteesEndpoint + selectedUser.id;
                this.rendered = false;
                if (!this.disposed) {
                    this.render();
                }
            } else {
                // user is not a manager but if this event is coming from the worksheets
                // we need to "select" the user on the tree to show they're selected

                // create node ID
                var nodeId = 'jstree_node_' + selectedUser.user_name;

                // select node only if it is not the already selected node
                if (this.jsTree.jstree('get_selected').attr('id') != nodeId) {
                    this.selectJSTreeNode(nodeId)
                }
            }
        }
    },

    /**
     * Function that handles deselecting any selected nodes then selects the nodeId
     *
     * @param nodeId {String} the node id starting with "jstree_node_"
     */
    selectJSTreeNode: function(nodeId) {
        // jstree kept trying to hold on to the root node css staying selected when
        // user clicked a user's name from the worksheet, so explicitly causing a deselection
        this.jsTree.jstree('deselect_all');

        this.jsTree.jstree('select_node', '#' + nodeId);
    },


    /**
     * Recursively step through the tree and for each node representing a tree node, run the data attribute through
     * the replaceHTMLChars function.  This function supports n-levels of the tree hierarchy.
     *
     * @param data The data structure returned from the REST API Forecasts/reportees endpoint
     * @param ctx A reference to the view's context so that we may recursively call _recursiveReplaceHTMLChars
     * @return object The modified data structure after all the parent and children nodes have been stepped through
     * @private
     */
    _recursiveReplaceHTMLChars: function(data, ctx) {

        _.each(data, function(entry, index) {

            //Scan for the nodes with the data attribute.  These are the nodes we are interested in
            if (entry.data) {
                data[index].data = (function(value) {
                    return value.replace(/&amp;/gi, '&').replace(/&lt;/gi, '<').replace(/&gt;/gi, '>').replace(/&#039;/gi, '\'').replace(/&quot;/gi, '"');
                })(entry.data);

                if (entry.children) {
                    //For each children found (if any) then call _recursiveReplaceHTMLChars again.  Notice setting
                    //childEntry to an Array.  This is crucial so that the beginning _.each loop runs correctly.
                    _.each(entry.children, function(childEntry, index2) {
                        entry.children[index2] = ctx._recursiveReplaceHTMLChars([childEntry]);
                        if (childEntry.attr.rel == 'my_opportunities' && childEntry.metadata.id == app.user.get('id')) {
                            childEntry.data = app.utils.formatString(app.lang.get('LBL_MY_MANAGER_LINE', 'Forecasts'), [childEntry.data]);
                        }
                    }, this);
                }
            }
        }, this);

        return data;
    },

    /**
     * Renders JSTree
     * @param ctx
     * @param options
     * @protected
     */
    _render: function(ctx, options) {
        app.view.Field.prototype._render.call(this, ctx, options);

        var options = {};
        // breaking out options as a proper object to allow for bind
        options.success = _.bind(function(data) {
            this.createTree(data);
        }, this);

        app.api.call('read', this.currentTreeUrl, null, options);
    },

    createTree: function(data) {
        // make sure we're using an array
        // if the data coming from the endpoint is an array with one element
        // it gets converted to a JS object in the process of getting here
        if (!_.isArray(data)) {
            data = [ data ];
        }

        var treeData = this._recursiveReplaceHTMLChars(data, this),
            selectedUser = this.context.get('selectedUser'),
            nodeId = (selectedUser.is_manager && selectedUser.showOpps ? 'jstree_node_myopps_' : 'jstree_node_') + selectedUser.user_name;
        treeData.ctx = this.context;

        this.jsTree = $(".jstree-sugar").jstree({
            "plugins": ["json_data", "ui", "crrm", "types", "themes"],
            "json_data": {
                "data": treeData
            },
            "ui": {
                // when the tree re-renders, initially select the root node
                "initially_select": [ nodeId ]
            },
            "types": {
                "types": {
                    "types": {
                        "parent_link": {},
                        "manager": {},
                        "my_opportunities": {},
                        "rep": {},
                        "root": {}
                    }
                }
            }
        }).on("reselect.jstree", _.bind(function() {
                // this is needed to stop the double select when the tree is rendered
                this.initHasSelected = true;
            }, this))
        .on("select_node.jstree", _.bind(function(event, data) {
            if (this.initHasSelected) {
                this.previousUserName = (this.selectedUser.is_manager && this.selectedUser.showOpps ? 'jstree_node_myopps_' : 'jstree_node_') + this.selectedUser.user_name;

                var jsData = data.inst.get_json(),
                    nodeType = jsData[0].attr.rel,
                    userData = jsData[0].metadata,
                    showOpps = false;

                // if user clicked on a "My Opportunities" node
                // set this flag true
                if (nodeType == "my_opportunities" || nodeType == "rep") {
                    showOpps = true
                }

                var selectedUser = {
                    'id': userData.id,
                    'user_name': userData.user_name,
                    'full_name': userData.full_name,
                    'first_name': userData.first_name,
                    'last_name': userData.last_name,
                    'reports_to_id': userData.reports_to_id,
                    'reports_to_name': userData.reports_to_name,
                    'is_manager': (nodeType != 'rep'),
                    'is_top_level_manager': (nodeType != 'rep' && _.isEmpty(userData.reports_to_id)),
                    'showOpps': showOpps,
                    'reportees': []
                };

                this.context.trigger('forecasts:user:changed', selectedUser, this.context);
            }
        }, this));

        if (treeData) {
            var rootId = -1;

            if (treeData.length == 1) {
                // this case appears when "Parent" is not present
                rootId = treeData[0].metadata.id;
            } else if (treeData.length == 2) {
                // this case appears with a "Parent" link label in the return set
                // treeData[0] is the Parent link, treeData[1] is our root user node
                rootId = treeData[1].metadata.id;
            }

            this.currentRootId = rootId;
        }

        // add proper class onto the tree
        this.$el.find('#people').addClass("jstree-sugar");

    }
}) },
"datapoint": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Datapoints in the info pane for Forecasts
 *
 * @class View.Fields.Base.Forecasts.DatapointField
 * @alias SUGAR.App.view.fields.BaseForecastsDatapointField
 * @extends View.Fields.Base.BaseField
 */
({
	// Datapoint FieldTemplate (base) 


    /**
     * Tracking the type of totals we are seeing
     */
    previous_type: '',

    /**
     * Arrow Colors
     */
    arrow: '',

    /**
     * What was the first total we got for a given type
     */
    initial_total: '',

    /**
     * The total we want to display
     */
    total: 0,

    /**
     * Can we actually display this field and have the data binding on it
     */
    hasAccess: true,

    /**
     * Do we have access from the ForecastWorksheet Level to show data here?
     */
    hasDataAccess: true,

    /**
     * What to show when we don't have access to the data
     */
    noDataAccessTemplate: undefined,

    /**
     * Holds the totals field name
     */
    total_field: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.total_field = this.total_field || this.name;

        this.hasAccess = app.utils.getColumnVisFromKeyMap(this.name, 'forecastsWorksheet');
        this.hasDataAccess = app.acl.hasAccess('read', 'ForecastWorksheets', app.user.get('id'), this.name);
        if (this.hasDataAccess === false) {
            this.noDataAccessTemplate = app.template.getField('base', 'noaccess')(this);
        }

        // before we try and render, lets see if we can actually render this field
        this.before('render', function() {
            if (!this.hasAccess) {
                return false;
            }
            // adjust the arrow
            this.arrow = this._getArrowIconColorClass(this.total, this.initial_total);
            this.checkIfNeedsCommit();
            return true;
        }, this);
        //if user resizes browser, adjust datapoint layout accordingly
        $(window).on('resize.datapoints', _.bind(this.resize, this));
        this.on('render', function() {
            if (!this.hasAccess) {
                return false;
            }
            this.resize();
            return true;
        }, this);
    },

    /**
     * Check to see if the worksheet needs commit
     */
    checkIfNeedsCommit: function() {
        // if the initial_total is an empty string (default value) don't run this
        if (!_.isEqual(this.initial_total, '') && app.math.isDifferentWithPrecision(this.total, this.initial_total)) {

            this.context.trigger('forecasts:worksheet:needs_commit', null);
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        $(window).off('resize.datapoints');

        // make sure we've cleared the resize timer before navigating away
        clearInterval(this.resizeDetectTimer);

        this._super('_dispose');
    },

    /**
     * Overwrite this to only place the placeholder if we actually have access to view it
     *
     * @return {*}
     */
    getPlaceholder: function() {
        if (this.hasAccess) {
            return this._super('getPlaceholder');
        }

        return '';
    },

    /**
     * Adjusts the CSS for the datapoint
     */
    adjustDatapointLayout: function() {
        if (this.hasAccess) {
            var parentMarginLeft = this.view.$('.topline .datapoints').css('margin-left'),
                parentMarginRight = this.view.$('.topline .datapoints').css('margin-right'),
                timePeriodWidth = this.view.$('.topline .span4').outerWidth(true),
                toplineWidth = this.view.$('.topline ').width(),
                collection = this.view.$('.topline div.pull-right').children('span'),
                collectionWidth = parseInt(parentMarginLeft) + parseInt(parentMarginRight);

            collection.each(function(index) {
                collectionWidth += $(this).children('div.datapoint').outerWidth(true);
            });

            //change width of datapoint div to span entire row to make room for more numbers
            if ((collectionWidth + timePeriodWidth) > toplineWidth) {
                this.view.$('.topline div.hr').show();
                this.view.$('.info .last-commit').find('div.hr').show();
                this.view.$('.topline .datapoints').removeClass('span8').addClass('span12');
                this.view.$('.info .last-commit .datapoints').removeClass('span8').addClass('span12');
                this.view.$('.info .last-commit .commit-date').removeClass('span4').addClass('span12');

            } else {
                this.view.$('.topline div.hr').hide();
                this.view.$('.info .last-commit').find('div.hr').hide();
                this.view.$('.topline .datapoints').removeClass('span12').addClass('span8');
                this.view.$('.info .last-commit .datapoints').removeClass('span12').addClass('span8');
                this.view.$('.info .last-commit .commit-date').removeClass('span12').addClass('span4');
                var lastCommitHeight = this.view.$('.info .last-commit .commit-date').height();
                this.view.$('.info .last-commit .datapoints div.datapoint').height(lastCommitHeight);
            }
            //adjust height of last commit datapoints
            var index = this.$el.index(),
                width = this.$('div.datapoint').outerWidth(),
                datapointLength = this.view.$('.info .last-commit .datapoints div.datapoint').length,
                sel = this.view.$('.last-commit .datapoints div.datapoint:nth-child(' + index + ')');
            if (datapointLength > 2 && index <= 2 || datapointLength == 2 && index == 1) {
                // RTL was off 1px
                var widthMod = (app.lang.direction === 'rtl') ? 7 : 8;
                $(sel).width(width - widthMod);
            } else {
                $(sel).width(width);
            }
        }
    },

    /**
     * Resizes the datapoint on window resize
     */
    resize: function() {
        //The resize event is fired many times during the resize process. We want to be sure the user has finished
        //resizing the window that's why we set a timer so the code should be executed only once
        if (this.resizeDetectTimer) {
            clearTimeout(this.resizeDetectTimer);
        }
        this.resizeDetectTimer = setTimeout(_.bind(function() {
            this.adjustDatapointLayout();
        }, this), 250);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (!this.hasAccess) {
            return;
        }

        this.context.on('change:selectedUser change:selectedTimePeriod', function() {
            this.initial_total = '';
            this.total = 0;
            this.arrow = '';
        }, this);

        // any time the main forecast collection is reset this contains the commit history
        this.collection.on('reset', this._onCommitCollectionReset, this);
        this.context.on('forecasts:worksheet:totals', this._onWorksheetTotals, this);
        this.context.on('forecasts:worksheet:committed', this._onWorksheetCommit, this);
    },

    /**
     * Collection Reset Handler
     * @param {Backbone.Collection} collection
     * @private
     */
    _onCommitCollectionReset: function(collection) {
        // get the first line
        var model = _.first(collection.models);
        if (!_.isUndefined(model)) {
            this.initial_total = model.get(this.total_field);
            if (!this.disposed) {
                this.render();
            }
        }
    },

    /**
     * Worksheet Totals Handler
     * @param {Object} totals       The totals from the worksheet
     * @param {String} type         Which worksheet are we dealing with it
     * @private
     */
    _onWorksheetTotals: function(totals, type) {
        var field = this.total_field;
        if (type == 'manager') {
            // split off '_case'
            field = field.split('_')[0] + '_adjusted';
        }
        this.total = totals[field];
        this.previous_type = type;

        if (!this.disposed) {
            this.render();
        }
    },

    /**
     * What to do when the worksheet is committed
     *
     * @param {String} type     What type of worksheet was committed
     * @param {Object} forecast What was committed for the timeperiod
     * @private
     */
    _onWorksheetCommit: function(type, forecast) {
        var field = this.total_field;
        if (type == 'manager') {
            // split off '_case'
            field = field.split('_')[0] + '_adjusted';
        }
        this.total = forecast[field];
        this.initial_total = forecast[field];
        this.arrow = '';
        if (!this.disposed) {
            this.render();
        }
    },

    /**
     * Returns the CSS classes for an up or down arrow icon
     *
     * @param {String|Number} newValue the new value
     * @param {String|Number} oldValue the previous value
     * @return {String} css classes for up or down arrow icons, if the values didn't change, returns ''
     * @private
     */
    _getArrowIconColorClass: function(newValue, oldValue) {
        var cls = '';

        // figure out if it changed here based
        if (app.math.isDifferentWithPrecision(newValue, oldValue)) {
            cls = (newValue > oldValue) ? ' fa-arrow-up font-green' : ' fa-arrow-down font-red';
        }
        return cls;
    }
}) }
}}
,
"views": {
"base": {
"config-worksheet-columns": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastsConfigWorksheetColumnsView
 * @alias SUGAR.App.view.layouts.BaseForecastsConfigWorksheetColumnsView
 * @extends View.Views.Base.ConfigPanelView
 */
({
	// Config-worksheet-columns View (base) 

    extendsFrom: 'ConfigPanelView',

    /**
     * Holds the select2 reference to the #wkstColumnSelect element
     */
    wkstColumnsSelect2: undefined,

    /**
     * Holds the default/selected items
     */
    selectedOptions: [],

    /**
     * Holds all items
     */
    allOptions: [],

    /**
     * The field object id/label for likely_case
     */
    likelyFieldObj: {},

    /**
     * The field object id/label for best_case
     */
    bestFieldObj: {},

    /**
     * The field object id/label for worst_case
     */
    worstFieldObj: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // patch metadata for if opps_view_by is Opportunities, not RLIs
        if (app.metadata.getModule('Opportunities', 'config').opps_view_by === 'Opportunities') {
            _.each(_.first(options.meta.panels).fields, function(field) {
                if (field.label_module && field.label_module === 'RevenueLineItems') {
                    field.label_module = 'Opportunities';
                }
            });
        }

        this._super('initialize', [options]);

        this.allOptions = [];
        this.selectedOptions = [];

        var cfgFields = this.model.get('worksheet_columns'),
            index = 0;

        // set up scenarioOptions
        _.each(this.meta.panels[0].fields, function(field) {
            var obj = {
                    id: field.name,
                    text: app.lang.get(field.label, this._getLabelModule(field.name, field.label_module)),
                    index: index,
                    locked: field.locked || false
                },
                cField = _.find(cfgFields, function(cfgField) {
                    return cfgField == field.name;
                }, this),
                addFieldToFullList = true;

            // save the field objects
            if (field.name == 'best_case') {
                this.bestFieldObj = obj;
                addFieldToFullList = (this.model.get('show_worksheet_best') === 1);
            } else if (field.name == 'likely_case') {
                this.likelyFieldObj = obj;
                addFieldToFullList = (this.model.get('show_worksheet_likely') === 1);
            } else if (field.name == 'worst_case') {
                this.worstFieldObj = obj;
                addFieldToFullList = (this.model.get('show_worksheet_worst') === 1);
            }

            if (addFieldToFullList) {
                this.allOptions.push(obj);
            }

            // If the current field being processed was found in the config fields,
            if (!_.isUndefined(cField)) {
                // push field to defaults
                this.selectedOptions.push(obj);
            }

            index++;
        }, this);
    },

    /**
     * Empty function as the title values have already been set properly
     * with the change:worksheet_columns event handler
     *
     * @inheritdoc
     */
    _updateTitleValues: function() {
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:worksheet_columns', function() {
            var arr = [],
                cfgFields = this.model.get('worksheet_columns'),
                metaFields = this.meta.panels[0].fields;

            _.each(metaFields, function(metaField) {
                _.each(cfgFields, function(field) {
                    if (metaField.name == field) {
                        arr.push(
                            app.lang.get(
                                metaField.label,
                                this._getLabelModule(metaField.name, metaField.label_module)
                            )
                        );
                    }
                }, this);
            }, this);
            this.titleSelectedValues = arr.join(', ');

            // Handle truncating the title string and adding "..."
            this.titleSelectedValues = this.titleSelectedValues.slice(0, 50) + '...';

            this.updateTitle();
        }, this);

        // trigger the change event to set the title when this gets added
        this.model.trigger('change:worksheet_columns');

        this.model.on('change:scenarios', function() {
            // check model settings and update select2 options
            if (this.model.get('show_worksheet_best')) {
                this.addOption(this.bestFieldObj);
            } else {
                this.removeOption(this.bestFieldObj);
            }

            if (this.model.get('show_worksheet_likely')) {
                this.addOption(this.likelyFieldObj);
            } else {
                this.removeOption(this.likelyFieldObj);
            }

            if (this.model.get('show_worksheet_worst')) {
                this.addOption(this.worstFieldObj);
            } else {
                this.removeOption(this.worstFieldObj);
            }

            // force render
            this._render();

            // update the model, since a field was added or removed
            var arr = [];
            _.each(this.selectedOptions, function(field) {
                arr.push(field.id);
            }, this);

            this.model.set('worksheet_columns', arr);
        }, this);
    },

    /**
     * Adds a field object to allOptions & selectedOptions if it is not found in those arrays
     *
     * @param {Object} fieldObj
     */
    addOption: function(fieldObj) {
        if (!_.contains(this.allOptions, fieldObj)) {
            this.allOptions.splice(fieldObj.index, 0, fieldObj);
            this.selectedOptions.splice(fieldObj.index, 0, fieldObj);
        }
    },

    /**
     * Removes a field object to allOptions & selectedOptions if it is not found in those arrays
     *
     * @param {Object} fieldObj
     */
    removeOption: function(fieldObj) {
        this.allOptions = _.without(this.allOptions, fieldObj);
        this.selectedOptions = _.without(this.selectedOptions, fieldObj);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // handle setting up select2 options
        this.wkstColumnsSelect2 = this.$('#wkstColumnsSelect').select2({
            data: this.allOptions,
            multiple: true,
            containerCssClass: 'select2-choices-pills-close',
            initSelection: _.bind(function(element, callback) {
                callback(this.selectedOptions);
            }, this)
        });
        this.wkstColumnsSelect2.select2('val', this.selectedOptions);

        this.wkstColumnsSelect2.on('change', _.bind(this.handleColumnModelChange, this));
    },

    /**
     * Handles the select2 adding/removing columns
     *
     * @param {Object} evt change event from the select2 selected values
     */
    handleColumnModelChange: function(evt) {
        // did we add something?  if so, lets add it to the selectedOptions
        if (!_.isUndefined(evt.added)) {
            this.selectedOptions.push(evt.added);
        }

        // did we remove something? if so, lets remove it from the selectedOptions
        if (!_.isUndefined(evt.removed)) {
            this.selectedOptions = _.without(this.selectedOptions, evt.removed);
        }

        this.model.set('worksheet_columns', evt.val);
    },

    /**
     * @inheritdoc
     *
     * Remove custom listeners off select2 instances
     */
    _dispose: function() {
        if (this.wkstColumnsSelect2) {
            this.wkstColumnsSelect2.off();
            this.wkstColumnsSelect2.select2('destroy');
            this.wkstColumnsSelect2 = null;
        }
        this._super('_dispose');
    },

    /**
     * Re-usable method to get the module label for the column list
     *
     * @param {String} fieldName The field we are currently looking at
     * @param {String} setModule If the metadata has a module set it will be passed in here
     * @return {string}
     * @private
     */
    _getLabelModule: function(fieldName, setModule) {
        var labelModule = setModule || 'Forecasts';
        if (fieldName === 'parent_name') {
            // when we have the parent_name, pull the label from the module we are forecasting by
            labelModule = this.model.get('forecast_by');
        }

        return labelModule;
    }
}) },
"forecasts-chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Dashlet that displays a chart
 */
({
	// Forecasts-chart View (base) 

    plugins: ['Dashlet'],

    /**
     * This is the values model for the template
     */
    values: new Backbone.Model(),

    className: 'forecasts-chart-wrapper',

    /**
     * Hold the initOptions if we have to call the Forecast/init end point cause we are not on Forecasts
     */
    initOptions: null,

    /**
     * The context of the ForecastManagerWorksheet Module if one exists
     */
    forecastManagerWorksheetContext: undefined,

    /**
     * The context of the ForecastWorksheet Module if one exists
     */
    forecastWorksheetContext: undefined,

    /**
     * Track if current user is manager.
     */
    isManager: false,
    
    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // after we init, find and bind to the Worksheets Contexts
        this.once('init', this.findWorksheetContexts, this);
        this.once('render', function() {
            this.parseCollectionForData();
        }, this);
        this.isManager = app.user.get('is_manager');
        this._super('initialize', [options]);
        if (!this.meta.config) {
            var ctx = this.context.parent,
                user = ctx.get('selectedUser') || app.user.toJSON(),
                showMgr = ctx.get('model').get('forecastType') == 'Rollup';

            this.values.set({
                user_id: user.id,
                display_manager: showMgr,
                show_target_quota: (user.is_manager && !user.is_top_level_manager),
                ranges: ctx.get('selectedRanges') || ['include'],
                timeperiod_id: ctx.get('selectedTimePeriod'),
                dataset: 'likely',
                group_by: 'forecast',
                no_data: true
            });
        }
    },

    /**
     * Specific code to run after a dashlet Init Code has ran
     */
    initDashlet: function() {
        var fieldOptions,
            cfg = app.metadata.getModule('Forecasts', 'config');
        fieldOptions = app.lang.getAppListStrings(this.dashletConfig.dataset.options);
        this.dashletConfig.dataset.options = {};

        if (cfg.show_worksheet_worst &&
            app.acl.hasAccess('view', 'ForecastWorksheets', app.user.get('id'), 'worst_case')) {
            this.dashletConfig.dataset.options['worst'] = fieldOptions['worst'];
        }

        if (cfg.show_worksheet_likely) {
            this.dashletConfig.dataset.options['likely'] = fieldOptions['likely'];
        }

        if (cfg.show_worksheet_best &&
            app.acl.hasAccess('view', 'ForecastWorksheets', app.user.get('id'), 'best_case')) {
            this.dashletConfig.dataset.options['best'] = fieldOptions['best'];
        }

        // Hide dataset drop-down if there is only one option.
        this.dashletConfig.show_dataset = true;
        if (_.size(this.dashletConfig.dataset.options) <= 1) {
            this.dashletConfig.show_dataset = false;
        }
    },

    /**
     * Loop though the parent context children context to find the worksheet, if they exist
     */
    findWorksheetContexts: function() {
        // loop though the children context looking for the ForecastWorksheet and ForecastManagerWorksheet Modules
        _.filter(this.context.parent.children, function(item) {
            if (item.get('module') == 'ForecastWorksheets') {
                this.forecastWorksheetContext = item;
                return true;
            } else if (item.get('module') == 'ForecastManagerWorksheets') {
                this.forecastManagerWorksheetContext = item;
                return true;
            }
            return false;
        }, this);

        var collection;

        if (this.forecastWorksheetContext) {
            // listen for collection change events
            collection = this.forecastWorksheetContext.get('collection');
            if (collection) {
                collection.on('change', this.repWorksheetChanged, this);
                collection.on('reset', function(collection) {
                    this.parseCollectionForData(collection);
                }, this);
            }
        }

        if (this.forecastManagerWorksheetContext) {
            // listen for collection change events
            collection = this.forecastManagerWorksheetContext.get('collection');
            if (collection) {
                collection.on('change', this.mgrWorksheetChanged, this);
                collection.on('reset', function(collection) {
                    this.parseCollectionForData(collection);
                }, this);
            }
        }
    },

    /**
     * Figure out which way we need to parse a collection
     *
     * @param {Backbone.Collection} [collection]
     */
    parseCollectionForData: function(collection) {
        if (this.meta.config) {
            return;
        }
        // get the field
        var field = this.getField('paretoChart');
        if(field && !field.hasServerData()) {
            // if the field does not have any data, wait for the xhr call to run and then just call this
            // method again
            field.once('chart:pareto:rendered', this.parseCollectionForData, this);
            return;
        }

        if (this.values.get('display_manager')) {
            this.parseManagerWorksheet(collection || this.forecastManagerWorksheetContext.get('collection'));
        } else {
            this.parseRepWorksheet(collection || this.forecastWorksheetContext.get('collection'));
        }
    },

    /**
     * Parses a chart data collection for the Rep worksheet
     *
     * @param {Backbone.Collection} collection
     */
    parseRepWorksheet: function(collection) {
        var field = this.getField('paretoChart');
        if(field) {
            var serverData = field.getServerData();

            serverData.data = collection.map(function(item) {
                var i = {
                    id: item.get('id'),
                    forecast: item.get('commit_stage'),
                    probability: item.get('probability'),
                    sales_stage: item.get('sales_stage'),
                    likely: app.currency.convertWithRate(item.get('likely_case'), item.get('base_rate')),
                    date_closed_timestamp: parseInt(item.get('date_closed_timestamp'))
                };

                if (!_.isUndefined(this.dashletConfig.dataset.options['best'])) {
                    i.best = app.currency.convertWithRate(item.get('best_case'), item.get('base_rate'));
                }
                if (!_.isUndefined(this.dashletConfig.dataset.options['worst'])) {
                    i.worst = app.currency.convertWithRate(item.get('worst_case'), item.get('base_rate'));
                }

                return i;
            }, this);

            field.setServerData(serverData, true);
        }
    },

    /**
     * Parses a chart data collection for the Manager worksheet
     *
     * @param {Backbone.Collection} collection
     */
    parseManagerWorksheet: function(collection) {
        var field = this.getField('paretoChart');
        if(field) {
            var serverData = field.getServerData();

            serverData.data = collection.map(function(item) {
                var i = {
                    id: item.get('id'),
                    user_id: item.get('user_id'),
                    name: item.get('name'),
                    likely: app.currency.convertWithRate(item.get('likely_case'), item.get('base_rate')),
                    likely_adjusted: app.currency.convertWithRate(item.get('likely_case_adjusted'), item.get('base_rate')),
                    quota: app.currency.convertWithRate(item.get('quota'), item.get('base_rate'))
                };

                if (!_.isUndefined(this.dashletConfig.dataset.options['best'])) {
                    i.best = app.currency.convertWithRate(item.get('best_case'), item.get('base_rate'));
                    i.best_adjusted = app.currency.convertWithRate(item.get('best_case_adjusted'), item.get('base_rate'));
                }
                if (!_.isUndefined(this.dashletConfig.dataset.options['worst'])) {
                    i.worst = app.currency.convertWithRate(item.get('worst_case'), item.get('base_rate'));
                    i.worst_adjusted = app.currency.convertWithRate(item.get('worst_case_adjusted'), item.get('base_rate'));
                }

                return i;
            }, this);

            serverData.quota = _.reduce(serverData.data, function(memo, item) {
                return app.math.add(memo, item.quota, undefined, true);
            }, 0);

            field.setServerData(serverData);
        }
    },

    /**
     * Handler for when the Rep Worksheet Changes
     * @param {Object} model
     */
    repWorksheetChanged: function(model) {
        // get what we are currently filtered by
        // find the item in the serverData
        var changed = model.changed,
            changedField = _.keys(changed),
            field = this.getField('paretoChart'),
            serverData = field.getServerData();

        // if the changedField is date_closed, we need to adjust the timestamp as well since SugarLogic doesn't work
        // on list views yet
        if (changedField.length == 1 && changedField[0] == 'date_closed') {
            // convert this into the timestamp
            changedField.push('date_closed_timestamp');
            changed.date_closed_timestamp = Math.round(+app.date.parse(changed.date_closed).getTime() / 1000);
            model.set('date_closed_timestamp', changed.date_closed_timestamp, {silent: true});
        }

        if (_.contains(changedField, 'likely_case')) {
            changed.likely = app.currency.convertWithRate(changed.likely_case, model.get('base_rate'));
            delete changed.likely_case;
        }
        if (_.contains(changedField, 'best_case')) {
            changed.best = app.currency.convertWithRate(changed.best_case, model.get('base_rate'));
            delete changed.best_case;
        }
        if (_.contains(changedField, 'worst_case')) {
            changed.worst = app.currency.convertWithRate(changed.worst_case, model.get('base_rate'));
            delete changed.worst_case;
        }

        if (_.contains(changedField, 'commit_stage')) {
            changed.forecast = changed.commit_stage;
            delete changed.commit_stage;
        }

        _.find(serverData.data, function(record, i, list) {
            if (model.get('id') == record.id) {
                list[i] = _.extend({}, record, changed);
                return true;
            }
            return false;
        });

        field.setServerData(serverData, _.contains(changedField, 'probability'));
    },

    /**
     * Handler for when the Manager Worksheet Changes
     * @param {Object} model
     */
    mgrWorksheetChanged: function(model) {
        var fieldsChanged = _.keys(model.changed),
            changed = model.changed,
            field = this.getField('paretoChart');
        if(field && field.hasServerData()) {
            var serverData = field.getServerData();

            if (_.contains(fieldsChanged, 'quota')) {
                var q = parseInt(serverData.quota, 10);
                q = app.math.add(app.math.sub(q, model.previous('quota')), model.get('quota'));
                serverData.quota = q;
            } else {
                var f = _.first(fieldsChanged),
                    fieldChartName = f.replace('_case', '');

                // find the user
                _.find(serverData.data, function(record, i, list) {
                    if (model.get('user_id') == record.user_id) {
                        list[i][fieldChartName] = changed[f];
                        return true;
                    }
                    return false;
                });
            }

            field.setServerData(serverData);
        }
    },

    /**
     * When loadData is called, find the paretoChart field, if it exist, then have it render the chart
     *
     * @inheritdoc
     */
    loadData: function(options) {
        var field = this.getField('paretoChart');

        if (!_.isUndefined(field)) {
            field.once('chart:pareto:rendered', this.parseCollectionForData, this);
            field.renderChart(options);
        }
        if (options && _.isFunction(options.complete)) {
            options.complete();
        }
    },

    /**
     * Called after _render
     */
    toggleRepOptionsVisibility: function() {
        this.$('div.groupByOptions').toggleClass('hide', this.values.get('display_manager') === true);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        // on the off chance that the init has not run yet.
        var meta = this.meta || this.initOptions.meta;
        if (meta.config) {
            return;
        }

        this.values.on('change:title', function(model, title) {
            this.layout.setTitle(app.lang.get(this.meta.label) + title);
        }, this);

        this.on('render', function() {
            var field = this.getField('paretoChart'),
                dashToolbar = this.layout.getComponent('dashlet-toolbar');

            // if we have a dashlet-toolbar, then make it do the refresh icon while the chart is loading from the
            // server
            if (dashToolbar) {
                field.before('chart:pareto:render', function() {
                    this.$("[data-action=loading]").removeClass(this.cssIconDefault).addClass(this.cssIconRefresh);
                }, dashToolbar);
                field.on('chart:pareto:rendered', function() {
                    this.$("[data-action=loading]").removeClass(this.cssIconRefresh).addClass(this.cssIconDefault);
                }, dashToolbar);
            }
            this.toggleRepOptionsVisibility();
            this.parseCollectionForData();
        }, this);

        var ctx = this.context.parent;

        ctx.on('change:selectedUser', function(context, user) {
            var displayMgr = ctx.get('model').get('forecastType') == 'Rollup',
                showTargetQuota = (displayMgr && !user.is_top_level_manager);
            this.values.set({
                user_id: user.id,
                display_manager: displayMgr,
                show_target_quota: showTargetQuota
            });
            this.toggleRepOptionsVisibility();
        }, this);
        ctx.on('change:selectedTimePeriod', function(context, timePeriod) {
            this.values.set({timeperiod_id: timePeriod});
        }, this);
        ctx.on('change:selectedRanges', function(context, value) {
            this.values.set({ranges: value});
        }, this);
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        var ctx = this.context.parent;
        if (ctx) {
            ctx.off(null, null, this);
        }

        if (this.forecastManagerWorksheetContext && this.forecastManagerWorksheetContext.get('collection')) {
            this.forecastManagerWorksheetContext.get('collection').off(null, null, this);
        }

        if (this.forecastWorksheetContext && this.forecastWorksheetContext.get('collection')) {
            this.forecastWorksheetContext.get('collection').off(null, null, this);
        }

        if (this.context) {
            this.context.off(null, null, this);
        }

        if (this.values) {
            this.values.off(null, null, this);
        }

        this._super('unbindData');
    }
}) },
"forecast-pipeline": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Forecast-pipeline View (base) 

    extendsFrom: 'SalesPipelineView',

    /**
     * Is the forecast Module setup??
     */
    forecastSetup: 0,

    /**
     * Holds the forecast isn't set up message if Forecasts hasn't been set up yet
     */
    forecastsNotSetUpMsg: undefined,

    /**
     * Track if current user is manager.
     */
    isManager: false,

    /**
     * @inheritDoc
     */
    initialize: function(options) {
        options.meta.type = 'sales-pipeline';
        options.meta = _.extend({}, app.metadata.getView(this.module, 'sales-pipeline'), options.meta);

        this._super('initialize', [options]);
    }
}) },
"config-header-buttons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastsConfigHeaderButtonsView
 * @alias SUGAR.App.view.layouts.BaseForecastsConfigHeaderButtonsView
 * @extends View.Views.Base.ConfigHeaderButtonsView
 */
({
	// Config-header-buttons View (base) 

    extendsFrom: 'ConfigHeaderButtonsView',

    /**
     * @inheritdoc
     */
    _beforeSaveConfig: function() {
        var ctxModel = this.context.get('model');

        // Set config settings before saving
        ctxModel.set({
            is_setup:true,
            show_forecasts_commit_warnings: true
        });

        // update the commit_stages_included property and
        // remove 'include_in_totals' from the ranges so it doesn't get saved
        if(ctxModel.get('forecast_ranges') == 'show_custom_buckets') {
            var ranges = ctxModel.get('show_custom_buckets_ranges'),
                labels = ctxModel.get('show_custom_buckets_options'),
                commitStages = [],
                finalLabels = [];

            ctxModel.unset('commit_stages_included');
            _.each(ranges, function(range, key) {
                if (range.in_included_total) {
                    commitStages.push(key);
                }
                delete range.in_included_total;

                finalLabels.push([key, labels[key]]);
            }, this);

            ctxModel.set({
                commit_stages_included: commitStages,
                show_custom_buckets_ranges: ranges,
                show_custom_buckets_options: finalLabels
            }, {silent: true});
        }
    },

    /**
     * @inheritdoc
     */
    cancelConfig: function() {
        if (app.metadata.getModule('Forecasts', 'config').is_setup) {
            return this._super('cancelConfig');
        }
        if (this.triggerBefore('cancel')) {
            if (app.drawer.count()) {
                app.drawer.close(this.context, this.context.get('model'));
            }
            // Redirect to Admin panel if Forecasts has not been set up
            app.router.navigate('#Administration', {trigger: true});
        }
    },


    /**
     * @inheritdoc
     */
    _saveConfig: function() {
        var url = app.api.buildURL(this.module, 'config');
        app.api.call('create', url, this.model.attributes, {
                success: _.bind(function() {
                    if (app.drawer.count()) {
                        this.showSavedConfirmation();
                        // close the drawer and return to Forecasts
                        app.drawer.close(this.context, this.context.get('model'));
                        // Forecasts requires a refresh, always, so we force it
                        Backbone.history.loadUrl(app.api.buildURL(this.module));
                    } else {
                        app.router.navigate(this.module, {trigger: true});
                    }
                }, this),
                error: _.bind(function() {
                    this.getField('save_button').setDisabled(false);
                }, this)
            }
        );
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Forecasts.PreviewView
 * @alias SUGAR.App.view.views.BaseForecastsPreviewView
 * @extends View.Views.Base.PreviewView
 */
({
	// Preview View (base) 

    extendsFrom: 'PreviewView',

    /**
     * Track the original model passed in from the worksheet, this is needed becuase of how the base preview works
     */
    originalModel: undefined,

    _delegateEvents: function() {
        app.events.on('preview:render', this._renderPreview, this);
        app.events.on('preview:close', this.closePreview, this);
        this._super('_delegateEvents');
    },

    /**
     * @inheritdoc
     */
    closePreview: function() {
        this.originalModel = undefined;
        this._super("closePreview");
    },

    /**
     * Override _renderPreview to pull in the parent_type and parent_id when we are running a fetch
     *
     * @param model
     * @param collection
     * @param fetch
     * @param previewId
     * @param dontClose overrides triggering preview:close
     * @private
     */
    _renderPreview: function(model, collection, fetch, previewId, dontClose){
        var self = this;
        dontClose = dontClose || false;

        // If there are drawers there could be multiple previews, make sure we are only rendering preview for active drawer
        if(app.drawer && !app.drawer.isActive(this.$el)){
            return;  //This preview isn't on the active layout
        }

        // Close preview if we are already displaying this model
        if(!dontClose && this.originalModel && model && (this.originalModel.get("id") == model.get("id") && previewId == this.previewId)) {
            // Remove the decoration of the highlighted row
            app.events.trigger("list:preview:decorate", false);
            // Close the preview panel
            app.events.trigger('preview:close');
            return;
        }

        if (model) {
            // Get the corresponding detail view meta for said module.
            // this.meta needs to be set before this.getFieldNames is executed.
            this.meta = app.metadata.getView(model.get('parent_type') || model.get('_module'), 'record') || {};
            this.meta = this._previewifyMetadata(this.meta);
        }

        if (fetch) {
            var mdl = app.data.createBean(model.get('parent_type'), {'id' : model.get('parent_id')});
            this.originalModel = model;
            mdl.fetch({
                //Show alerts for this request
                showAlerts: true,
                success: function(model) {
                    self.renderPreview(model, collection);
                }
            });
        } else {
            this.renderPreview(model, collection);
        }

        this.previewId = previewId;
    },

    /**
     * Show previous and next buttons groups on the view.
     *
     * This gets called everytime the collection gets updated. It also depends
     * if we have a current model or layout.
     *
     * TODO we should check if we have the preview open instead of doing a bunch
     * of if statements.
     */
    showPreviousNextBtnGroup: function () {
        if (!this.model || !this.layout || !this.collection) {
            return;
        }
        var collection = this.collection;
        if (!collection.size()) {
            this.layout.hideNextPrevious = true;
        }
        // use the originalModel if one is defined, if not fall back to the basic model
        var model = this.originalModel || this.model;
        var recordIndex = collection.indexOf(collection.get(model.id));
        this.layout.previous = collection.models[recordIndex-1] ? collection.models[recordIndex-1] : undefined;
        this.layout.next = collection.models[recordIndex+1] ? collection.models[recordIndex+1] : undefined;
        this.layout.hideNextPrevious = _.isUndefined(this.layout.previous) && _.isUndefined(this.layout.next);

        // Need to rerender the preview header
        this.layout.trigger("preview:pagination:update");
    },

    /**
     * Renders the preview dialog with the data from the current model and collection
     * @param model Model for the object to preview
     * @param newCollection Collection of related objects to the current model
     */
    renderPreview: function(model, newCollection) {
        if(newCollection) {
            this.collection.reset(newCollection.models);
        }

        if (model) {
            this.model = app.data.createBean(model.module, model.toJSON());
            this.render();

            // TODO: Remove when pagination on activity streams is fixed.
            if (this.previewModule && this.previewModule === "Activities") {
                this.layout.hideNextPrevious = true;
                this.layout.trigger("preview:pagination:update");
            }
            // Open the preview panel
            app.events.trigger("preview:open",this);
            // Highlight the row
            // use the original model when going to the list:preview:decorate event
            app.events.trigger("list:preview:decorate", this.originalModel, this);
        }
    },

    /**
     * Switches preview to left/right model in collection.
     * @param {String} data direction Direction that we are switching to, either 'left' or 'right'.
     * @param index Optional current index in list
     * @param id Optional
     * @param module Optional
     */
    switchPreview: function(data, index, id, module) {
        var self = this,
            currModule = module || this.model.module,
            currID = id || this.model.get("postId") || this.model.get("id"),
            // use the originalModel vs the model
            currIndex = index || _.indexOf(this.collection.models, this.collection.get(this.originalModel.get('id')));

        if( this.switching || this.collection.models.length < 2) {
            // We're currently switching previews or we don't have enough models, so ignore any pagination click events.
            return;
        }
        this.switching = true;
        // get the parent_id from the specific module
        if( data.direction === "left" && (currID === _.first(this.collection.models).get("parent_id")) ||
            data.direction === "right" && (currID === _.last(this.collection.models).get("parent_id")) ) {
            this.switching = false;
            return;
        }
        else {
            // We can increment/decrement
            data.direction === "left" ? currIndex -= 1 : currIndex += 1;

            // If there is no target_id, we don't have access to that activity record
            // The other condition ensures we're previewing from activity stream items.
            if( _.isUndefined(this.collection.models[currIndex].get("target_id")) &&
                this.collection.models[currIndex].get("activity_data") ) {

                currID = this.collection.models[currIndex].id;
                this.switching = false;
                this.switchPreview(data, currIndex, currID, currModule);
            } else {
                var targetModule = this.collection.models[currIndex].get("target_module") || currModule;

                this.model = app.data.createBean(targetModule);

                if( _.isUndefined(this.collection.models[currIndex].get("target_id")) ) {
                    // get the parent_id
                    this.model.set("id", this.collection.models[currIndex].get("parent_id"));
                } else {
                    this.model.set("postId", this.collection.models[currIndex].get("id"));
                    this.model.set("id", this.collection.models[currIndex].get("target_id"));
                }
                this.originalModel = this.collection.models[currIndex];
                this.model.fetch({
                    //Show alerts for this request
                    showAlerts: true,
                    success: function(model) {
                        model.set("_module", targetModule);
                        self.model = null;
                        //Reset the preview
                        app.events.trigger("preview:render", model, null, false);
                        self.switching = false;
                    }
                });
            }
        }
    }
}) },
"config-timeperiods": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastsConfigTimeperiodsView
 * @alias SUGAR.App.view.layouts.BaseForecastsConfigTimeperiodsView
 * @extends View.Views.Base.ConfigPanelView
 */
({
	// Config-timeperiods View (base) 

    extendsFrom: 'ConfigPanelView',

    /**
     * Holds the moment.js date object
     * @type Moment
     */
    tpStartDate: undefined,

    /**
     * If the Fiscal Year field is displayed, this holds the reference to the field
     */
    fiscalYearField: undefined,

    /**
     * Holds the timeperiod_fiscal_year metadata so it doesn't render until the view needs it
     */
    fiscalYearMeta: undefined,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // remove the fiscal year metadata since we cant use the enabled check
        var fieldsMeta = _.filter(_.first(options.meta.panels).fields, function(field) {
            if (field.name === 'timeperiod_fiscal_year') {
                this.fiscalYearMeta = _.clone(field);
            }
            // return all fields except fiscal year
            return field.name !== 'timeperiod_fiscal_year';
        }, this);

        // put updated fields back into options
        _.first(options.meta.panels).fields = fieldsMeta;

        this._super('initialize', [options]);

        // check if Forecasts is set up, if so, make the timeperiod field readonly
        if (!this.model.get('is_setup')) {
            _.each(fieldsMeta, function(field) {
                if (field.name == 'timeperiod_start_date') {
                    field.click_to_edit = true;
                }
            }, this);
        }

        this.tpStartDate = this.model.get('timeperiod_start_date');
        if (this.tpStartDate) {
            // convert the tpStartDate to a Moment object
            this.tpStartDate = app.date(this.tpStartDate, app.user.getPreference('datepref'));
        }
    },

    /**
     * @inheritdoc
     */
    _updateTitleValues: function() {
        this.titleSelectedValues = (this.tpStartDate) ? this.tpStartDate.formatUser(true) : '';
    },

    /**
     * Checks the timeperiod start date to see if it's 01/01 to know
     * if we need to display the Fiscal Year field or not
     */
    checkFiscalYearField: function() {
        // moment.js months are zero-based: 0 = January
        if (this.tpStartDate.month() !== 0 ||
            (this.tpStartDate.month() === 0 && this.tpStartDate.date() !== 1)) {
            // if the start date's month isn't Jan,
            // or it IS Jan but a date other than the 1st, add the field
            this.addFiscalYearField();
        } else if (this.fiscalYearField) {
            this.model.set({
                timeperiod_fiscal_year: null
            });
            this.removeFiscalYearField();
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.once('change', function(model) {
                // on a fresh install with no demo data,
                // this.model has the values and the param model is undefined
                if (_.isUndefined(model)) {
                    model = this.model;
                }
            }, this);

            this.model.on('change:timeperiod_start_date', function(model) {
                this.tpStartDate = app.date(model.get('timeperiod_start_date'));
                this.checkFiscalYearField();
                this.titleSelectedValues = this.tpStartDate.formatUser(true);
                this.updateTitle();
            }, this);
        }
    },

    /**
     * Creates the fiscal-year field and adds it to the DOM
     */
    addFiscalYearField: function() {
        if (!this.fiscalYearField) {
            // set the value so the fiscal-year field chooses its first option
            // in the dropdown
            this.model.set({
                timeperiod_fiscal_year: 'current_year'
            });

            var $el = this.$('#timeperiod_start_date_subfield');
            if ($el) {
                var fiscalYearFieldMeta = this.updateFieldMetadata(this.fiscalYearMeta),
                    fieldSettings = {
                        view: this,
                        def: fiscalYearFieldMeta,
                        viewName: 'edit',
                        context: this.context,
                        module: this.module,
                        model: this.model,
                        meta: app.metadata.getField({name: 'enum', module: this.module})
                    };

                this.fiscalYearField = app.view.createField(fieldSettings);

                $el.html(this.fiscalYearField.el);
                this.fiscalYearField.render();
            }
        }
    },

    /**
     * Takes the default fiscal-year metadata and adds any dynamic values
     * Done in function form in case this field ever needs to be extended with
     * more than just 2 years
     *
     * @param {Object} fieldMeta The field's metadata
     * @return {Object}
     */
    updateFieldMetadata: function(fieldMeta) {
        fieldMeta.startYear = this.tpStartDate.year();
        return fieldMeta;
    },

    /**
     * Disposes the fiscal-year field and removes it from the DOM
     */
    removeFiscalYearField: function() {
        this.model.set({
            timeperiod_fiscal_year: null
        });
        this.fiscalYearField.dispose();
        this.fiscalYearField = null;
        this.$('#timeperiod_start_date_subfield').html('');
    },

    /**
     * @inheritdoc
     *
     * Sets up a binding to the start month dropdown to populate the day drop down on change
     *
     * @param {View.Field} field
     * @private
     */
    _renderField: function(field) {
        field = this._setUpTimeperiodConfigField(field);

        // check for all fields, if forecast is setup, set to detail/readonly mode
        if (this.model.get('is_setup')) {
            field.options.def.view = 'detail';
        } else if (field.name == 'timeperiod_start_date') {
            // if this is the timeperiod_start_date field and Forecasts is not setup
            field.options.def.click_to_edit = true;
        }

        this._super('_renderField', [field]);

        if (field.name == 'timeperiod_start_date') {
            if (this.model.get('is_setup')) {
                var year = this.model.get('timeperiod_start_date').substring(0, 4),
                    str,
                    $el;

                if (this.model.get('timeperiod_fiscal_year') === 'next_year') {
                    year++;
                }

                str = app.lang.get('LBL_FISCAL_YEAR', 'Forecasts') + ': ' + year;
                $el = this.$('#timeperiod_start_date_sublabel');
                if ($el) {
                    $el.html(str);
                }
            } else {
                this.tpStartDate = app.date(this.model.get('timeperiod_start_date'));
                this.checkFiscalYearField();
            }
        }
    },

    /**
     * Sets up the fields with the handlers needed to properly get and set their values for the timeperiods config view.
     *
     * @param {View.Field} field the field to be setup for this config view.
     * @return {*} field that has been properly setup and augmented to function for this config view.
     * @private
     */
    _setUpTimeperiodConfigField: function(field) {
        switch (field.name) {
            case 'timeperiod_shown_forward':
            case 'timeperiod_shown_backward':
                return this._setUpTimeperiodShowField(field);
            case 'timeperiod_interval':
                return this._setUpTimeperiodIntervalBind(field);
            default:
                return field;
        }
    },

    /**
     * Sets up the timeperiod_shown_forward and timeperiod_shown_backward dropdowns to set the model and values properly
     *
     * @param {View.Field} field The field being set up.
     * @return {*} The configured field.
     * @private
     */
    _setUpTimeperiodShowField: function(field) {
        // ensure Date object gets an additional function
        field.events = _.extend({'change input': '_updateSelection'}, field.events);
        field.bindDomChange = function() {};

        field._updateSelection = function(event) {
            var value = $(event.currentTarget).val();
            this.def.value = value;
            this.model.set(this.name, value);
        };

        // force value to a string so hbs has helper will match the dropdown correctly
        this.model.set(field.name, this.model.get(field.name).toString(), {silent: true});

        field.def.value = this.model.get(field.name) || 1;
        return field;
    },

    /**
     * Sets up the change event on the timeperiod_interval drop down to maintain the interval selection
     * and push in the default selection for the leaf period
     *
     * @param {View.Field} field the dropdown interval field
     * @return {*}
     * @private
     */
    _setUpTimeperiodIntervalBind: function(field) {
        field.def.value = this.model.get(field.name);

        // ensure selected day functions like it should
        field.events = _.extend({'change input': '_updateIntervals'}, field.events);
        field.bindDomChange = function() {};

        if (typeof(field.def.options) == 'string') {
            field.def.options = app.lang.getAppListStrings(field.def.options);
        }

        /**
         * function that updates the selected interval
         * @param {Event} event
         * @private
         */
        field._updateIntervals = function(event) {
            //get the timeperiod interval selector
            var selected_interval = $(event.currentTarget).val();
            this.def.value = selected_interval;
            this.model.set(this.name, selected_interval);
            this.model.set('timeperiod_leaf_interval', selected_interval == 'Annual' ? 'Quarter' : 'Month');
        };

        return field;
    }
}) },
"config-ranges": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastsConfigRangesView
 * @alias SUGAR.App.view.layouts.BaseForecastsConfigRangesView
 * @extends View.Views.Base.ConfigPanelView
 */
({
	// Config-ranges View (base) 

    extendsFrom: 'ConfigPanelView',

    events: {
        'click #btnAddCustomRange a': 'addCustomRange',
        'click #btnAddCustomRangeWithoutProbability a': 'addCustomRange',
        'click .addCustomRange': 'addCustomRange',
        'click .removeCustomRange': 'removeCustomRange',
        'keyup input[type=text]': 'updateCustomRangeLabel',
        'change :radio': 'selectionHandler'
    },

    /**
     * Holds the fields metadata
     */
    fieldsMeta: {},

    /**
     * used to hold the metadata for the forecasts_ranges field, used to manipulate and render out as the radio buttons
     * that correspond to the fieldset for each bucket type.
     */
    forecastRangesField: {},

    /**
     * Used to hold the buckets_dom field metadata, used to retrieve and set the proper bucket dropdowns based on the
     * selection for the forecast_ranges
     */
    bucketsDomField: {},

    /**
     * Used to hold the category_ranges field metadata, used for rendering the sliders that correspond to the range
     * settings for each of the values contained in the selected buckets_dom dropdown definition.
     */
    categoryRangesField: {},

    /**
     * Holds the values found in Forecasts Config commit_stages_included value
     */
    includedCommitStages: [],

    //TODO-sfa remove this once the ability to map buckets when they get changed is implemented (SFA-215).
    /**
     * This is used to determine whether we need to lock the module or not, based on whether forecasts has been set up already
     */
    disableRanges: false,

    /**
     * Used to keep track of the selection as it changes so that it can be used to determine how to hide and show the
     * sub-elements that contain the fields for setting the category ranges
     */
    selectedRange: '',

    /**
     * a placeholder for the individual range sliders that will be used to build the range setting
     */
    fieldRanges: {},

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // parse get the fields metadata
        _.each(_.first(this.meta.panels).fields, function(field) {
            this.fieldsMeta[field.name] = field;
            if (field.name === 'category_ranges') {
                // get rid of the name key so it doesn't mess up the other fields
                delete this.fieldsMeta.category_ranges.name;
            }
        }, this);

        // init the fields from metadata
        this.forecastRangesField = this.fieldsMeta.forecast_ranges;
        this.bucketsDomField = this.fieldsMeta.buckets_dom;
        this.categoryRangesField = this.fieldsMeta.category_ranges;

        // get the included commit stages
        this.includedCommitStages = this.model.get('commit_stages_included');

        // set the values for forecastRangesField and bucketsDomField from the model, so it can be set to selected properly when rendered
        this.forecastRangesField.value = this.model.get('forecast_ranges');
        this.bucketsDomField.value = this.model.get('buckets_dom');

        // This will be set to true if the forecasts ranges setup should be disabled
        this.disableRanges = this.model.get('has_commits');
        this.selectedRange = this.model.get('forecast_ranges');
    },

    /**
     * @inheritdoc
     */
    _updateTitleValues: function() {
        var forecastRanges = this.model.get('forecast_ranges'),
            rangeObjs = this.model.get(forecastRanges + '_ranges'),
            tmpArr = [],
            str = '',
            aSort = function(a, b) {
                if (a.min < b.min) {
                    return -1;
                } else if (a.min > b.min) {
                    return 1;
                }
            }

        // Get the keys into an object
        _.each(rangeObjs, function(value, key) {
            if(key.indexOf('without_probability') === -1) {
                tmpArr.push({
                    min: value.min,
                    max: value.max
                });
            }
        });

        tmpArr.sort(aSort);

        _.each(tmpArr, function(val) {
            str += val.min + '% - ' + val.max + '%, ';
        });

        this.titleSelectedValues = str.slice(0, str.length - 2);
        this.titleSelectedRange = app.lang.getAppListStrings('forecasts_config_ranges_options_dom')[forecastRanges];
    },

    /**
     * @inheritdoc
     */
    _updateTitleTemplateVars: function() {
        this.titleTemplateVars = {
            title: this.titleViewNameTitle,
            message: this.titleSelectedRange,
            selectedValues: this.titleSelectedValues,
            viewName: this.name
        };
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:show_binary_ranges change:show_buckets_ranges change:show_custom_buckets_ranges',
            function() {
                this.updateTitle();
            }, this
        );
        this.model.on('change:forecast_ranges', function(model) {
            this.updateTitle();
            if(model.get('forecast_ranges') === 'show_custom_buckets') {
                this.updateCustomRangesCheckboxes();
            }
        }, this);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // after the view renders, check for the range that has been selected and
        // trigger the change event on its element so that it shows
        this.$(':radio:checked').trigger('change');

        if(this.model.get('forecast_ranges') === 'show_custom_buckets') {
            this.updateCustomRangesCheckboxes();
        }
    },

    /**
     * Handles when the radio buttons change
     *
     * @param {jQuery.Event} event
     */
    selectionHandler: function(event) {
        var newValue = $(event.target).val(),
            oldValue = this.selectedRange,
            bucket_dom = this.bucketsDomField.options[newValue],
            elToHide = this.$('#' + oldValue + '_ranges'),
            elToShow = this.$('#' + newValue + '_ranges');

        // now set the new selection, so that if they change it,
        // we can later hide the things we are about to show.
        this.selectedRange = newValue;

        if(elToShow.children().length === 0) {
            if(newValue === 'show_custom_buckets') {
                this._customSelectionHandler(newValue, elToShow);
            } else {
                this._selectionHandler(newValue, elToShow);
            }

            // use call to set context back to the view for connecting the sliders
            this.connectSliders.call(this, newValue, this.fieldRanges);
        }

        if(elToHide) {
            elToHide.toggleClass('hide', true);
        }

        if(elToShow) {
            elToShow.toggleClass('hide', false);
        }

        // set the forecast ranges and associated dropdown dom on the model
        this.model.set({
            forecast_ranges: newValue,
            buckets_dom: bucket_dom
        });
    },

    /**
     * Selection handler for standard ranges (two and three ranges)
     *
     * @param {Object} elementVal value of the radio button that was clicked
     * @param {Object} showElement the jQuery-wrapped html element from selectionHandler
     * @private
     */
    _selectionHandler: function(elementVal, showElement) {
        var bucketDomStrings = app.lang.getAppListStrings(this.bucketsDomField.options[elementVal]);

        // add the things here...
        this.fieldRanges[elementVal] = {};
        showElement.append('<p>' + app.lang.get('LBL_FORECASTS_CONFIG_' + elementVal.toUpperCase() + '_RANGES_DESCRIPTION', 'Forecasts', this) + '</p>');

        _.each(bucketDomStrings, function(label, key) {
            if(key != 'exclude') {
                var rangeField,
                    model = new Backbone.Model(),
                    fieldSettings;

                // get the value in the current model and use it to display the slider
                model.set(key, this.model.get(elementVal + '_ranges')[key]);

                // build a range field
                fieldSettings = {
                    view: this,
                    def: this.fieldsMeta.category_ranges[key],
                    viewName: 'edit',
                    context: this.context,
                    module: this.module,
                    model: model,
                    meta: app.metadata.getField({name: 'range', module: this.module})
                };

                rangeField = app.view.createField(fieldSettings);
                showElement.append('<b>' + label + ':</b>').append(rangeField.el);
                rangeField.render();

                // now give the view a way to get at this field's model, so it can be used to set the value on the
                // real model.
                this.fieldRanges[elementVal][key] = rangeField;

                // this gives the field a way to save to the view's real model. It's wrapped in a closure to allow us to
                // ensure we have everything when switching contexts from this handler back to the view.
                rangeField.sliderDoneDelegate = function(category, key, view) {

                    return function(value) {
                        this.view.updateRangeSettings(category, key, value);
                    };
                }(elementVal, key, this);
            }
        }, this);
        showElement.append($('<p>' + app.lang.get('LBL_FORECASTS_CONFIG_RANGES_EXCLUDE_INFO', 'Forecasts') + '</p>'));
    },

    /**
     * Selection handler for custom ranges
     *
     * @param {Object} elementVal value of the radio button that was clicked
     * @param {Object} showElement the jQuery-wrapped html element from selectionHandler
     * @private
     */
    _customSelectionHandler: function(elementVal, showElement) {
        var bucketDomOptions = {},
            elValRanges = elementVal + '_ranges',
            bucketDomStrings = app.lang.getAppListStrings(this.bucketsDomField.options[elementVal]),
            rangeField,
            _ranges = _.clone(this.model.get(elValRanges));

        this.fieldRanges[elementVal] = {};
        showElement.append('<p>' + app.lang.get('LBL_FORECASTS_CONFIG_' + elementVal.toUpperCase() + '_RANGES_DESCRIPTION', 'Forecasts', this) + '</p>');

        // if custom bucket isn't defined save default values
        if(!this.model.has(elValRanges)) {
            this.model.set(elValRanges, {});
        }

        _.each(bucketDomStrings, function(label, key) {
            if (_.isUndefined(_ranges[key])) {
                // the range doesn't exist, so we add it to the ranges
                _ranges[key] = {min: 0, max: 100, in_included_total: false};
            } else {
                // the range already exists, update the in_included_total value
                _ranges[key].in_included_total = (_.contains(this.includedCommitStages, key));
            }
            bucketDomOptions[key] = label;
        }, this);
        this.model.set(elValRanges, _ranges);

        // save key and label of custom range from the language file to model
        // then we can add or remove ranges and save it on backend side
        // bind handler on change to validate data
        this.model.set(elementVal + '_options', bucketDomOptions);
        this.model.on('change:' + elementVal + '_options', function(event) {
            this.validateCustomRangeLabels(elementVal);
        }, this);

        // create layout, create placeholders for different types of custom ranges
        this._renderCustomRangesLayout(showElement, elementVal);

        // render custom ranges
        _.each(bucketDomStrings, function(label, key) {
            rangeField = this._renderCustomRange(key, label, showElement, elementVal);
            // now give the view a way to get at this field's model, so it can be used to set the value on the
            // real model.
            this.fieldRanges[elementVal][key] = rangeField;
        }, this);

        // if there are custom ranges not based on probability hide add button on the top of block
        if(this._getLastCustomRangeIndex(elementVal, 'custom')) {
            this.$('#btnAddCustomRange').hide();
        }

        // if there are custom ranges not based on probability hide add button on the top of block
        if(this._getLastCustomRangeIndex(elementVal, 'custom_without_probability')) {
            this.$('#btnAddCustomRangeWithoutProbability').hide();
        }
    },

    /**
     * Render layout for custom ranges, add placeholders for different types of ranges
     *
     * @param {Object} showElement the jQuery-wrapped html element from selectionHandler
     * @param {string} category type for the ranges 'show_binary' etc.
     * @private
     */
    _renderCustomRangesLayout: function(showElement, category) {
        var template = app.template.getView('config-ranges.customRangesDefault', 'Forecasts'),
            mdl = {
                category: category
            };

        showElement.append(template(mdl));
    },

    /**
     * Creates a new custom range field and renders it in showElement
     *
     * @param {string} key
     * @param {string} label
     * @param {Object} showElement the jQuery-wrapped html element from selectionHandler
     * @param {string} category type for the ranges 'show_binary' etc.
     * @private
     * @return {View.field} new created field
     */
    _renderCustomRange: function(key, label, showElement, category) {
        var customType = key,
            customIndex = 0,
            isExclude = false,
            // placeholder to insert custom range
            currentPlaceholder = showElement,
            rangeField,
            model = new Backbone.Model(),
            fieldSettings,
            lastCustomRange;

        // define type of new custom range based on name of range and choose placeholder to insert
        // custom_default: include, upside or exclude
        // custom - based on probability
        // custom_without_probability - not based on probability
        if(key.substring(0, 26) == 'custom_without_probability') {
            customType = 'custom_without_probability';
            customIndex = key.substring(27);
            currentPlaceholder = this.$('#plhCustomWithoutProbability');
        } else if(key.substring(0, 6) == 'custom') {
            customType = 'custom';
            customIndex = key.substring(7);
            currentPlaceholder = this.$('#plhCustom');
        } else if(key.substring(0, 7) == 'exclude') {
            customType = 'custom_default';
            currentPlaceholder = this.$('#plhExclude');
            isExclude = true;
        } else {
            customType = 'custom_default';
            currentPlaceholder = this.$('#plhCustomDefault');
        }

        // get the value in the current model and use it to display the slider
        model.set(key, this.model.get(category + '_ranges')[key]);

        // get the field definition from
        var fieldDef = this.fieldsMeta.category_ranges[key] || this.fieldsMeta.category_ranges[customType];

        // build a range field
        fieldSettings = {
            view: this,
            def: _.clone(fieldDef),
            viewName: 'forecastsCustomRange',
            context: this.context,
            module: this.module,
            model: model,
            meta: app.metadata.getField({name: 'range', module: this.module})
        };
        // set up real range name
        fieldSettings.def.name = key;
        // set up view
        fieldSettings.def.view = 'forecastsCustomRange';
        // enable slider
        fieldSettings.def.enabled = true;

        rangeField = app.view.createField(fieldSettings);
        currentPlaceholder.append(rangeField.el);
        rangeField.label = label;
        rangeField.customType = customType;

        // added + to make sure customIndex is numeric
        rangeField.customIndex = +customIndex;

        rangeField.isExclude = isExclude;
        rangeField.in_included_total = (_.contains(this.includedCommitStages, key));
        rangeField.category = category;

        if(key == 'include') {
            rangeField.isReadonly = true;
        }

        rangeField.render();

        // enable slider after render
        rangeField.$(rangeField.fieldTag).noUiSlider('enable');

        // hide add button for previous custom range not based on probability
        lastCustomRange = this._getLastCustomRange(category, rangeField.customType);
        if(lastCustomRange) {
            lastCustomRange.$('.addCustomRange').parent().hide();
        }

        // add error class if the range has an empty label
        if(_.isEmpty(rangeField.label)) {
            rangeField.$('.control-group').addClass('error');
        } else {
            rangeField.$('.control-group').removeClass('error');
        }

        // this gives the field a way to save to the view's real model. It's wrapped in a closure to allow us to
        // ensure we have everything when switching contexts from this handler back to the view.
        rangeField.sliderDoneDelegate = function(category, key, view) {
            return function(value) {
                this.view.updateRangeSettings(category, key, value);
            };
        }(category, key, this);

        return rangeField;
    },

    /**
     * Returns the index of the last custom range or 0
     *
     * @param {string} category type for the ranges 'show_binary' etc.
     * @param {string} customType
     * @return {number}
     * @private
     */
    _getLastCustomRangeIndex: function(category, customType) {
        var lastCustomRangeIndex = 0;
        // loop through all ranges, if there are multiple ranges with the same customType, they'll just overwrite
        // each other's index and after the loop we'll have the final index left
        if(this.fieldRanges[category]) {
            _.each(this.fieldRanges[category], function(range) {
                if(range.customType == customType && range.customIndex > lastCustomRangeIndex) {
                    lastCustomRangeIndex = range.customIndex;
                }
            }, this);
        }
        return lastCustomRangeIndex;
    },

    /**
     * Returns the last created custom range object, if no range object, return upside/include
     * for custom type and exclude for custom_without_probability type
     *
     * @param {string} category type for the ranges 'show_binary' etc.
     * @param {string} customType
     * @return {*}
     * @private
     */
    _getLastCustomRange: function(category, customType) {
        if(!_.isEmpty(this.fieldRanges[category])) {
            var lastCustomRange = undefined;
            // loop through all ranges, if there are multiple ranges with the same customType, they'll just overwrite
            // each other on lastCustomRange and after the loop we'll have the final one left
            _.each(this.fieldRanges[category], function(range) {
                if(range.customType == customType
                    && (_.isUndefined(lastCustomRange) || range.customIndex > lastCustomRange.customIndex)) {
                    lastCustomRange = range;
                }
            }, this);

            if(_.isUndefined(lastCustomRange)) {
                // there is not custom range - use default ranges
                if(customType == 'custom') {
                    // use upside or include
                    lastCustomRange = this.fieldRanges[category].upside || this.fieldRanges[category].include;
                } else {
                    // use exclude
                    lastCustomRange = this.fieldRanges[category].exclude;
                }
            }
        }

        return lastCustomRange;
    },

    /**
     * Adds a new custom range field and renders it in specific placeholder
     *
     * @param {jQuery.Event} event click
     */
    addCustomRange: function(event) {
        var self = this,
            category = $(event.currentTarget).data('category'),
            customType = $(event.currentTarget).data('type'),
            categoryRange = category + '_ranges',
            categoryOptions = category + '_options',
            ranges = _.clone(this.model.get(categoryRange)),
            bucketDomOptions = _.clone(this.model.get(categoryOptions));

        if (_.isUndefined(category) || _.isUndefined(customType)
            || _.isUndefined(ranges) || _.isUndefined(bucketDomOptions)) {
            return false;
        }

        var showElement = (customType == 'custom') ? this.$('#plhCustom') : this.$('#plhCustomWithoutProbability'),
            label = app.lang.get('LBL_FORECASTS_CUSTOM_RANGES_DEFAULT_NAME', 'Forecasts'),
            rangeField,
            lastCustomRange = this._getLastCustomRange(category, customType),
            lastCustomRangeIndex = this._getLastCustomRangeIndex(category, customType);

        lastCustomRangeIndex++;

        // setup key for the new range
        var key = customType + '_' + lastCustomRangeIndex;

        // set up min/max values for new custom range
        if (customType != 'custom') {
            // if range is without probability setup min and max values to 0
            ranges[key] = {
                min: 0,
                max: 0,
                in_included_total: false
            };
        } else if (ranges.exclude.max - ranges.exclude.min > 3) {
            // decrement exclude range to insert new range
            ranges[key] = {
                min: parseInt(ranges.exclude.max, 10) - 1,
                max: parseInt(ranges.exclude.max, 10),
                in_included_total: false
            };
            ranges.exclude.max = parseInt(ranges.exclude.max, 10) - 2;
            if (this.fieldRanges[category].exclude.$el) {
                this.fieldRanges[category].exclude.$(this.fieldRanges[category].exclude.fieldTag)
                    .noUiSlider('move', {handle: 'upper', to: ranges.exclude.max});
            }
        } else if (ranges[lastCustomRange.name].max - ranges[lastCustomRange.name].min > 3) {
            // decrement previous range to insert new range
            ranges[key] = {
                min: parseInt(ranges[lastCustomRange.name].min, 10),
                max: parseInt(ranges[lastCustomRange.name].min, 10) + 1,
                in_included_total: false
            };
            ranges[lastCustomRange.name].min = parseInt(ranges[lastCustomRange.name].min, 10) + 2;
            if (lastCustomRange.$el) {

                lastCustomRange.$(lastCustomRange.fieldTag)
                    .noUiSlider('move', {handle: 'lower', to: ranges[lastCustomRange.name].min});
            }
        } else {
            ranges[key] = {
                min: parseInt(ranges[lastCustomRange.name].min, 10) - 2,
                max: parseInt(ranges[lastCustomRange.name].min, 10) - 1,
                in_included_total: false
            };
        }

        this.model.set(categoryRange, ranges);

        rangeField = this._renderCustomRange(key, label, showElement, category);
        if(rangeField) {
            this.fieldRanges[category][key] = rangeField;
        }

        bucketDomOptions[key] = label;
        this.model.set(categoryOptions, bucketDomOptions);

        // adding event listener to new custom range
        rangeField.$(':checkbox').each(function() {
            var $el = $(this);
            $el.on('click', _.bind(self.updateCustomRangeIncludeInTotal, self));
            app.accessibility.run($el, 'click');
        });

        if(customType == 'custom') {
            // use call to set context back to the view for connecting the sliders
            this.$('#btnAddCustomRange').hide();
            this.connectSliders.call(this, category, this.fieldRanges);
        } else {
            // hide add button form top of block and for previous ranges not based on probability
            this.$('#btnAddCustomRangeWithoutProbability').hide();
            _.each(this.fieldRanges[category], function(item) {
                if(item.customType == customType && item.customIndex < lastCustomRangeIndex && item.$el) {
                    item.$('.addCustomRange').parent().hide();
                }
            }, this);
        }

        // update checkboxes
        this.updateCustomRangesCheckboxes();
    },

    /**
     * Removes a custom range from the model and view
     *
     * @param {jQuery.Event} event click
     * @return void
     */
    removeCustomRange: function(event) {
        var category = $(event.currentTarget).data('category'),
            fieldKey = $(event.currentTarget).data('key'),
            categoryRanges = category + '_ranges',
            categoryOptions = category + '_options',
            ranges = _.clone(this.model.get(categoryRanges)),
            bucketDomOptions = _.clone(this.model.get(categoryOptions));

        if (_.isUndefined(category) || _.isUndefined(fieldKey) || _.isUndefined(this.fieldRanges[category])
            || _.isUndefined(this.fieldRanges[category][fieldKey]) || _.isUndefined(ranges)
            || _.isUndefined(bucketDomOptions))
        {
            return false;
        }

        var range,
            previousCustomRange,
            lastCustomRangeIndex,
            lastCustomRange;

        range = this.fieldRanges[category][fieldKey];

        if (_.indexOf(['include', 'upside', 'exclude'], range.name) != -1) {
            return false;
        }

        if(range.customType == 'custom') {
            // find previous renge and reassign range values form removed to it
            _.each(this.fieldRanges[category], function(item) {
                if(item.customType == 'custom' && item.customIndex < range.customIndex) {
                    previousCustomRange = item;
                }
            }, this);

            if(_.isUndefined(previousCustomRange)) {
                previousCustomRange = (this.fieldRanges[category].upside) ? this.fieldRanges[category].upside : this.fieldRanges[category].include;
            }

            ranges[previousCustomRange.name].min = +ranges[range.name].min;

            if(previousCustomRange.$el) {
                previousCustomRange.$(previousCustomRange.fieldTag).noUiSlider('move', {handle: 'lower', to: ranges[previousCustomRange.name].min});
            }
        }

        // update included ranges
        this.includedCommitStages = _.without(this.includedCommitStages, range.name)

        // removing event listener for custom range
        range.$(':checkbox').off('click');

        // remove view for the range
        this.fieldRanges[category][range.name].remove();

        delete ranges[range.name];
        delete this.fieldRanges[category][range.name];
        delete bucketDomOptions[range.name];

        this.model.set(categoryOptions, bucketDomOptions);
        this.model.set(categoryRanges, ranges);

        lastCustomRangeIndex = this._getLastCustomRangeIndex(category, range.customType);
        if(range.customType == 'custom') {
            // use call to set context back to the view for connecting the sliders
            if (lastCustomRangeIndex == 0) {
                this.$('#btnAddCustomRange').show();
            }
            this.connectSliders.call(this, category, this.fieldRanges);
        } else {
            // show add button for custom range not based on probability
            if(lastCustomRangeIndex == 0) {
                this.$('#btnAddCustomRangeWithoutProbability').show();
            }
        }
        lastCustomRange = this._getLastCustomRange(category, range.customType);
        if(lastCustomRange.$el) {
            lastCustomRange.$('.addCustomRange').parent().show();
        }

        // update checkboxes
        this.updateCustomRangesCheckboxes();
    },

    /**
     * Change a label for a custom range in the model
     *
     * @param {jQuery.Event} event keyup
     */
    updateCustomRangeLabel: function(event) {
        var category = $(event.target).data('category'),
            fieldKey = $(event.target).data('key'),
            categoryOptions = category + '_options',
            bucketDomOptions = _.clone(this.model.get(categoryOptions));

        if (category && fieldKey && bucketDomOptions) {
            bucketDomOptions[fieldKey] = $(event.target).val();
            this.model.set(categoryOptions, bucketDomOptions);
        }
    },

    /**
     * Validate labels for custom ranges, if it is invalid add error style for input
     *
     * @param {string} category type for the ranges 'show_binary' etc.
     */
    validateCustomRangeLabels: function(category) {
        var opts = this.model.get(category + '_options'),
            hasErrors = false,
            range;

        _.each(opts, function(label, key) {
            range = this.fieldRanges[category][key];
            if(_.isEmpty(label.trim())) {
                range.$('.control-group').addClass('error');
                hasErrors = true;
            } else {
                range.$('.control-group').removeClass('error');
            }
        }, this);

        var saveBtn = this.layout.layout.$('[name=save_button]');
        if(saveBtn) {
            if(hasErrors) {
                // if there are errors, disable the save button
                saveBtn.addClass('disabled');
            } else if(!hasErrors && saveBtn.hasClass('disabled')) {
                // if there are no errors and the save btn is disabled, enable it
                saveBtn.removeClass('disabled');
            }
        }
    },

    /**
     * Change in_included_total value for custom range in model
     *
     * @param {Backbone.Event} event change
     */
    updateCustomRangeIncludeInTotal: function(event) {
        var category = $(event.target).data('category'),
            fieldKey = $(event.target).data('key'),
            categoryRanges = category + '_ranges',
            ranges;

        if (category && fieldKey) {
            ranges = _.clone(this.model.get(categoryRanges));
            if (ranges && ranges[fieldKey]) {
                if (fieldKey !== 'exclude' && fieldKey.indexOf('custom_without_probability') == -1) {
                    var isChecked = $(event.target).is(':checked');
                    ranges[fieldKey].in_included_total = isChecked;
                    if(isChecked) {
                        // silently add this range to the includedCommitStages
                        this.includedCommitStages.push(fieldKey);
                    } else {
                        // silently remove this range from includedCommitStages
                        this.includedCommitStages = _.without(this.includedCommitStages, fieldKey)
                    }

                    this.model.set('commit_stages_included', this.includedCommitStages);

                } else {
                    ranges[fieldKey].in_included_total = false;
                }
                this.model.set(categoryRanges, ranges);
                this.updateCustomRangesCheckboxes();
            }
        }
    },

    /**
     * Iterates through custom ranges checkboxes and enables/disables
     * checkboxes so users can only select certain checkboxes to include ranges
     */
    updateCustomRangesCheckboxes: function() {
        var els = this.$('#plhCustomDefault :checkbox, #plhCustom :checkbox'),
            len = els.length,
            $el,
            fieldKey,
            i;

        for(i = 0; i < len; i++) {
            $el = $(els[i]);
            fieldKey = $el.data('key');

            //disable the checkbox
            $el.attr('disabled', true);
            // remove any click event listeners
            $el.off('click');

            // looking specifically for checkboxes that are not the 'include' checkbox but that are
            // the last included commit stage range or the first non-included commit stage range
            if(fieldKey !== 'include'
                && (i == this.includedCommitStages.length - 1 || i == this.includedCommitStages.length)) {
                // enable the checkbox
                $el.attr('disabled', false);
                // add new click event listener
                $el.on('click', _.bind(this.updateCustomRangeIncludeInTotal, this));
                app.accessibility.run($el, 'click');
            }
        }
    },

    /**
     * Updates the setting in the model for the specific range types.
     * This gets triggered when the range slider after the user changes a range
     *
     * @param {string} category type for the ranges 'show_binary' etc.
     * @param {string} range - the range being set, i. e. `include`, `exclude` or `upside` for `show_buckets` category
     * @param {number} value - the value being set
     */
    updateRangeSettings: function(category, range, value) {
        var catRange = category + '_ranges',
            setting = _.clone(this.model.get(catRange));

        if (category == 'show_custom_buckets') {
            value.in_included_total = setting[range].in_included_total || false;
        }

        setting[range] = value;
        this.model.set(catRange, setting);
    },

    /**
     * Graphically connects the sliders to the one below, so that they move in unison when changed, based on category.
     *
     * @param {string} ranges - the forecasts category that was selected, i. e. 'show_binary' or 'show_buckets'
     * @param {Object} sliders - an object containing the sliders that have been set up in the page.  This is created in the
     * selection handler when the user selects a category type.
     */
    connectSliders: function(ranges, sliders) {
        var rangeSliders = sliders[ranges];

        if(ranges == 'show_binary') {
            rangeSliders.include.sliderChangeDelegate = function(value) {
                // lock the upper handle to 100, as per UI/UX requirements to show a dual slider
                rangeSliders.include.$(rangeSliders.include.fieldTag).noUiSlider('move', {handle: 'upper', to: rangeSliders.include.def.maxRange});
                // set the excluded range based on the lower value of the include range
                this.view.setExcludeValueForLastSlider(value, ranges, rangeSliders.include);
            };
        } else if(ranges == 'show_buckets') {
            rangeSliders.include.sliderChangeDelegate = function(value) {
                // lock the upper handle to 100, as per UI/UX requirements to show a dual slider
                rangeSliders.include.$(rangeSliders.include.fieldTag).noUiSlider('move', {handle: 'upper', to: rangeSliders.include.def.maxRange});

                rangeSliders.upside.$(rangeSliders.upside.fieldTag).noUiSlider('move', {handle: 'upper', to: value.min - 1});
                if(value.min <= rangeSliders.upside.$(rangeSliders.upside.fieldTag).noUiSlider('value')[0] + 1) {
                    rangeSliders.upside.$(rangeSliders.upside.fieldTag).noUiSlider('move', {handle: 'lower', to: value.min - 2});
                }
            };
            rangeSliders.upside.sliderChangeDelegate = function(value) {
                rangeSliders.include.$(rangeSliders.include.fieldTag).noUiSlider('move', {handle: 'lower', to: value.max + 1});
                // set the excluded range based on the lower value of the upside range
                this.view.setExcludeValueForLastSlider(value, ranges, rangeSliders.upside);
            };
        } else if(ranges == 'show_custom_buckets') {
            var i, max,
                customSliders = _.sortBy(_.filter(
                    rangeSliders,
                    function(item) {
                        return item.customType == 'custom';
                    }
                ), function(item) {
                        return parseInt(item.customIndex, 10);
                    }
                ),
                probabilitySliders = _.union(rangeSliders.include, rangeSliders.upside, customSliders, rangeSliders.exclude);

            if(probabilitySliders.length) {
                for(i = 0, max = probabilitySliders.length; i < max; i++) {
                    probabilitySliders[i].connectedSlider = (probabilitySliders[i + 1]) ? probabilitySliders[i + 1] : null;
                    probabilitySliders[i].connectedToSlider = (probabilitySliders[i - 1]) ? probabilitySliders[i - 1] : null;
                    probabilitySliders[i].sliderChangeDelegate = function(value, populateEvent) {
                        // lock the upper handle to 100, as per UI/UX requirements to show a dual slider
                        if(this.name == 'include') {
                            this.$(this.fieldTag).noUiSlider('move', {handle: 'upper', to: this.def.maxRange});
                        } else if(this.name == 'exclude') {
                            this.$(this.fieldTag).noUiSlider('move', {handle: 'lower', to: this.def.minRange});
                        }

                        if(this.connectedSlider) {
                            this.connectedSlider.$(this.connectedSlider.fieldTag).noUiSlider('move', {handle: 'upper', to: value.min - 1});
                            if(value.min <= this.connectedSlider.$(this.connectedSlider.fieldTag).noUiSlider('value')[0] + 1) {
                                this.connectedSlider.$(this.connectedSlider.fieldTag).noUiSlider('move', {handle: 'lower', to: value.min - 2});
                            }
                            if(_.isUndefined(populateEvent) || populateEvent == 'down') {
                                this.connectedSlider.sliderChangeDelegate.call(this.connectedSlider, {
                                    min: this.connectedSlider.$(this.connectedSlider.fieldTag).noUiSlider('value')[0],
                                    max: this.connectedSlider.$(this.connectedSlider.fieldTag).noUiSlider('value')[1]
                                }, 'down');
                            }
                        }
                        if(this.connectedToSlider) {
                            this.connectedToSlider.$(this.connectedToSlider.fieldTag).noUiSlider('move', {handle: 'lower', to: value.max + 1});
                            if(value.max >= this.connectedToSlider.$(this.connectedToSlider.fieldTag).noUiSlider('value')[1] - 1) {
                                this.connectedToSlider.$(this.connectedToSlider.fieldTag).noUiSlider('move', {handle: 'upper', to: value.max + 2});
                            }
                            if(_.isUndefined(populateEvent) || populateEvent == 'up') {
                                this.connectedToSlider.sliderChangeDelegate.call(this.connectedToSlider, {
                                    min: this.connectedToSlider.$(this.connectedToSlider.fieldTag).noUiSlider('value')[0],
                                    max: this.connectedToSlider.$(this.connectedToSlider.fieldTag).noUiSlider('value')[1]
                                }, 'up');
                            }
                        }
                    };
                }
            }
        }
    },

    /**
     * Provides a way for the last of the slider fields in the view, to set the value for the exclude range.
     *
     * @param {Object} value the range value of the slider
     * @param {string} ranges the selected config range
     * @param {Object} slider the slider
     */
    setExcludeValueForLastSlider: function(value, ranges, slider) {
        var excludeRange = {
                min: 0,
                max: 100
            },
            settingName = ranges + '_ranges',
            setting = _.clone(this.model.get(settingName));

        excludeRange.max = value.min - 1;
        excludeRange.min = slider.def.minRange;
        setting.exclude = excludeRange;
        this.model.set(settingName, setting);
    }
}) },
"config-forecast-by": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastsConfigForecastByView
 * @alias SUGAR.App.view.layouts.BaseForecastsConfigForecastByView
 * @extends View.Views.Base.ConfigPanelView
 */
({
	// Config-forecast-by View (base) 

    extendsFrom: 'ConfigPanelView',

    /**
     * @inheritdoc
     */
    _updateTitleValues: function() {
        this.titleSelectedValues = this.model.get('forecast_by');
    }
}) },
"list-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastsListHeaderpaneView
 * @alias SUGAR.App.view.layouts.BaseForecastsListHeaderpaneView
 * @extends View.Views.Base.ListHeaderpaneView
 */
({
	// List-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    plugins: ['FieldErrorCollection'],

    /**
     * If the Save button should be disabled or not
     * @type Boolean
     */
    saveBtnDisabled: true,

    /**
     * If the Commit button should be disabled or not
     * @type Boolean
     */
    commitBtnDisabled: true,

    /**
     * If any fields in the view have errors or not
     * @type Boolean
     */
    fieldHasErrorState: false,

    /**
     * The Save Draft Button Field
     * @type View.Fields.Base.ButtonField
     */
    saveDraftBtnField: undefined,

    /**
     * The Commit Button Field
     * @type View.Fields.Base.ButtonField
     */
    commitBtnField: undefined,

    /**
     * If Forecasts' data sync is complete and we can render buttons
     * @type Boolean
     */
    forecastSyncComplete: false,

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.layout.context.on('forecasts:sync:start', function() {
            this.forecastSyncComplete = false;
            this.setButtonStates();
        }, this);
        this.layout.context.on('forecasts:sync:complete', function() {
            this.forecastSyncComplete = true;
            this.setButtonStates();
        }, this);

        this.on('render', function() {
            // switching from mgr to rep leaves $el null, so make sure we grab a fresh reference
            // to the field if it's there but $el is null in the current reference
            if (!this.saveDraftBtnField || (this.saveDraftBtnField && _.isNull(this.saveDraftBtnField.$el))) {
                // get reference to the Save Draft button Field
                this.saveDraftBtnField = this.getField('save_draft_button');
            }
            if (!this.commitBtnField || (this.commitBtnField && _.isNull(this.commitBtnField.$el))) {
                // get reference to the Commit button Field
                this.commitBtnField = this.getField('commit_button');
            }

            this.saveDraftBtnField.setDisabled();
            this.commitBtnField.setDisabled();
        }, this);

        this.context.on('change:selectedUser', function(model, changed) {
            this._title = changed.full_name;
            if (!this.disposed) {
                this.render();
            }
        }, this);

        this.context.on('plugin:fieldErrorCollection:hasFieldErrors', function(collection, hasErrors) {
            if(this.fieldHasErrorState !== hasErrors) {
                this.fieldHasErrorState = hasErrors;
                this.setButtonStates();
            }
        }, this)

        this.context.on('button:print_button:click', function() {
            window.print();
        }, this);

        this.context.on('forecasts:worksheet:is_dirty', function(worksheet_type, is_dirty) {
            is_dirty = !is_dirty;
            if (this.saveBtnDisabled !== is_dirty || this.commitBtnDisabled !== is_dirty) {
                this.saveBtnDisabled = is_dirty;
                this.commitBtnDisabled = is_dirty;
                this.setButtonStates();
            }
        }, this);

        this.context.on('button:commit_button:click button:save_draft_button:click', function() {
            if (!this.saveBtnDisabled || !this.commitBtnDisabled) {
                this.saveBtnDisabled = true;
                this.commitBtnDisabled = true;
                this.setButtonStates();
            }
        }, this);

        this.context.on('forecasts:worksheet:saved', function(totalSaved, worksheet_type, wasDraft) {
            if(wasDraft === true && this.commitBtnDisabled) {
                this.commitBtnDisabled = false;
                this.setButtonStates();
            }
        }, this);

        this.context.on('forecasts:worksheet:needs_commit', function(worksheet_type) {
            if (this.commitBtnDisabled) {
                this.commitBtnDisabled = false;
                this.setButtonStates();
            }
        }, this);

        this._super('bindDataChange');
    },

    /**
     * Sets the Save Button and Commit Button to enabled or disabled
     */
    setButtonStates: function() {
        // make sure all data sync has finished before updating button states
        if(this.forecastSyncComplete) {
            // fieldHasErrorState trumps the disabled flags, but when it's cleared
            // revert back to whatever states the buttons were in
            if (this.fieldHasErrorState) {
                this.saveDraftBtnField.setDisabled(true);
                this.commitBtnField.setDisabled(true);
                this.commitBtnField.$('.commit-button').tooltip();
            } else {
                this.saveDraftBtnField.setDisabled(this.saveBtnDisabled);
                this.commitBtnField.setDisabled(this.commitBtnDisabled);

                if (!this.commitBtnDisabled) {
                    this.commitBtnField.$('.commit-button').tooltip('destroy');
                } else {
                    this.commitBtnField.$('.commit-button').tooltip();
                }
            }
        } else {
            // disable buttons while syncing
            if(this.saveDraftBtnField) {
                this.saveDraftBtnField.setDisabled(true);
            }
            if(this.commitBtnField) {
                this.commitBtnField.setDisabled(true);
            }
        }
    },

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        if(!this._title) {
            var user = this.context.get('selectedUser') || app.user.toJSON();
            this._title = user.full_name;
        }

        this._super('_renderHtml');
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if(this.layout.context) {
            this.layout.context.off('forecasts:sync:start', null, this);
            this.layout.context.off('forecasts:sync:complete', null, this);
        }
        this._super('_dispose');
    }
}) },
"config-scenarios": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastsConfigScenariosView
 * @alias SUGAR.App.view.layouts.BaseForecastsConfigScenariosView
 * @extends View.Views.Base.ConfigPanelView
 */
({
	// Config-scenarios View (base) 

    extendsFrom: 'ConfigPanelView',

    /**
     * Holds ALL possible different scenarios
     */
    scenarioOptions: [],

    /**
     * Holds the scenario objects that should start selected by default
     */
    selectedOptions: [],

    /**
     * Holds the select2 instance of the default scenario that users cannot change
     */
    defaultSelect2: undefined,

    /**
     * Holds the select2 instance of the options that users can add/remove
     */
    optionsSelect2: undefined,

    /**
     * The default key used for the "Amount" value in forecasts, right now it is "likely" but users will be able to
     * change that in admin to be best or worst
     *
     * todo: eventually this will be moved to config settings where users can select their default forecasted value likely/best/worst
     */
    defaultForecastedAmountKey: 'show_worksheet_likely',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.selectedOptions = [];
        this.scenarioOptions = [];

        // set up scenarioOptions
        _.each(this.meta.panels[0].fields, function(field) {
            var obj = {
                id: field.name,
                text: app.lang.get(field.label, 'Forecasts')
            }

            // Check if this field is the one we don't want users to delete
            if(field.name == this.defaultForecastedAmountKey) {
                obj['locked'] = true;
            }

            this.scenarioOptions.push(obj);

            // if this should be selected by default and it is not the undeletable scenario, push it to selectedOptions
            if(this.model.get(field.name) == 1) {
                // push fields that should be selected to selectedOptions
                this.selectedOptions.push(obj);
            }
        }, this);
    },

    /**
     * Empty function as the title values have already been set properly
     * with the change:scenarios event handler
     *
     * @inheritdoc
     */
    _updateTitleValues: function() {
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:scenarios', function(model) {
            var arr = [];

            if(model.get('show_worksheet_likely')) {
                arr.push(app.lang.get('LBL_FORECASTS_CONFIG_WORKSHEET_SCENARIOS_LIKELY', 'Forecasts'));
            }
            if(model.get('show_worksheet_best')) {
                arr.push(app.lang.get('LBL_FORECASTS_CONFIG_WORKSHEET_SCENARIOS_BEST', 'Forecasts'));
            }
            if(model.get('show_worksheet_worst')) {
                arr.push(app.lang.get('LBL_FORECASTS_CONFIG_WORKSHEET_SCENARIOS_WORST', 'Forecasts'));
            }

            this.titleSelectedValues = arr.join(', ');

            this.updateTitle();
        }, this);

        // trigger the change event to set the title when this gets added
        this.model.trigger('change:scenarios', this.model);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        this.$('.select2-container-disabled').width('auto');
        this.$('.select2-search-field').css('display','none');

        // handle setting up select2 options
        var isRTL = app.lang.direction === 'rtl';
        this.optionsSelect2 = this.$('#scenariosSelect').select2({
            data: this.scenarioOptions,
            multiple: true,
            width: "100%",
            containerCssClass: "select2-choices-pills-close",
            escapeMarkup: function(m) {
                return m;
            },
            initSelection : _.bind(function (element, callback) {
                callback(this.selectedOptions);
            }, this)
        });
        this.optionsSelect2.select2('val', this.selectedOptions);

        this.optionsSelect2.on('change', _.bind(this.handleScenarioModelChange, this));
    },

    /**
     * Event handler for the select2 dropdown changing selected items
     *
     * @param {jQuery.Event} evt select2 change event
     */
    handleScenarioModelChange: function(evt) {
        var changedEnabled = [],
            changedDisabled = [],
            allOptions = [];

        // Get the options that changed and set the model
        _.each($(evt.target).val().split(','), function(option) {
            changedEnabled.push(option);
            this.model.set(option, true, {silent: true});
        }, this);

        // Convert all scenario options into a flat array of ids
        _.each(this.scenarioOptions, function(option) {
            allOptions.push(option.id);
        }, this);

        // Take all options and return an array without the ones that changed to true
        changedDisabled = _.difference(allOptions, changedEnabled);

        // Set any options that weren't changed to true to false
        _.each(changedDisabled, function(option) {
            this.model.set(option, false, {silent: true});
        }, this);

        this.model.trigger('change:scenarios', this.model);
    },

    /**
     * Formats pill selections
     *
     * @param {Object} item selected item
     */
    formatCustomSelection: function(item) {
        return '<a class="select2-choice-filter" rel="'+ item.id + '" href="javascript:void(0)">'+ item.text +'</a>';
    },

    /**
     * @inheritdoc
     *
     * Remove custom listeners off select2 instances
     */
    _dispose: function() {
        // remove event listener from select2
        if (this.defaultSelect2) {
            this.defaultSelect2.off();
            this.defaultSelect2.select2('destroy');
            this.defaultSelect2 = null;
        }
        if (this.optionsSelect2) {
            this.optionsSelect2.off();
            this.optionsSelect2.select2('destroy');
            this.optionsSelect2 = null;
        }

        this._super('_dispose');
    }
}) },
"info": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Forecasts.InfoView
 * @alias SUGAR.App.view.views.BaseForecastsInfoView
 * @extends View.View
 */
({
	// Info View (base) 

    /**
     * Timeperiod model 
     */
    tpModel: undefined,
    
    /**
     * @inheritdoc
     *
     */
    initialize: function(options) {
        if (app.lang.direction === 'rtl') {
            options.template = app.template.getView('info.info-rtl', 'Forecasts');

            // reverse the datapoints
            options.meta.datapoints.reverse();
        }

        this.tpModel = new Backbone.Model();
        this._super("initialize", [options]);
        this.resetSelection(this.context.get("selectedTimePeriod"));
    },
    
    /**
     * @inheritdoc
     *
     */
    bindDataChange: function(){
        this.tpModel.on("change", function(model){
            this.context.trigger(
                'forecasts:timeperiod:changed',
                model,
                this.getField('selectedTimePeriod').tpTooltipMap[model.get('selectedTimePeriod')]);
        }, this);
        
        this.context.on("forecasts:timeperiod:canceled", function(){
            this.resetSelection(this.tpModel.previous("selectedTimePeriod"));
        }, this);
        
    },
    
    /**
     * Sets the timeperiod to the selected timeperiod, used primarily for resetting
     * the dropdown on nav cancel
     */
    resetSelection: function(timeperiod_id){
        this.tpModel.set({selectedTimePeriod:timeperiod_id}, {silent:true});
        _.find(this.fields, function(field){
            if(_.isEqual(field.name, "selectedTimePeriod")){
                field.render();
                return true;
            }
        });
    }
    
}) }
}}
,
"layouts": {
"base": {
"records": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Forecasts Records Layout
 *
 * @class View.Layouts.Base.Forecasts.RecordsLayout
 * @alias SUGAR.App.view.layouts.BaseForecastsRecordsLayout
 * @extends View.Layouts.Base.RecordsLayout
 *
 * Events
 *
 * forecasts:worksheet:committed
 *  on: this.context
 *  by: commitForecast
 *  when: after a successful Forecast Commit
 */
({
	// Records Layout (base) 

    /**
     * bool to store if a child worksheet is dirty
     */
    isDirty: false,
    
    /**
     * worksheet type
     */
    worksheetType: '',
    
    /**
     * the forecast navigation message
     */
    navigationMessage: "",
    
    /**
     * The options from the initialize call
     */
    initOptions: undefined,

    /**
     * Are the event already bound to the context and the models?
     */
    eventsBound: false,

    /**
     * Overrides the Layout.initialize function and does not call the parent so we can defer initialization
     * until _onceInitSelectedUser is called
     *
     * @inheritdoc
     */
    initialize: function(options) {
        this.initOptions = options;
        this._super('initialize', [options]);
        this.syncInitData();

    },

    /**
     * @inheritdoc
     */
    initComponents: function() {
    },

    /**
     * Overrides loadData to defer it running until we call it in _onceInitSelectedUser
     *
     * @inheritdoc
     */
    loadData: function() {
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        // we need this here to track when the selectedTimeperiod changes and then also move it up to the context
        // so the recordlists can listen for it.
        if (!_.isUndefined(this.model) && this.eventsBound == false) {
            this.eventsBound = true;
            this.collection.on('reset', function() {
                // get the first model and set the last commit date
                var lastCommit = _.first(this.collection.models);
                var commitDate = undefined;
                if (lastCommit instanceof Backbone.Model && lastCommit.has('date_modified')) {
                    commitDate = lastCommit.get('date_modified');
                }
                this.context.set({'currentForecastCommitDate': commitDate});
            }, this);
            // since the selected user change on the context, update the model
            this.context.on('change:selectedUser', function(model, changed) {
                var update = {
                    'selectedUserId': changed.id,
                    'forecastType': app.utils.getForecastType(changed.is_manager, changed.showOpps)
                };
                this.model.set(update);
            }, this);

            // if the model changes, run a fetch
            this.model.on('change', function() {
                // clear this out as something on the model changed,
                // this will be set once the collection resets
                // set the value to null since it can be undefined
                this.context.set({'currentForecastCommitDate' : null}, {silent: true});
                this.collection.fetch();
            }, this);

            this.context.on('change:selectedTimePeriod', function() {
                // clear this out if the timeperiod changed on the context,
                // this will be set once the collection resets
                // set the value to null since it can be undefined
                this.context.set({'currentForecastCommitDate' : null}, {silent: true});
                this.collection.fetch();
            }, this);

            // listen on the context for a commit trigger
            this.context.on('forecasts:worksheet:commit', function(user, worksheet_type, forecast_totals) {
                this.commitForecast(user, worksheet_type, forecast_totals);
            }, this);

            //listen for the worksheets to be dirty/clean
            this.context.on("forecasts:worksheet:dirty", function(type, isDirty) {
                this.isDirty = isDirty;
                this.worksheetType = type;
            }, this);

            //listen for the worksheet navigation messages
            this.context.on("forecasts:worksheet:navigationMessage", function(message) {
                this.navigationMessage = message;
            }, this);

            //listen for the user to change
            this.context.on("forecasts:user:changed", function(selectedUser, context) {
                if (this.isDirty) {
                    app.alert.show('leave_confirmation', {
                        level: 'confirmation',
                        messages: app.lang.get(this.navigationMessage, 'Forecasts').split('<br>'),
                        onConfirm: _.bind(function() {
                            app.utils.getSelectedUsersReportees(selectedUser, context);
                        }, this),
                        onCancel: _.bind(function() {
                            this.context.trigger('forecasts:user:canceled');
                        }, this)
                    });
                } else {
                    app.utils.getSelectedUsersReportees(selectedUser, context);
                }
            }, this);

            //handle timeperiod change events
            this.context.on('forecasts:timeperiod:changed', function(model, startEndDates) {
                // create an anonymous function to combine the two calls where this is used
                var onSuccess = _.bind(function() {
                    this.context.set('selectedTimePeriod', model.get('selectedTimePeriod'));
                    this._saveTimePeriodStatEndDates(startEndDates['start'], startEndDates['end']);
                }, this);

                if (this.isDirty) {
                    app.alert.show('leave_confirmation', {
                        level: 'confirmation',
                        messages: app.lang.get(this.navigationMessage, 'Forecasts').split('<br>'),
                        onConfirm: onSuccess,
                        onCancel: _.bind(function() {
                            this.context.trigger('forecasts:timeperiod:canceled');
                        }, this)
                    });
                } else {
                    // call the on success handler
                    onSuccess();
                }
            }, this);
        }
    },

    /**
     * Utility Method to handle saving of the timeperiod start and end dates so we can use them in other parts
     * of the forecast application
     *
     * @param {String} startDate        Start Date
     * @param {String} endDate          End Date
     * @param {Boolean} [doSilent]      When saving to the context, should this be silent to supress events
     * @return {Object} The object that is saved to the context if the context is there.
     * @private
     */
    _saveTimePeriodStatEndDates: function(startDate, endDate, doSilent)
    {
        // if do silent is not passed in or it's not a boolean, then just default it to false, so the events will fire
        if (_.isUndefined(doSilent) || !_.isBoolean(doSilent)) {
            doSilent = false;
        }
        var userPref = app.date.convertFormat(app.user.getPreference('datepref')),
            systemPref = 'YYYY-MM-DD',
            dateObj = {
                start: app.date(startDate, [userPref, systemPref]).format(systemPref),
                end: app.date(endDate, [userPref, systemPref]).format(systemPref)
            };

        if (!_.isUndefined(this.context)) {
            this.context.set(
                'selectedTimePeriodStartEnd',
                dateObj,
                {silent: doSilent}
            );
        }

        return dateObj;
    },

    /**
     * Opens the Forecasts Config drawer
     */
    openConfigDrawer: function() {
        // if there is no drawer open, then we need to open the drawer.
        if(app.drawer._components.length == 0) {
            // trigger the forecast config by going to the config route, while replacing what
            // is currently there so when we use app.route.goBack() from the cancel button
            app.router.navigate('Forecasts/config', {replace: true, trigger: true});
        }
    },

    /**
     * Get the Forecast Init Data from the server
     *
     * @param {Object} options
     */
    syncInitData: function(options) {
        var callbacks,
            url;

        options = options || {};
        // custom success handler
        options.success = _.bind(function(data) {
            // Add Forecasts-specific stuff to the app.user object
            app.user.set(data.initData.userData);
            if (data.initData.forecasts_setup === 0) {
                // Immediately open the config drawer so user can set up config
                this.openConfigDrawer();
            } else {
                this.initForecastsModule(data);
            }
        }, this);

        // since we have not initialized the view yet, pull the model from the initOptions.context
        var model = this.initOptions.context.get('model');
        callbacks = app.data.getSyncCallbacks('read', model, options);
        this.trigger("data:sync:start", 'read', model, options);

        url = app.api.buildURL("Forecasts/init", null, null, options.params);

        var params = {},
            cfg = app.metadata.getModule('Forecasts', 'config');
        if (cfg && cfg.is_setup === 0) {
            // add no-cache header if forecasts isnt set up yet
            params = {
                headers: {
                    'Cache-Control': 'no-cache'
                }
            };
        }
        app.api.call("read", url, null, callbacks, params);
    },

    /**
     * Process the Forecast Data
     *
     * @param {Object} data contains the data passed back from Forecasts/init endpoint
     */
    initForecastsModule: function(data) {
        var ctx = this.initOptions.context;
        // we watch for the first selectedUser change to actually init the Forecast Module case then we know we have
        // a proper selected user
        ctx.once('change:selectedUser', this._onceInitSelectedUser, this);

        // lets see if the user has ranges selected, so lets generate the key from the filters
        var ranges_key = app.user.lastState.buildKey('worksheet-filter', 'filter', 'ForecastWorksheets'),
            default_selection = app.user.lastState.get(ranges_key) || data.defaultSelections.ranges;

        // set items on the context from the initData payload
        ctx.set({
            // set the value to null since it can be undefined
            currentForecastCommitDate: null,
            selectedTimePeriod: data.defaultSelections.timeperiod_id.id,
            selectedRanges: default_selection,
            selectedTimePeriodStartEnd: this._saveTimePeriodStatEndDates(
                data.defaultSelections.timeperiod_id.start,
                data.defaultSelections.timeperiod_id.end,
                true
            )
        }, {silent: true});

        ctx.get('model').set({'selectedTimePeriod': data.defaultSelections.timeperiod_id.id}, {silent: true});

        // set the selected user to the context
        app.utils.getSelectedUsersReportees(app.user.toJSON(), ctx);
    },

    /**
     * Event handler for change:selectedUser
     * Triggered once when the user is set for the first time.  After setting user it calls
     * the init of the records layout
     *
     * @param {Backbone.Model} model the model from the change event
     * @param {String} change the updated selectedUser value from the change event
     * @private
     */
    _onceInitSelectedUser: function(model, change) {
        // init the recordlist view
        app.view.Layout.prototype.initialize.call(this, this.initOptions);
        app.view.Layout.prototype.initComponents.call(this);

        // set the selected user and forecast type on the model
        this.model.set('selectedUserId', change.id, {silent: true});
        this.model.set('forecastType', app.utils.getForecastType(change.is_manager, change.showOpps));
        // bind the collection sync to our custom sync
        this.collection.sync = _.bind(this.sync, this);

        // load the data
        app.view.Layout.prototype.loadData.call(this);
        if (this.eventsBound === false) {
            // bind the data change
            this.bindDataChange();
        }
        // render everything
        if (!this.disposed) this.render();
    },

    /**
     * Custom sync method used by this.collection
     *
     * @param {String} method
     * @param {Backbone.Model} model
     * @param {Object} options
     */
    sync: function(method, model, options) {
        var callbacks,
            url;

        options = options || {};

        options.params = options.params || {};

        var args_filter = [],
            filter = null;
        if (this.context.has('selectedTimePeriod')) {
            args_filter.push({"timeperiod_id": this.context.get('selectedTimePeriod')});
        }
        if (this.model.has('selectedUserId')) {
            args_filter.push({"user_id": this.model.get('selectedUserId')});
            args_filter.push({"forecast_type": this.model.get('forecastType')});
        }

        if (!_.isEmpty(args_filter)) {
            filter = {"filter": args_filter};
        }

        options.params.order_by = 'date_entered:DESC'
        options = app.data.parseOptionsForSync(method, model, options);

        // custom success handler
        options.success = _.bind(function(data) {
            if (!this.disposed) {
                this.collection.reset(data);
            }
        }, this);

        callbacks = app.data.getSyncCallbacks(method, model, options);

        // if there's a 412 error dismiss the custom loading alert
        this.collection.once('data:sync:error', function() {
            app.alert.dismiss('worksheet_loading');
        }, this);

        this.collection.trigger("data:sync:start", method, model, options);

        url = app.api.buildURL("Forecasts/filter", null, null, options.params);
        app.api.call("create", url, filter, callbacks);
    },

    /**
     * Commit A Forecast
     *
     * @fires forecasts:worksheet:committed
     * @param {Object} user
     * @param {String} worksheet_type
     * @param {Object} forecast_totals
     */
    commitForecast: function(user, worksheet_type, forecast_totals) {
        var forecast = new this.collection.model(),
            forecastType = app.utils.getForecastType(user.is_manager, user.showOpps),
            forecastData = {};


        // we need a commit_type so we know what to do on the back end.
        forecastData.commit_type = worksheet_type;
        forecastData.timeperiod_id = forecast_totals.timeperiod_id || this.context.get('selectedTimePeriod');
        forecastData.forecast_type = forecastType;

        forecast.save(forecastData, { success: _.bind(function(model, response) {
            // we need to make sure we are not disposed, this handles any errors that could come from the router and window
            // alert events
            if (!this.disposed) {
                // Call sync again so commitLog has the full collection
                // method gets overridden and options just needs an
                this.collection.fetch();
                this.context.trigger("forecasts:worksheet:committed", worksheet_type, response);
                var msg, managerName;
                if (worksheet_type === 'sales_rep') {
                    if (user.is_manager) {
                        // as manager, use own name
                        managerName = user.full_name;
                    } else {
                        // as sales rep, use manager name
                        managerName = user.reports_to_name;
                    }
                } else {
                    if (user.reports_to_id) {
                        // if manager has a manager, use reports to name
                        managerName = user.reports_to_name;
                    }
                }
                if (managerName) {
                    msg = Handlebars.compile(app.lang.get('LBL_FORECASTS_WORKSHEET_COMMIT_SUCCESS_TO', 'Forecasts'))(
                        {
                            manager: managerName
                        }
                    );
                } else {
                    // user does not report to anyone, don't use any name
                    msg = Handlebars.compile(app.lang.get('LBL_FORECASTS_WORKSHEET_COMMIT_SUCCESS', 'Forecasts'))();
                }

                app.alert.show('success', {
                    level: 'success',
                    autoClose: true,
                    autoCloseDelay: 10000,
                    title: app.lang.get('LBL_FORECASTS_WIZARD_SUCCESS_TITLE', 'Forecasts') + ':',
                    messages: [msg]
                });
            }
        }, this),
            error: _.bind(function(model, error) {
                //if the metadata error comes back, we saved successfully, so we need to clear the is_dirty flag so the
                //page can reload
                if (error.status === 412) {
                    this.context.trigger('forecasts:worksheet:is_dirty', worksheet_type, false);
                }
            }, this),
            silent: true, alerts: { 'success': false }});
    }
}) },
"config-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ForecastsConfigDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseForecastsConfigDrawerLayout
 * @extends View.Layouts.Base.ConfigDrawerLayout
 */
({
	// Config-drawer Layout (base) 

    extendsFrom: 'ConfigDrawerLayout',

    /**
     * @inheritdoc
     *
     * Checks Forecasts ACLs to see if the User is a system admin
     * or if the user has a developer role for the Forecasts module
     *
     * @inheritdoc
     */
    _checkModuleAccess: function() {
        var acls = app.user.getAcls().Forecasts,
            isSysAdmin = (app.user.get('type') == 'admin'),
            isDev = (!_.has(acls, 'developer'));

        return (isSysAdmin || isDev);
    },

    /**
     * Checks Forecasts config metadata to see if the correct Sales Stage Won/Lost settings are present
     *
     * @inheritdoc
     */
    _checkModuleConfig: function() {
        return app.utils.checkForecastConfig();
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PreviewLayout
 * @alias SUGAR.App.view.layouts.BasePreviewLayout
 * @extends View.Layout
 */
({
	// Preview Layout (base) 

    events: {
        'click .closeSubdetail': 'hidePreviewPanel'
    },
    initialize: function(opts) {
        app.view.Layout.prototype.initialize.call(this, opts);
        app.events.on('preview:open', this.showPreviewPanel, this);
        app.events.on('preview:close', this.hidePreviewPanel, this);
        app.events.on('preview:pagination:hide', this.hidePagination, this);
    },

    /**
     * Show the preview panel, if it is part of the active drawer
     * @param event (optional) DOM event
     */
    showPreviewPanel: function(event) {
        if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            var layout = this.$el.parents('.sidebar-content');
            layout.find('.side-pane').removeClass('active');
            layout.find('.dashboard-pane').hide();
            layout.find('.preview-pane').addClass('active');

            var defaultLayout = this.closestComponent('sidebar');
            if (defaultLayout) {
                defaultLayout.trigger('sidebar:toggle', true);
            }
        }
    },

    /**
     * Hide the preview panel, if it is part of the active drawer
     * @param event (optional) DOM event
     */
    hidePreviewPanel: function(event) {
        if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            var layout = this.$el.parents('.sidebar-content');
            layout.find('.side-pane').addClass('active');
            layout.find('.dashboard-pane').show();
            layout.find('.preview-pane').removeClass('active');
            app.events.trigger('list:preview:decorate', false);
        }
    },

    hidePagination: function() {
        if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            this.hideNextPrevious = true;
            this.trigger('preview:pagination:update');
        }
    }
}) },
"config-drawer-content": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.ForecastsConfigDrawerContentLayout
 * @alias SUGAR.App.view.layouts.BaseForecastsConfigDrawerContentLayout
 * @extends View.Layouts.Base.ConfigDrawerContentLayout
 */
({
	// Config-drawer-content Layout (base) 

    extendsFrom: 'ConfigDrawerContentLayout',

    timeperiodsTitle: undefined,
    timeperiodsText: undefined,
    scenariosTitle: undefined,
    scenariosText: undefined,
    rangesTitle: undefined,
    rangesText: undefined,
    forecastByTitle: undefined,
    forecastByText: undefined,
    wkstColumnsTitle: undefined,
    wkstColumnsText: undefined,

    /**
     * @inheritdoc
     */
    _initHowTo: function() {
        var appLang = app.lang,
            forecastBy = app.metadata.getModule('Forecasts', 'config').forecast_by,
            forecastByLabels = {
                forecastByModule: appLang.getAppListStrings('moduleList')[forecastBy],
                forecastByModuleSingular: appLang.getAppListStrings('moduleListSingular')[forecastBy]
            };

        this.timeperiodsTitle = appLang.get('LBL_FORECASTS_CONFIG_TITLE_TIMEPERIODS', 'Forecasts');
        this.timeperiodsText = appLang.get('LBL_FORECASTS_CONFIG_HELP_TIMEPERIODS', 'Forecasts');
        this.scenariosTitle = appLang.get('LBL_FORECASTS_CONFIG_TITLE_SCENARIOS', 'Forecasts');
        this.scenariosText = appLang.get('LBL_FORECASTS_CONFIG_HELP_SCENARIOS', 'Forecasts', forecastByLabels);
        this.rangesTitle = appLang.get('LBL_FORECASTS_CONFIG_TITLE_RANGES', 'Forecasts');
        this.rangesText = appLang.get('LBL_FORECASTS_CONFIG_HELP_RANGES', 'Forecasts', forecastByLabels);
        this.forecastByTitle = appLang.get('LBL_FORECASTS_CONFIG_HOWTO_TITLE_FORECAST_BY', 'Forecasts');
        this.forecastByText = appLang.get('LBL_FORECASTS_CONFIG_HELP_FORECAST_BY', 'Forecasts');
        this.wkstColumnsTitle = appLang.get('LBL_FORECASTS_CONFIG_TITLE_WORKSHEET_COLUMNS', 'Forecasts');
        this.wkstColumnsText = appLang.get('LBL_FORECASTS_CONFIG_HELP_WORKSHEET_COLUMNS', 'Forecasts');
    },

    /**
     * @inheritdoc
     */
    _switchHowToData: function(helpId) {
        switch(helpId) {
            case 'config-timeperiods':
                this.currentHowToData.title = this.timeperiodsTitle;
                this.currentHowToData.text = this.timeperiodsText;
                break;

            case 'config-ranges':
                this.currentHowToData.title = this.rangesTitle;
                this.currentHowToData.text = this.rangesText;
                break;

            case 'config-scenarios':
                this.currentHowToData.title = this.scenariosTitle;
                this.currentHowToData.text = this.scenariosText;
                break;

            case 'config-forecast-by':
                this.currentHowToData.title = this.forecastByTitle;
                this.currentHowToData.text = this.forecastByText;
                break;

            case 'config-worksheet-columns':
                this.currentHowToData.title = this.wkstColumnsTitle;
                this.currentHowToData.text = this.wkstColumnsText;
                break;
        }
    }
}) },
"preview-activitystream": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.PreviewActivityStreamLayout
 * @alias SUGAR.App.view.layouts.BasePreviewActivityStreamLayout
 * @extends View.Layouts.Base.ActivitystreamLayout
 */
({
	// Preview-activitystream Layout (base) 

    extendsFrom: 'ActivitystreamLayout',

    _previewOpened: false, //is the preview pane open?

    /**
     * Fetch and render activities when 'preview:render' event has been fired.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        app.events.on('preview:render', this.fetchActivities, this);
        app.events.on('preview:open', function() {
            this._previewOpened = true;
        }, this);
        app.events.on('preview:close', function() {
            this._previewOpened = false;
            this.disposeAllActivities();
        }, this);
    },

    /**
     * Fetch and render activities.
     *
     * @param model
     * @param collection
     * @param fetch
     * @param previewId
     * @param {boolean} showActivities
     */
    fetchActivities: function(model, collection, fetch, previewId, showActivities) {
        if (app.metadata.getModule(model.module).isBwcEnabled) {
            // don't fetch activities for BWC modules
            return;
        }
        this.disposeAllActivities();
        this.collection.dataFetched = false;
        this.$el.hide();

        showActivities = _.isUndefined(showActivities) ? true : showActivities;
        if (showActivities) {
            this.collection.reset();
            this.collection.resetPagination();
            this.collection.setOption('endpoint', function(method, collection, options, callbacks) {
                var url = app.api.buildURL(
                    model.module,
                    null,
                    {id: model.get('id'), link: 'activities'},
                    options.params
                );

                return app.api.call('read', url, null, callbacks);
            });
            this.collection.fetch({
                /*
                 * Render activity stream
                 */
                success: _.bind(this.renderActivities, this)
            });
        }
    },

    /**
     * Render activity stream once the preview pane opens. Hide it when there are no activities.
     * @param collection
     */
    renderActivities: function(collection) {
        var self = this;
        if (this.disposed) {
            return;
        }

        if (this._previewOpened) {
            if (collection.length === 0) {
                this.$el.hide();
            } else {
                this.$el.show();
                collection.each(function(activity) {
                    self.renderPost(activity, true);
                });
            }
        } else {
            //FIXME: MAR-2798 prevent the possibility of an infinite loop
            _.delay(function() {
                self.renderActivities(collection);
            }, 500);
        }
    },

    /**
     * No need to set collectionOptions.
     */
    setCollectionOptions: function() {},

    /**
     * No need to expose data transfer object since this activity stream is readonly.
     */
    exposeDataTransfer: function() {},

    /**
     * Don't load activity stream until 'preview:render' event has been fired.
     */
    loadData: function() {},

    /**
     * No need to bind events here because this activity stream is readonly.
     */
    bindDataChange: function() {
        this.collection.on('add', function(activity) {
            if (!this.disposed) {
                this.renderPost(activity, true);
            }
        }, this);
    }
}) }
}}
,
"datas": {}

},
		"ForecastWorksheets":{"fieldTemplates": {
"base": {
"currency": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastsWorksheets.CurrencyField
 * @alias SUGAR.App.view.fields.BaseForecastsWorksheetsCurrencyField
 * @extends View.Fields.Base.CurrencyField
 */
({
	// Currency FieldTemplate (base) 

    extendsFrom: 'CurrencyField',

    initialize: function(options) {
        // we need to make a clone of the plugins and then push to the new object. this prevents double plugin
        // registration across ExtendedComponents
        this.plugins = _.clone(this.plugins) || [];
        this.plugins.push('ClickToEdit');
        this._super("initialize", [options]);
    }
}) },
"enum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastsWorksheets.EnumField
 * @alias SUGAR.App.view.fields.BaseForecastsWorksheetsEnumField
 * @extends View.Fields.Base.EnumField
 */
({
	// Enum FieldTemplate (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // we need to make a clone of the plugins and then push to the new object. this prevents double plugin
        // registration across ExtendedComponents
        this.plugins = _.clone(this.plugins) || [];
        this.plugins.push('ClickToEdit');
        this._super("initialize", [options]);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if(this.name === 'sales_stage') {
            this.model.on('change:sales_stage', function(model, newValue) {
                var salesStageWon = app.metadata.getModule('Forecasts', 'config').sales_stage_won;
                if(_.contains(salesStageWon, newValue)) {
                    this.context.trigger('forecasts:cteRemove:' + model.id)
                }
            }, this);
        }

        if(this.name === 'commit_stage') {
            this.context.on('forecasts:cteRemove:' + this.model.id, function() {
                this.$el.removeClass('isEditable');
                var $divEl = this.$('div.clickToEdit');
                if($divEl.length) {
                    $divEl.removeClass('clickToEdit');
                }
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');

        // make sure commit_stage enum maintains 'list' class for style reasons
        if(this.name === 'commit_stage' && this.$el.hasClass('disabled')) {
            this.$el.addClass('list');
        }
    }
}) },
"parent": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastsWorksheets.ParentField
 * @alias SUGAR.App.view.fields.BaseForecastsWorksheetsParentField
 * @extends View.Fields.Base.ParentField
 */
({
	// Parent FieldTemplate (base) 

    extendsFrom: 'ParentField',

    _render: function () {
        if(this.model.get('parent_deleted') == 1) {
            // set the value for use in the template
            this.deleted_value = this.model.get('name');
            // override the template to use the delete one
            this.options.viewName = 'deleted';
        }
        this._super("_render");
    }
}) },
"date": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastsWorksheets.DateField
 * @alias SUGAR.App.view.fields.BaseForecastsWorksheetsDateField
 * @extends View.Fields.Base.DateField
 */
({
	// Date FieldTemplate (base) 

    extendsFrom: 'DateField',

    /**
     * @inheritdoc
     *
     * Add `ClickToEdit` plugin to the list of required plugins.
     */
    _initPlugins: function() {
        this._super('_initPlugins');

        this.plugins = _.union(this.plugins, [
            'ClickToEdit'
        ]);

        return this;
    }
}) },
"int": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastsWorksheets.IntField
 * @alias SUGAR.App.view.fields.BaseForecastsWorksheetsIntField
 * @extends View.Fields.Base.IntField
 */
({
	// Int FieldTemplate (base) 

    extendsFrom: 'IntField',

    initialize: function(options) {
        // we need to make a clone of the plugins and then push to the new object. this prevents double plugin
        // registration across ExtendedComponents
        this.plugins = _.clone(this.plugins) || [];
        this.plugins.push('ClickToEdit');
        this._super("initialize", [options]);
    }
}) }
}}
,
"views": {
"base": {
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Forecast Sales Rep Worksheet Record List.
 *
 * @class View.Views.Base.ForecastsWorksheets.RecordlistView
 * @alias SUGAR.App.view.views.BaseForecastsWorksheetsRecordlistView
 * @extends View.Views.Base.RecordlistView
 */
/**
 * Events
 *
 * forecasts:worksheet:is_dirty
 *  on: this.context.parent || this.context
 *  by: this.dirtyModels 'add' Event
 *  when: a model is added to the dirtModels collection
 *
 * forecasts:worksheet:needs_commit
 *  on: this.context.parent || this.context
 *  by: checkForDraftRows
 *  when: this.collection has a row newer than the last commit date
 *
 * forecasts:worksheet:totals
 *  on: this.context.parent || this.context
 *  by: calculateTotals
 *  when: after it's done calculating totals from a collection change or reset event
 *
 * forecasts:worksheet:saved
 *  on: this.context.parent || this.context
 *  by: saveWorksheet
 *  when: after it's done saving the worksheets to the db for a save draft
 *
 * forecasts:worksheet:commit
 *  on: this.context.parent || this.context
 *  by: forecasts:worksheet:saved event
 *  when: only when the commit button is pressed
 *
 * forecasts:sync:start
 *  on: this.context.parent
 *  by: data:sync:start handler
 *  when: this.collection starts syncing
 *
 * forecasts:sync:complete
 *  on: this.context.parent
 *  by: data:sync:complete handler
 *  when: this.collection completes syncing
 *
 */
({
	// Recordlist View (base) 

    /**
     * Who is my parent
     */
    extendsFrom: 'RecordlistView',

    /**
     * Type of worksheet
     */
    worksheetType: 'sales_rep',

    /**
     * Totals Storage
     */
    totals: {},

    /**
     * Before W/L/B Columns Colspan
     */
    before_colspan: 0,

    /**
     * After W/L/B Columns Colspan
     */
    after_colspan: 0,

    /**
     * Selected User Storage
     */
    selectedUser: {},

    /**
     * Can we edit this worksheet?
     *
     * defaults to true as it's always the current user that loads first
     */
    canEdit: true,

    /**
     * Active Filters
     */
    filters: [],

    /**
     * Filtered Collection
     */
    filteredCollection: new Backbone.Collection(),

    /**
     * Selected Timeperiod Storage
     */
    selectedTimeperiod: '',

    /**
     * Navigation Message To Display
     */
    navigationMessage: '',

    /**
     * Special Navigation for the Window Refresh
     */
    routeNavigationMessage: '',

    /**
     * Do we actually need to display a navigation message
     */
    displayNavigationMessage: false,

    /**
     * Only check for draft records once
     */
    hasCheckedForDraftRecords: false,

    /**
     * Holds the model currently being displayed in the preview panel
     */
    previewModel: undefined,

    /**
     * Tracks if the preview panel is visible or not
     */
    previewVisible: false,

    /**
     * is the collection syncing
     * @param boolean
     */
    isCollectionSyncing: false,

    /**
     * is the commit history being loading
     * @param boolean
     */
    isLoadingCommits: false,

    /**
     * The template for when we don't have access to a data point
     */
    noAccessDataErrorTemplate: undefined,

    /**
     * Target URL of the nav action
     */
    targetURL: '',
    
    /**
     * Current URL of the module
     */
    currentURL: '',

    /**
     * Takes the values calculated in `this.totals` and condenses them for the totals.hbs subtemplate
     */
    totalsTemplateObj: undefined,

    initialize: function(options) {
        // we need to make a clone of the plugins and then push to the new object. this prevents double plugin
        // registration across ExtendedComponents
        this.plugins = _.without(this.plugins, 'ReorderableColumns', 'MassCollection');
        this.plugins.push('ClickToEdit', 'DirtyCollection');
        this._super('initialize', [options]);
        // we need to get the flex-list template from the ForecastWorksheets module so it can use the filteredCollection
        // for display
        this.template = app.template.getView('flex-list', this.module);
        this.selectedUser = this.context.get('selectedUser') || this.context.parent.get('selectedUser') || app.user.toJSON();
        this.selectedTimeperiod = this.context.get('selectedTimePeriod') || this.context.parent.get('selectedTimePeriod') || '';
        this.context.set('skipFetch', !(this.selectedUser.showOpps || !this.selectedUser.is_manager)); // if user is a manager, skip the initial fetch
        this.filters = this.context.get('selectedRanges') || this.context.parent.get('selectedRanges');
        this.collection.sync = _.bind(this.sync, this);
        this.noAccessDataErrorTemplate = app.template.getField('base', 'noaccess')(this);
        this.currentURL = Backbone.history.getFragment();
    },

    _dispose: function() {
        if (!_.isUndefined(this.context.parent) && !_.isNull(this.context.parent)) {
            this.context.parent.off(null, null, this);
            if (this.context.parent.has('collection')) {
                this.context.parent.get('collection').off(null, null, this);
            }
        }
        // make sure this alert is hidden if the the view is disposed
        app.alert.dismiss('workshet_loading');
        app.routing.offBefore('route', this.beforeRouteHandler, this);
        $(window).off('beforeunload.' + this.worksheetType);
        this._super('_dispose');
    },

    bindDataChange: function() {
        // these are handlers that we only want to run when the parent module is forecasts
        if (!_.isUndefined(this.context.parent) && !_.isUndefined(this.context.parent.get('model'))) {
            if (this.context.parent.get('model').module == 'Forecasts') {
                this.context.parent.on('button:export_button:click', function() {
                    if (this.layout.isVisible()) {
                        this.exportCallback();
                    }
                }, this);
                this.before('render', function() {
                    return this.beforeRenderCallback()
                }, this);
                this.on('render', function() {
                    this.renderCallback();
                    if (this.previewVisible) {
                        this.decorateRow(this.previewModel);
                    }
                }, this);

                this.on('list:toggle:column', function(column, isVisible, columnMeta) {
                    // if we hide or show a column, recalculate totals
                    this.calculateTotals();
                }, this);

                this.context.parent.on('forecasts:worksheet:totals', function(totals, type) {
                    if (type == this.worksheetType && this.layout.isVisible()) {
                        this.totalsTemplateObj = {
                            orderedFields: []
                        };
                        var tpl = app.template.getView('recordlist.totals', this.module),
                            filteredKey,
                            totalValues;

                        // loop through visible fields in metadata order
                        _.each(this._fields.visible, function(field) {
                            if(_.contains(['likely_case', 'best_case', 'worst_case'], field.name)) {
                                totalValues = {};
                                totalValues.fieldName = field.name;

                                switch(field.name) {
                                    case 'worst_case':
                                    case 'best_case':
                                        filteredKey = field.name.split('_')[0];
                                        break;
                                    case 'likely_case':
                                        filteredKey = 'amount';
                                        break;
                                }

                                totalValues.display = this.totals[field.name + '_display'];
                                totalValues.access = this.totals[field.name + '_access'];
                                totalValues.filtered = this.totals['filtered_' + filteredKey];
                                totalValues.overall = this.totals['overall_' + filteredKey];

                                this.totalsTemplateObj.orderedFields.push(totalValues);
                            }
                        }, this);

                        this.$('tfoot').remove();
                        this.$('tbody').after(tpl(this));
                    }
                }, this);

                /**
                 * trigger an event if dirty
                 */
                this.dirtyModels.on('add change reset', function(){
                    if(this.layout.isVisible()){
                        this.context.parent.trigger('forecasts:worksheet:dirty', this.worksheetType, this.dirtyModels.length > 0);
                    }
                }, this);
                
                this.context.parent.on('change:selectedTimePeriod', function(model, changed) {
                    this.updateSelectedTimeperiod(changed);
                }, this);

                this.context.parent.on('change:selectedUser', function(model, changed) {
                    this.updateSelectedUser(changed)
                }, this);

                this.context.parent.on('button:save_draft_button:click', function() {
                    if (this.layout.isVisible()) {
                        // after we save, trigger the needs_commit event
                        this.context.parent.once('forecasts:worksheet:saved', function() {
                            // clear out the current navigation message
                            this.setNavigationMessage(false, '', '');
                            this.cleanUpDirtyModels();
                            this.refreshData();
                            this.collection.once('reset', function(){
                                this.context.parent.trigger('forecasts:worksheet:needs_commit', this.worksheetType);
                            }, this);
                        }, this);
                        this.saveWorksheet(true);
                    }
                }, this);

                this.context.parent.on('button:commit_button:click', function() {
                    if (this.layout.isVisible()) {
                        this.context.parent.once('forecasts:worksheet:saved', function() {
                            this.context.parent.trigger('forecasts:worksheet:commit', this.selectedUser, this.worksheetType, this.getCommitTotals())
                        }, this);
                        this.saveWorksheet(false);
                    }
                }, this);

                this.context.parent.on('change:currentForecastCommitDate', function(context, changed) {
                    if (this.layout.isVisible()) {
                        this.checkForDraftRows(changed);
                    }
                }, this);

                if (this.context.parent.has('collection')) {
                    var parentCollection = this.context.parent.get('collection');

                    parentCollection.on('data:sync:start', function() {
                        this.isLoadingCommits = true;
                    }, this);
                    parentCollection.on('data:sync:complete', function() {
                        this.isLoadingCommits = false;
                    }, this);
                }

                this.collection.on('data:sync:start', function() {
                    this.isCollectionSyncing = true;
                    // Begin sync start for buttons
                    this.context.parent.trigger('forecasts:sync:start');
                }, this);

                this.collection.on('data:sync:complete', function() {
                    this.isCollectionSyncing = false;
                    // End sync start for buttons
                    this.context.parent.trigger('forecasts:sync:complete');
                }, this);

                this.collection.on('reset', function() {
                    this.setNavigationMessage(false, '', '');
                    this.cleanUpDirtyModels();
                    var ctx = this.context.parent || this.context;
                    ctx.trigger('forecasts:worksheet:is_dirty', this.worksheetType, false);
                    if (this.isLoadingCommits === false) {
                        this.checkForDraftRows(ctx.get('currentForecastCommitDate'));
                    }
                    this.filterCollection();
                }, this);

                this.collection.on('change:commit_stage', function(model) {
                    if (!_.isEmpty(this.filters)  // we have filters
                        && _.indexOf(this.filters, model.get('commit_stage')) === -1 // and the commit_stage is not shown
                        ) {
                        this.filterCollection();
                        _.defer(_.bind(function() {
                            if (!this.disposed) {
                                this.render();
                            }
                        }, this));
                    } else {
                        var commitStage = model.get('commit_stage'),
                            includedCommitStages = app.metadata.getModule('Forecasts', 'config').commit_stages_included,
                            el = this.$('tr[name=' + model.module + '_' + model.id + ']'),
                            isIncluded = _.include(includedCommitStages, commitStage);

                        if (el) {
                            // we need to update the data-forecast attribute on the row
                            // and the new commit stage is visible
                            el.attr('data-forecast', commitStage);

                            if (isIncluded && !el.hasClass('included')) {
                                // if the commitStage is included, and it doesnt have the included class, add it
                                el.addClass('included');
                                model.set({ includedInForecast: true }, {silent: true});
                            } else if (!isIncluded && el.hasClass('included')) {
                                // if the commitStage isn't included, and it still has the class, remove it
                                el.removeClass('included');
                                model.unset('includedInForecast');
                            }
                        }
                    }
                }, this);

                this.context.parent.on('change:selectedRanges', function(model, changed) {
                    this.filters = changed;
                    this.once('render', function() {
                        app.alert.dismiss('worksheet_filtering');
                    });
                    this.filterCollection();
                    this.calculateTotals();
                    if (!this.disposed) this.render();
                }, this);

                this.context.parent.on('forecasts:worksheet:committed', function() {
                    if (this.layout.isVisible()) {
                        this.setNavigationMessage(false, '', '');
                        this.cleanUpDirtyModels();
                        var ctx = this.context.parent || this.context;
                        ctx.trigger('forecasts:worksheet:is_dirty', this.worksheetType, false);
                        this.refreshData();
                    }
                }, this);

                this.context.parent.on('forecasts:worksheet:is_dirty', function(worksheetType, is_dirty) {
                    if (this.worksheetType == worksheetType) {
                        if (is_dirty) {
                            this.setNavigationMessage(true, 'LBL_WARN_UNSAVED_CHANGES', 'LBL_WARN_UNSAVED_CHANGES');
                        } else {
                            this.setNavigationMessage(false, '', '');
                        }
                    }
                }, this);

                app.routing.before('route', this.beforeRouteHandler, this);

                $(window).bind('beforeunload.' + this.worksheetType, _.bind(function() {
                    var ret = this.showNavigationMessage('window');
                    if (_.isString(ret)) {
                        return ret;
                    }
                }, this));
            }
        }

        // listen for the before list:orderby to handle if the worksheet is dirty or notW
        this.before('list:orderby', function(options) {
            if (this.isDirty()) {
                app.alert.show('leave_confirmation', {
                    level: 'confirmation',
                    messages: app.lang.get('LBL_WARN_UNSAVED_CHANGES_CONFIRM_SORT', 'Forecasts'),
                    onConfirm: _.bind(function() {
                        this._setOrderBy(options);
                    }, this)
                });
                return false;
            }
            return true;
        }, this);

        this.collection.on('reset change', function() {
            this.calculateTotals();
        }, this);

        if (!_.isUndefined(this.dirtyModels)) {
            this.dirtyModels.on('add', function() {
                if (this.canEdit) {
                    var ctx = this.context.parent || this.context;
                    ctx.trigger('forecasts:worksheet:is_dirty', this.worksheetType, true);
                }
            }, this);
        }

        this.layout.on('hide', function() {
            this.totals = {};
        }, this);

        // call the parent
        this._super('bindDataChange');
    },

    beforeRouteHandler: function() {
        return this.showNavigationMessage('router');
    },
    
    /**
     * default navigation callback for alert message
     */
    defaultNavCallback: function(){
        this.displayNavigationMessage = false;
        app.router.navigate(this.targetURL, {trigger: true});
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        app.events.off(null, null, this);
        this._super('unbindData');
    },

    /**
     * Handle Showing of the Navigation messages if any are applicable
     *
     * @param type
     * @returns {*}
     */
    showNavigationMessage: function(type, callback) {
        if (!_.isFunction(callback)) {
            callback = this.defaultNavCallback;
        }
        
        if (this.layout.isVisible()) {
            var canEdit = this.dirtyCanEdit || this.canEdit;
            if (canEdit && this.displayNavigationMessage) {
                if (type == 'window') {
                    if (!_.isEmpty(this.routeNavigationMessage)) {
                        return app.lang.get(this.routeNavigationMessage, 'Forecasts');
                    }
                    return false;
                }
                this.targetURL = Backbone.history.getFragment();

                //Replace the url hash back to the current staying page
                app.router.navigate(this._currentUrl, {trigger: false, replace: true});

                app.alert.show('leave_confirmation', {
                    level: 'confirmation',
                    messages: app.lang.get(this.navigationMessage, 'Forecasts').split('<br>'),
                    onConfirm: _.bind(function() {
                        callback.call(this);
                    }, this)
                });
                return false;
            }
        }
        return true;
    },

    /**
     * Utility to set the Navigation Message and Flag
     *
     * @param display
     * @param reload_label
     * @param route_label
     */
    setNavigationMessage: function(display, reload_label, route_label) {
        this.displayNavigationMessage = display;
        this.navigationMessage = reload_label;
        this.routeNavigationMessage = route_label;
        this.context.parent.trigger('forecasts:worksheet:navigationMessage', this.navigationMessage);
    },

    /**
     * Handle the export callback
     */
    exportCallback: function() {

        if (this.canEdit && this.isDirty()) {
            app.alert.show('leave_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_WORKSHEET_EXPORT_CONFIRM', 'Forecasts'),
                onConfirm: _.bind(function() {
                    this.doExport();
                }, this)
            });
        } else {
            this.doExport();
        }
    },

    /**
     * Actually run the export
     */
    doExport: function() {
        app.alert.show('massexport_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});
        var params = {
            timeperiod_id: this.selectedTimeperiod,
            user_id: this.selectedUser.id,
            filters: this.filters,
            platform: app.config.platform
        };
        var url = app.api.buildURL(this.module, 'export', null, params);

        app.api.fileDownload(url, {
            complete: function(data) {
                app.alert.dismiss('massexport_loading');
            }
        }, { iframe: this.$el });
    },

    /**
     * Callback for the before('render') event
     * @returns {boolean}
     */
    beforeRenderCallback: function() {
        // set the defaults to make it act like a manager so it doesn't actually render till the selected
        // user is updated
        var showOpps = (_.isUndefined(this.selectedUser.showOpps)) ? false : this.selectedUser.showOpps,
            isManager = (_.isUndefined(this.selectedUser.is_manager)) ? true : this.selectedUser.is_manager;

        if (!(showOpps || !isManager) && this.layout.isVisible()) {
            this.layout.hide();
        } else if ((showOpps || !isManager) && !this.layout.isVisible()) {
            this.layout.once('show', this.calculateTotals, this);
            this.layout.show();
        }

        // empty out the left columns
        this.leftColumns = [];

        return (showOpps || !isManager);
    },

    /**
     * Callback for the on('render') event
     */
    renderCallback: function() {
        var user = this.selectedUser || this.context.parent.get('selectedUser') || app.user.toJSON()
        if (user.showOpps || !user.is_manager) {
            if (!this.layout.isVisible()) {
                this.layout.show();
            }

            if (this.filteredCollection.length == 0) {
                var tpl = app.template.getView('recordlist.noresults', this.module);
                this.$('tbody').html(tpl(this));
            }

            // insert the footer
            if (!_.isEmpty(this.totals) && this.layout.isVisible()) {
                var tpl = app.template.getView('recordlist.totals', this.module);
                this.$('tbody').after(tpl(this));
            }
            //adjust width of sales stage column to longest value so cells don't shift when using CTE
            var sales_stage_width = this.$('td[data-field-name="sales_stage"] span.isEditable').width();
            var sales_stage_outerwidth = this.$('td[data-field-name="sales_stage"] span.isEditable').outerWidth();
            this.$('td[data-field-name="sales_stage"] span.isEditable').width(sales_stage_width + 20);
            this.$('td[data-field-name="sales_stage"] span.isEditable').parent('td').css('min-width', sales_stage_outerwidth + 26 + 'px');

            // figure out if any of the row actions need to be disabled
            this.setRowActionButtonStates();
        } else {
            if (this.layout.isVisible()) {
                this.layout.hide();
            }
        }
    },

    /**
     * Code to handle if the selected user changes
     *
     * @param changed
     */
    updateSelectedUser: function(changed) {
        var doFetch = false;
        if (this.selectedUser.id != changed.id) {
            // user changed. make sure it's not a manager view before we say fetch or not
            doFetch = (changed.showOpps || !changed.is_manager);
        }
        // if we are already not going to fetch, check to see if the new user is showingOpps or is not
        // a manager, then we want to fetch
        if (!doFetch && (changed.showOpps || !changed.is_manager)) {
            doFetch = true;
        }

        if (this.displayNavigationMessage) {
            // save the user just in case
            this.dirtyUser = this.selectedUser;
            this.dirtyCanEdit = this.canEdit;
        }
        this.cleanUpDirtyModels();
        
        this.selectedUser = changed;

        // Set the flag for use in other places around this controller to suppress stuff if we can't edit
        this.canEdit = (this.selectedUser.id == app.user.get('id'));
        this.hasCheckedForDraftRecords = false;

        if (doFetch) {
            this.refreshData();
        } else {
            if ((!this.selectedUser.showOpps && this.selectedUser.is_manager) && this.layout.isVisible()) {
                // we need to hide
                this.layout.hide();
            }
        }
    },

    updateSelectedTimeperiod: function(changed) {
        if (this.displayNavigationMessage) {
            // save the time period just in case
            this.dirtyTimeperiod = this.selectedTimeperiod;
        }
        this.selectedTimeperiod = changed;
        this.hasCheckedForDraftRecords = false;
        if (this.layout.isVisible()) {
            this.refreshData();
        }
    },

    /**
     * Check to make sure that if there are dirty rows, then trigger the needs_commit event to enable
     * the buttons
     *
     * @fires forecasts:worksheet:needs_commit
     * @param lastCommitDate
     */
    checkForDraftRows: function(lastCommitDate) {
        if (this.layout.isVisible() && this.canEdit && this.hasCheckedForDraftRecords === false
            && !_.isEmpty(this.collection.models) && this.isCollectionSyncing === false) {
            this.hasCheckedForDraftRecords = true;
            if (_.isUndefined(lastCommitDate)) {
                // we have rows but no commit, enable the commit button
                this.context.parent.trigger('forecasts:worksheet:needs_commit', this.worksheetType);
            } else {
                // check to see if anything in the collection is a draft, if it is, then send an event
                // to notify the commit button to enable
                this.collection.find(function(item) {
                    if (item.get('date_modified') > lastCommitDate) {
                        this.context.parent.trigger('forecasts:worksheet:needs_commit', this.worksheetType);
                        return true;
                    }
                    return false;
                }, this);
            }
        } else if (this.layout.isVisible() === false && this.canEdit && this.hasCheckedForDraftRecords === false) {
            // since the layout is not visible, lets wait for it to become visible
            this.layout.once('show', function() {
                this.checkForDraftRows(lastCommitDate);
            }, this);
        } else if (this.isCollectionSyncing === true) {
            this.collection.once('data:sync:complete', function() {
                this.checkForDraftRows(lastCommitDate);
            }, this);
        }
    },

    /**
     * Handles setting the proper state for the Preview in the row-actions
     */
    setRowActionButtonStates: function() {
        _.each(this.fields, function(field) {
            if (field.def.event === 'list:preview:fire') {
                // we have a field that needs to be disabled, so disable it!
                field.setDisabled((field.model.get('parent_deleted') == '1'));
                field.render();
            }
        });
    },

    /**
     * Filter the Collection so we only show what the filter says we should show
     */
    filterCollection: function() {
        this.filteredCollection.reset();
        if (_.isEmpty(this.filters)) {
            this.filteredCollection.add(this.collection.models);
        } else {
            this.collection.each(function(model) {
                if (_.indexOf(this.filters, model.get('commit_stage')) !== -1) {
                    this.filteredCollection.add(model);
                }
            }, this);
        }
    },

    /**
     * Save the worksheet to the database
     *
     * @fires forecasts:worksheet:saved
     * @return {Number}
     */
    saveWorksheet: function(isDraft) {
        // only run the save when the worksheet is visible and it has dirty records
        var totalToSave = 0;
        if (this.layout.isVisible()) {
            var saveCount = 0,
                ctx = this.context.parent || this.context;

            if (this.isDirty()) {
                totalToSave = this.dirtyModels.length;
                this.dirtyModels.each(function(model) {
                    //set properties on model to aid in save
                    model.set({
                        draft: (isDraft && isDraft == true) ? 1 : 0,
                        timeperiod_id: this.dirtyTimeperiod || this.selectedTimeperiod,
                        current_user: this.dirtyUser.id || this.selectedUser.id
                    }, {silent: true});

                    // set the correct module on the model since sidecar doesn't support sub-beans yet
                    model.save({}, {success: _.bind(function() {
                        saveCount++;

                        // Make sure the preview panel gets updated model info
                        if (this.previewVisible) {
                            var previewId = this.previewModel.get('parent_id') || this.previewModel.get('id');
                            if (model.get('parent_id') == previewId) {
                                var previewCollection = new Backbone.Collection();
                                this.filteredCollection.each(function(model) {
                                    if (model.get('parent_deleted') !== '1') {
                                        previewCollection.add(model);
                                    }
                                }, this);

                                app.events.trigger('preview:render', model, previewCollection, true, model.get('id'), true);
                            }
                        }

                        //if this is the last save, go ahead and trigger the callback;
                        if (totalToSave === saveCount) {
                            // we only want to show this when the draft is being saved
                            if (isDraft) {
                                app.alert.show('success', {
                                    level: 'success',
                                    autoClose: true,
                                    autoCloseDelay: 10000,
                                    title: app.lang.get('LBL_FORECASTS_WIZARD_SUCCESS_TITLE', 'Forecasts') + ':',
                                    messages: [app.lang.get('LBL_FORECASTS_WORKSHEET_SAVE_DRAFT_SUCCESS', 'Forecasts')]
                                });
                            }
                            ctx.trigger('forecasts:worksheet:saved', totalToSave, this.worksheetType, isDraft);
                        }
                    }, this), silent: true, alerts: { 'success': false }});
                }, this);

                this.cleanUpDirtyModels();
            } else {
                // we only want to show this when the draft is being saved
                if (isDraft) {
                    app.alert.show('success', {
                        level: 'success',
                        autoClose: true,
                        autoCloseDelay: 10000,
                        title: app.lang.get('LBL_FORECASTS_WIZARD_SUCCESS_TITLE', 'Forecasts') + ':',
                        messages: [app.lang.get('LBL_FORECASTS_WORKSHEET_SAVE_DRAFT_SUCCESS', 'Forecasts')]
                    });
                }
                ctx.trigger('forecasts:worksheet:saved', totalToSave, this.worksheetType, isDraft);
            }
        }

        return totalToSave
    },

    /**
     * Calculate the totals for the visible fields
     */
    calculateTotals: function() {
        // fire an event on the parent context
        if (this.layout.isVisible()) {
            this.totals = this.getCommitTotals();
            var calcFields = ['worst_case', 'best_case', 'likely_case'],
                fields = _.filter(this._fields.visible, function(field) {
                    if (_.contains(calcFields, field.name)) {
                        this.totals[field.name + '_access'] = app.acl.hasAccess('read', this.module, app.user.get('id'), field.name);
                        this.totals[field.name + '_display'] = true;
                        return true;
                    }

                    return false;
                }, this);

            // loop though all the fields and find where the worst/likely/best start at
            for(var x = 0; x < this._fields.visible.length; x++) {
                var f = this._fields.visible[x];
                if (_.contains(calcFields, f.name)) {
                    break;
                }
            }

            this.before_colspan = x;
            this.after_colspan = (this._fields.visible.length - (x + fields.length));

            var ctx = this.context.parent || this.context;
            ctx.trigger('forecasts:worksheet:totals', this.totals, this.worksheetType);
        }
    },

    /**
     * Set the loading message and have a way to hide it
     */
    displayLoadingMessage: function() {
        app.alert.show('worksheet_loading',
            {level: 'process', title: app.lang.get('LBL_LOADING')}
        );
        this.collection.once('reset', function() {
            app.alert.dismiss('worksheet_loading');
        }, this);
    },

    /**
     * Custom Method to handle the refreshing of the worksheet Data
     */
    refreshData: function() {
        this.displayLoadingMessage();
        this.collection.fetch();
    },

    /**
     * Custom Sync Method
     *
     * @param method
     * @param model
     * @param options
     */
    sync: function(method, model, options) {
        var callbacks,
            url;

        options = options || {};
        options.params = options.params || {};

        if (!_.isUndefined(this.selectedUser.id)) {
            options.params.user_id = this.selectedUser.id;
        }
        if (!_.isEmpty(this.selectedTimeperiod)) {
            options.params.timeperiod_id = this.selectedTimeperiod;
        }

        options.limit = 1000;
        options = app.data.parseOptionsForSync(method, model, options);

        // Since parent_name breaks the XHR call in the order by, just use the name field instead
        // they are the same anyways.
        if (!_.isUndefined(options.params.order_by) && options.params.order_by.indexOf('parent_name') === 0) {
            options.params.order_by = options.params.order_by.replace('parent_', '');
        }

        // custom success handler
        options.success = _.bind(function(data) {
            if (!this.disposed) {
                this.collection.reset(data);
            }
        }, this);

        callbacks = app.data.getSyncCallbacks(method, model, options);
        this.collection.trigger('data:sync:start', method, model, options);

        url = app.api.buildURL('ForecastWorksheets', null, null, options.params);
        app.api.call('read', url, null, callbacks);
    },

    /**
     * Get the totals that need to be committed
     *
     * @returns {{amount: number, best_case: number, worst_case: number, overall_amount: number, overall_best: number, overall_worst: number, timeperiod_id: (*|bindDataChange.selectedTimeperiod), lost_count: number, lost_amount: number, won_count: number, won_amount: number, included_opp_count: number, total_opp_count: Number, closed_count: number, closed_amount: number}}
     */
    getCommitTotals: function() {
        var includedAmount = 0,
            includedBest = 0,
            includedWorst = 0,
            filteredAmount = 0,
            filteredBest = 0,
            filteredWorst = 0,
            filteredCount = 0,
            overallAmount = 0,
            overallBest = 0,
            overallWorst = 0,
            includedCount = 0,
            lostCount = 0,
            lostAmount = 0,
            lostBest = 0,
            lostWorst = 0,
            wonCount = 0,
            wonAmount = 0,
            wonBest = 0,
            wonWorst = 0,
            includedClosedCount = 0,
            includedClosedAmount = 0,
            cfg = app.metadata.getModule('Forecasts', 'config'),
            startEndDates = this.context.get('selectedTimePeriodStartEnd') ||
                this.context.parent.get('selectedTimePeriodStartEnd'),
            activeFilters = this.context.get('selectedRanges') || this.context.parent.get('selectedRanges') || [];

        //Get the excluded_sales_stage property.  Default to empty array if not set
        var sales_stage_won_setting = cfg.sales_stage_won || [],
            sales_stage_lost_setting = cfg.sales_stage_lost || [];

        // set up commit_stages that should be processed in included total
        var commit_stages_in_included_total = ['include'];

        if (cfg.forecast_ranges == 'show_custom_buckets') {
            commit_stages_in_included_total = cfg.commit_stages_included;
        }

        this.collection.each(function(model) {
            // make sure that the selected date is between the start and end dates for the current timeperiod
            // if it's not, then don't include it in the totals
            if (app.date(model.get('date_closed')).isBetween(startEndDates['start'], startEndDates['end'])) {
                var won = _.include(sales_stage_won_setting, model.get('sales_stage')),
                    lost = _.include(sales_stage_lost_setting, model.get('sales_stage')),
                    commit_stage = model.get('commit_stage'),
                    base_rate = model.get('base_rate'),
                    // added || 0 in case these converted out to NaN so they dont make charts blow up
                    worst_base = app.currency.convertWithRate(model.get('worst_case'), base_rate) || 0,
                    amount_base = app.currency.convertWithRate(model.get('likely_case'), base_rate) || 0,
                    best_base = app.currency.convertWithRate(model.get('best_case'), base_rate) || 0,
                    includedInForecast = _.include(commit_stages_in_included_total, commit_stage),
                    includedInFilter = _.include(activeFilters, commit_stage);

                if (won && includedInForecast) {
                    wonAmount = app.math.add(wonAmount, amount_base);
                    wonBest = app.math.add(wonBest, best_base);
                    wonWorst = app.math.add(wonWorst, worst_base);
                    wonCount++;

                    includedClosedCount++;
                    includedClosedAmount = app.math.add(amount_base, includedClosedAmount);
                } else if (lost) {
                    lostAmount = app.math.add(lostAmount, amount_base);
                    lostBest = app.math.add(lostBest, best_base);
                    lostWorst = app.math.add(lostWorst, worst_base);
                    lostCount++;
                }

                if (includedInFilter || _.isEmpty(activeFilters)) {
                    filteredAmount = app.math.add(filteredAmount, amount_base);
                    filteredBest = app.math.add(filteredBest, best_base);
                    filteredWorst = app.math.add(filteredWorst, worst_base);
                    filteredCount++;
                }

                if (includedInForecast) {
                    includedAmount = app.math.add(includedAmount, amount_base);
                    includedBest = app.math.add(includedBest, best_base);
                    includedWorst = app.math.add(includedWorst, worst_base);
                    includedCount++;

                    // since we're already looping through the collection of models and we have
                    // the included commit stages, set or unset the includedInForecast property here
                    model.set({ includedInForecast: true }, {silent: true});
                } else if (model.has('includedInForecast')) {
                    model.unset('includedInForecast');
                }

                overallAmount = app.math.add(overallAmount, amount_base);
                overallBest = app.math.add(overallBest, best_base);
                overallWorst = app.math.add(overallWorst, worst_base);
            }
        }, this);

        return {
            'likely_case': includedAmount,
            'best_case': includedBest,
            'worst_case': includedWorst,
            'overall_amount': overallAmount,
            'overall_best': overallBest,
            'overall_worst': overallWorst,
            'filtered_amount': filteredAmount,
            'filtered_best': filteredBest,
            'filtered_worst': filteredWorst,
            'timeperiod_id': this.dirtyTimeperiod || this.selectedTimeperiod,
            'lost_count': lostCount,
            'lost_amount': lostAmount,
            'won_count': wonCount,
            'won_amount': wonAmount,
            'included_opp_count': includedCount,
            'total_opp_count': this.collection.length,
            'closed_count': includedClosedCount,
            'closed_amount': includedClosedAmount
        };
    },

    /**
     * We need to overwrite so we pass in the filterd list
     */
    addPreviewEvents: function() {
        //When clicking on eye icon, we need to trigger preview:render with model&collection
        this.context.on('list:preview:fire', function(model) {
            var previewCollection = new Backbone.Collection();
            this.filteredCollection.each(function(model) {
                if (model.get('parent_deleted') !== '1') {
                    previewCollection.add(model);
                }
            }, this);

            if (_.isUndefined(this.previewModel) || model.get('id') != this.previewModel.get('id')) {
                this.previewModel = model;
                app.events.trigger('preview:render', model, previewCollection, true);
            } else {
                // user already has the preview panel open and has clicked the preview icon again
                // remove row decoration
                this.decorateRow();
                // close the preview panel
                app.events.trigger('preview:close');
            }
        }, this);

        //When switching to next/previous record from the preview panel, we need to update the highlighted row
        app.events.on('list:preview:decorate', this.decorateRow, this);
        if (this.layout) {
            this.layout.on('list:sort:fire', function() {
                //When sorting the list view, we need to close the preview panel
                app.events.trigger('preview:close');
            }, this);
        }

        app.events.on('preview:render', function(model) {
            if (this.disposed) {
                return;
            }
            this.previewModel = model;
            this.previewVisible = true;
        }, this);

        app.events.on('preview:close', function() {
            this.previewVisible = false;
            this.previewModel = undefined;
        }, this);
    }
}) },
"filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ForecastsWorksheets.FilterView
 * @alias SUGAR.App.view.views.BaseForecastsWorksheetsFilterView
 * @extends View.View
 */
({
	// Filter View (base) 

    /**
     * Front End Javascript Events
     */
    events: {
        'keydown .select2-input': 'disableSelect2KeyPress'
    },

    /**
     * Since we don't what the user to be able to type in the filter input
     * just disable all key press events for the .select2-input boxes
     *
     * @param event
     */
    disableSelect2KeyPress: function(event) {
        event.preventDefault();
    },

    /**
     * Key for saving the users last selected filters
     */
    userLastWorksheetFilterKey: undefined,

    /**
     * Initialize because we need to set the selectedUser variable
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.userLastWorksheetFilterKey = app.user.lastState.key('worksheet-filter', this);
        this.selectedUser = {
            id: app.user.get('id'),
            is_manager: app.user.get('is_manager'),
            showOpps: false
        };
    },

    // prevent excessive renders when things change.
    bindDomChange: function() {},

    /**
     * Override the render to have call the group by toggle
     *
     * @private
     */
    _render:function () {
        app.view.View.prototype._render.call(this);

        this.node = this.$el.find("#" + this.cid);

        // set up the filters
        this._setUpFilters();

        return this;
    },


    /**
     * Set up select2 for driving the filter UI
     * @param node the element to use as the basis for select2
     * @private
     */
    _setUpFilters: function() {
        var ctx = this.context.parent || this.context,
            user_ranges = app.user.lastState.get(this.userLastWorksheetFilterKey),
            selectedRanges = user_ranges || ctx.get('selectedRanges') || app.defaultSelections.ranges;

        this.node.select2({
            data:this._getRangeFilters(),
            initSelection: function(element, callback) {
                callback(_.filter(
                    this.data,
                    function(obj) {
                        return _.contains(this, obj.id);
                    },
                    $(element.val().split(","))
                ));
            },
            multiple:true,
            placeholder: app.lang.get("LBL_MODULE_FILTER"),
            dropdownCss: {width:"auto"},
            containerCssClass: "select2-choices-pills-close",
            containerCss: "border: none",
            formatSelection: this.formatCustomSelection,
            formatResultCssClass: this.formatCustomResultCssClass,
            dropdownCssClass: "search-filter-dropdown",
            escapeMarkup: function(m) { return m; },
            width: '100%'
        });

        // set the default selections
        this.node.select2("val", selectedRanges);

        // add a change handler that updates the forecasts context appropriately with the user's selection
        this.node.change(
            {
                context: ctx
            },
            _.bind(function(event) {
                app.alert.show('worksheet_filtering',
                    {level: 'process', title: app.lang.get('LBL_LOADING')}
                );
                app.user.lastState.set(this.userLastWorksheetFilterKey, event.val);
                _.delay(function() {
                    event.data.context.set('selectedRanges', event.val);
                }, 25);
            }, this)
        );
    },

    /**
     * Formats pill selections
     *
     * @param {Object} item The selected item
     * @param {jQuery} container The jQuery container element
     */
    formatCustomSelection: function(item, container) {
        $(container.prevObject).addClass(item.id + '-select-choice');
        return '<span class="select2-choice-type" disabled="disabled">' + app.lang.get('LBL_FILTER') +
            '</span><a class="select2-choice-filter" rel="' + item.id +
            '" href="javascript:void(0)">' + item.text + '</a>';
    },

    /**
     * Adds custom css class for result items
     *
     * @param {Object} object The selected item
     */
    formatCustomResultCssClass: function(object) {
        return object.id + '-select-result';
    },

    /**
     * Gets the list of filters that correspond to the forecasts range settings that were selected by the admin during
     * configuration of the forecasts module.
     *
     * @return {Array} array of the selected ranges
     */
    _getRangeFilters: function() {
        var options = app.metadata.getModule('Forecasts', 'config').buckets_dom || 'commit_stage_binary_dom';

        return _.map(app.lang.getAppListStrings(options), function(value, key)  {
            return {id: key, text: value};
        });
    }

}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"ForecastManagerWorksheets":{"fieldTemplates": {
"base": {
"currency": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastsManagerWorksheets.CurrencyField
 * @alias SUGAR.App.view.fields.BaseForecastsManagerWorksheetsCurrencyField
 * @extends View.Fields.Base.CurrencyField
 */
({
	// Currency FieldTemplate (base) 

    extendsFrom: 'CurrencyField',

    initialize: function(options) {
        // we need to make a clone of the plugins and then push to the new object. this prevents double plugin
        // registration across ExtendedComponents
        this.plugins = _.clone(this.plugins) || [];
        this.plugins.push('ClickToEdit');
        this._super("initialize", [options]);
    }
}) },
"userLink": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastsManagerWorksheets.UserLinkField
 * @alias SUGAR.App.view.fields.BaseForecastsManagerWorksheetsUserLinkField
 * @extends View.Fields.Base.BaseField
 */
({
	// UserLink FieldTemplate (base) 

    /**
     * Attach a click event to <a class="worksheetManagerLink"> field
     */
    events: { 'click a.worksheetManagerLink': 'linkClicked' },

    /**
     * Holds the user_id for passing into userTemplate
     */
    uid: '',

    initialize: function(options) {
        this.uid = this.model.get('user_id');

        app.view.Field.prototype.initialize.call(this, options);
        return this;
    },

    format: function(value) {
        var su = this.context.get('selectedUser') || this.context.parent.get('selectedUser') || app.user.toJSON();
        if (value == su.full_name && su.id == app.user.get('id')) {
            var hb = Handlebars.compile("{{str key module context}}");
            value = hb({'key': 'LBL_MY_MANAGER_LINE', 'module': this.module, 'context': su});
        }

        return value;
    },

    /**
     * Handle a user link being clicked
     * @param event
     */
    linkClicked: function(event) {
        var uid = $(event.target).data('uid');
        var selectedUser = {
            id: '',
            user_name: '',
            full_name: '',
            first_name: '',
            last_name: '',
            is_manager: false,
            showOpps: false,
            reportees: []
        };

        var options = {
            dataType: 'json',
            success: _.bind(function(data) {
                selectedUser.id = data.id;
                selectedUser.user_name = data.user_name;
                selectedUser.full_name = data.full_name;
                selectedUser.first_name = data.first_name;
                selectedUser.last_name = data.last_name;
                selectedUser.is_manager = data.is_manager;
                selectedUser.reports_to_id = data.reports_to_id;
                selectedUser.reports_to_name = data.reports_to_name;
                selectedUser.is_top_level_manager = data.is_top_level_manager || (data.is_manager && _.isEmpty(data.reports_to_id));

                var su = this.context.get('selectedUser') || this.context.parent.get('selectedUser') || app.user.toJSON();
                // get the current selected user, if the id's match up set the showOpps to be true)
                selectedUser.showOpps = (su.id == data.id);

                this.context.parent.trigger("forecasts:user:changed", selectedUser, this.context.parent);
            }, this)
        };

        myURL = app.api.buildURL('Forecasts', 'user/' + uid);
        app.api.call('read', myURL, null, options);
    }
}) },
"commithistory": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.ForecastsManagerWorksheets.CommithistoryField
 * @alias SUGAR.App.view.fields.BaseForecastsManagerWorksheetsCommithistoryField
 * @extends View.Fields.Base.BaseField
 */
({
	// Commithistory FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.on('render', function() {
            this.loadData();
        }, this);
    },

    /**
     * @inheritdoc
     */
    loadData: function() {
        var ctx = this.context.parent || this.context,
            su = ctx.get('selectedUser') || app.user.toJSON(),
            isManager = this.model.get('is_manager'),
            showOpps = (su.id == this.model.get('user_id')) ? 1 : 0,
            forecastType = app.utils.getForecastType(isManager, showOpps),
            args_filter = [],
            options = {},
            url;

        args_filter.push(
            {"user_id": this.model.get('user_id')},
            {"forecast_type": forecastType},
            {"timeperiod_id": this.view.selectedTimeperiod}
        );

        url = {"url": app.api.buildURL('Forecasts', 'filter'), "filters": {"filter": args_filter}};

        options.success = _.bind(function(data) {
            this.buildLog(data);
        }, this);
        app.api.call('create', url.url, url.filters, options, { context: this });
    },

    /**
     * Build out the History Log
     * @param data
     */
    buildLog: function(data) {
        data = data.records;
        var ctx = this.context.parent || this.context,
            forecastCommitDate = ctx.get('currentForecastCommitDate'),
            commitDate = app.date(forecastCommitDate),
            newestModel = new Backbone.Model(_.first(data)),
        // get everything that is left but the first item.
            otherModels = _.last(data, data.length - 1),
            oldestModel = {},
            displayCommitDate = newestModel.get('date_modified');

        // using for because you can't break out of _.each
        for(var i = 0; i < otherModels.length; i++) {
            // check for the first model equal to or past the forecast commit date
            // we want the last commit just before the whole forecast was committed
            if (app.date(otherModels[i].date_modified) <= commitDate) {
                oldestModel = new Backbone.Model(otherModels[i]);
                break;
            }
        }

        // create the history log
        var tpl = app.template.getField(this.type, 'log', this.module);
        this.$el.html(tpl({
            commit: app.utils.createHistoryLog(oldestModel, newestModel).text,
            commit_date: displayCommitDate
        }));
    },

    /**
     * Override the _render so we can tell it where to render at in the list view
     * @private
     */
    _render: function() {
        // set the $el equal to the place holder so it renders in the correct spot
        this.$el = this.view.$('span[sfuuid="' + this.sfId + '"]');
        this._super('_render');
    }
}) }
}}
,
"views": {
"base": {
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Forecast Manager Worksheet Record List.
 *
 * Events
 *
 * forecasts:worksheet:is_dirty
 *  on: this.context.parent || this.context
 *  by: this.dirtyModels 'add' Event
 *  when: a model is added to the dirtModels collection
 *
 * forecasts:worksheet:needs_commit
 *  on: this.context.parent || this.context
 *  by: checkForDraftRows
 *  when: this.collection has a row newer than the last commit date
 *
 * forecasts:worksheet:totals
 *  on: this.context.parent || this.context
 *  by: calculateTotals
 *  when: after it's done calculating totals from a collection change or reset event
 *
 * forecasts:worksheet:saved
 *  on: this.context.parent || this.context
 *  by: saveWorksheet and _worksheetSaveHelper
 *  when: after it's done saving the worksheets to the db for a save draft
 *
 * forecasts:worksheet:commit
 *  on: this.context.parent || this.context
 *  by: forecasts:worksheet:saved event
 *  when: only when the commit button is pressed
 *
 * forecasts:assign_quota
 *  on: this.context.parent || this.context
 *  by: forecasts:worksheet:saved event
 *  when: only when the Assign Quota button is pressed
 *
 * forecasts:sync:start
 *  on: this.context.parent
 *  by: data:sync:start handler
 *  when: this.collection starts syncing
 *
 * forecasts:sync:complete
 *  on: this.context.parent
 *  by: data:sync:complete handler
 *  when: this.collection completes syncing
 *
 * @class View.Views.Base.ForecastsManagerWorksheets.RecordListView
 * @alias SUGAR.App.view.views.BaseForecastsManagerWorksheetsRecordListView
 * @extends View.Views.Base.RecordListView
 */
({
	// Recordlist View (base) 

    /**
     * Who are parent is
     */
    extendsFrom: 'RecordlistView',

    /**
     * what type of worksheet are we?
     */
    worksheetType: 'manager',

    /**
     * Selected User Storage
     */
    selectedUser: {},

    /**
     * Can we edit this worksheet?
     */
    canEdit: true,

    /**
     * Selected Timeperiod Storage
     */
    selectedTimeperiod: {},

    /**
     * Totals Storage
     */
    totals: {},

    /**
     * Default values for the blank rows
     */
    defaultValues: {
        id: '',         // set id to empty so it fails the isNew() check as we don't want this to override the currency
        quota: '0',
        best_case: '0',
        best_case_adjusted: '0',
        likely_case: '0',
        likely_case_adjusted: '0',
        worst_case: '0',
        worst_case_adjusted: '0',
        show_history_log: 0
    },

    /**
     * Navigation Message To Display
     */
    navigationMessage: '',

    /**
     * Special Navigation for the Window Refresh
     */
    routeNavigationMessage: '',

    /**
     * Do we actually need to display a navigation message
     */
    displayNavigationMessage: false,

    /**
     * Only check for draft records once
     */
    hasCheckedForDraftRecords: false,

    /**
     * Draft Save Type
     */
    draftSaveType: undefined,

    /**
     * is the collection syncing
     * @param boolean
     */
    isCollectionSyncing: false,

    /**
     * is the commit history being loading
     * @param boolean
     */
    isLoadingCommits: false,

    /**
     * Target URL of the nav action
     */
    targetURL: '',

    /**
     * Current URL of the module
     */
    currentURL: '',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // we need to make a clone of the plugins and then push to the new object. this prevents double plugin
        // registration across ExtendedComponents
        this.plugins = _.without(this.plugins, 'ReorderableColumns', 'MassCollection');
        this.plugins.push('ClickToEdit');
        this.plugins.push('DirtyCollection');
        this._super("initialize", [options]);
        this.template = app.template.getView('flex-list', this.module);
        this.selectedUser = this.context.get('selectedUser') || this.context.parent.get('selectedUser') || app.user.toJSON();
        this.selectedTimeperiod = this.context.get('selectedTimePeriod') || this.context.parent.get('selectedTimePeriod') || '';
        this.context.set('skipFetch', (this.selectedUser.is_manager && this.selectedUser.showOpps));    // skip the initial fetch, this will be handled by the changing of the selectedUser
        this.collection.sync = _.bind(this.sync, this);
        this.currentURL = Backbone.history.getFragment();
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (!_.isUndefined(this.context.parent) && !_.isNull(this.context.parent)) {
            this.context.parent.off(null, null, this);
            if (this.context.parent.has('collection')) {
                this.context.parent.get('collection').off(null, null, this);
            }
        }
        app.routing.offBefore('route', this.beforeRouteHandler, this);
        $(window).off("beforeunload." + this.worksheetType);
        this._super("_dispose");
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        // these are handlers that we only want to run when the parent module is forecasts
        if (!_.isUndefined(this.context.parent) && !_.isUndefined(this.context.parent.get('model'))) {
            if (this.context.parent.get('model').module == 'Forecasts') {
                this.context.parent.on('button:export_button:click', function() {
                    if (this.layout.isVisible()) {
                        this.exportCallback();
                    }
                }, this);
                // before render has happened, potentially stopping the render from happening
                this.before('render', this.beforeRenderCallback, this);

                // after render has completed
                this.on('render', this.renderCallback, this);

                this.on('list:toggle:column', function(column, isVisible, columnMeta) {
                    // if we hide or show a column, recalculate totals
                    this.calculateTotals();
                }, this);

                // trigger the worksheet save draft code
                this.context.parent.on('button:save_draft_button:click', function() {
                    if (this.layout.isVisible()) {
                        // after we save, trigger the needs_commit event

                        this.context.parent.once('forecasts:worksheet:saved', function() {
                            // clear out the current navigation message
                            this.setNavigationMessage(false, '', '');
                            this.context.parent.trigger('forecasts:worksheet:needs_commit', this.worksheetType);
                        }, this);
                        this.draftSaveType = 'draft';
                        this.saveWorksheet(true);
                    }
                }, this);

                // trigger the worksheet save draft code and then commit the worksheet
                this.context.parent.on('button:commit_button:click', function() {
                    if (this.layout.isVisible()) {
                        // we just need to listen to it once, then we don't want to listen to it any more
                        this.context.parent.once('forecasts:worksheet:saved', function() {
                            this.context.parent.trigger('forecasts:worksheet:commit', this.selectedUser, this.worksheetType, this.getCommitTotals())
                        }, this);
                        this.draftSaveType = 'commit';
                        this.saveWorksheet(false);
                    }
                }, this);

                /**
                 * trigger an event if dirty
                 */
                this.dirtyModels.on("add change reset", function(){
                    if(this.layout.isVisible()){
                        this.context.parent.trigger("forecasts:worksheet:dirty", this.worksheetType, this.dirtyModels.length > 0);
                    }
                }, this);

                /**
                 * Watch for a change to the selectedTimePeriod
                 */
                this.context.parent.on('change:selectedTimePeriod', function(model, changed) {
                    this.updateSelectedTimeperiod(changed);
                }, this);

                /**
                 * Watch for a change int he worksheet totals
                 */
                this.context.parent.on('forecasts:worksheet:totals', function(totals, type) {
                    if (type == this.worksheetType) {
                        var tpl = app.template.getView('recordlist.totals', this.module);
                        this.$el.find('tfoot').remove();
                        this.$el.find('tbody').after(tpl(this));
                    }
                }, this);

                /**
                 * Watch for a change in the selectedUser
                 */
                this.context.parent.on('change:selectedUser', function(model, changed) {
                    this.updateSelectedUser(changed);
                }, this);

                /**
                 * Watch for the currentForecastCommitDate to be updated
                 */
                this.context.parent.on('change:currentForecastCommitDate', function(context, changed) {
                    if (this.layout.isVisible()) {
                        this.checkForDraftRows(changed);
                    }
                }, this);

                if (this.context.parent.has('collection')) {
                    var parentCollection = this.context.parent.get('collection');

                    parentCollection.on('data:sync:start', function() {
                        this.isLoadingCommits = true;
                    }, this);
                    parentCollection.on('data:sync:complete', function() {
                        this.isLoadingCommits = false;
                    }, this);
                }

                this.collection.on('data:sync:start', function() {
                    this.isCollectionSyncing = true;
                    // Begin sync start for buttons
                    this.context.parent.trigger('forecasts:sync:start');
                }, this);

                this.collection.on('data:sync:complete', function() {
                    this.isCollectionSyncing = false;
                    // End sync start for buttons
                    this.context.parent.trigger('forecasts:sync:complete');
                }, this);

                /**
                 * When the collection is reset, we need checkForDraftRows
                 */
                this.collection.on('reset', function() {
                    var ctx = this.context.parent || this.context;
                    ctx.trigger('forecasts:worksheet:is_dirty', this.worksheetType, false);
                    if (this.isLoadingCommits === false) {
                        this.checkForDraftRows(ctx.get('currentForecastCommitDate'));
                    }
                }, this);

                this.collection.on('change:quota', function(model, changed) {
                    // a quota has changed, trigger an event to toggle the assign quota button
                    var ctx = this.context.parent || this.context;
                    ctx.trigger('forecasts:worksheet:quota_changed', this.worksheetType);
                }, this);

                this.context.parent.on('forecasts:worksheet:committed', function() {
                    if (this.layout.isVisible()) {
                        var ctx = this.context.parent || this.context;
                        ctx.trigger('forecasts:worksheet:is_dirty', this.worksheetType, false);
                        this.refreshData();
                        // after a commit, we don't need to check for draft records again
                        this.hasCheckedForDraftRecords = true;
                    }
                }, this);

                this.context.parent.on('forecasts:worksheet:is_dirty', function(worksheetType, is_dirty) {
                    if (this.worksheetType == worksheetType) {
                        if (is_dirty) {
                            this.setNavigationMessage(true, 'LBL_WARN_UNSAVED_CHANGES', 'LBL_WARN_UNSAVED_CHANGES');
                        } else {
                            // worksheet is not dirty,
                            this.cleanUpDirtyModels();
                            this.setNavigationMessage(false, '', '');
                        }
                    }
                }, this);

                this.context.parent.on('button:assign_quota:click', function() {
                    this.context.parent.once('forecasts:worksheet:saved', function() {
                        // clear out the current navigation message
                        this.setNavigationMessage(false, '', '');
                        this.context.parent.trigger('forecasts:assign_quota', this.worksheetType, this.selectedUser, this.selectedTimeperiod);
                    }, this);
                    app.alert.show('saving_quota', {
                        level: 'process',
                        title: app.lang.get('LBL_ASSIGNING_QUOTA', 'Forecasts')
                    });
                    this.draftSaveType = 'assign_quota';
                    this.saveWorksheet(true, true);
                }, this);

                this.context.parent.on('forecasts:quota_assigned', function() {
                    // after the quote has been re-assigned, lets refresh the data just in case.
                    this.refreshData();
                }, this);

                app.routing.before('route', this.beforeRouteHandler, this);

                $(window).bind("beforeunload." + this.worksheetType, _.bind(function() {
                    if (!this.disposed) {
                        var ret = this.showNavigationMessage('window');
                        if (_.isString(ret)) {
                            return ret;
                        }
                    }
                }, this));

                this.layout.on('hide', function() {
                    this.hasCheckedForDraftRecords = false;
                }, this);
            }
        }

        // make sure that the dirtyModels plugin is there
        if (!_.isUndefined(this.dirtyModels)) {
            // when something gets added, the save_draft and commit buttons need to be enabled
            this.dirtyModels.on('add', function() {
                var ctx = this.context.parent || this.context;
                ctx.trigger('forecasts:worksheet:is_dirty', this.worksheetType, true);
            }, this);
        }

        /**
         * Listener for the list:history_log:fire event, this triggers the inline history log to display or hide
         */
        this.context.on('list:history_log:fire', function(model, e) {
            // parent row

            var row_name = model.module + '_' + model.id;

            // check if the row is open, if it is, just destroy it
            var log_row = this.$el.find('tr[name="' + row_name + '_commit_history"]');

            var field;

            // if we have a row, just close it and destroy the field
            if (log_row.length == 1) {
                // remove it and dispose the field
                log_row.remove();
                // find the field
                field = _.find(this.fields, function(field, idx) {
                    return (field.name == row_name + '_commit_history');
                }, this);
                field.dispose();
            } else {
                var rowTpl = app.template.getView('recordlist.commithistory', this.module);
                field = app.view.createField({
                    def: {
                        'type': 'commithistory',
                        'name': row_name + '_commit_history'
                    },
                    view: this,
                    model: model
                });
                this.$el.find('tr[name="' + row_name + '"]').after(rowTpl({
                    module: this.module,
                    id: model.id,
                    placeholder: field.getPlaceholder(),
                    colspan: this._fields.visible.length + this.leftColumns.length + this.rightColumns.length  // do the +1 to account for right side Row Actions
                }));
                field.render();
            }
        }, this);

        // listen for the before list:orderby to handle if the worksheet is dirty or not
        this.before('list:orderby', function(options) {
            if (this.isDirty()) {
                app.alert.show('leave_confirmation', {
                    level: 'confirmation',
                    messages: app.lang.get('LBL_WARN_UNSAVED_CHANGES_CONFIRM_SORT', 'Forecasts'),
                    onConfirm: _.bind(function() {
                        this._setOrderBy(options);
                    }, this)
                });
                return false;
            }
            return true;
        }, this);

        /**
         * On Collection Reset or Change, calculate the totals
         */
        this.collection.on('reset change', function() {
            this.calculateTotals();
        }, this);

        this.layout.on('hide', function() {
            this.totals = {};
        }, this);

        // call the parent
        this._super("bindDataChange");
    },

    /**
     * Handles the before route event so we can show nav messages
     * @returns {*}
     */
    beforeRouteHandler: function() {
        return this.showNavigationMessage('router');
    },

    /**
     * default navigation callback for alert message
     */
    defaultNavCallback: function(){
        this.displayNavigationMessage = false;
        app.router.navigate(this.targetURL, {trigger: true});
    },

    /**
     * Handle Showing of the Navigation messages if any are applicable
     *
     * @param type
     * @returns {*}
     */
    showNavigationMessage: function(type, callback) {
        if (!_.isFunction(callback)) {
            callback = this.defaultNavCallback;
        }
        if (this.layout.isVisible()) {
            var canEdit = this.dirtyCanEdit || this.canEdit;
            if (canEdit && this.displayNavigationMessage) {
                if (type == 'window') {
                    if (!_.isEmpty(this.routeNavigationMessage)) {
                        return app.lang.get(this.routeNavigationMessage, 'Forecasts');
                    }
                    return false;
                }

                this.targetURL = Backbone.history.getFragment();

                //Replace the url hash back to the current staying page
                app.router.navigate(this._currentUrl, {trigger: false, replace: true});

                app.alert.show('leave_confirmation', {
                    level: 'confirmation',
                    messages: app.lang.get(this.navigationMessage, 'Forecasts').split('<br>'),
                    onConfirm: _.bind(function() {
                        callback.call(this);
                    }, this)
                });
                return false;
            }
        }
        return true;
    },

    /**
     * Utility to set the Navigation Message and Flag
     *
     * @param display
     * @param reload_label
     * @param route_label
     */
    setNavigationMessage: function(display, reload_label, route_label) {
        this.displayNavigationMessage = display;
        this.navigationMessage = reload_label;
        this.routeNavigationMessage = route_label;
        this.context.parent.trigger("forecasts:worksheet:navigationMessage", this.navigationMessage);
    },

    /**
     * Custom Method to handle the refreshing of the worksheet Data
     */
    refreshData: function() {
        this.displayLoadingMessage();
        this.collection.fetch();
    },

    /**
     * Set the loading message and have a way to hide it
     */
    displayLoadingMessage: function() {
        app.alert.show('worksheet_loading',
            {level: 'process', title: app.lang.get('LBL_LOADING')}
        );
        this.collection.once('reset', function() {
            app.alert.dismiss('worksheet_loading');
        }, this);
    },

    /**
     * Handle the export callback
     */
    exportCallback: function() {

        if (this.canEdit && this.isDirty()) {
            app.alert.show('leave_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_WORKSHEET_EXPORT_CONFIRM', 'Forecasts'),
                onConfirm: _.bind(function() {
                    this.doExport();
                }, this)
            });
        } else {
            this.doExport();
        }
    },

    /**
     * Actually run the export
     */
    doExport: function() {
        app.alert.show('massexport_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});
        var params = {
            timeperiod_id: this.selectedTimeperiod,
            user_id: this.selectedUser.id,
            platform: app.config.platform
        };
        var url = app.api.buildURL(this.module, 'export/', null, params);

        app.api.fileDownload(url, {
            complete: function(data) {
                app.alert.dismiss('massexport_loading');
            }
        }, { iframe: this.$el });
    },

    /**
     * Method for the before('render') event
     */
    beforeRenderCallback: function() {
        // if manager is not set or manager == false
        var ret = true;
        if (_.isUndefined(this.selectedUser.is_manager) || this.selectedUser.is_manager == false) {
            ret = false;
        }

        // only render if this.selectedUser.showOpps == false which means
        // we want to display the manager worksheet view
        if (ret) {
            ret = !(this.selectedUser.showOpps);
        }

        // if we are going to stop render but the layout is visible
        if (ret === false && this.layout.isVisible()) {
            // hide the layout
            this.layout.hide();
        }

        // Adjust the label on the quota field if the user doesn't report to any one
        var quotaLabel = _.isEmpty(this.selectedUser.reports_to_id) ? 'LBL_QUOTA' : 'LBL_QUOTA_ADJUSTED';
        _.each(this._fields, function(fields) {
            _.each(fields, function(field) {
                if(field.name == 'quota') {
                    field.label = quotaLabel;
                }
            });
        });

        // empty out the left columns
        this.leftColumns = [];

        return ret;
    },

    /**
     * Method for the on('render') event
     */
    renderCallback: function() {
        var user = this.selectedUser || this.context.parent.get('selectedUser') || app.user.toJSON();
        if (user.is_manager && user.showOpps == false) {
            if (!this.layout.isVisible()) {
                this.layout.once('show', this.calculateTotals, this);
                this.layout.show();
            }

            if (!_.isEmpty(this.totals) && this.layout.isVisible()) {
                var tpl = app.template.getView('recordlist.totals', this.module);
                this.$el.find('tfoot').remove();
                this.$el.find('tbody').after(tpl(this));
            }

            // set the commit button states to match the models
            this.setCommitLogButtonStates();
        } else {
            if (this.layout.isVisible()) {
                this.layout.hide();
            }
        }
    },

    /**
     * Update the selected timeperiod, and run a fetch if the worksheet is visible
     * @param changed
     */
    updateSelectedTimeperiod: function(changed) {
        if (this.displayNavigationMessage) {
            // save the time period just in case
            this.dirtyTimeperiod = this.selectedTimeperiod;
        }

        this.selectedTimeperiod = changed;
        if (this.layout.isVisible()) {
            this.refreshData();
        }
    },

    /**
     * Update the selected user and do a fetch if the criteria is met
     * @param changed
     */
    updateSelectedUser: function(changed) {
        // selected user changed
        var doFetch = false;
        if (this.selectedUser.id != changed.id) {
            doFetch = true;
        }
        if (!doFetch && this.selectedUser.is_manager != changed.is_manager) {
            doFetch = true;
        }
        if (!doFetch && this.selectedUser.showOpps != changed.showOpps) {
            doFetch = !(changed.showOpps);
        }

        if (this.displayNavigationMessage) {
            // save the user just in case
            this.dirtyUser = this.selectedUser;
            this.dirtyCanEdit = this.canEdit;
        }

        this.selectedUser = changed;

        // Set the flag for use in other places around this controller to suppress stuff if we can't edit
        this.canEdit = (this.selectedUser.id == app.user.get('id'));
        this.cleanUpDirtyModels();

        if (doFetch) {
            this.refreshData();
        } else {
            if (this.selectedUser.is_manager && this.selectedUser.showOpps && this.layout.isVisible()) {
                // viewing managers opp worksheet so hide the manager worksheet
                this.layout.hide();
            }
        }
    },

    /**
     * Check the collection for any rows that may have been saved as a draft or rolled up from a reportee commit and
     * trigger the commit button to be enabled
     *
     * @fires forecasts:worksheet:needs_commit
     * @param lastCommitDate
     */
    checkForDraftRows: function(lastCommitDate) {
        var isVisible = this.layout.isVisible();
        if (isVisible && this.canEdit && !_.isUndefined(lastCommitDate)
            && this.collection.length !== 0 && this.hasCheckedForDraftRecords === false &&
            this.isCollectionSyncing === false) {
            this.hasCheckedForDraftRecords = true;
            this.collection.find(function(item) {
                if (item.get('date_modified') > lastCommitDate) {
                    this.context.parent.trigger('forecasts:worksheet:needs_commit', this.worksheetType);
                    return true;
                }
                return false;
            }, this);
        } else if (isVisible && this.canEdit &&_.isUndefined(lastCommitDate) && !this.collection.isEmpty) {
            // if there is no commit date, e.g. new manager with no commits yet
            // but there IS data, then the commit button should be enabled
            this.context.parent.trigger('forecasts:worksheet:needs_commit', this.worksheetType);
        } else if (isVisible === false && this.canEdit && this.hasCheckedForDraftRecords === false) {
            // since the layout is not visible, lets wait for it to become visible
            this.layout.once('show', function() {
                this.checkForDraftRows(lastCommitDate);
            }, this);
        } else if (this.isCollectionSyncing === true) {
            this.collection.once('data:sync:complete', function() {
                this.checkForDraftRows(lastCommitDate);
            }, this);
        }
    },

    /**
     * Handles setting the proper state for the CommitLog Buttons in the row-actions
     */
    setCommitLogButtonStates: function() {
        _.each(this.fields, function(field) {
            if (field.def.event === 'list:history_log:fire') {
                // we have a field that needs to be disabled, so disable it!
                field.setDisabled((field.model.get('show_history_log') == "0"));
                if ((field.model.get('show_history_log') == "0")) {
                    field.$el.find("a.rowaction").attr(
                        "data-original-title",
                        app.lang.get("LBL_NO_COMMIT", "ForecastManagerWorksheets")
                    );
                }
            }
        });
    },

    /**
     * Override the sync method so we can put out custom logic in it
     *
     * @param method
     * @param model
     * @param options
     */
    sync: function(method, model, options) {

        if (!_.isUndefined(this.context.parent) && !_.isUndefined(this.context.parent.get('selectedUser'))) {
            var sl = this.context.parent.get('selectedUser');

            if (sl.is_manager == false) {
                // they are not a manager, we should always hide this if it's not already hidden
                if (this.layout.isVisible()) {
                    this.layout.hide();
                }
                return;
            }
        }

        var callbacks,
            url;

        options = options || {};

        options.params = options.params || {};

        if (!_.isUndefined(this.selectedUser.id)) {
            options.params.user_id = this.selectedUser.id;
        }

        if (!_.isEmpty(this.selectedTimeperiod)) {
            options.params.timeperiod_id = this.selectedTimeperiod;
        }

        options.limit = 1000;
        options = app.data.parseOptionsForSync(method, model, options);

        // custom success handler
        options.success = _.bind(function(data) {
            this.collectionSuccess(data);
        }, this);

        callbacks = app.data.getSyncCallbacks(method, model, options);
        this.collection.trigger("data:sync:start", method, model, options);

        url = app.api.buildURL("ForecastManagerWorksheets", null, null, options.params);
        app.api.call("read", url, null, callbacks);
    },

    /**
     * Method to handle the success of a collection call to make sure that all reportee's show up in the table
     * even if they don't have data for the user that is asking for it.
     *
     * @param data
     */
    collectionSuccess: function(data) {
        var records = [],
            users = $.map(this.selectedUser.reportees, function(obj) {
                return $.extend(true, {}, obj);
            });

        // put the selected user on top
        users.unshift({id: this.selectedUser.id, name: this.selectedUser.full_name});

        // get the base currency
        var currency_id = app.currency.getBaseCurrencyId(),
            currency_base_rate = app.metadata.getCurrency(app.currency.getBaseCurrencyId()).conversion_rate;

        _.each(users, function(user) {
            var row = _.find(data, function(rec) {
                return (rec.user_id == this.id)
            }, user);
            if (!_.isUndefined(row)) {
                // update the name on the row as this will have the correct formatting for the locale
                row.name = user.name;
            } else {
                row = _.clone(this.defaultValues);
                row.currency_id = currency_id;
                row.base_rate = currency_base_rate;
                row.user_id = user.id;
                row.assigned_user_id = this.selectedUser.id;
                row.draft = (this.selectedUser.id == app.user.id) ? 1 : 0;
                row.name = user.name;
            }
            if (_.isEmpty(row.id)) {
                row.id = app.utils.generateUUID();
                row.fakeId = true;
            }
            records.push(row);
        }, this);

        if (!_.isUndefined(this.orderBy)) {
            // lets sort the collection
            if (this.orderBy.field !== 'name') {
                records = _.sortBy(records, function(item) {
                    // typecast values to Number since it's not the 'name'
                    // column (the only string value in the manager worksheet)
                    var val = +item[this.orderBy.field];

                    if (this.orderBy.direction == "desc") {
                        return -val;
                    } else {
                        return val;
                    }
                }, this);
            } else {
                // we have the name
                records.sort(_.bind(function(a, b) {
                    if (this.orderBy.direction == 'asc') {
                        if (a.name.toString() < b.name.toString()) return 1;
                        if (a.name.toString() > b.name.toString()) return -1;
                    } else {
                        if (a.name.toString() < b.name.toString()) return -1;
                        if (a.name.toString() > b.name.toString()) return 1;
                    }
                    return 0;
                }, this));
            }
        }

        this.collection.isEmpty = (_.isEmpty(data));
        this.collection.reset(records);
    },

    /**
     * Calculates the display totals for the worksheet
     *
     * @fires forecasts:worksheet:totals
     */
    calculateTotals: function() {
        if (this.layout.isVisible()) {
            this.totals = this.getCommitTotals();
            this.totals['display_total_label_in'] = _.first(this._fields.visible).name;
            _.each(this._fields.visible, function(field) {
                this.totals[field.name + '_display'] = true;
            }, this);

            var ctx = this.context.parent || this.context;
            // fire an event on the parent context
            ctx.trigger('forecasts:worksheet:totals', this.totals, this.worksheetType);
        }
    },

    /**
     * Gets the numbers needed for a commit
     *
     * @returns {{quota: number, best_case: number, best_adjusted: number, likely_case: number, likely_adjusted: number, worst_case: number, worst_adjusted: number, included_opp_count: number, pipeline_opp_count: number, pipeline_amount: number, closed_amount: number, closed_count: number}}
     */
    getCommitTotals: function() {
        var quota = 0,
            best_case = 0,
            best_case_adjusted = 0,
            likely_case = 0,
            likely_case_adjusted = 0,
            worst_case_adjusted = 0,
            worst_case = 0,
            included_opp_count = 0,
            pipeline_opp_count = 0,
            pipeline_amount = 0,
            closed_amount = 0;


        this.collection.forEach(function(model) {
            var base_rate = parseFloat(model.get('base_rate')),
                mPipeline_opp_count = model.get("pipeline_opp_count"),
                mPipeline_amount = model.get("pipeline_amount"),
                mClosed_amount = model.get("closed_amount"),
                mOpp_count = model.get("opp_count");

            quota = app.math.add(app.currency.convertWithRate(model.get('quota'), base_rate), quota);
            best_case = app.math.add(app.currency.convertWithRate(model.get('best_case'), base_rate), best_case);
            best_case_adjusted = app.math.add(app.currency.convertWithRate(model.get('best_case_adjusted'), base_rate), best_case_adjusted);
            likely_case = app.math.add(app.currency.convertWithRate(model.get('likely_case'), base_rate), likely_case);
            likely_case_adjusted = app.math.add(app.currency.convertWithRate(model.get('likely_case_adjusted'), base_rate), likely_case_adjusted);
            worst_case = app.math.add(app.currency.convertWithRate(model.get('worst_case'), base_rate), worst_case);
            worst_case_adjusted = app.math.add(app.currency.convertWithRate(model.get('worst_case_adjusted'), base_rate), worst_case_adjusted);
            included_opp_count += (_.isUndefined(mOpp_count)) ? 0 : parseInt(mOpp_count);
            pipeline_opp_count += (_.isUndefined(mPipeline_opp_count)) ? 0 : parseInt(mPipeline_opp_count);
            if (!_.isUndefined(mPipeline_amount)) {
                pipeline_amount = app.math.add(pipeline_amount, mPipeline_amount);
            }
            if (!_.isUndefined(mClosed_amount)) {
                closed_amount = app.math.add(closed_amount, mClosed_amount);
            }

        });

        return {
            'quota': quota,
            'best_case': best_case,
            'best_adjusted': best_case_adjusted,
            'likely_case': likely_case,
            'likely_adjusted': likely_case_adjusted,
            'worst_case': worst_case,
            'worst_adjusted': worst_case_adjusted,
            'included_opp_count': included_opp_count,
            'pipeline_opp_count': pipeline_opp_count,
            'pipeline_amount': pipeline_amount,
            'closed_amount': closed_amount,
            'closed_count': (included_opp_count - pipeline_opp_count)
        };
    },

    /**
     * We have to overwrite this method completely, since there is currently no way to completely disable
     * a field from being displayed
     *
     * @returns {{default: Array, available: Array, visible: Array, options: Array}}
     */
    parseFields: function() {
        var catalog = this._super("parseFields");
        _.each(catalog, function(group, i) {
            if (_.isArray(group)) {
                catalog[i] = _.filter(group, function(fieldMeta) {
                    return app.utils.getColumnVisFromKeyMap(fieldMeta.name, 'forecastsWorksheetManager');
                });
            } else {
                // _byId is an Object and _.filter returns data in Array form
                // so just go through _byId this way
                _.each(group, function(fieldMeta) {
                    if (!app.utils.getColumnVisFromKeyMap(fieldMeta.name, 'forecastsWorksheetManager')) {
                        delete group[fieldMeta.name];
                    }
                });
            }
        });
        return catalog;
    },

    /**
     * Call the worksheet save event
     *
     * @fires forecasts:worksheet:saved
     * @param {bool} isDraft
     * @param {bool} [suppressMessage]
     * @returns {number}
     */
    saveWorksheet: function(isDraft, suppressMessage) {
        // only run the save when the worksheet is visible and it has dirty records
        var saveObj = {
                totalToSave: 0,
                saveCount: 0,
                model: undefined,
                isDraft: isDraft,
                suppressMessage: suppressMessage || false,
                timeperiod: this.dirtyTimeperiod,
                userId: this.dirtyUser
            },
            ctx = this.context.parent || this.context;

        if (this.layout.isVisible()) {

            if (_.isUndefined(saveObj.userId)) {
                saveObj.userId = this.selectedUser;
            }
            saveObj.userId = saveObj.userId.id;
            /**
             * If the sheet is dirty, save the dirty rows. Else, if the save is for a commit, and we have
             * draft models (things saved as draft), we need to resave those as committed (version 1). If neither
             * of these conditions are true, then we need to fall through and signal that the save is complete so other
             * actions listening for this can continue.
             */
            if (this.isDirty()) {
                saveObj.totalToSave = this.dirtyModels.length;

                this.dirtyModels.each(function(model) {
                    saveObj.model = model;
                    this._worksheetSaveHelper(saveObj, ctx);
                }, this);

                this.cleanUpDirtyModels();
            } else {
                if (isDraft && saveObj.suppressMessage === false) {
                    app.alert.show('success', {
                        level: 'success',
                        autoClose: true,
                        autoCloseDelay: 10000,
                        title: app.lang.get("LBL_FORECASTS_WIZARD_SUCCESS_TITLE", "Forecasts") + ":",
                        messages: [app.lang.get("LBL_FORECASTS_WORKSHEET_SAVE_DRAFT_SUCCESS", "Forecasts")]
                    });
                }
                ctx.trigger('forecasts:worksheet:saved', saveObj.totalToSave, this.worksheetType, isDraft);
            }
        }

        this.draftSaveType = undefined;

        return saveObj.totalToSave
    },

    /**
     * Helper function for worksheet save
     *
     * @fires forecasts:worksheet:saved
     */
    _worksheetSaveHelper: function(saveObj, ctx) {
        var id = (saveObj.model.get('fakeId')) ? null : saveObj.model.get('id');
        saveObj.model.set({
            id: id,        // we have to set the id back to null if ID is not set
                                                        // so when the xhr runs it knows it's a new model and will use
                                                        // POST vs PUT
            current_user: saveObj.userId || this.selectedUser.id,
            timeperiod_id: saveObj.timeperiod || this.selectedTimeperiod,
            draft_save_type: this.draftSaveType
        }, {silent: true});

        saveObj.model.save({}, {success: _.bind(function() {
            saveObj.saveCount++;
            //if this is the last save, go ahead and trigger the callback;
            if (saveObj.totalToSave === saveObj.saveCount) {
                if (saveObj.isDraft && saveObj.suppressMessage === false) {
                    app.alert.show('success', {
                        level: 'success',
                        autoClose: true,
                        autoCloseDelay: 10000,
                        title: app.lang.get("LBL_FORECASTS_WIZARD_SUCCESS_TITLE", "Forecasts") + ":",
                        messages: [app.lang.get("LBL_FORECASTS_WORKSHEET_SAVE_DRAFT_SUCCESS", "Forecasts")]
                    });
                }
                ctx.trigger('forecasts:worksheet:saved', saveObj.totalToSave, this.worksheetType, saveObj.isDraft);
            }
        }, this), silent: true, alerts: { 'success': false }});
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"MergeRecords":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Quotas":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Teams":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"TeamNotices":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Manufacturers":{"fieldTemplates": {}
,
"views": {
"base": {
"filter-filter-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Filter-filter-dropdown View (base) 

    extendsFrom: 'FilterFilterDropdownView',

    /**
     * @inheritdoc
     */
    getFilterList: function() {
        var list = this._super('getFilterList').filter(function(obj) {
            if (obj.id == 'favorites') {
                return false;
            }

            return true;
        });

        return list;
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Activities":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Comments":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Subscriptions":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Bugs":{"fieldTemplates": {}
,
"views": {
"base": {
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Bugs.RecordView
 * @alias SUGAR.App.view.views.BaseBugsRecordView
 * @extends View.Views.Base.RecordView
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['HistoricalSummary', 'KBContent']);
        this._super('initialize', [options]);
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Feeds":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"iFrames":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"TimePeriods":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"TaxRates":{"fieldTemplates": {}
,
"views": {
"base": {
"selection-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.TaxRates.SelectionListView
 * @alias SUGAR.App.view.views.BaseTaxRatesSelectionListView
 * @extends View.Views.Base.SelectionListView
 */
({
	// Selection-list View (base) 

    extendsFrom: 'SelectionListView',

    /**
     * Extending to add the value into the attributes passed back
     *
     * @inheritdoc
     */
    _getModelAttributes: function(model) {
        var attributes = {
            id: model.id,
            name: model.get('name'),
            value: model.get('value')
        };

        //only pass attributes if the user has view access
        _.each(model.attributes, function(value, field) {
            if (app.acl.hasAccessToModel('view', model, field)) {
                attributes[field] = attributes[field] || model.get(field);
            }
        }, this);

        return attributes;
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"ContractTypes":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Schedulers":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Project":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"ProjectTask":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Campaigns":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"CampaignLog":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"CampaignTrackers":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Documents":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"DocumentRevisions":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Connectors":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Roles":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Notifications":{"fieldTemplates": {
"base": {
"severity": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Severity FieldTemplate (base) 

    /**
     * Severity Widget.
     *
     * Extends from EnumField widget adding style property according to specific
     * severity.
     */
    extendsFrom: 'EnumField',

    /**
     * An object where its keys map to specific severity and values to matching
     * CSS classes.
     *
     * @property {Object}
     * @protected
     */
    _styleMapping: {
        'default': 'label-unknown',
        alert: 'label-important',
        information: 'label-info',
        other: 'label-inverse',
        success: 'label-success',
        warning: 'label-warning'
    },

    /**
     * @inheritdoc
     *
     * Listen to changes on `is_read` field only if view name matches
     * notifications.
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        if (this.model && this.view.name === 'notifications') {
            this.model.on('change:is_read', this.render, this);
        }
    },

    /**
     * @inheritdoc
     *
     * Inject additional logic to load templates based on different view names
     * according to the following:
     *
     * - `fields/severity/<view-name>-<tpl-name>.hbs`
     * - `fields/severity/<view-template-name>-<tpl-name>.hbs`
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        var template = app.template.getField(
            this.type,
            this.view.name + '-' + this.tplName,
            this.model.module
        );

        if (!template && this.view.meta && this.view.meta.template) {
            template = app.template.getField(
                this.type,
                this.view.meta.template + '-' + this.tplName,
                this.model.module
            );
        }

        this.template = template || this.template;
    },

    /**
     * @inheritdoc
     *
     * Defines `severityCss` property based on field value. If current severity
     * does not match a known value its value is used as label and default
     * style is used as well.
     */
    _render: function () {
        var severity = this.model.get(this.name),
            options = app.lang.getAppListStrings(this.def.options);

        this.severityCss = this._styleMapping[severity] || this._styleMapping['default'];
        this.severityLabel = options[severity] || severity;

        this._super('_render');
    }
}) },
"read": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Read FieldTemplate (base) 

    events: {
        'click [data-action=toggle]': 'toggleIsRead',
        'mouseover [data-action=toggle]': 'toggleMouse',
        'mouseout [data-action=toggle]': 'toggleMouse'
    },

    /**
     * @inheritdoc
     *
     * The read field is always a readonly field.
     *
     * If `mark_as_read` option is enabled on metadata it means we should
     * automatically mark the notification as read.
     *
     */
    initialize: function(options) {
        options.def.readonly = true;

        this._super('initialize', [options]);

        if (options.def && options.def.mark_as_read) {
            this.markAs(true);
        }
    },

    /**
     * Event handler for mouse events.
     *
     * @param {Event} event Mouse over / mouse out.
     */
    toggleMouse: function(event) {
        var $target= this.$(event.currentTarget),
            isRead = this.model.get('is_read');

        if (!isRead) {
            return;
        }

        var label = event.type === 'mouseover' ? 'LBL_UNREAD' : 'LBL_READ';
        $target.html(app.lang.get(label, this.module));
        $target.toggleClass('label-inverse', event.type === 'mouseover');
    },

    /**
     * Toggle notification `is_read` flag.
     */
    toggleIsRead: function() {
        this.markAs(!this.model.get('is_read'));
    },

    /**
     * Mark notification as read/unread.
     *
     * @param {Boolean} read `True` marks notification as read, `false` as
     *   unread.
     */
    markAs: function(read) {
        if (read === this.model.get('is_read')) {
            return;
        }

        this.model.save({is_read: !!read}, {
            success: _.bind(function() {
                if (!this.disposed) {
                    this.render();
                }
            }, this)
        });
    }
}) }
}}
,
"views": {
"base": {
"preview-header": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.NotificationsPreviewHeaderView
 * @alias SUGAR.App.view.views.BaseNotificationsPreviewHeaderView
 * @extends View.Views.Base.PreviewHeaderView
 */
({
	// Preview-header View (base) 

    extendsFrom: 'PreviewHeaderView',

    /**
     * @inheritdoc
     *
     * @override To make 'previewEdit' always false. Notifications do not allow any editing (but not via module ACL).
     */
    checkACL: function(model) {
        this._super('checkACL', [model]);
        this.layout.previewEdit = false;
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Sync":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"ReportMaker":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"DataSets":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"CustomQueries":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"pmse_Inbox":{"fieldTemplates": {
"base": {
"reassignbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Reassignbutton FieldTemplate (base) 

    extendsFrom: 'RowactionField',
    initialize: function (options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    _render: function () {
        var value=this.model.get('cas_status');
//        if(value==='TODO'){
        if(/IN PROGRESS/.test(value)){
            this._super("_render");
        } else {
            this.hide();
        }
    },

    bindDataChange: function () {
        if (this.model) {
            this.model.on("change", this.render, this);
        }
    }
}) },
"event-status-pmse": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * EventStatusField is a field for Meetings/Calls that show the status field of the model as a badge field.
 *
 * @class View.Fields.Base.EventStatusField
 * @alias SUGAR.App.view.fields.BaseEventStatusField
 * @extends View.Fields.Base.BadgeSelectField
 */
({
	// Event-status-pmse FieldTemplate (base) 

    extendsFrom: 'BaseField',

    /**
     * @inheritdoc
     */
    initialize: function (options) {
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     *
     * Styles the badge.
     *
     * @private
     */
    _render: function () {
        this._super('_render');
        this.styleLabel();
    },

    /**
     * Sets the appropriate CSS class on the label based on the value of the
     * status.
     *
     * It is a noop when the field is in edit mode.
     *
     * @param {String} status
     */
    styleLabel: function () {
        var $label;
        $label = this.$el.children(0);
        $label.removeClass('ellipsis_inline');
        switch (this.value) {
            case 'IN PROGRESS':
                $label.addClass('label label-process-in-progress');
                break;
            case 'COMPLETED':
                $label.addClass('label label-process-completed');
                break;
            case 'TERMINATED':
                $label.addClass('label label-process-terminate');
                break;
            case 'CANCELLED':
                $label.addClass('label label-process-cancelled');
                break;
            default:
                $label.addClass('label label-process-error');
                break;
        }

    }
}) },
"pmse-link": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Pmse-link FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    _render: function() {
        var action = 'view';
        if (this.def.link && this.def.route) {
            action = this.def.route.action;
        }
        if (((!app.acl.hasAccess('developer', this.model.get('cas_sugar_module')) || this.model.get('prj_deleted') == '1')
            && this.def.name == 'pro_title') ||
            (!app.acl.hasAccess(action, this.model.get('cas_sugar_module')) && this.def.name == 'cas_title')) {
            this.def.link = false;
        }
        if (this.def.link) {
            this.href = this.buildHref();
        }
        app.view.Field.prototype._render.call(this);
    },


    _isErasedField: function() {
        var erased = false;
        if (this.def.name == 'cas_title') {
            var module;
            if (this.model.attributes.is_a_person) {
                module = this.model.module;
                this.model.module = this.model.attributes.cas_sugar_module;
                this.model.fields.name.type = 'fullname';
                this.model.attributes.cas_title = app.utils.formatNameModel(
                    this.model.attributes.cas_sugar_module,
                    this.model.attributes
                );
            }
            erased = app.utils.isNameErased(this.model);
            if (this.model.attributes.is_a_person) {
                this.model.module = module;
            }
        }
        return erased;
    },

    buildHref: function() {
        var defRoute = this.def.route ? this.def.route : {},
            module = this.model.module || this.context.get('module');
        switch (this.def.name) {
            case 'pro_title':
                return '#' + app.router.buildRoute('pmse_Project', this.model.attributes.prj_id, defRoute.action, this.def.bwcLink);
                break;
            case 'cas_title':
                return '#' + app.router.buildRoute(this.model.attributes.cas_sugar_module, this.model.attributes.cas_sugar_object_id, defRoute.action, this.def.bwcLink);
                break;
        }
    },

    unformat: function(value) {
        return _.isString(value) ? value.trim() : value;
    }
}) },
"sugarbpm-header-label": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Label for trademarked `SugarBPM` term.
 */
({
	// Sugarbpm-header-label FieldTemplate (base) 

    extendsFrom: 'LabelField'
}) },
"relate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
// jscs:disable jsDoc
/**
 * relate Widget.
 *
 * Extends from BaseRelateField widget
 *
 * @class View.Fields.Base.pmse_Inbox.RelateField
 * @alias SUGAR.App.view.fields.Basepmse_InboxRelateField
 * @extends View.Fields.Base.RelateField
 */
// jscs:anable jsDoc
({
	// Relate FieldTemplate (base) 

    /**
     * Renders relate field
     */
    _render: function() {
        // a way to override viewName
        if (this.def.view) {
            this.options.viewName = this.def.view;
        }
        this._super('_render');
    }

}) },
"enum": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.pmse_Inbox.EnumField
 * @alias SUGAR.App.view.fields.Basepmse_InboxEnumField
 * @extends View.Fields.Base.EnumField
 */
({
	// Enum FieldTemplate (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    _render: function() {
        this.items = this.model.get('cas_reassign_user_combo_box');
        this._super('_render');
    }
}) },
"cancelcasebutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Cancelcasebutton FieldTemplate (base) 

    extendsFrom: 'RowactionField',
    initialize: function (options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    _render: function () {
        var value=this.model.get('cas_status');
//        if(value==='TODO' || /Error/.test(value)){
        if(/IN PROGRESS/.test(value) || /ERROR/.test(value)){
            this._super("_render");
        } else {
            this.hide();
        }
    },

    bindDataChange: function () {
        if (this.model) {
            this.model.on("change", this.render, this);
        }
    }
}) },
"executebutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Executebutton FieldTemplate (base) 

    extendsFrom: 'RowactionField',
    initialize: function (options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    _render: function () {
        var value=this.model.get('cas_status');
        if(/ERROR/.test(value)){
            this._super("_render");
        } else {
            this.hide();
        }
    },

    bindDataChange: function () {
        if (this.model) {
            this.model.on("change", this.render, this);
        }
    }
}) }
}}
,
"views": {
"base": {
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.pmse_Inbox.RecordlistView
 * @alias SUGAR.App.view.views.Basepmse_InboxRecordlistView
 * @extends View.Views.Base.RecordlistView
 */
({
	// Recordlist View (base) 

    extendsFrom: 'RecordlistView',

    contextEvents: {
        "list:process:fire": "showCase"
    },

    showCase: function (model) {
        //var url = model.module + '/' + model.id + '/layout/show-case/' + model.get('flow_id');
        var ShowCaseUrl = app.router.buildRoute(model.module, model.get('id2'), 'layout/show-case/' + model.get('flow_id'));
        var ShowCaseUrlBwc = app.bwc.buildRoute(model.module, '', 'showCase', {id:model.get('flow_id')});
        var SugarModule = model.get('cas_sugar_module');
        if (app.metadata.getModule(SugarModule).isBwcEnabled) {
            app.router.navigate(ShowCaseUrlBwc , {trigger: true, replace: true });
        } else {
            app.router.navigate(ShowCaseUrl , {trigger: true, replace: true });
        }
    },

    /**
     * Decorate a row in the list that is being shown in Preview
     * @override pmse_Inbox uses flow_id instead of id to keep track of records
     * and add them to the DOM
     * @param model Model for row to be decorated.  Pass a falsy value to clear decoration.
     */
    decorateRow: function (model) {
        // If there are drawers, make sure we're updating only list views on active drawer.
        if (_.isUndefined(app.drawer) || app.drawer.isActive(this.$el)) {
            this._previewed = model;
            this.$("tr.highlighted").removeClass("highlighted current above below");
            if (model) {
                //use flow_id here since that's what is in the DOM
                var rowName = model.module + "_" + model.get('flow_id');
                var curr = this.$("tr[name='" + rowName + "']");
                curr.addClass("current highlighted");
                curr.prev("tr").addClass("highlighted above");
                curr.next("tr").addClass("highlighted below");
            }
        }
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Record View (base) 

    extendsFrom: 'RecordView',

    events: {
        'click .record-edit-link-wrapper': 'handleEdit',
        'click [data-action=scroll]': 'paginateRecord',
        'click .record-panel-header': 'togglePanel',
        'click .tab a': 'setActiveTab'
    },

    initialize: function(options) {
        options.meta = _.extend({}, app.metadata.getView(null, 'record'), options.meta);
        options.meta.hashSync = _.isUndefined(options.meta.hashSync) ? true : options.meta.hashSync;
        this._super('initialize', [options]);

        this.context.on('approve:case', this.approveCase, this);
        this.context.on('reject:case', this.rejectCase, this);
        this.context.on('cancel:case', this.cancelCase, this);
        this.context.on('button:cancel_button:click', this.cancelClicked, this);
        //event register for preventing actions
        // when user escapes the page without confirming deleting
        // add a callback to close the alert if users navigate from the page
        app.routing.before('route', this.dismissAlert, this);
        $(window).on('beforeunload.delete' + this.cid, _.bind(this.warnDeleteOnRefresh, this));

        this.delegateButtonEvents();

        if (this.createMode) {
            this.model.isNotEmpty = true;
        }

        this.noEditFields = [];
        // properly namespace SHOW_MORE_KEY key
        this.MORE_LESS_KEY = app.user.lastState.key(this.MORE_LESS_KEY, this);

        this.adjustHeaderpane = _.bind(_.debounce(this.adjustHeaderpane, 50), this);
        $(window).on('resize.' + this.cid, this.adjustHeaderpane);
    },

    approveCase: function(options){
        var self = this;
        var statusApprove = 'approve';
        url = App.api.buildURL('pmse_approve', null, {id: statusApprove});
        App.api.call('update', url, options.attributes, {
            success: function () {
            },
            error: function (err) {
            }
        });
        var redirect = options.module;
        app.router.navigate(redirect , {trigger: true, replace: true });
    },

    rejectCase: function(options){
        var self = this;
        var statusApprove = 'reject';
        url = App.api.buildURL('pmse_approve', null, {id: statusApprove});
        App.api.call('update', url, options.attributes, {
            success: function () {
            },
            error: function (err) {
            }
        });
        var redirect = options.module;
        app.router.navigate(redirect , {trigger: true, replace: true });
    },

    cancelCase: function(options){
        var redirect = options.module;
        app.router.navigate(redirect , {trigger: true, replace: true });
    },

    validationComplete: function(isValid) {
        if (isValid) {
            this.setButtonStates(this.STATE.VIEW);
            this.handleSave();
        }
    },


    _initButtons: function() {

        if (this.options.meta && this.options.meta.buttons) {
            _.each(this.options.meta.buttons, function(button) {
                this.registerFieldAsButton(button.name);
                if (button.buttons) {
                    var dropdownButton = this.getField(button.name);
                    if (!dropdownButton) {
                        return;
                    }
                    _.each(dropdownButton.fields, function(ddButton) {
                        this.buttons[ddButton.name] = ddButton;
                    }, this);
                }
            }, this);
        }
    },
    toggleViewButtons: function(isEdit) {
        this.$('.headerpane span[data-type="badge"]').toggleClass('hide', isEdit);
        this.$('.headerpane span[data-type="favorite"]').toggleClass('hide', isEdit);
        this.$('.headerpane span[data-type="follow"]').toggleClass('hide', isEdit);
        this.$('.headerpane .btn-group-previous-next').toggleClass('hide', isEdit);
    }

}) },
"config-log": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Config-log View (base) 

    /**
     * @inheritdoc
     *
     * Sets up the file field to edit mode
     *
     * @param {View.Field} field
     * @private
     */
    _renderField: function(field) {
        app.view.View.prototype._renderField.call(this, field);
        app.alert.show('txtConfigLog', {level: 'process', title: 'Loading', autoclose: false});
        url = app.api.buildURL(this.module + '/logGetConfig');
        app.api.call('READ', url, {},{
            success: function(data)
            {
                field.model.set('comboLogConfig',data['records'][0]['cfg_value']);
                app.alert.dismiss('txtConfigLog');
            }
        });
    }
}) },
"config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Config View (base) 

//    extendsFrom :'RecordView',
//    className: 'settings',

    events: {
        //'click .sugar-cube': 'spinCube'
    },
    initialize: function(options) {
        if (app.acl.hasAccessToAny('developer')) {
            var self=this;
            var url = app.api.buildURL('pmse_Inbox', 'settings', null, options.params);
            app.api.call('READ', url, options.attributes, {
                success: function (data) {
                    self.model.set(data);
                }
            });
            this._super('initialize', [options]);
        } else {
            app.controller.loadView({
                layout: 'access-denied'
            });
        }
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.pmse_Inbox.PreviewView
 * @alias SUGAR.App.view.views.Basepmse_InboxPreviewView
 * @extends View.Views.Base.PreviewView
 */
({
	// Preview View (base) 

    extendsFrom: 'PreviewView',

    events: {
        'click .minify': 'toggleMinify'
    },

    toggleMinify: function(evt) {
        var $el = this.$('.dashlet-toggle > i'),
            collapsed = $el.is('.icon-chevron-up');
            if(collapsed){
                $('.dashlet-toggle > i').removeClass('icon-chevron-up');
            $('.dashlet-toggle > i').addClass('icon-chevron-down');
        }else{
                $('.dashlet-toggle > i').removeClass('icon-chevron-down');
                $('.dashlet-toggle > i').addClass('icon-chevron-up');
            }
        $('.dashlet').toggleClass('collapsed');
        $('.dashlet-content').toggleClass('hide');
    },

    /**
     * Renders the preview dialog with the data from the current model and collection.
     */
    _render: function() {
        var self = this;

        //only use id2 if it's available
        if (this.model.get('id2')) {
            this.model.set('id', this.model.get('id2'));
        }

        var pmseInboxUrl = app.api.buildFileURL({
            module: 'pmse_Inbox',
            id: self.model.get('cas_id') || (self.model.collection.get(self.model)).get('cas_id'),
            field: 'id'
        }, {cleanCache: true});
        this.image_preview_url = pmseInboxUrl;

        this._super('_render');
    }
}) },
"dashlet-inbox": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dashlet-inbox View (base) 

    extendsFrom: 'HistoryView',

    /**
     * @inheritdoc
     *
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        date:'true',
        limit: 10,
        visibility: 'user'
    },

    thresholdRelativeTime: 2, //Show relative time for 2 days and then date time after

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this._super('initialize', [options]);
    },

    /**
     * Besides defining new DOM events that will be later bound to methods
     * through {@link #delegateEvents, the events method also makes sure parent
     * classes events are explicitly inherited.
     *
     * @property {Function}
     */
    events: function() {
        var prototype = Object.getPrototypeOf(this);
        var parentEvents = _.result(prototype, 'events');

        return _.extend({}, parentEvents, {
            'click [data-action=date-switcher]': 'dateSwitcher'
        });
    },

    /**
     * Event handler for date switcher.
     *
     * @param {Event} event Click event.
     */
    dateSwitcher: function(event) {
        var date = this.$(event.currentTarget).val();
        if (date === this.getDate()) {
            return;
        }
        this.settings.set('date', date);
        this.loadData();
    },

    /**
     * Get current date state.
     * Returns default value if can't find in last state or settings.
     *
     * @return {String} Date state.
     */
    getDate: function() {
        var date = app.user.lastState.get(
            app.user.lastState.key('date', this),
            this
        );
        return date || this.settings.get('date') || this._defaultSettings.date;
    },

    /**
     * @inheritdoc
     *
     * On load of new data, make sure we reload invitations related data, if
     * it is defined for the current tab.
     */
    loadData: function(options) {
        if (this.disposed || this.meta.config) {
            return;
        }
        var tab = this.tabs[this.settings.get('activeTab')];
        if (tab.invitations) {
            tab.invitations.dataFetched = false;
        }
        this._super('loadData', [options]);
    },

    /**
     * @inheritdoc
     *
     * FIXME: This should be removed when metadata supports date operators to
     * allow one to define relative dates for date filters.
     */
    _initTabs: function() {
        this._super('_initTabs');
    },

    /**
     * @inheritdoc
     */
    _getFilters: function(index) {
          var  tab = this.tabs[index],
            filter = {},
            filters = [],
            defaultFilters = {
                'true': {$equal: 'true'},
                'false': {$equal: 'false'}
            };

        filter[tab.filter_applied_to] = defaultFilters[this.getDate()];

        filters.push(filter);

        return filters;
    },

    /**
     * Updating in fields delete removed
     * @return {Function} complete callback
     * @private
     */
    _getRemoveRecord: function() {
        return _.bind(function(model){
            if (this.disposed) {
                return;
            }
            this.collection.remove(model);
            this.render();
            this.context.trigger("tabbed-dashlet:refresh", model.module);
        }, this);
    },

    /**
     * Method view alert in process with text modify
     * show and hide alert
     */
    _refresh: function(model, status) {
        app.alert.show(model.id + ':refresh', {
            level:"process",
            title: status,
            autoclose: false
        });
        return _.bind(function(model){
            var options = {};
            this.layout.reloadDashlet(options);
            app.alert.dismiss(model.id + ':refresh');
        }, this);
    },

    /**
     * Sets property useRelativeTime to show date created as a relative time or as date time.
     *
     * @private
     */
    _setRelativeTimeAvailable: function(date) {
        var diffInDays = Math.abs(app.date().diff(date, 'days', true));
        var useRelativeTime = (diffInDays <= this.thresholdRelativeTime);
        return useRelativeTime;
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     * - {String} picture_url Picture url for model's assigned user.
     */
    _renderHtml: function() {
        var self = this;
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        if (tab.overdue_badge) {
            this.overdueBadge = tab.overdue_badge;
        }
        _.each(this.collection.models, function(model){

            // only admins and developers have access to process definitions
            model.set({linkToPD: app.acl.hasAccess('admin', 'pmse_Project')}, {silent: true});

            var pictureUrl = App.api.buildFileURL({
                module: 'Users',
                id: model.get('assigned_user_id'),
                field: 'picture'
            });
            var ShowCaseUrl = 'pmse_Inbox/' +  model.get('id2') + '/layout/show-case/' +  model.get('flow_id');
            var ShowCaseUrlBwc = App.bwc.buildRoute('pmse_Inbox', '', 'showCase', {id:model.get('flow_id')});
            var SugarModule = model.get('cas_sugar_module');
            if (app.metadata.getModule(SugarModule).isBwcEnabled) {
                model.set('show_case_url', ShowCaseUrlBwc);
            } else {
                model.set('show_case_url', ShowCaseUrl);
            }
            model.set('picture_url', pictureUrl);
            model.set('is_assigned', this.isAssigned(model));
            if (model.attributes.cas_due_date) {
                var useRelativeTime = this._setRelativeTimeAvailable(model.attributes.cas_due_date);
                if (useRelativeTime) {
                    model.useRelativeTime = true;
                } else {
                    model.useAbsoluteTime = true;
                }
            }
            if (model.attributes.is_a_person) {
                model.set('name', app.utils.formatNameModel(model.attributes.cas_sugar_module, model.attributes));
            }
        }, this);
        this._super('_renderHtml');
    },

    isAssigned: function(model) {
        return model.get('cas_assignment_method') != 'selfservice';
    }
}) },
"config-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Config-headerpane View (base) 

    extendsFrom: "HeaderpaneView",

    events: {
        "click [name=save_button]":   "_save",
        "click [name=cancel_button]": "_cancel"
    },
    /**
     * Save the drawer.
     *
     * @private
     */
    _save: function() {
        var fieldPmse=new Object();
        fieldPmse.logger_level={name: "logger_level", required: true};
        fieldPmse.error_timeout={name: "error_timeout", required: true, type: 'int'};
//        console.log('mmm',fieldPmse);
        this.model.doValidate(fieldPmse, _.bind(this.validationCompleteSettings, this));
    },
    validationCompleteSettings: function(isValid) {
        var self=this;
        if (isValid) {
            app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
            var value = {}, data = {};
            data.logger_level = self.model.get('logger_level');
            data.error_timeout = self.model.get('error_timeout');
            value.data = data;
            //console.log('Values->',value);
            var pmseInboxUrl = app.api.buildURL('pmse_Inbox/settings','',{},{});
            app.api.call('update', pmseInboxUrl, value,{
                success: function (data){
                    if(data.success){
                        app.alert.dismiss('upload');
//                        app.router.goBack();
                        app.router.navigate("bwc/index.php?module=Administration&action=index",{trigger:true});
                    }
                }
            });

//            console.log('Validado');
        }
    },
    /**
     * Close the drawer.
     *
     * @private
     */
    _cancel: function() {
        app.router.navigate(app.router.buildRoute('Administration'), {trigger: true});
    }
}) },
"logView-pane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// LogView-pane View (base) 

    /**
     * @inheritdoc
     *
     * Sets up the file field to edit mode
     *
     * @param {View.Field} field
     * @private
     */
    _renderField: function(field) {
        if (app.acl.hasAccessToAny('developer')) {
            app.view.View.prototype._renderField.call(this, field);
            field.$el.children().css('width','100%');
            field.$el.children().attr('readonly','readonly');
        } else {
            app.controller.loadView({
                layout: 'access-denied'
            });
        }
    }
}) },
"unattendedCases-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// UnattendedCases-list View (base) 

    extendsFrom: 'RecordlistView',
    contextEvents: {
        "list:reassign:fire": "reassignCase"
    },

    _render: function() {
        if (app.acl.hasAccessToAny('developer')) {
            this._super('_render');
        } else {
            app.controller.loadView({
                layout: 'access-denied'
            });
        }
    },
    reassignCase: function (model) {
        var self=this;
        app.drawer.open({
            layout: 'reassignCases',
            context: {
                module: 'pmse_Inbox',
                parent: this.context,
                cas_id: model.get('cas_id'),
                unattended: true
            }

        },
            function(variables) {
                if(variables==='saving'){
                    self.reloadList();
                }
            });
    },
    reloadList: function() {
        this.context.reloadData({
            recursive:false,
        });
    }
}) },
"casesList-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// CasesList-list View (base) 

    extendsFrom: 'RecordlistView',

    /**
     * Removes the event listeners that were added to the mass collection.
     */
    unbindData: function() {
        var massCollection = this.context.get('mass_collection');
        if (massCollection) {
            massCollection.off(null, null, this);
        }
        this._super("unbindData");
    },

    /**
     * @inheritdoc
     */
    _setOrderBy: function(options) {
        this.context.set('sortOptions', options);
        options.query = this.context.get('query');
        options.module_list = this.context.get('module_list');
        options.offset = 0;
        options.update = false;
        this._super('_setOrderBy', options);
    },

    /**
     * Override to hook in additional triggers as the mass collection is updated (rows are checked on/off in
     * the actionmenu field). Also attempts to pre-check any rows when the list is refreshed and selected recipients
     * are found within the new result set (this behavior occurs when the user searches the address book).
     *
     * @private
     */
    _render: function() {
        if (app.acl.hasAccessToAny('developer')) {
            this._super('_render');
        }
        else {
            app.controller.loadView({
                layout: 'access-denied'
            });
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        jQuery('.adam-modal').remove();
        this._super('_dispose');
    }
}) },
"logView-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// LogView-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',
    events:{
        'click [name=log_pmse_button]': 'getLogPmse',
        'click [name=log_clear_button]': 'logClearClick',
        'click [name=log_cron_button]': 'getLogCron'
    },
    initialize: function(options) {
        this._super('initialize', [options]);
        this.getLogPmse();
        this.context.on('list:cancelCase:fire', this.cancelCases, this);
        //this.context.on('configLog:fire', this.getLogConfig, this);
    },

    logClearClick: function () {
        var self = this;
        app.alert.show('clear_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_PMSE_WARNING_CLEAR', this.module),
            onConfirm: function () {
                app.alert.show('data:sync:process', {
                    level: 'process',
                    title: app.lang.get('LBL_LOADING'),
                    autoClose: false
                });
                self.clearLog();
            },
            onCancel: $.noop

        });
    },

    clearLog: function () {
        var self = this;
        var pmseInboxUrl = app.api.buildURL(this.module + '/clearLog/pmse');
        app.api.call('update', pmseInboxUrl, {}, {
            success: function () {
                self.getLog();
            }
        });

    },

    getLogPmse: function() {
        app.alert.show('data:sync:process', {
            level: 'process',
            title: app.lang.get('LBL_LOADING'),
            autoClose: false});
        var self = this;
        var pmseInboxUrl = app.api.buildURL(this.module + '/getLog');
        app.api.call('READ', pmseInboxUrl, {},{
            success: function(data)
            {
                self.getLog(data)
            }
        });
    },

    getLogCron : function() {
        app.alert.show('data:sync:process', {level: 'process', title: 'Loading', autoclose: false});
        var self = this;
        var pmseInboxUrl = app.api.buildURL(this.module + '/getLog/cron');
        app.api.call('READ', pmseInboxUrl, {},{
            success: function(data)
            {
                $('#logPmseId').html('Cron Log');
                self.getLog(data)
            }
        });
    },

    getLog: function(data) {
        $("textarea").val(data);
        app.alert.dismiss('data:sync:process');
    }
}) },
"reassignCases-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// ReassignCases-list View (base) 

    extendsFrom: 'RecordlistView',

    initialize: function (options) {
        this._super("initialize", [options]);
        this.collection.on('data:sync:complete', this.loaded, this);
    },

    loaded: function () {
        _.each(this.fields, function (field) {
            if(field.name === 'assigned_user') {
                this.auser = field.value;
                setTimeout(function () {
                    var spans = document.getElementsByClassName('select2-chosen');
                    for (var i=0;i<spans.length;i++) {
                        if (spans[i].innerText && (spans[i].innerText != app.lang.get('LBL_PMSE_FILTER', 'pmse_Inbox'))) {
                            spans[i].innerText = this.auser;
                        }
                        else if (spans[i].textContent && (spans[i].textContent != app.lang.get('LBL_PMSE_FILTER', 'pmse_Inbox'))) {
                            spans[i].textContent = this.auser;
                        }
                    }
                },2000);
            }
        });
    }
}) },
"casesList-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// CasesList-filter View (base) 

    _moduleFilterList: [],
    _allModulesId:     'All',
    _selectedModule:   null,
    _currentSearch:    '',
    events: {
        'keyup .search-name':        'throttledSearch',
        'paste .search-name':        'throttledSearch',
        'click .add-on.fa-times':    'clearInput'
    },
    processStatus: [app.lang.get('LBL_STATUS_COMPLETED', this.module),
        app.lang.get('LBL_STATUS_TERMINATED', this.module),
        app.lang.get('LBL_STATUS_IN_PROGRESS', this.module),
        app.lang.get('LBL_STATUS_CANCELLED', this.module),
        app.lang.get('LBL_STATUS_ERROR', this.module)],

    /**
    * Initialize
    */
    initialize: function(options) {
        this.cacheKiller = (new Date()).getTime();
        this._super('initialize', [options]);
    },

    /**
     * Converts the input field to a select2 field and adds the module filter for refining the search.
     *
     * @private
     */
    _render: function() {
        app.view.View.prototype._render.call(this);
        this.buildModuleFilterList();
        this.buildFilter();
    },
    /**
     * Builds the list of allowed modules to provide the data to the select2 field.
     */
    buildModuleFilterList: function() {
        var allowedModules = this.collection.allowed_modules;

        this._moduleFilterList = [
            {id: this._allModulesId, text: app.lang.get('LBL_MODULE_ALL')}
        ];

        _.each(allowedModules, function(module) {
//            this._moduleFilterList.push({id: module, text: app.lang.get('LBL_MODULE_NAME', module)});
            this._moduleFilterList.push({id: module, text: module});
        }, this);
    },
    /**
     * Converts the input field to a select2 field and initializes the selected module.
     */
    buildFilter: function() {
        var $filter = this.getFilterField();
        if ($filter.length > 0) {
            $filter.select2({
                data:                    this._moduleFilterList,
                allowClear:              false,
                multiple:                false,
                minimumResultsForSearch: -1,
                formatSelection:         _.bind(this.formatModuleSelection, this),
                formatResult:            _.bind(this.formatModuleChoice, this),
                dropdownCss:             {width: 'auto'},
                dropdownCssClass:        'search-filter-dropdown',
                initSelection:           _.bind(this.initSelection, this),
                escapeMarkup:            function(m) { return m; },
                width:                   'off'
            });
            $filter.off('change');
            $filter.on('change', _.bind(this.handleModuleSelection, this));
            this._selectedModule = this._selectedModule || this._allModulesId;
            $filter.select2('val', this._selectedModule);
        }
    },
    /**
     * Gets the filter DOM field.
     *
     * @returns {Object} DOM Element
     */
    getFilterField: function() {
        return this.$('input.select2');
    },
    /**
     * Gets the module filter DOM field.
     *
     * @returns {Object} DOM Element
     */
    getModuleFilter: function() {
        return this.$('span.choice-filter-label');
    },
    /**
     * Destroy the select2 plugin.
     */
    unbind: function() {
        $filter = this.getFilterField();
        if ($filter.length > 0) {
            $filter.off();
            $filter.select2('destroy');
        }
        this._super("unbind");
    },
    /**
     * Performs a search once the user has entered a term.
     */
    throttledSearch: _.debounce(function(evt) {
        var newSearch = this.$(evt.currentTarget).val();
        if (this._currentSearch !== newSearch && _.indexOf(this.processStatus, this._selectedModule) == -1) {
            this._currentSearch = newSearch;
            this.applyFilter();
        }
    }, 400),
    /**
     * Initialize the module selection with the value for all modules.
     *
     * @param el
     * @param callback
     */
    initSelection: function(el, callback) {
        if (el.is(this.getFilterField())) {
            var module = _.findWhere(this._moduleFilterList, {id: el.val()});
            callback({id: module.id, text: module.text});
        }
    },
    /**
     * Format the selected module to display its name.
     *
     * @param {Object} item
     * @return {String}
     */
    formatModuleSelection: function(item) {
        // update the text for the selected module
        this.getModuleFilter().html(item.text);
        return '<span class="select2-choice-type">'
            + app.lang.get('LBL_PMSE_FILTER', this.module)
            + '<i class="fa fa-caret-down"></i></span>';
    },
    /**
     * Format the choices in the module select box.
     *
     * @param {Object} option
     * @return {String}
     */
    formatModuleChoice: function (option) {
        return '<div><span class="select2-match"></span>' + option.text + '</div>';
    },
    /**
     * Handler for when the module filter dropdown value changes, either via a click or manually calling jQuery's
     * .trigger("change") event.
     *
     * @param {Object} evt jQuery Change Event Object
     * @param {string} overrideVal (optional) ID passed in when manually changing the filter dropdown value
     */
    handleModuleSelection: function(evt, overrideVal) {
        var module = overrideVal || evt.val || this._selectedModule || this._allModulesId;
        // only perform a search if the module is in the approved list
        if (!_.isEmpty(_.findWhere(this._moduleFilterList, {id: module}))) {
            this._selectedModule = module;
            this.getFilterField().select2('val', this._selectedModule);
            this.getModuleFilter().css('cursor', 'pointer');
            this.applyFilter();
        }
    },
    /**
     * Triggers an event that makes a call to search the address book and filter the data set.
     */
    applyFilter: function() {
        var searchAllModules = (this._selectedModule === this._allModulesId),
        // pass an empty array when all modules are being searched
            module = searchAllModules ? [] : [this._selectedModule],
        // determine if the filter is dirty so the "clearQuickSearchIcon" can be added/removed appropriately
            isDirty = !_.isEmpty(this._currentSearch);
        this._toggleClearQuickSearchIcon(isDirty);
        this.context.trigger('compose:addressbook:search', module, this._currentSearch);
    },
    /**
     * Append or remove an icon to the quicksearch input so the user can clear the search easily.
     * @param {Boolean} addIt TRUE if you want to add it, FALSE to remove
     */
    _toggleClearQuickSearchIcon: function(addIt) {
        if (addIt && !this.$('.add-on.fa-times')[0]) {
            this.$('.filter-view.search').append('<i class="add-on fa fa-times"></i>');
        } else if (!addIt) {
            this.$('.add-on.fa-times').remove();
        }
    },
    /**
     * Clear input
     */
    clearInput: function() {
        var $filter          = this.getFilterField();
        this._currentSearch  = '';
        this._selectedModule = this._allModulesId;
        this.$('.search-name').val(this._currentSearch);
        if ($filter.length > 0) {
            $filter.select2('val', this._selectedModule);
        }
        this.applyFilter();
    }
}) },
"config-log-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Config-log-headerpane View (base) 

    extendsFrom: "HeaderpaneView",

    events: {
        "click [name=save_button]":   "_save",
        "click [name=cancel_button]": "_cancel"
    },
    /**
     * Save the drawer.
     *
     * @private
     */
    _save: function() {
        app.alert.show('txtConfigLog', {level: 'process', title: 'Saving', autoclose: false})
        var value = this.model.attributes;
        value.frm_action = 'Approve';
        value.cfg_value=this.model.get('comboLogConfig');
        var url = app.api.buildURL('pmse_Inbox/logSetConfig','',{},{});
        app.api.call('update', url, value,{
            success: function (){
                app.alert.dismiss('txtConfigLog');
                app.drawer.close();
            }
        });
    },
    /**
     * Close the drawer.
     *
     * @private
     */
    _cancel: function() {
        app.drawer.close();
    }
}) },
"show-case": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Show-case View (base) 


    /**
     * @deprecated Since 7.8. Will be removed in 7.10
     * @param options
     */
    initialize: function(options) {
        app.logger.warn('View.Views.Base.pmse_Inbox.ShowCaseView is deprecated. It will be removed in 7.10');
        this.inboxId = options.context.attributes.modelId;
        this.flowId = options.context.attributes.action;
        app.routing.before('route', this.beforeRouteChange, this);
    },

    loadData: function () {
        var self = this,
            sep = '/',
            pmseInboxUrl = app.api.buildURL(this.options.module + '/case/' + this.inboxId + sep + this.flowId ,'',{},{});

        app.api.call('READ', pmseInboxUrl, {},{
            success: function(data) {
                self.initCaseView(data)
            },
            error: function (error) {
                app.error.handleNotFoundError();
            }
        });
    },
    initCaseView: function(data){
        if(data.case.flow.cas_flow_status==='FORM'){
            this.params = {
                action: 'detail',
                layout: 'pmse-case',
                module: data.case.flow.cas_sugar_module,
                modelId: data.case.flow.cas_sugar_object_id,
                case: data.case
            };
            app.controller.loadView(this.params);
        } else if (data.case.flow.cas_flow_status === 'CLOSED') {
            app.alert.show('message-id', {
                level: 'warning',
                messages: app.lang.get('LBL_PA_PROCESS_CLOSED','pmse_Inbox'),
                autoClose: false
            });
            app.router.goBack();
        } else {
            app.alert.show('message-id', {
                level: 'warning',
                messages: app.lang.get('LBL_PA_PROCESS_UNAVAILABLE','pmse_Inbox'),
                autoClose: false
            });
        }
    },

    beforeRouteChange: function () {
        app.routing.offBefore('route', this.beforeRouteChange);
        $('.adam-modal').remove();
    }
}) },
"process-status-chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Process-status-chart View (base) 

    plugins: ['Dashlet', 'Chart'],
    processCollection: null,
    currentValue: 'all',
    chartCollection: null,
    hasData: false,
    total: 0,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.locale = SUGAR.charts.getUserLocale();
        this.tooltipTemplate = app.template.getField('chart', 'multipletooltiptemplate', 'Reports');

        this.chart = sucrose.charts.multibarChart()
            .showTitle(false)
            .showControls(true)
            .showValues(false)
            .stacked(true)
            .tooltipContent(_.bind(function(eo, properties) {
                var point = {};
                var precision = this.locality.precision;
                point.groupName = app.lang.get('LBL_PMSE_LABEL_PROCESS', this.module);
                point.groupLabel = eo.group.label;
                point.seriesName = app.lang.get('LBL_PMSE_LABEL_STATUS', this.module);
                point.seriesLabel = eo.series.key;
                point.valueName = app.lang.get('LBL_CHART_COUNT');
                point.valueLabel = sucrose.utility.numberFormat(eo.point.y, precision, false, this.locality);
                return this.tooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .tooltips(true)
            .strings({
                legend: {
                    close: app.lang.get('LBL_CHART_LEGEND_CLOSE'),
                    open: app.lang.get('LBL_CHART_LEGEND_OPEN'),
                    noLabel: app.lang.get('LBL_CHART_UNDEFINED')
                },
                noData: app.lang.get('LBL_CHART_NO_DATA'),
                noLabel: app.lang.get('LBL_CHART_UNDEFINED')
            })
            .locality(this.locale);

        this.locality = this.chart.locality();
    },

    hasChartData: function () {
        return this.hasData;
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        d3.select(this.el).select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.update);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            url;
        if (this.meta.config) {
            return;
        }
        if (!this.currentValue) {
            return;
        }
        url = app.api.buildURL('pmse_Inbox/processStatusChart/' + this.currentValue);
        this.hasData = false;
        app.api.call('GET', url, null, {
            success: function(data) {
                self.evaluateResponse(data);
                self.renderChart();
            },
            complete: options ? options.complete : null
        });
    },

    evaluateResponse: function(response) {
        var total = d3.sum(response.data, function(d) {
                return d3.sum(d.values, function(h) {
                  return h.y;
                });
              });
        this.hasData = !!total;
        this.chartCollection = response;
    }
}) },
"reassignCases-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.pmse_Inbox.ReassignCasesHeaderpaneView
 * @alias SUGAR.App.view.views.Basepmse_InboxReassignCasesHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// ReassignCases-headerpane View (base) 

    extendsFrom: "HeaderpaneView",

    events: {
        'click [name=done_button]':   '_done',
        'click [name=cancel_button]': '_cancel'
    },

     /**
      * Clicking the Done button will update the process with the new process user
      * and close the drawer
      *
      * @private
      */
     _done: function() {
         // If collection.models is missing or empty then there is nothing to save
         if (_.isUndefined(this.collection.models) || (this.collection.models.length == 0)) {
             app.drawer.close();
             return;
         }

         var attributes = {};
         app.alert.show('saving', {level: 'process', title: 'LBL_SAVING', autoclose: false});
         var url = app.api.buildURL('pmse_Inbox', 'reassignFlows', null, null);

         // we only have one model
         var model = _.first(this.collection.models);
         attributes.flow_data = [{
             'cas_id': model.get('cas_id'),
             'cas_index': model.get('cas_index'),
             'user_id': model.get('id')
         }];

         app.api.call('update', url, attributes, {
             success: function (data) {
                 app.alert.dismiss('saving');
                 app.drawer.close('saving');
                 app.router.refresh();
             },
             error: function (err) {
             }
         });
     },

    /**
     * Close the drawer.
     *
     * @private
     */
    _cancel: function() {
        app.drawer.close();
    }
}) },
"process-users-chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Process-users-chart View (base) 

    plugins: ['Dashlet', 'Chart'],
    processCollection: null,
    currentValue: null,
    chartCollection: null,
    hasData: false,
    total: 0,
    showProcesses: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.locale = SUGAR.charts.getUserLocale();
        this.tooltipTemplate = app.template.getField('chart', 'singletooltiptemplate', 'Reports');

        this.chart = sucrose.charts.pieChart()
            .margin({top: 5, right: 20, bottom: 20, left: 20})
            .donut(true)
            .donutLabelsOutside(true)
            .donutRatio(0.447)
            .hole(this.total)
            .showTitle(false)
            .tooltips(true)
            .showLegend(true)
            .colorData('class')
            .tooltipContent(_.bind(function(eo, properties) {
                var point = {};
                point.key = eo.key;
                point.label = app.lang.get('LBL_CHART_COUNT');
                point.value = sucrose.utility.numberFormat(eo.value, this.locality.precision, false, this.locality);
                return this.tooltipTemplate(point).replace(/(\r\n|\n|\r)/gm, '');
            }, this))
            .strings({
                legend: {
                    close: app.lang.get('LBL_CHART_LEGEND_CLOSE'),
                    open: app.lang.get('LBL_CHART_LEGEND_OPEN'),
                    noLabel: app.lang.get('LBL_CHART_UNDEFINED')
                },
                noData: app.lang.get('LBL_CHART_NO_DATA'),
                noLabel: app.lang.get('LBL_CHART_UNDEFINED')
            })
            .locality(this.locale);

        this.locality = this.chart.locality();
    },

    initDashlet: function (view) {
        var self = this;
        // loading all Processes list
        this.showProcesses = !(this.settings.get('isRecord') === '1');

        if (this.showProcesses) {
            app.api.call('GET', app.api.buildURL('pmse_Project/filter?fields=id,name'), null, {
                success: _.bind(function (data) {
                    var options = {};

                    this.processCollection = data.records;
                    this.processCollection.unshift({
                        id: 'all',
                        name: app.lang.get('LBL_PMSE_ALL_PROCESSES_LABEL', 'pmse_Inbox')
                    });

                    //Filling options
                    _.each(this.processCollection, function (row) {
                        options[row.id] = row.name;
                    });
                    this.dashletConfig.processes_selector[0].options = options;
                    this.currentValue = 'all';

                    this.layout.render();
                    this.layout.loadData();
                }, this),
                complete: view.options ? view.options.complete : null
            });

            this.settings.on('change:processes_selector', function (context, value) {
                self.currentValue = value;
                self.loadData();
            });
        } else {
            this.currentValue = this.model.get('id');
            //this.loadData();
        }
    },

    hasChartData: function () {
       return this.hasData;
    },

    /**
     * Generic method to render chart with check for visibility and data.
     * Called by _renderHtml and loadData.
     */
    renderChart: function() {
        if (!this.isChartReady()) {
            return;
        }

        // Set value of label inside donut chart if is greater than zero
        if (this.total && this.total > 0) {
            this.chart.hole(this.total);
        }

        d3.select(this.el).select('svg#' + this.cid)
            .datum(this.chartCollection)
            .transition().duration(500)
            .call(this.chart);

        this.chart_loaded = _.isFunction(this.chart.update);
        this.displayNoData(!this.chart_loaded);
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var self = this,
            url;
        if (this.meta.config) {
            return;
        }
        if (!this.currentValue) {
            return;
        }
        url = app.api.buildURL('pmse_Inbox/processUsersChart/' + this.currentValue);
        this.hasData = false;
        app.api.call('GET', url, null, {
            success: function(data) {
                self.evaluateResponse(data);
                self.renderChart();
            },
            complete: options ? options.complete : null
        });
    },

    evaluateResponse: function(response) {
        this.total = response.properties.total;
        this.hasData = !!this.total;
        response.data.map(function(d) {
            d.value = parseInt(d.value, 10);
        });
        this.chartCollection = response;
    }
}) }
}}
,
"layouts": {
"base": {
"reassignCases": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// ReassignCases Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.view.Layout.prototype.initialize.call(this, options);
        this.collection.sync = _.bind(this.sync, this);
//        this.collection.allowed_modules = ['User Assigned'];
        this.context.on('compose:addressbook:search', this.search, this);
    },
    /**
     * Calls the custom PMSEEngine API endpoint to search for Task for Cases.
     *
     * @param method
     * @param model
     * @param options
     */
    sync: function(method, model, options) {
        var callbacks,
            url;

        options = options || {};

        // only fetch from the approved modules
        if (_.isEmpty(options.module_list)) {
            options.module_list = ['User Assigned'];
        } else {
            options.module_list = _.intersection(this.allowed_modules, options.module_list);
        }

        // this is a hack to make pagination work while trying to minimize the affect on existing configurations
        // there is a bug that needs to be fixed before the correct approach (config.maxQueryResult vs. options.limit)
        // can be determined
        app.config.maxQueryResult = app.config.maxQueryResult || 20;
        options.limit = options.limit || app.config.maxQueryResult;

        options = app.data.parseOptionsForSync(method, model, options);

        callbacks = app.data.getSyncCallbacks(method, model, options);
        this.trigger('data:sync:start', method, model, options);

        if (this.context.get('unattended')) {
            options.params.unattended = true;
        }

        url = app.api.buildURL('pmse_Inbox', 'reassignFlows/' + this.context.get('cas_id'), null, options.params);
        app.api.call('read', url, null, callbacks);
    },
    /**
     * Adds the set of modules and term that should be used to search for recipients.
     *
     * @param {Array} modules
     * @param {String} term
     */
    search: function(modules, term) {
        // reset offset to 0 on a search. make sure that it resets and does not update.
        this.collection.fetch({query: term, module_list: modules, offset: 0, update: false});
    }
}) },
"show-case": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Layouts.Base.pmse_Inbox.ShowCaseLayout
 * @alias SUGAR.App.view.layouts.Basepmse_InboxShowCaseLayout
 * @extends View.Layout
 */
({
	// Show-case Layout (base) 

    plugins: ['ProcessActions'],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.inboxId = options.context.get('modelId');
        this.flowId = options.context.get('action');
        this.recordAction = options.context.get('record') || 'detail';
        this._super('initialize', [options]);
        this.context.set('skipFetch', true);
    },

    /**
     * Request case data to find record id and module
     *
     * @param {Object} [options] Options that are passed to
     *   collection/model's fetch method.
     */
    loadData: function(options) {
        var self = this,
            pmseInboxUrl = app.api.buildURL(this.module + '/case/' + this.inboxId + '/' + this.flowId);

        app.api.call('read', pmseInboxUrl, {}, {
            success: function (data) {
                // Make sure we have an options object to work with
                var options = options || {};

                // This allows us to define our own endpoint setter, which is needed
                // for case view to force consuming our own endpoint
                options.endpoint = function(method, model, opts, callbacks) {
                    var casModule = data.case.flow.cas_sugar_module;
                    var casModuleId = data.case.flow.cas_sugar_object_id;

                    // This is the endpoint URL we want to consume
                    var resourcePath = 'pmse_Inbox/caseRecord/' + casModule + '/' + casModuleId;
                    var url = app.api.buildURL(resourcePath, null, null, {view: 'record', erased_fields: true});
                    // For some reason, options contains a method property that
                    // is causing the subsequent success call to be a READ HTTP
                    // Request Type. So delete the method property of options to
                    // force a GET request to be made.
                    delete opts.method;

                    // Send back the data from our own endpoint
                    return app.api.call('read', url, {}, callbacks, opts);
                };

                self.initCaseView(data, [options]);
            },

            error: function (error) {
                app.error.handleNotFoundError();
            }
        });
    },

    /**
     * Call loadChildLayout to create the module base record view.
     * Show error messages if process is closed or unavailable.
     *
     * @param data Case information
     * @param loadDataParams
     */
    initCaseView: function(data, loadDataParams){
        if (data.case.flow.cas_flow_status === 'FORM') {
            this.loadChildLayout(data, loadDataParams);
        } else if (data.case.flow.cas_flow_status === 'CLOSED') {
            app.alert.show('message-id', {
                level: 'warning',
                messages: app.lang.get('LBL_PA_PROCESS_CLOSED','pmse_Inbox'),
                autoClose: false
            });
            app.router.goBack();
        } else {
            app.alert.show('message-id', {
                level: 'warning',
                messages: app.lang.get('LBL_PA_PROCESS_UNAVAILABLE','pmse_Inbox'),
                autoClose: false
            });
        }
    },

    /**
     * Get the module specific record layout and view and override
     * the view metadata to use PA specific buttons (like Approve/Reject).
     * Update this layout's metadata with the modified record view metadata
     * and load all the new components.
     *
     * @param data Case information
     * @param loadDataParams
     */
    loadChildLayout: function(data, loadDataParams) {
        this.case = data.case;

        //dispose of anything currently here
        app.plugins.detach(this, 'layout');
        _.each(this._components, function(component) {
            component.dispose();
        });
        this._components = [];

        this.recordModule = data.case.flow.cas_sugar_module;

        // Create the context for the record view
        var context = this.context.getChildContext({
            module: this.recordModule,
            modelId: data.case.flow.cas_sugar_object_id
        });

        // to display due date in browser time zone we need to fix it before
        // context is set since we're using raw values set in context inside template
        this.case.flow.cas_due_date = this.fixDateToLocale(this.case.flow.cas_due_date);

        context.prepare();
        context.set('case', this.case);
        context.set('layout', 'record');
        context.set('action', this.recordAction);

        this.recordContext = context;
        this.recordModel = context.get('model');

        // Get the current module specific record layout and view
        var origRecordLayout = app.metadata.getLayout(this.recordModule, 'record');

        var record = this._getChildComponent('view', 'record', origRecordLayout);
        if (!record) {
            app.logger.fatal('Record not found.');
        }

        // Override the templates and buttons to use SugarBPM templates and buttons
        record.xmeta = {
            template: 'pmse-case',
            buttons: data.case.buttons
        };

        // Set this layout's meta to create a record layout inside it
        this.meta = {
            'components': [{
                'layout': origRecordLayout,
                'context': this.recordContext
            }]
        };
        this.initComponents();

        this.recordComponent = this._getNestedComponent(this._components, 'record');

        // Override functions on the record view
        _.extend(this.recordComponent, this.caseViewOverrides());

        // Swap out the event handler so we can override the error message.
        this.recordComponent.model.off('error:validation');
        var showInvalidModel = function() {
                var name = 'invalid-data';
                this._viewAlerts.push(name);
                var msg = this.formAction == 'approve' ?
                    'ERR_AWF_APPROVE_VALIDATION_ERROR' :
                    'ERR_AWF_REJECT_VALIDATION_ERROR';
                app.alert.show(name, {
                    level: 'error',
                    messages: msg
                });
            };
        this.recordComponent.model.on('error:validation', showInvalidModel, this.recordComponent);

        this._super('loadData', loadDataParams);
        this._render();
        this._delegateEvents();
    },

    /**
     * Returns a string containing only date and time for a specified date as
     * per user preferences
     * @param date A date String
     * @return String
     * @private
     */

    fixDateToLocale: function(date) {
        // get local date time for the given utc datetime
        var local = app.date.utc(date).toDate();
        var dateObj = app.date(local);
        // get date and time based on user preferences
        var fixedDate = dateObj.format(app.date.getUserDateFormat());
        var fixedTime = dateObj.format(app.date.getUserTimeFormat());

        return fixedDate + ' ' + fixedTime;
    },

    /**
     * Search the meta recursively to find to find the component
     * by the passed in name
     *
     * @param type Component type (view, layout)
     * @param name Name of the component
     * @param meta The meta for the component
     * @return {*} The component meta for the passed in name
     * @private
     */
    _getChildComponent: function(type, name, meta) {

        if (meta.name === name) {
            return meta;
        }

        if (!meta.components) {
            return;
        }

        for (var i = 0, l = meta.components.length; i < l; i++) {
            var comp = meta.components[i];

            if (comp[type] === name) {
                return comp;
            }

            var next = comp.view || comp.layout;

            if (_.isObject(next)) {
                var child = this._getChildComponent(type, name, next);
                if (child) {
                    return child;
                }
            }
        }
    },

    /**
     * Get the component from inside the layout by looking through _components
     *
     * @param components The _components inside the layout
     * @param name The name of the component we are looking for
     * @return {*} The actual component
     * @private
     */
    _getNestedComponent: function(components, name) {

        if (components.name === name) {
            return components;
        }
        for (var i = 0; i < components.length; i++) {

            if (components[i].name === name) {
                return components[i];
            }
            if (components[i]._components) {
                return this._getNestedComponent(components[i]._components, name);
            }
        }
    },

    /**
     * Set up event listeners on the record view's context
     * @private
     */
    _delegateEvents: function() {
        this.recordContext.on('case:cancel', this.cancelCase, this);
        this.recordContext.on('case:claim', this.caseClaim, this);
        this.recordContext.on('case:approve', _.bind(this.caseAction, this, 'Approve'));
        this.recordContext.on('case:reject', _.bind(this.caseAction, this, 'Reject'));
        this.recordContext.on('case:route', _.bind(this.caseAction, this, 'Route'));
        this.recordContext.on('case:history', this.caseHistory, this);
        this.recordContext.on('case:status', this.caseStatus, this);
        this.recordContext.on('case:add:notes', this.caseAddNotes, this);
        this.recordContext.on('case:change:owner', this.caseChangeOwner, this);
        this.recordContext.on('case:reassign', this.caseReassign, this);
    },

    /**
     * When clicking cancel, the case is redirected
     */
    cancelCase: function () {
        this.redirectCase();
    },

    caseClaim: function () {
        app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
        var frm_action = 'Claim';
        var value = this.recordModel.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        value.cas_id = this.case.flow.cas_id;
        value.cas_index = this.case.flow.cas_index;
        value.taskName = this.case.title.activity;
        var self = this;
        var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_claim','',{},{});
        app.api.call('update', pmseInboxUrl, value,{
            success: function (){
                app.alert.dismiss('upload');
                self.redirectCase(frm_action);
            },
            error: function(error) {
                app.alert.dismiss('upload');
                var message = (error && error.message) ? error.message : 'EXCEPTION_FATAL_ERROR';
                app.alert.show('error_claim', {
                    level: 'error',
                    messages: message
                });
            }
        });
    },

    /**
     * Validate the model when trying to approve/reject/route the case
     */
    caseAction: function (action) {
        var allFields = this.recordComponent.getFields(this.recordModule, this.recordModel);
        var fieldsToValidate = {};
        if (action == 'Reject' || action == 'Route') {
            this.recordComponent.formAction = 'reject';
            var erasedFields = this.recordModel.get('_erased_fields');
            for (var fieldKey in allFields) {
                if (app.acl.hasAccessToModel('edit', this.recordModel, fieldKey) &&
                    (!_.contains(erasedFields, fieldKey) || this.recordModel.get(fieldKey))) {
                    _.extend(fieldsToValidate, _.pick(allFields, fieldKey));
                }
            }
        } else {
            this.recordComponent.formAction = 'approve';
            for (var fieldKey in allFields) {
                if (app.acl.hasAccessToModel('edit', this.recordModel, fieldKey)) {
                    _.extend(fieldsToValidate, _.pick(allFields, fieldKey));
                }
            }
        }
        this.recordModel.doValidate(fieldsToValidate, _.bind(this.validationComplete, this, action));
    },

    /**
     * Shows a window with current history of the record
     */
    caseHistory: function () {
        this.getHistory(this.case.flow.cas_id);
    },

    /**
     * Shows window with picture of current status of the process
     */
    caseStatus: function() {
        this.showStatus(this.case.flow.cas_id);
    },

    /**
     * Shows window with notes of current process
     */
    caseAddNotes: function () {
        this.showNotes(this.case.flow.cas_id, this.case.flow.cas_index);
    },

    /**
     * Allow changing owner
     */
    caseChangeOwner: function () {
        var value = this.recordModel.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        this.showForm(this.case.flow.cas_id, this.case.flow.cas_index, 'adhoc', this.case.flowId, this.case.inboxId, this.case.title.activity, value);
    },

    /**
     * Reassign the case
     */
    caseReassign: function () {
        var value = this.recordModel.attributes;
        value.moduleName = this.case.flow.cas_sugar_module;
        value.beanId = this.case.flow.cas_sugar_object_id;
        this.showForm(this.case.flow.cas_id, this.case.flow.cas_index, 'reassign', this.case.flowId, this.case.inboxId, this.case.title.activity, value);
    },

    /**
     * If validation is valid, save the model and approve the case
     *
     * @param {string} action Either Approve, Reject or Route
     * @param {boolean} isValid `true` if valid, false if validation failed
     */
    validationComplete: function (action, isValid) {
        var buttonLangStrings = {
            'Approve': {
                confirm: 'LBL_PA_PROCESS_APPROVE_QUESTION',
                success: 'LBL_PA_PROCESS_APPROVED_SUCCESS'
            },
            'Reject': {
                confirm: 'LBL_PA_PROCESS_REJECT_QUESTION',
                success: 'LBL_PA_PROCESS_REJECTED_SUCCESS'
            },
            'Route': {
                confirm: 'LBL_PA_PROCESS_ROUTE_QUESTION',
                success: 'LBL_PA_PROCESS_ROUTED_SUCCESS'
            }
        };

        if (isValid) {
            app.alert.show('confirm_save_process', {
                level: 'confirmation',
                messages: app.lang.get(buttonLangStrings[action].confirm, 'pmse_Inbox'),
                onConfirm: _.bind(function () {
                    app.alert.show('upload', {
                        level: 'process',
                        title: app.lang.get('LBL_LOADING'),
                        autoclose: false
                    });
                    var data = app.data.getEditableFields(this.recordModel);
                    data = _.extend(data, {
                        frm_action: action,
                        idFlow: this.case.flowId,
                        idInbox: this.case.inboxId,
                        cas_id: this.case.flow.cas_id,
                        cas_index: this.case.flow.cas_index,
                        moduleName: this.case.flow.cas_sugar_module,
                        beanId: this.case.flow.cas_sugar_object_id,
                        taskName: this.case.title.activity
                    });

                    if (action === 'Route' && this.case.taskContinue) {
                        data.taskContinue = true;
                    }

                    var self = this;
                    var pmseInboxUrl = app.api.buildURL('pmse_Inbox/engine_route', '', {}, {});

                    app.api.call('update', pmseInboxUrl, data, {
                        success: function () {
                            app.alert.show('success_save_process', {
                                level: 'success',
                                messages: app.lang.get(buttonLangStrings[action].success, 'pmse_Inbox'),
                                autoClose: true
                            });
                            self.recordModel.setSyncedAttributes(data);
                            self.redirectCase();
                        },
                        error: function(error) {
                            app.alert.dismiss('upload');
                            var message = (error && error.message) ? error.message : 'EXCEPTION_FATAL_ERROR';
                            app.alert.show('error_save_process', {
                                level: 'error',
                                messages: message
                            });
                        }
                    });
                }, this),
                onCancel: $.noop
            });
        }
    },

    /**
     * Leave the case record view
     *
     * @param isRoute
     */
    redirectCase: function(isRoute){
        app.alert.dismiss('upload');
        switch(isRoute){
            case 'Claim':
                window.location.reload();
                break;
            default:
                app.router.list("Home");
                break;
        };
    },

    /**
     * Defines and returns functions that will override the case module's record view.
     * Add functions to the return object anytime you want to change record view behavior.
     *
     * @return Object of functions
     */
    caseViewOverrides: function() {
        return {
            /**
             * @override
             *
             * Allows checking SugarBPM readonly and required fields
             */
            setEditableFields: function() {
                delete this.editableFields;
                this.editableFields = [];
                var previousField, firstField;
                _.each(this.fields, function(field) {
                    if (this.checkReadonly(field)) {
                        field.def.readonly = true;
                    }
                    if (field.def.fields && _.isArray(field.def.fields)) {
                        var that = this;
                        var basefield = field;
                        _.each(field.def.fields, function(field) {
                            if (that.checkReadonly(field)) {
                                field.readonly = true;
                                field.action = 'detail';
                                // Some fields use shouldDisable to enable readonly property,
                                // like 'body' in KBContents
                                if (!_.isUndefined(field.shouldDisable)) {
                                    field.setDisabled(true);
                                    basefield.def.readonly = true;
                                }
                            }
                        });
                    }
                    if (field.fields && _.isArray(field.fields)) {
                        var self = this;
                        _.each(field.fields, function(field) {
                            if (self.checkRequired(field)) {
                                field.def.required = true;
                            }
                        });
                    }
                    var readonlyField = field.def.readonly ||
                        _.indexOf(this.noEditFields, field.def.name) >= 0 ||
                        field.parent || (field.name && this.buttons[field.name]);

                    if (readonlyField) {
                        // exclude read only fields
                        return;
                    }
                    if (this.checkRequired(field)) {
                        field.def.required = true;
                    }
                    if (previousField) {
                        previousField.nextField = field;
                        field.prevField = previousField;
                    } else {
                        firstField = field;
                    }
                    previousField = field;
                    this.editableFields.push(field);

                }, this);

                if (previousField) {
                    previousField.nextField = firstField;
                    firstField.prevField = previousField;
                }

            },

            /**
             * @override
             * Toggle more fields than on base record view
             * @param isEdit
             */
            toggleViewButtons: function(isEdit) {
                this.$('.headerpane span[data-type="badge"]').toggleClass('hide', isEdit);
                this.$('.headerpane span[data-type="favorite"]').toggleClass('hide', isEdit);
                this.$('.headerpane span[data-type="follow"]').toggleClass('hide', isEdit);
                this.$('.headerpane .btn-group-previous-next').toggleClass('hide', isEdit);
            },

            /**
             * @override
             * We want to set field metadata here if a field is readonly
             * @param panels
             * @private
             */
            _buildGridsFromPanelsMetadata: function(panels) {
                var lastTabIndex = 0;
                this.noEditFields = [];

                _.each(panels, function(panel) {
                    // it is assumed that a field is an object but it can also be a string
                    // while working with the fields, might as well take the opportunity to check the user's ACLs for the field
                    _.each(panel.fields, function(field, index) {
                        if (this.checkReadonly(field)) {
                            field.readonly = true;
                        }
                        if (_.isString(field)) {
                            panel.fields[index] = field = {name: field};
                        }

                        var keys = _.keys(field);

                        // Make filler fields readonly
                        if (keys.length === 1 && keys[0] === 'span') {
                            field.readonly = true;
                        }

                        // disable the pencil icon if the user doesn't have ACLs
                        if (field.type === 'fieldset') {
                            if (field.readonly || _.every(field.fields, function(field) {
                                    return !app.acl.hasAccessToModel('edit', this.model, field.name);
                                }, this)) {
                                this.noEditFields.push(field.name);
                            }
                        } else if (field.readonly || !app.acl.hasAccessToModel('edit', this.model, field.name)) {
                            this.noEditFields.push(field.name);
                        }
                    }, this);

                    // Set flag so that show more link can be displayed to show hidden panel.
                    if (panel.hide) {
                        this.hiddenPanelExists = true;
                    }

                    // labels: visibility for the label
                    if (_.isUndefined(panel.labels)) {
                        panel.labels = true;
                    }

                    if (_.isFunction(this.getGridBuilder)) {
                        var options = {
                                fields: panel.fields,
                                columns: panel.columns,
                                labels: panel.labels,
                                labelsOnTop: panel.labelsOnTop,
                                tabIndex: lastTabIndex
                            },
                            gridResults = this.getGridBuilder(options).build();

                        panel.grid = gridResults.grid;
                        lastTabIndex = gridResults.lastTabIndex;
                    }
                }, this);
            },

            /**
             * Check if the field is set to readonly by SugarBPM
             * @param field The field
             * @returns {boolean} `true` or `false`
             */
            checkReadonly: function(field){
                var isReadonly = false;
                _.each(this.context.get('case').readonly, function(caseField) {
                    if (field.name === caseField) {
                        isReadonly = true;
                    }
                }, this);
                return isReadonly;
            },

            /**
             * Check if the field is set to required by SugarBPM
             * @param field The field
             * @returns {boolean} `true` or `false`
             */
            checkRequired: function(field){
                var isRequired = false;
                _.each(this.context.get('case').required, function(caseField) {
                    if (field.name === caseField) {
                        isRequired = true;
                    }
                }, this);
                return isRequired;
            }
        }
    }
}) },
"casesList": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// CasesList Layout (base) 

    /**
     * @class ComposeAddressbookLayout
     * @extends Layout
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['ProcessActions']);
        app.view.Layout.prototype.initialize.call(this, options);
        this.collection.sync = this.sync;
//        this.collection.allowed_modules = ['Cases Title', 'Process Name', 'Status', 'Owner'];
        this.collection.allowed_modules = [
            app.lang.get('LBL_STATUS_COMPLETED', options.module),
            app.lang.get('LBL_STATUS_TERMINATED', options.module),
            app.lang.get('LBL_STATUS_IN_PROGRESS', options.module),
            app.lang.get('LBL_STATUS_CANCELLED', options.module),
            app.lang.get('LBL_STATUS_ERROR', options.module)];
        this.context.on('compose:addressbook:search', this.search, this);
        this.context.on('case:status', this.viewStatus, this);
        this.context.on('case:history', this.viewHistory, this);
        this.context.on('case:notes', this.viewNotes, this);
        this.context.on('case:execute', this.executeCase, this);
        this.context.on('case:reassign', this.executeReassign, this);
        this.context.on('list:cancelCase:fire', this.cancelCases, this);
//        this.context.on('list:executeCase:fire', this.executeCases, this);
    },
    viewStatus: function(model){
        this.showStatus(model.get('cas_id'));
    },
    viewHistory: function(model){
        this.getHistory(model.get('cas_id'));
    },
    viewNotes: function(model){
        this.showNotes(model.get('cas_id'), 1);
    },
    executeCase: function(model){
        app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
        this.executeCasesList([model.get('cas_id')]);
    },
    cancelCases: function(model){
        var self=this;

        var msg=app.lang.get('LBL_PMSE_CANCEL_MESSAGE', this.module);
        msg=msg.replace('[]',model.get('cas_title'));
        msg=msg.replace('{}',model.get('cas_id'));

        app.alert.show('cancelCase-id', {
            level: 'confirmation',
            messages:msg,
//            messages:app.lang.get('LBL_CANCEL_MESSAGE', this.module)+model.get('cas_title')+' with Cas Id: '+model.get('cas_id')+'?',
            autoClose: false,
            onConfirm: function(){
                app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
                var massCollection=self.context.get('mass_collection');
                var value = self.model.attributes;
//        value.cas_id = this.buildVariablesString(massCollection);
                value.cas_id = [model.get('cas_id')];
                var pmseInboxUrl = app.api.buildURL(self.module + '/cancelCases','',{},{});
                app.api.call('update', pmseInboxUrl, value,{
                    success: function(data)
                    {
                        self.reloadList();
                        app.alert.dismiss('upload');
//                        window.location.reload();
                    }
                });
            },
            onCancel: function(){
                app.alert.dismiss('cancelCase-id');
            }
        });
    },
//    executeCases: function(model){
//        app.alert.show('upload', {level: 'process', title: 'LBL_LOADING', autoclose: false});
//        var massCollection=this.context.get('mass_collection');
//        this.executeCasesList(this.buildVariablesString(massCollection));
//    },
    executeCasesList: function(idCases){
        var self=this;
        var value = this.model.attributes;
        value.cas_id = idCases;
        var pmseInboxUrl = app.api.buildURL(this.module + '/reactivateFlows','',{},{});
        app.api.call('update', pmseInboxUrl, value,{
            success: function(data)
            {
                self.reloadList();
                app.alert.dismiss('upload');
//                window.location.reload();
            }
        });
    },

    executeReassign: function(model) {
        app.drawer.open({
            layout: 'reassignCases',
            context: {
                module: 'pmse_Inbox',
                parent: this.context,
                cas_id: model.get('cas_id')
            }
        });
    },

    buildVariablesString: function(recipients) {
        var listIdCases = [],count=0;
        _.each(recipients.models, function(model) {
            listIdCases[count++]=model.attributes.cas_id
        });
        return currentValue = listIdCases;
    },
    /**
     * Calls the custom Mail API endpoint to search for email addresses.
     *
     * @param method
     * @param model
     * @param options
     */
    sync: function(method, model, options) {
        var callbacks,
            url;

        options = options || {};

        // only fetch from the approved modules
        if (_.isEmpty(options.module_list)) {
            options.module_list = ['all'];
        } else {
            options.module_list = _.intersection(this.allowed_modules, options.module_list);
//            options.module_list = this.allowed_modules;
        }

        // this is a hack to make pagination work while trying to minimize the affect on existing configurations
        // there is a bug that needs to be fixed before the correct approach (config.maxQueryResult vs. options.limit)
        // can be determined
        app.config.maxQueryResult = app.config.maxQueryResult || 20;
        options.limit = options.limit || app.config.maxQueryResult;

        options = app.data.parseOptionsForSync(method, model, options);

        callbacks = app.data.getSyncCallbacks(method, model, options);
        this.trigger('data:sync:start', method, model, options);

//        url = app.api.buildURL('pmse_Project', 'caseslist/find', null, options.params);
        url = app.api.buildURL('pmse_Inbox', 'casesList', null, options.params);
        app.api.call('read', url, null, callbacks);
    },
    /**
     * Adds the set of modules and term that should be used to search for recipients.
     *
     * @param {Array} modules
     * @param {String} term
     */
    search: function(modules, term) {
        // reset offset to 0 on a search. make sure that it resets and does not update.
        this.context.set('query', term);
        this.context.set('module_list', modules);
        var sortOptions = this.context.get('sortOptions') || {};
        sortOptions.query = term;
        sortOptions.module_list = modules;
        sortOptions.offset = 0;
        sortOptions.update = false;
        this.context.resetLoadFlag({recursive: false});
        this.context.set('skipFetch', false);
        this.context.loadData(sortOptions);
    },
    reloadList: function() {
        this.context.reloadData({
            recursive:false,
        });
    }
}) },
"config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Config Layout (base) 

initialize: function(options) {
    var acls = app.user.getAcls().Forecasts,
        hasAccess = (!_.has(acls, 'access') || acls.access == 'yes'),
        isSysAdmin = (app.user.get('type') == 'admin'),
        isDev = (!_.has(acls, 'developer') || acls.developer == 'yes');
    // if user has access AND is a System Admin OR has a Developer role
    if(hasAccess && (isSysAdmin || isDev)) {
        // initialize
        app.view.Layout.prototype.initialize.call(this, options);
        // load the data
        app.view.Layout.prototype.loadData.call(this);
    } else {
        this.codeBlockForecasts('LBL_FORECASTS_NO_ACCESS_TO_CFG_TITLE', 'LBL_FORECASTS_NO_ACCESS_TO_CFG_MSG');
    }
},

/**
 * Blocks forecasts from continuing to load
 */
codeBlockForecasts: function(title, msg) {
    var alert = app.alert.show('no_access_to_forecasts', {
        level: 'error',
        title: app.lang.get(title, 'pmse_Inbox') + ':',
        messages: [app.lang.get(msg, 'pmse_Inbox')]
    });

    var $close = alert.getCloseSelector();
    $close.on('click', function() {
        $close.off();
        app.router.navigate('#Home', {trigger: true});
    });
    app.accessibility.run($close, 'click');
},

/**
 * Overrides loadData to defer it running until we call it in _onceInitSelectedUser
 *
 * @override
 */
loadData: function() {
}
}) },
"unattendedCases": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// UnattendedCases Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.view.Layout.prototype.initialize.call(this, options);
        this.collection.sync = this.sync;
        this.collection.allowed_modules = [
            app.lang.get('LBL_CAS_ID',options.module),
            app.lang.get('LBL_PROCESS_DEFINITION_NAME',options.module),
            app.lang.get('LBL_RECORD_NAME',options.module),
            app.lang.get('LBL_OWNER',options.module)
        ];
        this.context.on('compose:addressbook:search', this.search, this);
        //this.context.on('compose:addressbook:search', this.search, this);
    },
    /**
     * Calls the custom PMSEEngine API endpoint to search for Task for Cases.
     *
     * @param method
     * @param model
     * @param options
     */
    sync: function(method, model, options) {
        var callbacks,
            url;

        options = options || {};

        // only fetch from the approved modules
        if (_.isEmpty(options.module_list)) {
            options.module_list = ['all'];
        } else {
            options.module_list = _.intersection(this.allowed_modules, options.module_list);
        }

        // this is a hack to make pagination work while trying to minimize the affect on existing configurations
        // there is a bug that needs to be fixed before the correct approach (config.maxQueryResult vs. options.limit)
        // can be determined
        app.config.maxQueryResult = app.config.maxQueryResult || 20;
        options.limit = options.limit || app.config.maxQueryResult;

        options = app.data.parseOptionsForSync(method, model, options);

        callbacks = app.data.getSyncCallbacks(method, model, options);
        this.trigger('data:sync:start', method, model, options);

        url = app.api.buildURL('pmse_Inbox', 'unattendedCases', null, options.params);
        app.api.call('read', url, null, callbacks);
    },
    /**
     * Adds the set of modules and term that should be used to search for recipients.
     *
     * @param {Array} modules
     * @param {String} term
     */
    search: function(modules, term) {
        // reset offset to 0 on a search. make sure that it resets and does not update.
        this.collection.fetch({query: term, module_list: modules, offset: 0, update: false});
    }
}) }
}}
,
"datas": {}

},
		"pmse_Project":{"fieldTemplates": {
"base": {
"enabled-disabled": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Enabled-disabled FieldTemplate (base) 

    extendsFrom: 'RowactionField',
    initialize: function (options) {
        this._super("initialize", [options]);
        this.type = 'rowaction';
    },

    _render: function () {
        var value=this.model.get('prj_status');

        if (value === 'ACTIVE') {
            this.label = App.lang.get("LBL_PMSE_LABEL_DISABLE", "pmse_Project");
        } else {
            this.label = App.lang.get("LBL_PMSE_LABEL_ENABLE", "pmse_Project");
        }

        this._super("_render");
    },

    bindDataChange: function () {
        if (this.model) {
            this.model.on("change", this.render, this);
        }
    }
}) },
"process-status": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Process-status FieldTemplate (base) 

    extendsFrom: 'BadgeSelectField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'badge-select';
    },

    /**
     * @inheritdoc
     *
     * Styles the badge.
     *
     * @private
     */
    _render: function() {
        this._super('_render');
        this.styleLabel(this.model.get(this.name));
    },

    /**
     * Sets the appropriate CSS class on the label based on the value of the
     * status.
     *
     * It is a noop when the field is in edit mode.
     *
     * @param {String} status
     */
    styleLabel: function(status) {
        var $label;

        if (this.action !== 'edit') {
            $label = this.$('.label');

            switch (status) {
                case 'ACTIVE':
                    $label.addClass('label-success');
                    break;
                case 'INACTIVE':
                    $label.addClass('label-important');
                    break;
                default:
                    break;
            }
        }
    }
}) }
}}
,
"views": {
"base": {
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Recordlist View (base) 

    extendsFrom: 'RecordlistView',

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        this.contextEvents = _.extend({}, this.contextEvents, {
            "list:opendesigner:fire": "openDesigner",
            "list:exportprocess:fire": "showExportingWarning",
            "list:enabledDisabledRow:fire": "enableDisableProcess"
        });

        this._super('initialize', [options]);
    },

    openDesigner: function(model) {
        var verifyURL = app.api.buildURL(
                this.module,
                'verify',
                {
                    id : model.get('id')
                }
            ),
            self = this;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    app.navigate(this.context, model, 'layout/designer');
                } else {
                    app.alert.show('project-design-confirmation',  {
                        level: 'confirmation',
                        messages: App.lang.get('LBL_PMSE_PROCESS_DEFINITIONS_EDIT', model.module),
                        onConfirm: function () {
                            app.navigate(this.context, model, 'layout/designer');
                        },
                        onCancel: $.noop
                    });
                }
            }
        });
    },

    showExportingWarning: function (model) {
        var that = this;
        if (app.cache.get("show_project_export_warning")) {
            app.alert.show('project-export-confirmation',  {
                level: 'confirmation',
                messages: App.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') + "<br/><br/>"
                    + app.lang.get('LBL_PMSE_EXPORT_CONFIRMATION'),
                onConfirm: function () {
                    app.cache.set("show_project_export_warning", false);
                    that.exportProcess(model);
                },
                onCancel: $.noop
            });
        } else {
            that.exportProcess(model);
        }
    },

    exportProcess: function(model) {
        var url = app.api.buildURL(model.module, 'dproject', {id: model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the Project download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },
    enabledProcess: function(model) {
        var self = this;
        var name = model.get('name') || '';
        app.alert.show(model.get('id') + ':deleted', {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('LBL_PRO_ENABLE_CONFIRMATION', model.module),[name.trim()]),
            onConfirm: function() {
                self._updateProStatusEnabled(model);
            }
        });
    },
    _showSuccessAlert: function () {
        app.alert.show("data:sync:success", {
            level: "success",
            messages: App.lang.get('LBL_RECORD_SAVED'),
            autoClose: true
        });
    },
    _updateProStatusEnabled: function(model) {
        model.set('prj_status', 'ACTIVE');
        model.save();
        this._showSuccessAlert();
    },
    disabledProcess: function(model) {
        var self = this;
        var name = model.get('name') || '';

        var verifyURL = app.api.buildURL(
                this.module,
                'verify',
                {
                    id : model.get('id')
                }
            );
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    app.alert.show('project_disable', {
                        level: 'confirmation',
                        messages: app.utils.formatString(app.lang.get('LBL_PRO_DISABLE_CONFIRMATION', model.module),[name.trim()]),
                        onConfirm: function() {
                            self._updateProStatusDisabled(model);
                        }
                    });
                } else {
                    app.alert.show('project-disable-confirmation',  {
                        level: 'confirmation',
                        messages: App.lang.get('LBL_PMSE_DISABLE_CONFIRMATION_PD', model.module),
                        onConfirm: function () {
                            self._updateProStatusDisabled(model);
                        },
                        onCancel: $.noop
                    });
                }
            }
        });
    },
    _updateProStatusDisabled: function(model) {
        model.set('prj_status', 'INACTIVE');
        model.save();
        this._showSuccessAlert();
    },
    enableDisableProcess: function (model) {
        var status = model.get("prj_status");
        if (status === 'ACTIVE') {
            this.disabledProcess(model);
        } else {
            this.enabledProcess(model);
        }
    },
    getDeleteMessages: function(model) {
        var messages = {};
        var name = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;

        messages.confirmation = app.utils.formatString(app.lang.get('NTC_DELETE_CONFIRMATION_FORMATTED'), [context]);
        messages.success = app.utils.formatString(app.lang.get('NTC_DELETE_SUCCESS'), [context]);
        return messages;
    },
    deleteModel: function() {
        var self = this,
            model = this._modelToDelete;

        model.destroy({

            //Show alerts for this request
            showAlerts: {
                'process': true,
                'success': {
                    messages: self.getDeleteMessages(model).success
                }
            },
            success: function() {
                var redirect = self._targetUrl !== self._currentUrl;
                self._modelToDelete = null;
                self.collection.remove(model, { silent: redirect });
                if (redirect) {
                    self.unbindBeforeRouteDelete();
                    //Replace the url hash back to the current staying page
                    app.router.navigate(self._targetUrl, {trigger: true});
                    return;
                }
                app.events.trigger("preview:close");
                if (!self.disposed) {
                    self.render();
                }

                self.layout.trigger("list:record:deleted", model);
            }
        });
    },
    warnDelete: function(model) {
        var verifyURL = app.api.buildURL(
                this.module,
                'verify',
                {
                    id : model.get('id')
                }
            ),
            self = this;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    namePd = Handlebars.Utils.escapeExpression(app.utils.getRecordName(model)).trim();
                    if ( (namePd !== '') && (app.lastNamePdDel !== namePd) ) {
                        self._targetUrl = Backbone.history.getFragment();
                        //Replace the url hash back to the current staying page
                        if (self._targetUrl !== self._currentUrl) {
                            app.router.navigate(self._currentUrl, {trigger: false, replace: true});
                        }
                        app.alert.show('delete_confirmation', {
                            level: 'confirmation',
                            messages: self.getDeleteMessages(model).confirmation,
                            onConfirm: function() {
                                self._modelToDelete = model;
                                self.deleteModel();
                                app.lastNamePdDel = namePd;
                            }
                        });
                    }
                } else {
                    app.alert.show('message-id', {
                        level: 'warning',
                        title: app.lang.get('LBL_WARNING'),
                        messages: app.lang.get('LBL_PA_PRODEF_HAS_PENDING_PROCESSES'),
                        autoClose: false
                    });
                }
            }
        });
    }
}) },
"dashlet-processes": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dashlet-processes View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        limit: 10,
        visibility: 'user'
    },

    thresholdRelativeTime: 2, //Show relative time for 2 days and then date time after

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';
        
        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);
        this.tbodyTag = 'ul[data-action="pagination-body"]';
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('dashlet-processes:designer:fire', this.designer, this);
        this.on('dashlet-processes:delete-record:fire', this.deleteRecord, this);
        this.on('dashlet-processes:enable-record:fire', this.enableRecord, this);
        this.on('dashlet-processes:disable-record:fire', this.disableRecord, this);
        this.on('dashlet-processes:download:fire', this.showExportingWarning, this);
        this.on('dashlet-processes:description-record:fire', this.descriptionRecord, this);
        this.on('linked-model:create', this.loadData, this);
        return this;
    },

    /**
     * Re-fetches the data for the context's collection.
     *
     * FIXME: This will be removed when SC-4775 is implemented.
     *
     * @private
     */
    _reloadData: function() {
        this.context.set('skipFetch', false);
        this.context.reloadData();
    },

    /**
     * Fire dessigner
     */
    designer: function(model){
        var verifyURL = app.api.buildURL(
                this.module,
                'verify',
                {
                    id : model.get('id')
                }
            ),
            self = this;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    var redirect = app.router.buildRoute(model.module, model.id, 'layout/designer');
                    app.router.navigate(redirect , {trigger: true, replace: true });
                } else {
                    app.alert.show('project-design-confirmation',  {
                        level: 'confirmation',
                        messages: App.lang.get('LBL_PMSE_PROCESS_DEFINITIONS_EDIT', model.module),
                        onConfirm: function () {
                            var redirect = app.router.buildRoute(model.module, model.id, 'layout/designer');
                            app.router.navigate(redirect , {trigger: true, replace: true });
                        },
                        onCancel: $.noop
                    });
                }
            }
        });
    },

    /**
     * Show warning of pmse_Process_Definition
     */
    showExportingWarning: function (model) {
        var that = this;
        if (app.cache.get("show_project_export_warning")) {
            app.alert.show('project-export-confirmation',  {
                level: 'confirmation',
                messages: App.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') + "<br/><br/>"
                + app.lang.get('LBL_PMSE_EXPORT_CONFIRMATION'),
                onConfirm: function () {
                    app.cache.set("show_project_export_warning", false);
                    that.exportProcess(model);
                },
                onCancel: $.noop
            });
        } else {
            that.exportProcess(model);
        }
    },

    /**
     * Download record of table pmse_Process_Definition
     */
    exportProcess: function (model) {
        var url = app.api.buildURL(model.module, 'dproject', {id: model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the Project download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    /**
     * @inheritdoc
     *
     * FIXME: This should be removed when metadata supports date operators to
     * allow one to define relative dates for date filters.
     */
    _initTabs: function() {
        this._super('_initTabs');

        // FIXME: since there's no way to do this metadata driven (at the
        // moment) and for the sake of simplicity only filters with 'date_due'
        // value 'today' are replaced by today's date
        var today = new Date();
        today.setHours(23, 59, 59);
        today.toISOString();

        _.each(_.pluck(_.pluck(this.tabs, 'filters'), 'date_due'), function(filter) {
            _.each(filter, function(value, operator) {
                if (value === 'today') {
                    filter[operator] = today;
                }
            });
        });
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    createRecord: function(event, params) {
        if (this.module !== 'pmse_Project') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            var self = this;
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }

    },

    importRecord: function(event, params) {
        App.router.navigate(params.link , {trigger: true, replace: true });
    },
    
    /**
     * Delete record.
     *
     * @param {Event} event Click event.
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    deleteRecord: function(model) {
        var self = this,
            verifyURL = app.api.buildURL(
                this.module,
                'verify',
                {
                id : model.get('id')
                }
            );
        var messages = {};
        var name = app.utils.getRecordName(model).trim();
        var context = app.lang.getModuleName(model.module).toLowerCase() + ' ' + name;

        messages.confirmation = app.utils.formatString(app.lang.get('NTC_DELETE_CONFIRMATION_FORMATTED'), [context]);

        this._modelToDelete = true;

        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    app.alert.show(model.get('id') + ':deleted', {
                         level: 'confirmation',
                         messages: messages.confirmation,
                         onConfirm: function() {
                             model.destroy({
                                 showAlerts: true,
                                 success: self._getRemoveRecord()
                             });
                         }
                     });
                } else {
                    app.alert.show('message-id', {
                        level: 'warning',
                        title: app.lang.get('LBL_WARNING'),
                        messages: app.lang.get('LBL_PA_PRODEF_HAS_PENDING_PROCESSES'),
                        autoClose: false
                    });
                }
            }
        });
    },
    
    /**
     * Updating in fields delete removed
     * @return {Function} complete callback
     * @private
     */
    _getRemoveRecord: function() {
        return _.bind(function(model){
            if (this.disposed) {
                return;
            }
            this.collection.remove(model);
            this.render();
            this.context.trigger("tabbed-dashlet:refresh", model.module);
        }, this);
    },
    
    /**
     * Method view alert in process with text modify
     * show and hide alert
     */
    _refresh: function(model, status) {
        app.alert.show(model.id + ':refresh', {
            level:"process",
            title: status,
            autoClose: false
        });
        return _.bind(function(model){
            var options = {};
            this.layout.reloadDashlet(options);
            app.alert.dismiss(model.id + ':refresh');
        }, this);
    },
    
    /**
     * Disable record.
     * 
     * @param {Event} event Click event.
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    disableRecord: function(model) {
        var self = this;
        var verifyURL = app.api.buildURL(
            this.module,
            'verify',
            {
                id : model.get('id')
            }
        );
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    app.alert.show('project_disable', {
                        level: 'confirmation',
                        messages: app.utils.formatString(app.lang.get('LBL_PRO_DISABLE_CONFIRMATION', model.module),[name.trim()]),
                        onConfirm: function() {
                            self._updateProStatusDisabled(model);
                        }
                    });
                } else {
                    app.alert.show('project-disable-confirmation',  {
                        level: 'confirmation',
                        messages: App.lang.get('LBL_PMSE_DISABLE_CONFIRMATION_PD', model.module),
                        onConfirm: function () {
                            self._updateProStatusDisabled(model);
                        },
                        onCancel: $.noop
                    });
                }
            }
        });
    },
    
    /**
     * Update record in table pmse_Project in fields prj_status by INACTIVE
     */
    _updateProStatusDisabled: function(model) {
        var self = this;
        url = App.api.buildURL(model.module, null, {id: model.id});
        attributes = {prj_status: 'INACTIVE'};
        //App.api.call('update', url, attributes,{success: self._refresh(model, app.lang.get('LBL_PRO_DISABLE', model.module))});
        app.api.call('update', url, attributes);
        app.alert.show(model.id + ':refresh', {
            level:"process",
            title: app.lang.get('LBL_PRO_DISABLE', model.module),
            autoClose: true
        });
        self.refresh_Dashlet();
    },
    
    /**
     * Enable record.
     *
     * @param {Event} event Click event.
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    enableRecord: function(model) {
        var self = this;
        this._modelToDelete = true;
        var name = model.get('name') || '';
        app.alert.show(model.get('id') + ':deleted', {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('LBL_PRO_ENABLE_CONFIRMATION', model.module),[name.trim()]),
            onConfirm: function() {
                self._updateProStatusEnabled(model);
            }
        });
    },
    
    /**
     * Update record in table pmse_Project in fields prj_status by ACTIVE
     */
    _updateProStatusEnabled: function(model) {
        var self = this;
        url = App.api.buildURL(model.module, null, {id: model.id});
        attributes = {prj_status: 'ACTIVE'};
        app.api.call('update', url, attributes);
        app.alert.show(model.id + ':refresh', {
            level:"process",
            title: app.lang.get('LBL_PRO_ENABLE', model.module),
            autoClose: true
        });
        self.refresh_Dashlet();
    },
    refresh_Dashlet:function(){
            var $el = this.$("[data-action=loading]"),
            self = this,
            options = {};
            if($el.length > 0) {
            $el.removeClass(this.cssIconDefault).addClass(this.cssIconRefresh);
            options.complete = function() {
            if(self.disposed) {
                return;
            }
            $el.removeClass(self.cssIconRefresh).addClass(self.cssIconDefault);
            };
            }
            this.layout.reloadDashlet(options);
    },
    /**
     * descriptionRecord: View description in table pmse_Project in fields
     */
    descriptionRecord: function(model) {
        app.alert.dismiss('message-id');
        app.alert.show('message-id', {
            level: 'info',
            title: app.lang.get('LBL_DESCRIPTION'),
            messages: '<br/>' + Handlebars.Utils.escapeExpression(model.get('description')),
            autoClose: false
        });
    },

    //tabs Switcher load
    tabSwitcher: function(event) {
        var index = this.$(event.currentTarget).data('index');
        if (index === this.settings.get('activeTab')) {
            return;
        }
        this.settings.set('activeTab', index);
        this.render();
        this.refresh_Dashlet();
    },

    /**
     * Sets property useRelativeTime to show date created as a relative time or as date time.
     *
     * @private
     */
    _setRelativeTimeAvailable: function(date) {
        var diffInDays = app.date().diff(date, 'days', true);
        var useRelativeTime = (diffInDays <= this.thresholdRelativeTime);
        return useRelativeTime;
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     * - {String} picture_url Picture url for model's assigned user.
     * - {String} prj_module_name Name of the triggering module.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        if (tab.overdue_badge) {
            this.overdueBadge = tab.overdue_badge;
        }

        _.each(this.collection.models, function(model) {
            var pictureUrl = app.api.buildFileURL({
                module: 'Users',
                id: model.get('assigned_user_id'),
                field: 'picture'
            });
            model.set('picture_url', pictureUrl);
            model.useRelativeTime = this._setRelativeTimeAvailable(model.attributes.date_entered);
            // Update the triggering module names.
            var module = model.get('prj_module');
            var label = app.lang.getModString('LBL_MODULE_NAME', module);
            if (_.isUndefined(label)) {
                label = module;
            }
            model.set('prj_module_name', label);
        }, this);

        this._super('_renderHtml');
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    initialize: function (options) {
        this._super('initialize', [options]);
        this.context.on('button:open_designer:click', this.openDesigner, this);
        this.context.on('button:export_process:click', this.showExportingWarning, this);
    },

    openDesigner: function(model) {
        var verifyURL = app.api.buildURL(
                this.module,
                'verify',
                {
                    id : this.model.get('id')
                }
            ),
            self = this;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    app.navigate(this.context, model, 'layout/designer');
                } else {
                    app.alert.show('project-export-confirmation',  {
                        level: 'confirmation',
                        messages: App.lang.get('LBL_PMSE_PROCESS_DEFINITIONS_EDIT', model.module),
                        onConfirm: function () {
                            app.navigate(this.context, model, 'layout/designer');
                        },
                        onCancel: $.noop
                    });
                }
            }
        });
    },

    showExportingWarning: function (model) {
        var that = this;
        if (app.cache.get("show_project_export_warning")) {
            app.alert.show('project-export-confirmation',  {
                level: 'confirmation',
                messages: App.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') + "<br/><br/>"
                + app.lang.get('LBL_PMSE_EXPORT_CONFIRMATION'),
                onConfirm: function () {
                    app.cache.set("show_project_export_warning", false);
                    that.exportProcess(model);
                },
                onCancel: $.noop
            });
        } else {
            that.exportProcess(model);
        }
    },

    exportProcess: function(model) {
        var url = app.api.buildURL(model.module, 'dproject', {id: model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the Project download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    warnDelete: function() {
        var verifyURL = app.api.buildURL(
            this.module,
            'verify',
            {
                id : this.model.get('id')
            }
        ),
            self = this;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    self._super('warnDelete', []);
                } else {
                    app.alert.show('message-id', {
                        level: 'warning',
                        title: app.lang.get('LBL_WARNING'),
                        messages: app.lang.get('LBL_PA_PRODEF_HAS_PENDING_PROCESSES'),
                        autoClose: false
                    });
                }
            }
        });
    },

    duplicateClicked: function() {
        var self = this,
            prefill = app.data.createBean(this.model.module);

        prefill.copy(this.model);
        this._copyNestedCollections(this.model, prefill);
        prefill.fields.prj_module.readonly = true;
        self.model.trigger('duplicate:before', prefill);
        prefill.unset('id');
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                model: prefill,
                copiedFromModelId: this.model.get('id')
            }
        }, function(context, newModel) {
            if (newModel && newModel.id) {
                app.router.navigate(self.model.module + '/' + newModel.id, {trigger: true});
            }
        });

        prefill.trigger('duplicate:field', self.model);
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.pmse_Project.PreviewView
 * @alias SUGAR.App.view.views.Basepmse_ProjectPreviewView
 * @extends View.Views.Base.RecordView
 */
({
	// Preview View (base) 

    extendsFrom: 'PreviewView',

    events: {
        'click .minify': 'toggleMinify'
    },

    toggleMinify: function (evt) {
        var $el = this.$('.dashlet-toggle > i'),
            collapsed = $el.is('.icon-chevron-up');
        if (collapsed) {
            $('.dashlet-toggle > i').removeClass('icon-chevron-up');
            $('.dashlet-toggle > i').addClass('icon-chevron-down');
        } else {
            $('.dashlet-toggle > i').removeClass('icon-chevron-down');
            $('.dashlet-toggle > i').addClass('icon-chevron-up');
        }
        $('.dashlet').toggleClass('collapsed');
        $('.dashlet-content').toggleClass('hide');
    },

    /**
     * @override Overriding so we can set this.image_preview_url for the
     * Process Definition image
     */
    _render: function() {
        if (this.model) {
            var pmseInboxUrl = app.api.buildFileURL({
                module: 'pmse_Project',
                id: this.model.get('id'),
                field: 'id'
            }, {cleanCache: true});
            this.image_preview_url = pmseInboxUrl;
        }

        this._super('_render');
    }
}) },
"dependency-picker": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.pmse_Project.DependencyPickerView
 * @alias SUGAR.App.view.views.Basepmse_ProjectDependencyPickerView
 * @extends View.View
 */
({
	// Dependency-picker View (base) 

    /**
     * The dependency collections map
     */
    collections: {},

    /**
     * The dependency models map
     */
    models: {},

    /**
     * Indicates if there are any dependencies
     */
    hasDependencies: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        this.context.on('updateData', this.processData, this);
        this.brCollection = app.data.createBeanCollection('br');
        this.etCollection = app.data.createBeanCollection('et');
        this.massCollection = app.data.createBeanCollection('pmse_elements');

        this.brModel = app.data.createBean('br', {elementType: 'business_rule'});
        this.etModel = app.data.createBean('et', {elementType: 'email_template'});

        this._setUpCollectionMap();
        this._setUpModelMap();

        this.context.set('mass_collection', this.massCollection);
        this._bindMassCollectionEvents();

        this.leftColumns = [{
            type: 'fieldset',
            fields: [
                {
                    name: 'actionmenu',
                    type: 'actionmenu',
                    buttons: [],
                    disable_select_all_alert: true
                }
            ],
            value: false,
            sortable: false
        }];
    },

    /**
     * Save collection to object for easy accessing
     * @private
     */
    _setUpCollectionMap: function() {
        this.collections.business_rule = this.brCollection;
        this.collections.email_template  = this.etCollection;
        this.collections.mass_collection = this.massCollection;
    },

    /**
     * Save models to object for easy accessing
     * @private
     */
    _setUpModelMap: function() {
        this.models.business_rules = this.brModel;
        this.models.email_template = this.etModel;
    },

    /**
     * Add dependencies to their respective collections and render
     * @param data
     */
    processData: function(data) {
        this._resetCollections();

        this.hasDependencies = false;

        // No dependencies so don't do anything
        if (!data || !data.dependencies) {
            this.render();
            return;
        }

        _.each(data.dependencies, function(defs, type) {
            var collection = this._getCollectionForType(type);
            // add dependency only when there's a definition
            if (collection && !_.isEmpty(defs)) {
                collection.add(defs);
                this.hasDependencies = true;
            }
        }, this);

        this._cleanFieldsForView();

        this.render();
    },

    /**
     * Set up the mass collection's events
     * @private
     */
    _bindMassCollectionEvents: function() {
        this.context.on('mass_collection:add', _.bind(this._updateModels, this, true));
        this.context.on('mass_collection:add:all', _.bind(this._updateAllModels, this, true));
        this.context.on('mass_collection:remove', _.bind(this._updateModels, this, false));
        this.context.on('mass_collection:remove:all', _.bind(this._updateAllModels, this, false));
    },

    /**
     * Add or remove a model or models in the mass collection. If all checkboxes are in a group are checked,
     * toggle the select all checkbox to checked. When removing a model, uncheck the select all checkbox
     *
     * @param {boolean} `true` to add model, `false` to remove
     * @param {Data.Bean|Data.Bean[]} models The model or the list of models to add/remove.
     * @private
     */
    _updateModels: function(addModel, models) {
        models = _.isArray(models) ? models : [models];
        var type = _.first(models).elementType;
        if (addModel) {
            this.massCollection.add(models);
            if (this._isAllChecked(type)) {
                this._toggleAllCheckbox(type, true);
            }
        } else {
            this.massCollection.remove(models);
            this._toggleAllCheckbox(type, false);
        }
    },

    /**
     * Add or remove all models for the collection group to the mass collection
     *
     * @param {boolean} `true` to add all models, `false` to remove all
     * @param {Data.Bean} checkbox Model containing elementType to indicate which
     *  check-all box was checked
     * @private
     */
    _updateAllModels: function(addModels, checkbox) {
        var type = checkbox.get('elementType');
        var models = this._getCollectionForType(type).models;
        this._updateModels(addModels, models);
    },

    /**
     * Checks if all elements in the collection are in the mass collection
     *
     * @param {string} type The element type
     * @return {boolean} `true` if all elements are in the mass collection
     * @private
     */
    _isAllChecked: function(type) {
        var collection = this._getCollectionForType(type);
        if (this.massCollection.length < collection.length) {
            return false;
        }
        var allChecked = _.every(collection.models, function(model) {
            return this.massCollection.get(model.id);
        }, this);

        return allChecked;
    },

    /**
     * Check/Uncheck the check-all checkbox
     * @param {string} type The element type
     * @param {boolean} check `true` to mark checked
     * @private
     */
    _toggleAllCheckbox: function(type, check) {
        var checkboxField = this.getField('actionmenu', this._getModelForType(type));
        checkboxField.$(checkboxField.fieldTag).prop('checked', check);
    },

    /**
     * Get the collection for type
     * @param {string} type The element type
     * @return {Data.BeanCollection|null} The collection asked for
     * @private
     */
    _getCollectionForType: function(type) {
        return this.collections[type] || null;
    },

    /**
     * Get the model for type
     * @param {string} type The element type
     * @return {Data.Bean|null} The model asked for
     * @private
     */
    _getModelForType: function(type) {
        return this.models[type] || null;
    },

    /**
     * Set up fields for the model so we render correctly
     * @private
     */
    _cleanFieldsForView: function() {
        _.each(this.collections, function(collection, type) {
            _.each(collection.models, function(model) {
                model.fields = this.meta.fields;
                model.elementType = type;
            }, this);
        }, this);
    },

    /**
     * Remove all the models from the collections
     * @param {Data.BeanCollection[]} collections
     * @private
     */
    _resetCollections: function(collections) {
        collections = collections || this.collections;
        _.each(collections, function(collection) {
            collection.reset();
        });
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.pmse_Project.CreateView
 * @alias SUGAR.App.view.views.pmse_ProjectCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    saveOpenDesignName: 'save_open_design',

    SAVEACTIONS: {
        SAVE_OPEN_DESIGN: 'saveOpenDesign'
    },

    initialize: function(options) {
        options.meta = _.extend({}, app.metadata.getView(null, 'create'), options.meta);
        this._super('initialize', [options]);
        this.context.on('button:' + this.saveOpenDesignName + ':click', this.saveOpenDesign, this);
    },

    save: function () {
        switch (this.context.lastSaveAction) {
            case this.SAVEACTIONS.SAVE_OPEN_DESIGN:
                this.saveOpenDesign();
                break;
            default:
                this.saveAndClose();
        }
    },

    saveOpenDesign: function() {
        this.context.lastSaveAction = this.SAVEACTIONS.SAVE_OPEN_DESIGN;
        this.initiateSave(_.bind(function () {
            app.navigate(this.context, this.model, 'layout/designer');
        }, this));
    }
}) },
"designer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Designer View (base) 

    className: 'designer',

    events: {
        'click .btn-close-designer': 'closeDesigner'
    },

    closeDesigner: function() {
        var route = app.router.buildRoute(this.module, this.prj_uid);
        app.router.navigate(route, {trigger: true});
    },

    loadData: function (options) {
        this.prj_uid = this.options.context.attributes.modelId;
        this.cacheKiller = (new Date()).getTime();
    },

    initialize: function (options) {
        this._super('initialize', [options]);
        app.routing.before('route', this.beforeRouteChange, this);
    },

    render: function () {
        app.view.View.prototype.render.call(this);
        renderProject(this.prj_uid);
    },

    beforeRouteChange: function(params) {
        var self = this,
            resp = false;
        if (project.isDirty){
            project.showWarning = true;
            var targetUrl = Backbone.history.getFragment();
            //Replace the url hash back to the current staying page
            app.router.navigate(targetUrl, {trigger: false, replace: true});
            app.alert.show('leave_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_WARN_UNSAVED_CHANGES', this.module),
                onConfirm: function () {
                    var targetUrl = Backbone.history.getFragment();
                    project.dispose();
                    app.router.navigate(targetUrl , {trigger: true, replace: true });
                    window.location.reload();
                },
                onCancel: function () {
                    app.router.navigate('' , {trigger: false, replace: false })
                }
            });
            return false;
        }
        project.dispose();
        return true;
    },

    _dispose: function () {
        app.routing.offBefore('route', this.beforeRouteChange);
        this._super("_dispose", arguments);
    }
}) },
"project-import-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Project-import-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',
    events:{
        'click [name=project_finish_button]': 'initiateFinish',
        'click [name=project_cancel_button]': 'initiateCancel'
    },

    initiateFinish: function() {
        var that = this;
        if (app.cache.get("show_project_import_warning")) {
            app.alert.show('project-import-confirmation',  {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') + "<br/><br/>"
                    + app.lang.get('LBL_PMSE_IMPORT_CONFIRMATION'),
                onConfirm: function () {
                    app.cache.set("show_project_import_warning", false);
                    that.context.trigger('project:import:finish');
                },
                onCancel: function () {
                    app.router.goBack();
                }
            });
        } else {
            that.context.trigger('project:import:finish');
        }
    },

    initiateCancel : function() {
        app.router.navigate(app.router.buildRoute(this.module), {trigger: true});
    }
}) },
"project-import": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Project-import View (base) 

    events: {
        'change input[name=project_import]': 'readFile',
    },

    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.context.off("project:import:finish", null, this);
        this.context.on("project:import:finish", this.importProject, this);
    },

    /**
     * Gets the file and parses its data
     */
    readFile: function() {
        var file = $('[name=project_import]')[0].files.item(0);
        if (!file) {
            this.context.trigger('updateData');
            return;
        }
        var callback = _.bind(function(text) {
            var json = {};
            try {
                json = JSON.parse(text);
            } catch (error) {
            }
            this.context.trigger('updateData', json);
        }, this);

        this.fileToText(file, callback);
    },

    /**
     * Use FileReader to read the file
     *
     * @param file
     * @param callback
     */
    fileToText: function(file, callback) {
        var reader = new FileReader();
        reader.readAsText(file);
        reader.onload = function() {
            callback(reader.result);
        };
    },
    /**
     * @inheritdoc
     *
     * Sets up the file field to edit mode
     *
     * @param {View.Field} field
     * @private
     */
    _renderField: function(field) {
        app.view.View.prototype._renderField.call(this, field);
        if (field.name === 'project_import') {
            field.setMode('edit');
        }
    },

    /**
     * Import the Process Definition File (.bpm)
     */
    importProject: function() {
        var self = this,
            projectFile = $('[name=project_import]');

        // Check if a file was chosen
        if (_.isEmpty(projectFile.val())) {
            app.alert.show('error_validation_process', {
                level:'error',
                messages: app.lang.get('LBL_PMSE_PROCESS_DEFINITION_EMPTY_WARNING', self.module),
                autoClose: false
            });
        } else {
            app.alert.show('upload', {level: 'process', title: 'LBL_UPLOADING', autoclose: false});
            var callbacks = {
                    success: function (data) {
                        // Success callback is called no matter due to some funky code with the
                        // jquery-iframe-transport plugin. So we manually call the error callback instead
                        if (data.error) {
                            callbacks.error(data);
                            return;
                        }
                        app.alert.dismiss('upload');
                        var route = app.router.buildRoute(self.module, data.project_import.id);
                        route = route + '/layout/designer?imported=true';
                        app.router.navigate(route, {trigger: true});
                        app.alert.show('process-import-saved', {
                            level: 'success',
                            messages: app.lang.get('LBL_PMSE_PROCESS_DEFINITION_IMPORT_SUCCESS', self.module),
                            autoClose: true
                        });
                        // Shows warning message if PD contains BR
                        if (data.project_import.br_warning) {
                            app.alert.show('process-import-save-with-br', {
                                level: 'warning',
                                messages: app.lang.get('LBL_PMSE_PROCESS_DEFINITION_IMPORT_BR', self.module),
                                autoClose: false
                            });
                        }
                    },
                    error: function (error) {
                        app.alert.dismiss('upload');
                        app.alert.show('process-import-saved', {
                            level: 'error',
                            messages: error.error_message,
                            autoClose: false
                        });
                    }
                };

            var ids = this._getSelectedIds();
            var attributes = {
                id: undefined,
                module: this.model.module,
                field: 'project_import'
            };
            var params = {
                format: 'sugar-html-json',
            };
            var ajaxParams = {
                files: projectFile,
                processData: false,
                iframe: true,
            };
            var body = {
                selectedIds: JSON.stringify(ids)
            };

            var url = app.api.buildURL(this.model.module, 'file', attributes, params);
            app.api.call('create', url, body, callbacks, ajaxParams);
        }
    },

    /**
     * Get IDs for models selected in mass collection
     * @return {Array} An array of IDs
     * @private
     */
    _getSelectedIds: function() {
        var collection = this.context.get('mass_collection');
        return collection ? _.pluck(collection.models, 'id') : [];
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"pmse_Business_Rules":{"fieldTemplates": {
"base": {
"hidden": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Hidden FieldTemplate (base) 

    _render: function () {
        if (this.name === 'rst_source_definition') {
            this.view.$('[data-name=rst_source_definition].record-cell').addClass('hide');
        }
        this._super("_render", arguments);
    }
}) }
}}
,
"views": {
"base": {
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Recordlist View (base) 

    extendsFrom: 'RecordlistView',

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        this.contextEvents = _.extend({}, this.contextEvents, {
            "list:editbusinessrules:fire": "openBusinessRules",
            "list:exportbusinessrules:fire": "warnExportBusinessRules",
            "list:edit_businessrules:fire": "warnEditBusinessRules",
            "list:deletebusinessrules:fire": "warnDeleteBusinessRules"
        });
        this._super('initialize', [options]);
    },

    openBusinessRules: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module}),
            self = this;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    app.navigate(this.context, model, 'layout/businessrules');
                } else {
                    app.alert.show('business-rule-design-confirmation',  {
                        level: 'confirmation',
                        messages: App.lang.get('LBL_PMSE_PROCESS_BUSINESS_RULES_EDIT', model.module),
                        onConfirm: function () {
                            app.navigate(this.context, model, 'layout/businessrules');
                        },
                        onCancel: $.noop
                    });
                }
            }
        });
    },

    warnEditBusinessRules: function(model){
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module}),
            self = this;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    self.toggleRow(model.id, true);
                    self.resize();
                } else {
                    app.alert.show('business-rule-design-confirmation',  {
                        level: 'confirmation',
                        messages: App.lang.get('LBL_PMSE_PROCESS_BUSINESS_RULES_EDIT', model.module),
                        onConfirm: function () {
                            self.toggleRow(model.id, true);
                            self.resize();
                        },
                        onCancel: $.noop
                    });
                }
            }
        });
    },

    warnDeleteBusinessRules: function (model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module}),
            self = this;
        this._modelToDelete = model;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    self._targetUrl = Backbone.history.getFragment();
                    //Replace the url hash back to the current staying page
                    if (self._targetUrl !== self._currentUrl) {
                        app.router.navigate(self._currentUrl, {trigger: false, replace: true});
                    }

                    app.alert.show('delete_confirmation', {
                        level: 'confirmation',
                        messages: self.getDeleteMessages(model).confirmation,
                        onConfirm: function () {
                            self.deleteModel();
                        },
                        onCancel: function () {
                            self._modelToDelete = null;
                        }
                    });
                } else {
                    app.alert.show('message-id', {
                        level: 'warning',
                        title: app.lang.get('LBL_WARNING'),
                        messages: app.lang.get('LBL_PMSE_PROCESS_BUSINESS_RULES_DELETE', model.module),
                        autoClose: false
                    });
                    self._modelToDelete = null;
                }
            }
        });
    },

    warnExportBusinessRules: function (model) {
        var that = this;
        if (app.cache.get("show_br_export_warning")) {
            app.alert.show('show-br-export-confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') + "<br/><br/>"
                    + app.lang.get('LBL_PMSE_EXPORT_CONFIRMATION'),
                onConfirm: function() {
                    app.cache.set("show_br_export_warning", false);
                    that.exportBusinessRules(model);
                },
                onCancel: $.noop
            });
        } else {
            that.exportBusinessRules(model);
        }
    },

    exportBusinessRules: function(model) {
        var url = app.api.buildURL(model.module, 'brules', {id: model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the Project download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    }
}) },
"businessrules": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Businessrules View (base) 

    className: 'businessrules',

    /**
     * @inheritdoc
     */
    loadData: function (options) {
        this.br_uid = this.options.context.attributes.modelId;
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.context.off("businessRules:save:finish", null, this);
        this.context.on("businessRules:save:finish", this.saveBusinessRules, this);

        this.context.off("businessRules:save:save", null, this);
        this.context.on("businessRules:save:save", this.saveOnlyBusinessRules, this);

        this.context.off("businessRules:cancel:button", null, this);
        this.context.on("businessRules:cancel:button", this.cancelBusinessRules, this);

        this.myDefaultLayout = this.closestComponent('sidebar');
        app.routing.before('route', _.bind(this.beforeRouteChange, this), this, true);
        this._currentUrl = Backbone.history.getFragment();

        this._decisionTable = null;
        this._brName = null;
        this._brModule = null;
    },

    /**
     * Updates the Business Rules decision table header text.
     * @param name
     * @param module
     * @private
     */
    _updateBRHeader: function (name, module) {
        this.$('.brTitle').text(name);
        var brModule = app.lang.get('LBL_RST_MODULE', this.module) + ': ' + module;
        this.$('.brModule').text(brModule);
    },

    /**
     * Creates the Business Rules decision table
     * @param data
     * @private
     */
    _addDecisionTable: function (data) {
        var module = 'pmse_Business_Rules';
        var pmseCurrencies = [];
        var currencies = App.metadata.getCurrencies();
        var that = this;

        for (currID in currencies) {
            if (currencies.hasOwnProperty(currID)) {
                if (currencies[currID].status === 'Active') {
                    pmseCurrencies.push({
                        id: currID,
                        iso: currencies[currID].iso4217,
                        name: currencies[currID].name,
                        rate: parseFloat(currencies[currID].conversion_rate),
                        preferred: currID === App.user.getCurrency().currency_id,
                        symbol: currencies[currID].symbol
                    });
                }
            }
        }

        $.extend(true, data, {
            dateFormat: App.date.getUserDateFormat(),
            timeFormat: App.user.getPreference("timepref"),
            currencies: pmseCurrencies
        });

        this._decisionTable = new DecisionTable(data);

        if (!this._decisionTable.correctlyBuilt) {
            this.$('#save').hide();
        }

        this._decisionTable.onDirty = function (state) {
            if (state) {
                updateName = that._brName + " *";
            } else {
                updateName = that._brName;
            }
            that.$(".brTitle").text(updateName);
        };

        this._decisionTable.onAddColumn =
            this._decisionTable.onAddRow = this._decisionTable.onRemoveColumn = this._decisionTable.onRemoveRow;

        this.$('#businessruledesigner').prepend(this._decisionTable.getHTML());
    },

    /**
     * Initialize the Business Rules decision table.
     * @param params
     * @private
     */
    _initDecisionTable: function (params) {
        var data;

        this._brName = params.data.name;
        this._brModule = App.lang.getModuleName(params.data.rst_module, {plural: true});

        //errorLog = $('#error-log');

        if (params.data && params.data.rst_source_definition) {
            data = JSON.parse(params.data.rst_source_definition);
        } else {
            data = {
                "saveedit":"1",
                "btnSubmitEdit":"Save and Edit",
                "id":params.data.id,
                "name":params.data.name,
                "base_module":params.data.rst_module,
                "type":"single",
                "columns":{
                    "conditions":[],
                    "conclusions":[]
                },
                "ruleset":[
                    {
                        "conditions":[],
                        "conclusions":[]
                    }
                ]
            }
        }
        this._updateBRHeader(this._brName, this._brModule);
        this._addDecisionTable(data);
        this._decisionTable.setIsDirty(false);
    },

    /**
     * @inheritdoc
     */
    render: function () {
        var that = this;
        app.view.View.prototype.render.call(this);

        var params = {
            br_uid: this.br_uid
        };
        App.api.call("read", App.api.buildURL("pmse_Business_Rules", null, {id: this.br_uid }), {}, {
            success: function (response) {
                params.data = response;
                that._initDecisionTable(params);
            }
        });
    },

    /**
     * Saves the Buiness Rules decision table data.
     * @param route
     * @param id
     */
    _saveBR: function (id, route) {
        var json,
            base64encoded,
            url,
            validation = this._decisionTable.isValid(),
            that = this;

        if (this._decisionTable && validation.valid) {
            json = this._decisionTable.getJSON();
            base64encoded = JSON.stringify(json);
            url = App.api.buildURL('pmse_Business_Rules', null, {id: id});
            attributes = {rst_source_definition: base64encoded};

            App.alert.show('upload', {level: 'process', title: 'LBL_SAVING', autoclose: false});

            App.api.call('update', url, attributes, {
                success: function (data) {
                    App.alert.dismiss('upload');
                    App.alert.show('save-success', {
                        level: 'success',
                        messages: App.lang.get('LBL_SAVED'),
                        autoClose: true
                    });
                    if (route) {
                        that._decisionTable.setIsDirty(false, true);
                        App.router.navigate(route, {trigger: true});
                    } else {
                        that._decisionTable.setIsDirty(false);
                    }
                },
                error: function (err) {
                    App.alert.dismiss('upload');
                }
            });
        } else {
            App.alert.show('br-save-error', {
                level: 'error',
                messages: validation.location + ": " + validation.message,
                autoClose: true
            });
        }
    },

    /**
     * Handler for the 'businessRules:save:finish' event.
     */
    saveBusinessRules: function() {
        this._saveBR(this.model.id, App.router.buildRoute("pmse_Business_Rules"));
    },

    /**
     * Handler for the 'businessRules:save:save'
     */
    saveOnlyBusinessRules: function() {
        this._saveBR(this.model.id);
    },

    /**
     * Handler for the 'businessRules:cancel:button' event.
     */
    cancelBusinessRules: function () {
        app.router.navigate('pmse_Business_Rules', {trigger: true});
    },

    /**
     * @inheritdoc
     * @returns {boolean}
     */
    beforeRouteChange: function () {
        var targetUrl = Backbone.history.getFragment(), that = this;
        if (this._decisionTable.getIsDirty()) {
            //Replace the url hash back to the current staying page
            app.router.navigate(this._currentUrl, {trigger: false, replace: true});
            app.alert.show('leave_confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_WARN_UNSAVED_CHANGES', this.module),
                onConfirm: function () {
                    that._decisionTable.setIsDirty(false, true);
                    app.router.navigate(targetUrl , {trigger: true, replace: true });
                },
                onCancel: $.noop
            });
            return false;
        }
        return true;
    },

    /**
     * @inheritdoc
     */
    _dispose: function () {
        this._super('_dispose', arguments);
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    initialize: function (options) {
        this._super('initialize', [options]);
        this.context.on('button:design_businessrules:click', this.designBusinessRules, this);
        this.context.on('button:export_businessrules:click', this.warnExportBusinessRules, this);
        this.context.on('button:delete_businessrules:click', this.warnDeleteBusinessRules, this);
        this.context.on('button:edit_businessrules:click', this.warnEditBusinessRules, this);
    },

    warnEditBusinessRules: function(model){
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module}),
            self = this;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    self.editClicked();
                } else {
                    app.alert.show('business-rule-design-confirmation',  {
                        level: 'confirmation',
                        messages: App.lang.get('LBL_PMSE_PROCESS_BUSINESS_RULES_EDIT', model.module),
                        onConfirm: function () {
                            self.editClicked();
                        },
                        onCancel: $.noop
                    });
                }
            }
        });
    },

    warnDeleteBusinessRules: function (model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module}),
            self = this;
        this._modelToDelete = model;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    app.alert.show('delete_confirmation', {
                        level: 'confirmation',
                        messages: self.getDeleteMessages(model).confirmation,
                        onConfirm: function () {
                            self.deleteModel();
                        },
                        onCancel: function () {
                            self._modelToDelete = null;
                        }
                    });
                } else {
                    app.alert.show('message-id', {
                        level: 'warning',
                        title: app.lang.get('LBL_WARNING'),
                        messages: app.lang.get('LBL_PMSE_PROCESS_BUSINESS_RULES_DELETE', model.module),
                        autoClose: false
                    });
                    self._modelToDelete = null;
                }
            }
        });
    },

    handleEdit: function(e, cell) {
        this.warnEditBusinessRules(this.model);
    },

    designBusinessRules: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module}),
            self = this;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    app.navigate(this.context, model, 'layout/businessrules');
                } else {
                    app.alert.show('business-rule-design-confirmation',  {
                        level: 'confirmation',
                        messages: App.lang.get('LBL_PMSE_PROCESS_BUSINESS_RULES_EDIT', model.module),
                        onConfirm: function () {
                            app.navigate(this.context, model, 'layout/businessrules');
                        },
                        onCancel: $.noop
                    });
                }
            }
        });
    },

    warnExportBusinessRules: function (model) {
        var that = this;
        if (app.cache.get("show_br_export_warning")) {
            app.alert.show('show-br-export-confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') + "<br/><br/>"
                + app.lang.get('LBL_PMSE_EXPORT_CONFIRMATION'),
                onConfirm: function() {
                    app.cache.set("show_br_export_warning", false);
                    that.exportBusinessRules(model);
                },
                onCancel: $.noop
            });
        } else {
            that.exportBusinessRules(model);
        }
    },

    exportBusinessRules: function(model) {
        var url = app.api.buildURL(model.module, 'brules', {id: model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the Project download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },

    duplicateClicked: function() {
        var self = this,
            prefill = app.data.createBean(this.model.module);

        prefill.copy(this.model);
        this._copyNestedCollections(this.model, prefill);
        prefill.fields.rst_module.readonly = true;
        self.model.trigger('duplicate:before', prefill);
        prefill.unset('id');
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                model: prefill,
                copiedFromModelId: this.model.get('id')
            }
        }, function(context, newModel) {
            if (newModel && newModel.id) {
                app.router.navigate(self.model.module + '/' + newModel.id, {trigger: true});
            }
        });

        prefill.trigger('duplicate:field', self.model);
    }
}) },
"dashlet-businessrules": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dashlet-businessrules View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        limit: 10,
        visibility: 'user'
    },

    thresholdRelativeTime: 2, //Show relative time for 2 days and then date time after

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('dashlet-businessrules:businessRulesLayout:fire', this.businessRulesLayout, this);
        this.on('dashlet-businessrules:delete-record:fire', this.deleteRecord, this);
        this.on('dashlet-businessrules:download:fire', this.warnExportBusinessRules, this);
        this.on('dashlet-businessrules:description-record:fire', this.descriptionRecord, this);
        this.on('linked-model:create', this.loadData, this);
        return this;
    },

    /**
     * Re-fetches the data for the context's collection.
     *
     * FIXME: This will be removed when SC-4775 is implemented.
     *
     * @private
     */
    _reloadData: function() {
        this.context.set('skipFetch', false);
        this.context.reloadData();
    },

    /**
     * Fire dessigner
     */
    businessRulesLayout: function (model) {
        var redirect = model.module+"/"+model.id+"/layout/businessrules";
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module}),
            self = this;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    app.router.navigate(redirect , {trigger: true, replace: true });
                } else {
                    app.alert.show('business-rule-design-confirmation',  {
                        level: 'confirmation',
                        messages: App.lang.get('LBL_PMSE_PROCESS_BUSINESS_RULES_EDIT', model.module),
                        onConfirm: function () {
                            app.router.navigate(redirect , {trigger: true, replace: true });
                        },
                        onCancel: $.noop
                    });
                }
            }
        });
    },

    /**
     * @inheritdoc
     *
     * FIXME: This should be removed when metadata supports date operators to
     * allow one to define relative dates for date filters.
     */
    _initTabs: function() {
        this._super('_initTabs');

        // FIXME: since there's no way to do this metadata driven (at the
        // moment) and for the sake of simplicity only filters with 'date_due'
        // value 'today' are replaced by today's date
        var today = new Date();
        today.setHours(23, 59, 59);
        today.toISOString();

        _.each(_.pluck(_.pluck(this.tabs, 'filters'), 'date_due'), function(filter) {
            _.each(filter, function(value, operator) {
                if (value === 'today') {
                    filter[operator] = today;
                }
            });
        });
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    createRecord: function(event, params) {
        if (this.module !== 'pmse_Business_Rules') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            var self = this;
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, function(context, model) {
                if (!model) {
                    return;
                }
                self.context.resetLoadFlag();
                self.context.set('skipFetch', false);
                if (_.isFunction(self.loadData)) {
                    self.loadData();
                } else {
                    self.context.loadData();
                }
            });
        }

    },
    importRecord: function(event, params) {
        App.router.navigate(params.link , {trigger: true, replace: true });
    },

    /**
     * Delete record.
     *
     * @param {Event} event Click event.
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    deleteRecord: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module}),
            self = this;
        this._modelToDelete = model;
        app.api.call('read', verifyURL, null, {
            success: function(data) {
                if (!data) {
                    app.alert.show('delete_confirmation', {
                        level: 'confirmation',
                        messages: app.utils.formatString(app.lang.get('LBL_PRO_DELETE_CONFIRMATION', model.module)),
                        onConfirm: function () {
                            model.destroy({
                                showAlerts: true,
                                success: self._getRemoveRecord()
                            });
                        },
                        onCancel: function () {
                            self._modelToDelete = null;
                        }
                    });
                } else {
                    app.alert.show('message-id', {
                        level: 'warning',
                        title: app.lang.get('LBL_WARNING'),
                        messages: app.lang.get('LBL_PMSE_PROCESS_BUSINESS_RULES_DELETE', model.module),
                        autoClose: false
                    });
                    self._modelToDelete = null;
                }
            }
        });
    },

    /**
     * Updating in fields delete removed
     * @return {Function} complete callback
     * @private
     */
    _getRemoveRecord: function() {
        return _.bind(function(model){
            if (this.disposed) {
                return;
            }
            this.collection.remove(model);
            this.render();
            this.context.trigger("tabbed-dashlet:refresh", model.module);
        }, this);
    },

    /**
     * Method view alert in process with text modify
     * show and hide alert
     */
    _refresh: function(model, status) {
        app.alert.show(model.id + ':refresh', {
            level:"process",
            title: status,
            autoclose: false
        });
        return _.bind(function(model){
            var options = {};
            this.layout.reloadDashlet(options);
            app.alert.dismiss(model.id + ':refresh');
        }, this);
    },

    /**
     * Disable record.
     *
     * @param {Event} event Click event.
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    disableRecord: function(model) {
        var self = this;
        this._modelToDelete = true;
        var name = model.get('name') || '';
        app.alert.show(model.get('id') + ':deleted', {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('LBL_PRO_DISABLE_CONFIRMATION', model.module),[name.trim()]),
            onConfirm: function() {
                self._updateProStatusDisabled(model);
            }
        });
    },

    /**
     * Update record in table pmse_Project in fields prj_status by INACTIVE
     */
    _updateProStatusDisabled: function(model) {
        var self = this;
        url = App.api.buildURL(model.module, null, {id: model.id});
        attributes = {prj_status: 'INACTIVE'};
        App.api.call('update', url, attributes, {
            success: self._refresh(model, app.lang.get('LBL_PRO_DISABLE', model.module)),
            error: function (err) {
//                app.error.handleHttpError(err); if (callback) callback(err);
//                self.isWaitingResponse = false;
//                self.mergeDirtyElements();
//                self.isDirty = false;
            }
        });
    },

    /**
     * Enable record.
     *
     * @param {Event} event Click event.
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    enableRecord: function(model) {
        var self = this;
        this._modelToDelete = true;
        var name = model.get('name') || '';
        app.alert.show(model.get('id') + ':deleted', {
            level: 'confirmation',
            messages: app.utils.formatString(app.lang.get('LBL_PRO_ENABLE_CONFIRMATION', model.module),[name.trim()]),
            onConfirm: function() {
                self._updateProStatusEnabled(model);
            }
        });
    },

    /**
     * Update record in table pmse_Project in fields prj_status by ACTIVE
     */
    _updateProStatusEnabled: function(model) {
        var self = this;
        url = App.api.buildURL(model.module, null, {id: model.id});
        attributes = {prj_status: 'ACTIVE'};
        App.api.call('update', url, attributes, {
            success: self._refresh(model,app.lang.get('LBL_PRO_ENABLE', model.module)),
            error: function (err) {
//                app.error.handleHttpError(err); if (callback) callback(err);
//                self.isWaitingResponse = false;
//                self.mergeDirtyElements();
//                self.isDirty = false;
            }
        });
    },

    /**
     * Show warning of pmse_bussiness_rules
     */
    warnExportBusinessRules: function (model) {
        var that = this;
        if (app.cache.get("show_br_export_warning")) {
            app.alert.show('show-br-export-confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') + "<br/><br/>"
                + app.lang.get('LBL_PMSE_EXPORT_CONFIRMATION'),
                onConfirm: function() {
                    app.cache.set("show_br_export_warning", false);
                    that.exportBusinessRules(model);
                },
                onCancel: $.noop
            });
        } else {
            that.exportBusinessRules(model);
        }
    },

    /**
     * Download record of table pmse_business_rules
     */
    exportBusinessRules: function (model) {
        var url = app.api.buildURL(model.module, 'brules', {id: model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the Business Rule download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: function(data) {
                // refresh token if it has expired
                app.error.handleHttpError(data, {});
            }
        }, {iframe: this.$el});
    },
    /**
     * descriptionRecord: View description in table pmse_Business Rules in fields
     */
    descriptionRecord: function(model) {
        app.alert.dismiss('message-id');
        app.alert.show('message-id', {
            level: 'info',
            title: app.lang.get('LBL_DESCRIPTION'),
            messages: '<br/>' + Handlebars.Utils.escapeExpression(model.get('description')),
            autoClose: false
        });
    },

    /**
     * Sets property useRelativeTime to show date created as a relative time or as date time.
     *
     * @private
     */
    _setRelativeTimeAvailable: function(date) {
        var diffInDays = app.date().diff(date, 'days', true);
        var useRelativeTime = (diffInDays <= this.thresholdRelativeTime);
        return useRelativeTime;
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     * - {String} picture_url Picture url for model's assigned user.
     * - {String} rst_module_name Name of the triggering module.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        if (tab.overdue_badge) {
            this.overdueBadge = tab.overdue_badge;
        }

        _.each(this.collection.models, function(model) {
            var pictureUrl = app.api.buildFileURL({
                module: 'Users',
                id: model.get('assigned_user_id'),
                field: 'picture'
            });
            model.set('picture_url', pictureUrl);
            model.useRelativeTime = this._setRelativeTimeAvailable(model.attributes.date_entered);
            // Update the triggering module names.
            var module = model.get('rst_module');
            var label = app.lang.getModString('LBL_MODULE_NAME', module);
            if (_.isUndefined(label)) {
                label = module;
            }
            model.set('rst_module_name', label);
        }, this);

        this._super('_renderHtml');
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.pmse_Business_Rules.CreateView
 * @alias SUGAR.App.view.views.pmse_Business_RulesCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    saveOpenBusinessRulesName: 'save_open_businessrules',

    SAVEACTIONS: {
        SAVE_OPEN_BUSINESRULES: 'saveOpenBusinessRules'
    },

    initialize: function(options) {
        options.meta = _.extend({}, app.metadata.getView(null, 'create'), options.meta);
        this._super('initialize', [options]);
        this.context.on('button:' + this.saveOpenBusinessRulesName + ':click', this.saveOpenBusinessRules, this);
    },

    save: function () {
        switch (this.context.lastSaveAction) {
            case this.SAVEACTIONS.SAVE_OPEN_BUSINESRULES:
                this.saveOpenBusinessRules();
                break;
            default:
                this.saveAndClose();
        }
    },

    saveOpenBusinessRules: function() {
        this.context.lastSaveAction = this.SAVEACTIONS.SAVE_OPEN_BUSINESRULES;
        this.initiateSave(_.bind(function () {
            app.navigate(this.context, this.model, 'layout/businessrules');
        }, this));
    }
}) },
"businessrules-import-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Businessrules-import-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',
    events:{
        'click [name=businessrules_finish_button]': 'initiateFinish',
        'click [name=businessrules_cancel_button]': 'initiateCancel'
    },

    initiateFinish: function() {
        this.context.trigger('businessrules:import:finish');
    },

    initiateCancel : function() {
        app.router.navigate(app.router.buildRoute(this.module), {trigger: true});
    }
}) },
"businessrules-import": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Businessrules-import View (base) 

    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.context.off("businessrules:import:finish", null, this);
        this.context.on("businessrules:import:finish", this.warnImportBusinessRules, this);
    },

    /**
     * @inheritdoc
     *
     * Sets up the file field to edit mode
     *
     * @param {View.Field} field
     * @private
     */
    _renderField: function(field) {
        app.view.View.prototype._renderField.call(this, field);
        if (field.name === 'businessrules_import') {
            field.setMode('edit');
        }
    },

    warnImportBusinessRules: function () {
        var that = this;
        if (app.cache.get('show_br_import_warning')) {
            app.alert.show('br-import-confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') + "<br/><br/>"
                    + app.lang.get('LBL_PMSE_IMPORT_CONFIRMATION'),
                onConfirm: function () {
                    app.cache.set('show_br_import_warning', false);
                    that.importBusinessRules();
                },
                onCancel: function () {
                    app.router.goBack();
                }
            });
        } else {
            this.importBusinessRules();
        }
    },

    /**
     * Import the Business Rules file (.pbr)
     */
    importBusinessRules: function() {
        var self = this,
            projectFile = $('[name=businessrules_import]');

        // Check if a file was chosen
        if (_.isEmpty(projectFile.val())) {
            app.alert.show('error_validation_businessrules', {
                level:'error',
                messages: app.lang.get('LBL_PMSE_BUSINESS_RULES_EMPTY_WARNING', self.module),
                autoClose: false
            });
        } else {
            app.alert.show('upload', {level: 'process', title: 'LBL_UPLOADING', autoclose: false});

            var callbacks = {
                success: function (data) {
                    app.alert.dismiss('upload');
                    app.router.goBack();
                    app.alert.show('process-import-saved', {
                        level: 'success',
                        messages: app.lang.get('LBL_PMSE_BUSINESS_RULES_IMPORT_SUCCESS', self.module),
                        autoClose: true
                    });
                },
                error: function (error) {
                    app.alert.dismiss('upload');
                    app.alert.show('process-import-saved', {
                        level: 'error',
                        messages: error.error_message,
                        autoClose: false
                    });
                }
            };

            this.model.uploadFile('businessrules_import', projectFile, callbacks, {deleteIfFails: true, htmlJsonFormat: true});
        }
    }
}) },
"businessrules-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Businessrules-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events:{
        'click [name=project_finish_button]': 'initiateFinish',
        'click [name=project_save_button]': 'initiateSave',
        'click [name=project_cancel_button]': 'initiateCancel'
    },

    initiateFinish: function() {
        this.context.trigger('businessRules:save:finish');
    },
    initiateSave: function() {
        this.context.trigger('businessRules:save:save');
    },
    initiateCancel : function() {
        this.context.trigger('businessRules:cancel:button');
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"pmse_Emails_Templates":{"fieldTemplates": {
"base": {
"readonly": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.pmse_Emails_Templates.ReadonlyField
 * @alias SUGAR.App.view.fields.Basepmse_Emails_TemplatesReadonlyField
 * @extends View.Fields.Base.BaseField
 */
({
	// Readonly FieldTemplate (base) 

    fieldTag: 'input.inherit-width',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.def.readonly = true;
        this._super('initialize', [options]);
    },
    
    _render: function() {
        if (this.view.name === 'record') {
            this.def.link = false;
        } else if (this.view.name === 'preview') {
            this.def.link = true;
        }
        this._super('_render');
    },

    /**
     * Gets the recipients DOM field
     *
     * @returns {Object} DOM Element
     */
    getFieldElement: function() {
        return this.$(this.fieldTag);
    },

    /**
     * @inheritdoc
     */
    format: function(value) {
        return app.lang.getModuleName(value, {plural: true})
    }
}) },
"from_address": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// From_address FieldTemplate (base) 

    'events': {
        'keyup input[name=name]': 'handleKeyup',
        "click .btn": "_showVarBook"
    },
    fieldTag: 'input.inherit-width',


    _render: function() {
        if (this.view.name === 'record') {
            this.def.link = false;
        } else if (this.view.name === 'preview') {
            this.def.link = true;
        }
        this._super('_render');
    },
    /**
     * Gets the recipients DOM field
     *
     * @returns {Object} DOM Element
     */
    getFieldElement: function() {
        return this.$(this.fieldTag);
    },

    /**
     * When in edit mode, the field includes an icon button for opening an address book. Clicking the button will
     * trigger an event to open the address book, which calls this method to do the dirty work. The selected recipients
     * are added to this field upon closing the address book.
     *
     * @private
     */
    _showVarBook: function() {
        /**
         * Callback to add recipients, from a closing drawer, to the target Recipients field.
         * @param {undefined|Backbone.Collection} recipients
         */
        var addEmails = _.bind(function(emails) {
            if (emails && emails.length > 0) {
                this.model.set(this.name, this.buildVariablesString(emails));
            }
        }, this);
        app.drawer.open(
            {
                layout:  "compose-addressbook",
                context: {
                    module: "Emails",
                    mixed:  true
                }
            },
            function(emails) {
                addEmails(emails);
            }
        );
    },
    buildVariablesString: function(recipients) {
        var result = '' , newExpression = '', i = 0;

        _.each(recipients.models, function(model) {
            newExpression += (i > 0) ? ', ': '';
            newExpression += model.attributes.email;
            i += 1;
        });

        result = newExpression;
        return result;
    },
    /**
     * Handles the keyup event in the account create page
     */
    handleKeyup: _.throttle(function() {
        var searchedValue = this.$('input.inherit-width').val();
        if (searchedValue && searchedValue.length >= 3) {
            this.context.trigger('input:name:keyup', searchedValue);
        }
    }, 1000, {leading: false})

}) },
"pmse_htmleditable_tinymce": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Pmse_htmleditable_tinymce FieldTemplate (base) 

    extendsFrom: 'Htmleditable_tinymceField',

    /**
     * @inheritdoc
     */
    addCustomButtons: function (editor) {
        editor.addButton('sugarfieldbutton', {
            title: app.lang.get('LBL_SUGAR_FIELD_SELECTOR', 'pmse_Emails_Templates'),
            class: 'mce_selectfield',
            icon: 'fullpage',

            onclick: _.bind(this._showVariablesBook, this)
        });
        editor.addButton('sugarlinkbutton', {
            title: app.lang.get('LBL_SUGAR_LINK_SELECTOR', 'pmse_Emails_Templates'),
            class: 'mce_selectfield',
            image: 'styleguide/assets/img/record-link.svg',
            onclick: _.bind(this._showLinksDrawer, this)
        });
    },

    /**
     * Save the TinyMCE editor's contents to the model
     * @private
     */
    _saveEditor: function(force){
        var save = force | this._isDirty;
        if(save){
            this.model.set(this.name, this.getEditorContent(), {silent: true});
            this._isDirty = false;
        }
    },

    /**
     * Finds textarea or iframe element in the field template
     *
     * @return {HTMLElement} element from field template
     * @private
     */
    _getHtmlEditableField: function() {
        return this.$el.find(this.fieldSelector);
    },

    /**
     * Sets TinyMCE editor content
     *
     * @param {String} value HTML content to place into HTML editor body
     */
    setEditorContent: function(value) {
        if(_.isEmpty(value)){
            value = "";
        }
        if (this._isEditView() && this._htmleditor && this._htmleditor.dom) {
            this._htmleditor.setContent(value);
        }
    },

    /**
     * Retrieves the  TinyMCE editor content
     *
     * @return {String} content from the editor
     */
    getEditorContent: function() {
        return this._htmleditor.getContent({format: 'raw'});
    },

    /**
     * Destroy TinyMCE Editor on dispose
     *
     * @private
     */
    _dispose: function() {
        this.destroyTinyMCEEditor();
        app.view.Field.prototype._dispose.call(this);
    },
    /**
     * When in edit mode, the field includes an icon button for opening an address book. Clicking the button will
     * trigger an event to open the address book, which calls this method to do the dirty work. The selected recipients
     * are added to this field upon closing the address book.
     *
     * @private
     */
    _showVariablesBook: function() {
        /**
         * Callback to add recipients, from a closing drawer, to the target Recipients field.
         * @param {undefined|Backbone.Collection} recipients
         */
        var addVariables = _.bind(function(variables) {
            if (variables && variables.length > 0) {
                this.model.set(this.name, this.buildVariablesString(variables));
            }

        }, this);
        app.drawer.open(
            {
                layout:  "compose-varbook",
                context: {
                    module: "pmse_Emails_Templates",
                    mixed:  true
                }
            },
            function(variables) {
                addVariables(variables);
            }
        );
    },
    /**
     * Adds placeholders fields the textbox content.
     *
     * @param {Object} recipients List of fields to create the placeholders.
     * @return {string} textbox content with the placeholders.
     */
    buildVariablesString: function(recipients) {
        var newExpression = this.buildPlaceholders(recipients);
        var bm = this._htmleditor.selection.getBookmark();
        this._htmleditor.selection.moveToBookmark(bm);
        this._htmleditor.selection.setContent(newExpression);

        return this._htmleditor.getContent();
    },

    /**
     * Creates the placeholders for Email Template Modules.
     *
     * @param {Object} recipients List of fields to create the placeholders.
     * @return {string} newExpression.
     */
    buildPlaceholders: function(recipients) {
        var newExpression = '';
        _.each(recipients, function(model) {
            newExpression += '{::' + model.get('rhs_module') + '::' + model.get('id');
            if (model.get('process_et_field_type') == 'old') {
                newExpression += '::' + model.get('process_et_field_type');
            }
            newExpression += '::}';
        });
        return newExpression;
    },

    /**
     * Open a drawer with a list of related fields that we want to link to in an email
     * Create a variable like {::href_link::Accounts::contacts::name::} which is understood
     * by the backend to replace the variable with the correct Sugar link
     *
     * @private
     */
    _showLinksDrawer: function() {
        var self = this;
        var baseModule = this.model.get('base_module');
        app.drawer.open({
                layout:  "compose-sugarlinks",
                context: {
                    module: "pmse_Emails_Templates",
                    mixed:  true,
                    skipFetch: true,
                    baseModule: baseModule
                }
            },
            function(field) {
                if (_.isUndefined(field)) {
                    return;
                }
                var link = '{::href_link::' + baseModule;

                //Target module doesn't need second part of variable
                //The second part is for related modules
                //Example {::href_link::Accounts::name::}} is for the target module Account's record
                //{{::href_link::Accounts::contacts::name::}} is for the related contacts's record
                if (baseModule !== field.get('value')) {
                    link += '::' + field.get('value');
                }
                link += '::name::}';
                self._htmleditor.selection.setContent(link);
                self.model.set(self.name, self._htmleditor.getContent())
            }
        );
    }

}) },
"subject": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Subject FieldTemplate (base) 

    events: {
        'keyup input[name=name]': 'handleKeyup',
        'click .btn': '_showVarBook'
    },

    fieldTag: 'input.inherit-width',

    _render: function() {
        if (this.view.name === 'record') {
            this.def.link = false;
        } else if (this.view.name === 'preview') {
            this.def.link = true;
        }
        this._super('_render');
    },
    /**
     * Gets the recipients DOM field
     *
     * @returns {Object} DOM Element
     */
    getFieldElement: function() {
        return this.$(this.fieldTag);
    },

    /**
     * When in edit mode, the field includes an icon button for opening an address book. Clicking the button will
     * trigger an event to open the address book, which calls this method to do the dirty work. The selected recipients
     * are added to this field upon closing the address book.
     *
     * @private
     */
    _showVarBook: function() {
        /**
         * Callback to add recipients, from a closing drawer, to the target Recipients field.
         * @param {undefined|Backbone.Collection} recipients
         */
        var addVariables = _.bind(function(variables) {
            if (variables && variables.length > 0) {
                this.model.set(this.name, this.buildVariablesString(variables));
            }
        }, this);
        app.drawer.open(
            {
                layout:  "compose-varbook",
                context: {
                    module: "pmse_Emails_Templates",
                    mixed:  true
                }
            },
            function(variables) {
                addVariables(variables);
            }
        );
    },

    /**
     * Adds placeholders fields to the subject field textbox.
     *
     * @param {Object} recipients List of fields to create the placeholders.
     * @return {string} textbox content with the placeholders.
     */
    buildVariablesString: function(recipients) {
        var currentValue;
        var newExpression = this.buildPlaceholders(recipients);

        var input = this.getFieldElement().get(0);
        currentValue = input.value;

        i = input.selectionStart;
        result = currentValue.substr(0, i) + newExpression + currentValue.substr(i);
        return result;
    },

    /**
     * Creates the placeholders for Email Template Modules.
     *
     * @param {Object} recipients List of fields to create the placeholders.
     * @return {string} newExpression.
     */
    buildPlaceholders: function(recipients) {
        var newExpression = '';
        _.each(recipients, function(model) {
            newExpression += '{::' + model.get('rhs_module') + '::' + model.get('id');
            if (model.get('process_et_field_type') == 'old') {
                newExpression += '::' + model.get('process_et_field_type');
            }
            newExpression += '::}';
        });
        return newExpression;
    },

    /**
     * Handles the keyup event in the account create page
     */
    handleKeyup: _.throttle(function() {
        var searchedValue = this.$('input.inherit-width').val();
        if (searchedValue && searchedValue.length >= 3) {
            this.context.trigger('input:name:keyup', searchedValue);
        }
    }, 1000, {leading: false})

}) }
}}
,
"views": {
"base": {
"compose-varbook-filter": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Compose-varbook-filter View (base) 

    /**
     * @class View.ComposeAddressbookFilterView
     * @alias SUGAR.App.view.views.ComposeAddressbookFilterView
     * @extends View
     */
    _moduleFilterList: [],
    _allModulesId:     'All',
    _selectedModule:   null,
    _currentSearch:    '',
    events: {
        'keyup .search-name':        'throttledSearch',
        'paste .search-name':        'throttledSearch',
        'click .add-on.fa-times':    'clearInput'
    },
    /**
     * Converts the input field to a select2 field and adds the module filter for refining the search.
     *
     * @private
     */
    _render: function() {
        app.view.View.prototype._render.call(this);
        this.buildModuleFilterList();
        this.buildFilter();
    },
    /**
     * Builds the list of allowed modules to provide the data to the select2 field.
     */
    buildModuleFilterList: function() {
        this._moduleFilterList = [
            {id: this._allModulesId, text: app.lang.get('Target Module')}
        ];

        url = app.api.buildURL('pmse_Emails_Templates',
            this.collection.baseModule +  '/find_modules',
            null,
            {module_list: this.collection.baseModule});
        app.api.call('read', url, null,
            {
                success: _.bind(this._onGetModuleFilterListSuccess, this)
            }
        );
    },
    /**
     * API success callback for buildModuleFilterList. Created to make unit testing possible.
     */
    _onGetModuleFilterListSuccess: function(result) {
        if (result.success && this.collection) {
            _.each(result.result, function(module) {
                if (module.value != this.collection.baseModule) {
                    this._moduleFilterList.push({id: module.value, text: module.text});
                }
            }, this);
        }
    },
    /**
     * Converts the input field to a select2 field and initializes the selected module.
     */
    buildFilter: function() {
        var $filter = this.getFilterField();
        if ($filter.length > 0) {
            $filter.select2({
                data:                    this._moduleFilterList,
                allowClear:              false,
                multiple:                false,
                minimumResultsForSearch: -1,
                formatSelection:         _.bind(this.formatModuleSelection, this),
                formatResult:            _.bind(this.formatModuleChoice, this),
                dropdownCss:             {width: 'auto'},
                dropdownCssClass:        'search-filter-dropdown',
                initSelection:           _.bind(this.initSelection, this),
                escapeMarkup:            function(m) { return m; },
                width:                   'off'
            });
            $filter.off('change');
            $filter.on('change', _.bind(this.handleModuleSelection, this));
            this._selectedModule = this._selectedModule || this._allModulesId;
            $filter.select2('val', this._selectedModule);
        }
    },
    /**
     * Gets the filter DOM field.
     *
     * @returns {Object} DOM Element
     */
    getFilterField: function() {
        return this.$('input.select2');
    },
    /**
     * Gets the module filter DOM field.
     *
     * @returns {Object} DOM Element
     */
    getModuleFilter: function() {
        return this.$('div.choice-filter');
    },
    /**
     * Destroy the select2 plugin.
     */
    unbind: function() {
        $filter = this.getFilterField();
        if ($filter.length > 0) {
            $filter.off();
            $filter.select2('destroy');
        }
        this._super('unbind');
    },
    /**
     * Performs a search once the user has entered a term.
     */
    throttledSearch: _.debounce(function(evt) {
        var newSearch = this.$(evt.currentTarget).val();
        if (this._currentSearch !== newSearch) {
            this._currentSearch = newSearch;
            this.applyFilter();
        }
    }, 400),
    /**
     * Initialize the module selection with the value for all modules.
     *
     * @param el
     * @param callback
     */
    initSelection: function(el, callback) {
        if (el.is(this.getFilterField())) {
            var module = _.findWhere(this._moduleFilterList, {id: el.val()});
            callback({id: module.id, text: module.text});
        }
    },
    /**
     * Format the selected module to display its name.
     *
     * @param {Object} item
     * @return {String}
     */
    formatModuleSelection: function(item) {
        // update the text for the selected module
        this.getModuleFilter().html(item.text);
        return '<span class="select2-choice-type">'
            + app.lang.get('LBL_MODULE')
            + '<i class="fa fa-caret-down"></i></span>';
    },
    /**
     * Format the choices in the module select box.
     *
     * @param {Object} option
     * @return {String}
     */
    formatModuleChoice: function(option) {
        return '<div><span class="select2-match"></span>' + option.text + '</div>';
    },
    /**
     * Handler for when the module filter dropdown value changes, either via a click or manually calling jQuery's
     * .trigger("change") event.
     *
     * @param {Object} evt jQuery Change Event Object
     * @param {string} overrideVal (optional) ID passed in when manually changing the filter dropdown value
     */
    handleModuleSelection: function(evt, overrideVal) {
        var module = overrideVal || evt.val || this._selectedModule || this._allModulesId;
        // only perform a search if the module is in the approved list
        if (!_.isEmpty(_.findWhere(this._moduleFilterList, {id: module}))) {
            this._selectedModule = module;
            this.getFilterField().select2('val', this._selectedModule);
            this.getModuleFilter().css('cursor', 'pointer');
            this.applyFilter();
        }
    },
    /**
     * Triggers an event that makes a call to search the address book and filter the data set.
     */
    applyFilter: function() {
        var searchAllModules = (this._selectedModule === this._allModulesId),
            // pass an empty array when all modules are being searched
            module = searchAllModules ? [] : [this._selectedModule],
            // determine if the filter is dirty so the "clearQuickSearchIcon" can be added/removed appropriately
            isDirty = !_.isEmpty(this._currentSearch);
        this._toggleClearQuickSearchIcon(isDirty);
        this.context.trigger('compose:addressbook:search', module, this._currentSearch);
    },
    /**
     * Append or remove an icon to the quicksearch input so the user can clear the search easily.
     * @param {Boolean} addIt TRUE if you want to add it, FALSE to remove
     */
    _toggleClearQuickSearchIcon: function(addIt) {
        if (addIt && !this.$('.add-on.fa-times')[0]) {
            this.$('.filter-view.search').append('<i class="add-on fa fa-times"></i>');
        } else if (!addIt) {
            this.$('.add-on.fa-times').remove();
        }
    },
    /**
     * Clear input
     */
    clearInput: function() {
        var $filter          = this.getFilterField();
        this._currentSearch  = '';
        this._selectedModule = this._allModulesId;
        this.$('.search-name').val(this._currentSearch);
        if ($filter.length > 0) {
            $filter.select2('val', this._selectedModule);
        }
        this.applyFilter();
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.pmse_Emails_Templates.CreateView
 * @alias SUGAR.App.view.views.pmse_Emails_TemplatesCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    saveOpenEmailsTemplatesName: 'save_open_emailstemplates',

    SAVEACTIONS: {
        SAVE_OPEN_EMAILS_TEMPLATES: 'saveOpenEmailsTemplates'
    },

    initialize: function(options) {
        options.meta = _.extend({}, app.metadata.getView(null, 'create'), options.meta);
        this._super('initialize', [options]);
        this.context.on('button:' + this.saveOpenEmailsTemplatesName + ':click', this.saveOpenEmailsTemplates, this);
    },

    save: function () {
        switch (this.context.lastSaveAction) {
            case this.SAVEACTIONS.SAVE_OPEN_EMAILS_TEMPLATES:
                this.saveOpenEmailsTemplates();
                break;
            default:
                this.saveAndClose();
        }
    },

    saveOpenEmailsTemplates: function() {
        this.context.lastSaveAction = this.SAVEACTIONS.SAVE_OPEN_EMAILS_TEMPLATES;
        this.initiateSave(_.bind(function () {
            app.navigate(this.context, this.model, 'layout/emailtemplates');
        }, this));
    }
}) },
"emailtemplates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Emailtemplates View (base) 

    className: 'emailtemplates',

    loadData: function () {
        this.et_uid = this.options.context.attributes.modelId;
        var self = this;
        App.api.call("read", App.api.buildURL("pmse_Emails_Templates/getFields", null, {id: this.et_uid }), {}, {
            success: function (a) {
                self.et_uid = self.options.context.attributes.modelId;
                self.body = a.body;
                self.bodyHtml = a.body_html;
                self.templateName = a.name;
                self.templateDescription = a.description;
                self.fromName = a.from_name;
                self.fromAddres = a.from_address;
                self.subject = a.subject;

                self.targetFields = a.fields;
                self.relatedModules = a.related_modules;
                self.targetModule = a.base_module;

                self.render();
                $(init(self));
            }
        });
    }
}) },
"compose": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.pmse_Emails_Templates.ComposeView
 * @alias SUGAR.App.view.views.Basepmse_Emails_TemplatesComposeView
 * @extends View.Views.Base.RecordView
 */
({
	// Compose View (base) 

    extendsFrom: 'RecordView',

    MIN_EDITOR_HEIGHT: 300,
    EDITOR_RESIZE_PADDING: 5,
    buttons: null,

    initialize: function(options) {
        this._super('initialize', [options]);
        this.events = _.extend({}, this.events, {
            'click [name=save_button]': 'save',
            'click [name=save_buttonExit]': 'saveExit',
            'click [name=cancel_button]': 'cancel'
        });

        this.context.on('tinymce:oninit', this.handleTinyMceInit, this);

        this.action = 'edit';
        this._lastSelectedSignature = app.user.getPreference("signature_default");
    },

    /**
     * Set the title to the module name
     * @private
     */
    _render: function () {
        this._super('_render');
        this.setTitle(app.lang.get('LBL_MODULE_NAME', this.module));
        this.toggleViewButtons(true);
    },

    /**
     * Cancel and close the drawer
     */
    cancel: function() {
            this.toggleEdit(false);
            this.inlineEditMode = false;
            App.router.navigate("pmse_Emails_Templates", {trigger: true});
    },

    /**
     * This is kept very simple because we always stay in detail mode
     *
     * @override
     */
    handleSave: function() {
        if (this.disposed) {
            return;
        }
        this._saveModel();
    },

    /**
     * Send the email immediately or warn if user did not provide subject or body
     */
    save: function () {
        this.model.doValidate(this.getFields(this.module), _.bind(this.validationComplete, this));
    },
    validationCompleteApprove: function (model,exit) {
        var url, attributes, bodyHtml, subject, route = this.context.get("module");

        url = App.api.buildURL('pmse_Emails_Templates', null, {id: this.context.attributes.modelId});
        bodyHtml = model.get('body_html');//bodyHtml = this.model.get('body_html');
        subject = model.get('subject');//subject = this.model.get('subject');

        attributes = {
            body_html: bodyHtml,
            subject: subject,
            description:model.get('description'),//description:this.model.get('description'),
            name: model.get('name')//name: this.model.get('name'),
        };
        App.alert.show('upload', {level: 'process', title: 'LBL_SAVING', autoclose: false});
        App.api.call('update', url, attributes, {
            success: function (data) {
                App.alert.dismiss('upload');
                App.alert.show('save-success', {
                    level: 'success',
                    messages: App.lang.get('LBL_SAVED'),
                    autoClose: true
                });
                if(exit)
                {
                    model.revertAttributes();
                    App.router.redirect(route);
                }
            },
            error: function (err) {
                App.alert.dismiss('upload');
            }
        });
    },
    saveExit: function() {
        this.model.doValidate(this.getFields(this.module), _.bind(function(isValid) {
            if (isValid) {
                this.validationCompleteApprove(this.model,true);
            }
        }, this));
    },

    /**
     * Email Templates Designer's URL should not change because it doesn't contain the action in it
     * @override
     */
    setRoute: _.noop,

    _dispose: function() {
        if (App.drawer) {
            App.drawer.off(null, null, this);
        }
        this._super("_dispose");
    },
    handleTinyMceInit: function() {
        this.resizeEditor();
    },
    /**
     * Resize the html editor based on height of the drawer it is in
     *
     * @param drawerHeight current height of the drawer or height the drawer will be after animations
     */
    resizeEditor: function(drawerHeight) {
        var $editor, headerHeight, recordHeight, showHideHeight, diffHeight, editorHeight, newEditorHeight;

        $editor = this.$('.mceLayout .mceIframeContainer iframe');
        //if editor not already rendered, cannot resize
        if ($editor.length === 0) {
            return;
        }

        drawerHeight = drawerHeight || app.drawer.getHeight();
        headerHeight = this.$('.headerpane').outerHeight(true);
        recordHeight = this.$('.record').outerHeight(true);
        showHideHeight = this.$('.show-hide-toggle').outerHeight(true);
        editorHeight = $editor.height();

        //calculate the space left to fill - subtracting padding to prevent scrollbar
        diffHeight = drawerHeight - headerHeight - recordHeight - showHideHeight - this.EDITOR_RESIZE_PADDING;

        //add the space left to fill to the current height of the editor to get a new height
        newEditorHeight = editorHeight + diffHeight;

        //maintain min height
        if (newEditorHeight < this.MIN_EDITOR_HEIGHT) {
            newEditorHeight = this.MIN_EDITOR_HEIGHT;
        }

        //set the new height for the editor
        $editor.height(newEditorHeight);
    }

}) },
"compose-varbook-list-bottom": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Compose-varbook-list-bottom View (base) 

    extendsFrom: "ListBottomView",

    /**
     * Assign proper label for 'show more' link.
     * Label should be "More recipients...".
     */
    setShowMoreLabel: function() {
        this.showMoreLabel = app.lang.get('LBL_PMSE_SHOW_MORE_VARIABLES', this.module);
    }
}) },
"emailtemplates-import-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Emailtemplates-import-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',
    events:{
        'click [name=emailtemplates_finish_button]': 'initiateFinish',
        'click [name=emailtemplates_cancel_button]': 'initiateCancel'
    },

    initiateFinish: function() {
        this.context.trigger('emailtemplates:import:finish');
    },

    initiateCancel : function() {
        app.router.navigate(app.router.buildRoute(this.module), {trigger: true});
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.on('button:design_emailtemplates:click', this.designEmailTemplates, this);
        this.context.on('button:export_emailtemplates:click', this.warnExportEmailTemplates, this);
        this.context.on('button:delete_emailstemplates:click', this.warnDeleteEmailsTemplates, this);
        this.context.on('button:edit_emailstemplates:click', this.warnEditEmailTemplates, this);
    },

    _render: function() {
        this._super('_render');
        this.$('.record-cell[data-name=subject]').remove();
        this.$('.record-cell[data-name=body_html]').remove();
    },

    designEmailTemplates: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module});
        this._modelToDesign = model;
        app.api.call('read', verifyURL, null, {
            success: _.bind(this._onDesignRecordVerify, this)
        });
    },

    /**
     * Callback after checking if the template to be designed is already in use.
     *
     * @param {boolean} data: True if the template is being used (e.g. in a process), false otherwise.
     *
     * @private
     */
    _onDesignRecordVerify: function(data) {
        var model = this._modelToDesign;
        if (!data) {
            app.navigate(this.context, model, 'layout/emailtemplates');
        } else {
            app.alert.show('email-templates-edit-confirmation',  {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_PROCESS_EMAIL_TEMPLATES_EDIT', model.module),
                onConfirm: _.bind(this._onWarnDesignActiveRecordConfirm, this, model),
                onCancel: $.noop
            });
        }
    },

    /**
     * onConfirm callback for design record warning.
     *
     * @private
     */
    _onWarnDesignActiveRecordConfirm: function(model) {
        app.navigate(this.context, model, 'layout/emailtemplates');
        this._modelToDesign = null;
    },

    warnEditEmailTemplates: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module});
        this._modelToEdit = model;
        app.api.call('read', verifyURL, null, {
            success: _.bind(this._onEditRecordVerify, this)
        });
    },

    /**
     * Callback after checking if the template to be edited is already in use.
     *
     * @param {boolean} data: True if the template is being used (e.g. in a process), false otherwise.
     *
     * @private
     */
    _onEditRecordVerify: function(data) {
        var model = this._modelToEdit;
        if (!data) { // Not in use, continue with edit.
            this.editClicked();
        } else { // Template in use, warn user.
            app.alert.show('email-templates-edit-confirmation',  {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_PROCESS_EMAIL_TEMPLATES_EDIT', model.module),
                onConfirm: _.bind(this._onWarnEditActiveRecordConfirm, this),
                onCancel: $.noop
            });
        }
    },

    /**
     * onConfirm callback for edit record warning.
     *
     * @private
     */
    _onWarnEditActiveRecordConfirm: function() {
        this.editClicked();
        this._modelToEdit = null;
    },

    handleEdit: function(e, cell) {
        this.warnEditEmailTemplates(this.model);
    },

    warnDeleteEmailsTemplates: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module});
        this._modelToDelete = model;

        app.api.call('read', verifyURL, null, {
            success: _.bind(this._onDeleteRecordVerify, this)
        });
    },

    /**
     * Callback for api call to verify whether the email template is active in a process.
     * @param {boolean} data: true if the email template is being used (e.g. in a process), false otherwise.
     * @private
     */
    _onDeleteRecordVerify: function(data) {
        var model = this._modelToDelete;
        if (!data) { // Template not in use, warn user.
            app.alert.show('delete_confirmation', {
                level: 'confirmation',
                messages: this.getDeleteMessages(model).confirmation,
                onConfirm: _.bind(this._onWarnDeleteInactiveRecordConfirm, this),
                onCancel: _.bind(this._clearModelToDelete, this)
            });
        } else { // Template in use, block deletion
            app.alert.show('message-id', {
                level: 'warning',
                title: app.lang.get('LBL_WARNING'),
                messages: app.lang.get('LBL_PMSE_PROCESS_EMAIL_TEMPLATES_DELETE', model.module),
                autoClose: false
            });
            this._clearModelToDelete();
        }
    },

    /**
     * onConfirm callback for delete record warning.
     *
     * @private
     */
    _onWarnDeleteInactiveRecordConfirm: function() {
        this.deleteModel();
    },

    /**
     * Unset _modelToDelete as it is used by the parent record.js file.
     *
     * @private
     */
    _clearModelToDelete: function() {
        this._modelToDelete = null;
    },

    warnExportEmailTemplates: function(model) {
        var that = this;
        if (app.cache.get('show_emailtpl_export_warning')) {
            app.alert.show('emailtpl-export-confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') +
                '<br/><br/>' + app.lang.get('LBL_PMSE_EXPORT_CONFIRMATION'),
                onConfirm: _.bind(that._onWarnExportEmailTemplatesConfirm, that, model),
                onCancel: $.noop
            });
        } else {
            that.exportEmailTemplates(model);
        }
    },

    /**
     * onConfirm callback for warnExportEmailTemplates call.
     * Set the cache so the warning isn't sent again and start the download.
     *
     * @param {Object} model: The model passed to the warnExportsEmailTemplates call
     *
     * @private
     */
    _onWarnExportEmailTemplatesConfirm: function(model) {
        app.cache.set('show_emailtpl_export_warning', false);
        this.exportEmailTemplates(model);
    },

    exportEmailTemplates: function(model) {
        var url = app.api.buildURL(model.module, 'etemplate', {id: model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the Project download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: this._onExportEmailTemplatesDownloadError
        }, {iframe: this.$el});
    },

    /**
     * error callback for exportEmailTemplates fileDownload call.
     * @param {Object} data: The data from the api call
     *
     * @private
     */
    _onExportEmailTemplatesDownloadError: function(data) {
        // refresh token if it has expired
        app.error.handleHttpError(data, {});
    }
}) },
"emailtemplates-import": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Emailtemplates-import View (base) 

    initialize: function(options) {
        app.view.View.prototype.initialize.call(this, options);
        this.context.off('emailtemplates:import:finish', null, this);
        this.context.on('emailtemplates:import:finish', this.warnImportEmailTemplates, this);
    },

    /**
     * @inheritdoc
     *
     * Sets up the file field to edit mode
     *
     * @param {View.Field} field
     * @private
     */
    _renderField: function(field) {
        app.view.View.prototype._renderField.call(this, field);
        if (field.name === 'emailtemplates_import') {
            field.setMode('edit');
        }
    },

    warnImportEmailTemplates: function() {
        var that = this;
        if (app.cache.get('show_emailtpl_import_warning')) {
            app.alert.show('emailtpl-import-confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') +
                '<br/><br/>' + app.lang.get('LBL_PMSE_IMPORT_CONFIRMATION'),
                onConfirm: _.bind(that._onWarnImportEmailTemplatesConfirm, that),
                onCancel: _.bind(that._onWarnImportEmailTemplatesCancel, that)
            });
        } else {
            that.importEmailTemplates();
        }
    },

    /**
     * onConfirm callback for warnImportEmailTemplates alert.
     * Set the cache so the warning isn't sent again and start the import.
     *
     * @private
     */
    _onWarnImportEmailTemplatesConfirm: function() {
        app.cache.set('show_emailtpl_import_warning', false);
        this.importEmailTemplates();
    },

    /**
     * onCancel callback for warnImportEmailTemplates alert.
     * Navigate the user back to where they were before.
     *
     * @private
     */
    _onWarnImportEmailTemplatesCancel: function() {
        app.router.goBack();
    },

    /**
     * Import the Email Templates file (.pet)
     */
    importEmailTemplates: function() {
        var self = this,
            projectFile = $('[name=emailtemplates_import]');

        // Check if a file was chosen
        if (_.isEmpty(projectFile.val())) {
            app.alert.show('error_validation_emailtemplates', {
                level: 'error',
                messages: app.lang.get('LBL_PMSE_EMAIL_TEMPLATES_EMPTY_WARNING', self.module),
                autoClose: false
            });
        } else {
            app.alert.show('upload', {level: 'process', title: 'LBL_UPLOADING', autoclose: false});

            var callbacks =
                {
                    success: _.bind(self._onImportEmailTemplatesSuccess, self),
                    error:  self._onImportEmailTemplatesError
                };

            this.model.uploadFile('emailtemplates_import',
                projectFile,
                callbacks,
                {deleteIfFails: true, htmlJsonFormat: true});
        }
    },

    /**
     * success callback for template import.
     * @param {Object} data: response data.
     *
     * @private
     */
    _onImportEmailTemplatesSuccess: function(data) {
        app.alert.dismiss('upload');
        app.router.goBack();
        app.alert.show('process-import-saved', {
            level: 'success',
            messages: app.lang.get('LBL_PMSE_EMAIL_TEMPLATES_IMPORT_SUCCESS', this.module),
            autoClose: true
        });
    },

    /**
     * error callback for template import.
     * @param {Object} error: response data.
     *
     * @private
     */
    _onImportEmailTemplatesError: function(error) {
        app.alert.dismiss('upload');
        app.alert.show('process-import-saved', {
            level: 'error',
            messages: error.error_message,
            autoClose: false
        });
    }
}) },
"compose-varbook-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Compose-varbook-headerpane View (base) 

    extendsFrom: "HeaderpaneView",

    events: {
        "click [name=done_button]":   "_done",
        "click [name=cancel_button]": "_cancel"
    },

     /**
      * The user clicked the Done button so trigger an event to add selected recipients from the address book to the
      * target field and then close the drawer.
      *
      * @private
      */
     _done: function() {
        var selectedList = this.selectList(this.collection.models);
        !_.isEmpty(selectedList) ? app.drawer.close(selectedList) : this._cancel();
     },

    /**
     * Close the drawer.
     *
     * @private
     */
    _cancel: function() {
        app.drawer.close();
    },

    /**
     * Creates and returns a list of all the fields the User selected for either
     * Current, Old or Both values.
     * If the value is Both there will be 2 models with the values Current and Old
     * for the same field.
     * Current translates to future on the backend.
     *
     * @param {Object} models List of all the modules.
     * @return {Object} selectedList.
     */
    selectList: function(models) {
        var selectedList = [];
        var i;
        var old;
        var future;
        for (i = 0 ; i < models.length; i++) {
            if (models[i].attributes.process_et_field_type === 'none') {
                continue;
            }

            if (models[i].attributes.process_et_field_type == 'both') {
                // Get clones of the model for old and new
                future = models[i].clone();
                old = models[i].clone();

                // Set the field type for the current field
                future.attributes.process_et_field_type = 'future';

                // Set the field type for the old field
                old.attributes.process_et_field_type = 'old';

                // Add them to the stack
                selectedList.push(future);
                selectedList.push(old);
            } else {
                // Since this is one or the other, take it as is
                selectedList.push(models[i]);
            }
        }
        return selectedList;
    }
}) },
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Recordlist View (base) 

    extendsFrom: 'RecordlistView',

    /**
     * @override
     * @param {Object} options
     */
    initialize: function(options) {
        this.contextEvents = _.extend({}, this.contextEvents, {
            'list:editemailstemplates:fire': 'openEmailsTemplates',
            'list:exportemailstemplates:fire': 'warnExportEmailsTemplates',
            'list:deleteemailstemplates:fire': 'warnDeleteEmailsTemplates',
            'list:edit_emailstemplates:fire': 'warnEditEmailsTemplates'
        });
        this._super('initialize', [options]);
    },

    openEmailsTemplates: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module});
        this._modelToDesign = model;

        app.api.call('read', verifyURL, null, {
            success: _.bind(this._onDesignRecordVerify, this)
        });
    },

    /**
     * Callback after checking if the template to be designed is already in use.
     *
     * @param {boolean} data: True if the template is being used (e.g. in a process), false otherwise.
     *
     * @private
     */
    _onDesignRecordVerify: function(data) {
        var model = this._modelToDesign;
        if (!data) {
            app.navigate(this.context, model, 'layout/emailtemplates');
        } else {
            app.alert.show('business-rule-design-confirmation',  {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_PROCESS_EMAIL_TEMPLATES_EDIT', model.module),
                onConfirm: _.bind(this._onWarnDesignActiveRecordConfirm, this, model),
                onCancel: $.noop
            });
        }
    },

    /**
     * onConfirm callback for design record warning.
     * @param {Object} model: The model of the template to be designed.
     *
     * @private
     */
    _onWarnDesignActiveRecordConfirm: function(model) {
        app.navigate(this.context, model, 'layout/emailtemplates');
    },

    warnEditEmailsTemplates: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module});
        this._modelToEdit = model;

        app.api.call('read', verifyURL, null, {
            success: _.bind(this._onEditRecordVerify, this)
        });
    },

    /**
     * Callback after checking if the template to be edited is already in use.
     *
     * @param {boolean} data: True if the template is being used (e.g. in a process), false otherwise.
     *
     * @private
     */
    _onEditRecordVerify: function(data) {
        var model = this._modelToEdit;
        if (!data) { //
            this.toggleRow(model.id, true);
            this.resize();
        } else {
            app.alert.show('business-rule-design-confirmation',  {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_PROCESS_EMAIL_TEMPLATES_EDIT', model.module),
                onConfirm: _.bind(this._onWarnEditActiveRecordConfirm, this),
                onCancel: $.noop
            });
        }
    },

    /**
     * onConfirm callback for edit record warning.
     *
     * @private
     */
    _onWarnEditActiveRecordConfirm: function() {
        var model = this._modelToEdit;
        this.toggleRow(model.id, true);
        this.resize();
        this._modelToEdit = null;
    },

    warnDeleteEmailsTemplates: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module});
        this._modelToDelete = model;

        app.api.call('read', verifyURL, null, {
            success: _.bind(this._onDeleteRecordVerify, this)
        });
    },

    /**
     * Callback for api call to verify whether the email template is active in a process.
     * @param {boolean} data: true if the email template is being used (e.g. in a process), false otherwise.
     * @private
     */
    _onDeleteRecordVerify: function(data) {
        if (!data) {
            this._warnDeleteInactiveRecord();
        } else {
            this._blockDeleteActiveRecord();
        }
    },

    /**
     * Get the user's confirmation before deleting the record.
     * Separated to reduce complexity of function for testing.
     *
     * @private
     */
    _warnDeleteInactiveRecord: function() {
        var model = this._modelToDelete;
        this._targetUrl = Backbone.history.getFragment();
        //Replace the url hash back to the current staying page
        if (this._targetUrl !== this._currentUrl) {
            app.router.navigate(this._currentUrl, {trigger: false, replace: true});
        }

        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: this.getDeleteMessages(model).confirmation,
            onConfirm: _.bind(this._onWarnDeleteInactiveRecordConfirm, this),
            onCancel: _.bind(this._clearModelToDelete, this)
        });
    },

    /**
     * Prevent the user from deleting an email template that is in use.
     * Separated to reduce complexity of function for testing.
     *
     * @private
     */
    _blockDeleteActiveRecord: function() {
        var model = this._modelToDelete;
        app.alert.show('message-id', {
            level: 'warning',
            title: app.lang.get('LBL_WARNING'),
            messages: app.lang.get('LBL_PMSE_PROCESS_EMAIL_TEMPLATES_DELETE', model.module),
            autoClose: false
        });
        this._clearModelToDelete();
    },

    /**
     * onConfirm callback for delete record warning.
     *
     * @private
     */
    _onWarnDeleteInactiveRecordConfirm: function() {
        this.deleteModel();
    },

    /**
     * onCancel callback for delete record warning.
     *
     * @private
     */
    _clearModelToDelete: function() {
        this._modelToDelete = null;
    },

    warnExportEmailsTemplates: function(model) {
        var that = this;
        if (app.cache.get('show_emailtpl_export_warning')) {
            app.alert.show('emailtpl-export-confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') +
                '<br/><br/>' + app.lang.get('LBL_PMSE_EXPORT_CONFIRMATION'),
                onConfirm: _.bind(that._onWarnExportEmailsTemplatesConfirm, that, model),
                onCancel: $.noop
            });
        } else {
            that.exportEmailsTemplates(model);
        }
    },

    /**
     * onConfirm callback for warnExportEmailsTemplates call.
     * Set the cache so the warning isn't sent again and start the download.
     *
     * @param {Object} model: The model passed to the warnExportsEmailTemplates call
     *
     * @private
     */
    _onWarnExportEmailsTemplatesConfirm: function(model) {
        app.cache.set('show_emailtpl_export_warning', false);
        this.exportEmailsTemplates(model);
    },

    exportEmailsTemplates: function(model) {
        var url = app.api.buildURL(model.module, 'etemplate', {id: model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the Project download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: this._onExportEmailsTemplatesDownloadError
        }, {iframe: this.$el});
    },

    /**
     * error callback for exportEmailsTemplates fileDownload call.
     * @param {Object} data: The data from the api call
     *
     * @private
     */
    _onExportEmailsTemplatesDownloadError: function(data) {
        // refresh token if it has expired
        app.error.handleHttpError(data, {});
    }
}) },
"compose-sugarlinks-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Compose-sugarlinks-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click [name=select_button]':   '_select',
        'click [name=cancel_button]': '_cancel'
    },

    /**
     * Close the drawer and pass in the selected model
     *
     * @private
     */
    _select: function() {
        var selectedModel = this.context.get('selection_model');

        if (selectedModel) {
            app.drawer.close(selectedModel);
        } else {
            this._cancel();
        }
    },

    /**
     * Close the drawer
     *
     * @private
     */
    _cancel: function() {
        app.drawer.close();
    }
}) },
"compose-varbook-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Compose-varbook-list View (base) 

    /**
     * @class View.ComposeAddressbookListView
     * @alias SUGAR.App.view.views.ComposeAddressbookListView
     * @extends View.FlexListView
     */
    extendsFrom: 'FlexListView',
    plugins: ['ListColumnEllipsis', 'Pagination'],

    /**
     * Override to inject field names into the request when fetching data for the list.
     *
     * @param module
     * @returns {Array}
     */
    getFieldNames: function(module) {
        // id and module always get returned, so name and email just need to be added
        return ['name', 'email'];
    },
    /**
     * Override to force translation of the module names as columns are added to the list.
     *
     * @param field
     * @private
     */
    _renderField: function(field) {
        if (field.name == 'process_et_field_type') {
            field.setViewName('edit');
            field.action = 'edit';
        }
        if (field.name == '_module') {
            field.model.set(field.name, app.lang.get('LBL_MODULE_NAME', field.module));
        }
        this._super('_renderField', [field]);
    }
}) },
"dashlet-email": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dashlet-email View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        limit: 10,
        visibility: 'user'
    },

    thresholdRelativeTime: 2, //Show relative time for 2 days and then date time after

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this.plugins = _.union(this.plugins, [
            'LinkedModel'
        ]);

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    _initEvents: function() {
        this._super('_initEvents');
        this.on('dashlet-email:edit:fire', this.editRecord, this);
        this.on('dashlet-email:delete-record:fire', this.deleteRecord, this);
        this.on('dashlet-email:enable-record:fire', this.enableRecord, this);
        this.on('dashlet-email:download:fire', this.warnExportEmailsTemplates, this);
        this.on('dashlet-email:description-record:fire', this.descriptionRecord, this);
        this.on('linked-model:create', this.loadData, this);
        return this;
    },

    /**
     * Re-fetches the data for the context's collection.
     *
     * FIXME: This will be removed when SC-4775 is implemented.
     *
     * @private
     */
    _reloadData: function() {
        this.context.set('skipFetch', false);
        this.context.reloadData();
    },

    /**
     * Fire dessigner
     */
    editRecord: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module});
        this._modelToEdit = model;
        app.api.call('read', verifyURL, null, {
            success: _.bind(this._onEditRecordVerify, this)
        });
    },

    /**
     * Callback after checking if the template to be edited is already in use.
     *
     * @param {boolean} data: True if the template is being used (e.g. in a process), false otherwise.
     *
     * @private
     */
    _onEditRecordVerify: function(data) {
        var model = this._modelToEdit;
        var redirect = model.module + '/' + model.id + '/layout/emailtemplates';
        if (!data) {
            app.router.navigate(redirect, {trigger: true, replace: true});
        } else {
            app.alert.show('email-templates-edit-confirmation',  {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_PROCESS_EMAIL_TEMPLATES_EDIT', model.module),
                onConfirm: _.bind(this._onWarnEditActiveRecordConfirm, this, redirect),
                onCancel: _.bind(this._onWarnEditActiveRecordCancel, this)
            });
        }
    },

    /**
     * onConfirm callback for edit record warning.
     * @param {string} redirect: The redirect location made in the _onEditRecordVerify call that lead to this.
     *
     * @private
     */
    _onWarnEditActiveRecordConfirm: function(redirect) {
        app.router.navigate(redirect, {trigger: true, replace: true});
        this._modelToEdit = null;
    },

    /**
     * onCancel callback for edit record warning.
     *
     * @private
     */
    _onWarnEditActiveRecordCancel: function() {
        this._modelToEdit = null;
    },

    /**
     * Show warning of pmse_email_templates
     */
    warnExportEmailsTemplates: function(model) {
        var that = this;
        if (app.cache.get('show_emailtpl_export_warning')) {
            app.alert.show('emailtpl-export-confirmation', {
                level: 'confirmation',
                messages: app.lang.get('LBL_PMSE_IMPORT_EXPORT_WARNING') +
                '<br/><br/>' + app.lang.get('LBL_PMSE_EXPORT_CONFIRMATION'),
                //model is passed to _.bind to pass it as a parameter to _onWarnExportEmailsTemplatesConfirm
                onConfirm: _.bind(this._onWarnExportEmailsTemplatesConfirm, this, model),
                onCancel: $.noop
            });
        } else {
            that.exportEmailsTemplates(model);
        }
    },
    /**
     * onConfirm callback for warnExportEmailsTemplates call.
     * Set the cache so the warning isn't sent again and start the download.
     *
     * @param {Object} model: The model passed to the warnExportsEmailsTemplates call
     *
     * @private
     */
    _onWarnExportEmailsTemplatesConfirm: function(model) {
        app.cache.set('show_emailtpl_export_warning', false);
        this.exportEmailsTemplates(model);
    },
    /**
     * Download record of table pmse_emails_templates
     */
    exportEmailsTemplates: function(model) {
        var url = app.api.buildURL(model.module, 'etemplate', {id: model.id}, {platform: app.config.platform});

        if (_.isEmpty(url)) {
            app.logger.error('Unable to get the Email Template download uri.');
            return;
        }

        app.api.fileDownload(url, {
            error: this._onExportEmailsTemplatesDownloadError
        }, {iframe: this.$el});
    },
    /**
     * error callback for exportEmailsTemplates fileDownload call.
     * @param {Object} data: The data from the api call
     *
     * @private
     */
    _onExportEmailsTemplatesDownloadError: function(data) {
        // refresh token if it has expired
        app.error.handleHttpError(data, {});
    },

    /**
     * @inheritdoc
     *
     * FIXME: This should be removed when metadata supports date operators to
     * allow one to define relative dates for date filters.
     */
    _initTabs: function() {
        this._super('_initTabs');
    },

    /**
     * Create new record.
     *
     * @param {Event} event Click event.
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    createRecord: function(event, params) {
        if (this.module !== 'pmse_Emails_Templates') {
            this.createRelatedRecord(params.module, params.link);
        } else {
            var self = this;
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    module: params.module
                }
            }, _.bind(self._onCreateRecordDrawerClose, self));
        }

    },
    /**
     * Callback used by the createRecord call to app.drawer.open
     *
     * @param {Object} context: Something that app.drawer.open calls this with
     * @param {Object} model: Model of the created record. Will be falsy if user cancels.
     *
     * @private
     */
    _onCreateRecordDrawerClose: function(context, model) {
        if (!model) {
            return;
        }
        this.context.resetLoadFlag();
        this.context.set('skipFetch', false);
        if (_.isFunction(this.loadData)) {
            this.loadData();
        } else {
            this.context.loadData();
        }
    },

    importRecord: function(event, params) {
        app.router.navigate(params.link, {trigger: true, replace: true});
    },

    /**
     * Delete record.
     *
     * @param {Event} event Click event.
     * @param {String} params.layout Layout name.
     * @param {String} params.module Module name.
     */
    deleteRecord: function(model) {
        var verifyURL = app.api.buildURL(
                'pmse_Project',
                'verify',
                {id: model.get('id')},
                {baseModule: this.module});
        this._modelToDelete = model;
        app.api.call('read', verifyURL, null, {
            success: _.bind(this._onDeleteRecordVerify, this)
        });
    },

    /**
     * Callback after api call to verify whether the email template is active in a process.
     * @param {boolean} data: true if the email template is being used (e.g. in a process), false otherwise.
     * @private
     */
    _onDeleteRecordVerify: function(data) {
        var model = this._modelToDelete;
        if (!data) { // Is NOT actively in use.
            app.alert.show('delete_confirmation', {
                level: 'confirmation',
                messages: app.utils.formatString(app.lang.get('LBL_PRO_DELETE_CONFIRMATION', model.module)),
                onConfirm: _.bind(this._onWarnDeleteInactiveRecordConfirm, this),
                onCancel: _.bind(this._onWarnDeleteInactiveRecordCancel, this)
            });
        } else { // Is actively in use, do not allow deletion.
            app.alert.show('message-id', {
                level: 'warning',
                title: app.lang.get('LBL_WARNING'),
                messages: app.lang.get('LBL_PMSE_PROCESS_EMAIL_TEMPLATES_DELETE', model.module),
                autoClose: false
            });
            this._modelToDelete = null;
        }
    },

    /**
     * onConfirm callback for delete record warning.
     * Called by _onDeleteRecordVerify if the template is not active.
     *
     * @private
     */
    _onWarnDeleteInactiveRecordConfirm: function() {
        var model = this._modelToDelete;
        model.destroy({
            showAlerts: true,
            success: _.bind(this._getRemoveRecord, this)
        });
    },

    /**
     * onCancel callback for delete record warning.
     * Called by _onDeleteRecordVerify if the template is not active.
     *
     * @private
     */
    _onWarnDeleteInactiveRecordCancel: function() {
        this._modelToDelete = null;
    },

    /**
     * Updating in fields delete removed
     * @private
     */
    _getRemoveRecord: function(model) {
        if (this.disposed) {
            return;
        }
        this.collection.remove(model);
        this.render();
        this.context.trigger('tabbed-dashlet:refresh', model.module);
    },

    /**
     * Method view alert in process with text modify
     * show and hide alert
     */
    _refresh: function(model, status) {
        app.alert.show(model.id + ':refresh', {
            level: 'process',
            title: status,
            autoclose: false
        });
        return _.bind(this._refreshReturn, this);
    },

    /**
     * Function that _refresh returns
     *
     * @param {Object} model: The model passed to _refresh
     * @private
     */
    _refreshReturn: function(model) {
        var options = {};
        this.layout.reloadDashlet(options);
        app.alert.dismiss(model.id + ':refresh');
    },

    /**
     * descriptionRecord: View description in table pmse_Emails_Templates in fields
     */
    descriptionRecord: function(model) {
        app.alert.dismiss('message-id');
        app.alert.show('message-id', {
            level: 'info',
            title: app.lang.get('LBL_DESCRIPTION'),
            messages: '<br/>' + Handlebars.Utils.escapeExpression(model.get('description')),
            autoClose: false
        });
    },

    /**
     * Sets property useRelativeTime to show date created as a relative time or as date time.
     *
     * @private
     */
    _setRelativeTimeAvailable: function(date) {
        var diffInDays = app.date().diff(date, 'days', true);
        var useRelativeTime = (diffInDays <= this.thresholdRelativeTime);
        return useRelativeTime;
    },

    /**
     * @inheritdoc
     *
     * New model related properties are injected into each model:
     *
     * - {Boolean} overdue True if record is prior to now.
     * - {String} picture_url Picture url for model's assigned user.
     * - {String} base_module_name Name of the triggering module.
     */
    _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        // Render each of the templates.
        _.each(this.collection.models, this._renderItemHtml, this);

        this._super('_renderHtml');
    },

    /**
     * Render an individual process emails template in the dashlet. Used by _renderHtml.
     *
     * @param {Object} model: The model object of the process emails template.
     * @private
     */
    _renderItemHtml: function(model) {
        model.useRelativeTime = this._setRelativeTimeAvailable(model.attributes.date_entered);
        // Update the triggering module names.
        var module = model.get('base_module');
        var label = app.lang.getModString('LBL_MODULE_NAME', module);
        if (_.isUndefined(label)) {
            label = module;
        }
        model.set('base_module_name', label);
    }
}) },
"compose-sugarlinks-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.ComposeSugarLinksListView
 * @alias SUGAR.App.view.views.ComposeSugarlinksListView
 * @extends View.FlexListView
 */

({
	// Compose-sugarlinks-list View (base) 

    extendsFrom: 'FlexListView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     * Load data from api endpoint
     */
    loadData: function() {
        var self = this;
        var baseModule = this.context.get('baseModule');
        var url = app.api.buildURL('pmse_Emails_Templates', baseModule +  '/find_modules', null, {module_list: baseModule});
        app.alert.show('sugar_link_load', {level: 'process'})
        app.api.call('GET', url, null, {
            success: function(data) {
                var processedData = self._processResults(data.result);
                if (self.collection) {
                    self.collection.add(processedData);
                    self.collection.dataFetched = true;
                    self.render();
                }
                app.alert.dismiss('sugar_link_load', {level: 'process'});

            },
            error: function(e) {
                app.alert.dismiss('sugar_link_load', {level: 'process'});
            }
        });

    },

    /**
     * Sanitize the results by cleaning up names and adding how module is related
     * to the target module
     * @param results
     * @returns {*} array of target module and related modules
     * @private
     */
    _processResults: function(results) {
        var targetModule = _.first(results);
        var relatedModules = _.rest(results, 1)

        //strip off '<' and '>' from target module's name
        targetModule.text = targetModule.text.substring(1, targetModule.text.length-1);
        targetModule.relatedTo = app.lang.get('LBL_BASE_MODULE', 'pmse_Emails_Templates');

        _.map(relatedModules, function(relatedModule){
            return _.extend(relatedModule, {relatedTo: app.lang.get('LBL_RELATED_TO_TARGET_MODULE', 'pmse_Emails_Templates')})
        });
        relatedModules.unshift(targetModule);
        return relatedModules;
    }
}) }
}}
,
"layouts": {
"base": {
"compose-varbook": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Compose-varbook Layout (base) 

    /**
     * @class ComposeAddressbookLayout
     * @extends Layout
     */
    initialize: function(options) {
        app.view.Layout.prototype.initialize.call(this, options);
        this.collection.sync = this.sync;
        this.collection.baseModule = this.layout.context.attributes.model.attributes.base_module;
        this.collection.allowed_modules = ['Accounts', 'Contacts', 'Leads', 'Prospects', 'Users'];
//        url = app.api.buildURL('pmse_Emails_Templates', 'modules/find', null, {'module': this.collection.baseModule});
//        app.api.call('read', url, null, {
//                success:function (modules){
//                    self.collection.allowed_modules= modules;
//
//                }
//            }
//        );


        this.context.on('compose:addressbook:search', this.search, this);
    },
    /**
     * Calls the custom Mail API endpoint to search for email addresses.
     *
     * @param method
     * @param model
     * @param options
     */
    sync: function(method, model, options) {
        var callbacks,
            baseModule,
            url;
        options = options || {};

        // only fetch from the approved modules
        if (_.isEmpty(options.module_list) || this.module_list.length > 1) {
            options.module_list = [this.baseModule];
        } else {
            options.module_list = [this.module_list[0]];
        }

        // this is a hack to make pagination work while trying to minimize the affect on existing configurations
        // there is a bug that needs to be fixed before the correct approach (config.maxQueryResult vs. options.limit)
        // can be determined
        app.config.maxQueryResult = app.config.maxQueryResult || 20;
        options.limit = options.limit || app.config.maxQueryResult;

        options = app.data.parseOptionsForSync(method, model, options);

        callbacks = app.data.getSyncCallbacks(method, model, options);
        this.trigger('data:sync:start', method, model, options);
        _.extend(options.params, {base_module: model.baseModule});
        url = app.api.buildURL('pmse_Emails_Templates', 'variables/find', null, options.params);
        app.api.call('read', url, null, callbacks);
    },
    /**
     * Adds the set of modules and term that should be used to search for recipients.
     *
     * @param {Array} modules
     * @param {String} term
     */
    search: function(modules, term) {
        // reset offset to 0 on a search. make sure that it resets and does not update.
        this.collection.fetch({query: term, module_list: modules, offset: 0, update: false});
    }
}) }
}}
,
"datas": {}

},
		"WorkFlow":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"EAPM":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Worksheet":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Users":{"fieldTemplates": {}
,
"views": {
"base": {
"module-menu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Module menu provides a reusable and easy render of a module Menu.
 *
 * This also helps doing customization of the menu per module and provides more
 * metadata driven features.
 *
 * @class View.Views.Base.Users.ModuleMenuView
 * @alias SUGAR.App.view.views.BaseUsersModuleMenuView
 * @extends View.Views.Base.ModuleMenuView
 */
({
	// Module-menu View (base) 

    extendsFrom: 'ModuleMenuView',

    handleRouteEvent: function(event) {
        if (App.config.idmModeEnabled && (event.target.getAttribute('data-navbar-menu-item') == 'LNK_NEW_USER')) {
            App.alert.show('idm_create_user', {
                level: 'info',
                messages: App.lang
                    .get('ERR_CREATE_USER_FOR_IDM_MODE', 'Users')
                    .replace('{0}', this.meta.cloudConsoleLink)
            });
        }
        this._super('handleRouteEvent', [event]);
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Employees":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Administration":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"ACLRoles":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"InboundEmail":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Releases":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Prospects":{"fieldTemplates": {}
,
"views": {
"base": {
"convert-results": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Convert-results View (base) 

    extendsFrom: 'ConvertResultsView',

    /**
     * Fetches the data for the leads model
     */
    populateResults: function() {
        if (!_.isEmpty(this.model.get('lead_id'))){
            var leads = app.data.createBean('Leads', { id: this.model.get('lead_id')});
            leads.fetch({
                success: _.bind(this.populateLeadCallback, this)
            });
        }
    },

    /**
     * Success callback for retrieving associated lead model
     * @param leadModel
     */
    populateLeadCallback: function (leadModel) {
        var rowTitle;

        this.associatedModels.reset();

        rowTitle = app.lang.get('LBL_CONVERTED_LEAD',this.module);

        leadModel.set('row_title', rowTitle);

        this.associatedModels.push(leadModel);

        app.view.View.prototype.render.call(this);
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['HistoricalSummary']);
        this._super('initialize', [options]);
    },

    delegateButtonEvents: function() {
        this.context.on('button:convert_button:click', this.convertProspectClicked, this);
        this._super('delegateButtonEvents');
    },

    convertProspectClicked: function() {
        var prefill = app.data.createBean('Leads');

        prefill.copy(this.model);
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                model: prefill,
                module: 'Leads',
                prospect_id: this.model.get('id')
            }
        }, _.bind(function(context, model) {
            //if lead is created, grab the new relationship to the target so the convert-results will refresh
            if (model && model.id && !this.disposed) {
                this.model.fetch();
                _.each(this.context.children, function(child) {
                    if (child.get('isSubpanel') && !child.get('hidden')) {
                        if (child.get('collapsed')) {
                            child.resetLoadFlag({recursive: false});
                        } else {
                            child.reloadData({recursive: false});
                        }
                    }
                });
            }
        }, this));

        prefill.trigger('duplicate:field', this.model);
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Queues":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"EmailMarketing":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"EmailTemplates":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"SNIP":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"ProspectLists":{"fieldTemplates": {}
,
"views": {
"base": {
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    delegateButtonEvents: function() {
        this.context.on('button:export_button:click', this.exportListMembers, this);
        this._super("delegateButtonEvents");
    },

    /**
     * Event to trigger the Export page level action
     */
    exportListMembers: function() {
        app.alert.show('export_loading', {level: 'process', title: app.lang.get('LBL_LOADING')});
        app.api.exportRecords(
            {
                module: this.module,
                uid: [this.model.id],
                members: true
            },
            this.$el,
            {
                complete: function() {
                    app.alert.dismiss('export_loading');
                }
            }
        );
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"SavedSearch":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"UpgradeWizard":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Trackers":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"TrackerPerfs":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"TrackerSessions":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"TrackerQueries":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"FAQ":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Newsletters":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"SugarFavorites":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"PdfManager":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"OAuthKeys":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"OAuthTokens":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Filters":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {
"base": {
"model": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class Data.Base.FiltersBean
 * @extends Data.Bean
 */
({
	// Model Data (base) 

    /**
     * @inheritdoc
     */
    defaults: {
        editable: true
    },

    /**
     * Maps field types and field operator types.
     *
     * @property {Object}
     */
    fieldTypeMap: {
        'datetime': 'date',
        'datetimecombo': 'date'
    },

    /**
     * Gets the filter definition based on quick search metadata.
     *
     * The filter definition that is built is based on the `basic` filter
     * metadata. By default, modules will make a search on the `name` field, but
     * this is configurable. For instance, the `person` type modules
     * (e.g. Contacts or Leads) will perform a search on the first name and the
     * last name (`first_name` and `last_name` fields).
     *
     * For these modules whom the search is performed on two fields, you can
     * also configure to split the terms. In this case, the terms are split such
     * that different combinations of the terms are search against each search
     * field.
     *
     * There is a special case if the `moduleName` is `all_modules`: the
     * function will always return an empty filter definition (empty `array`).
     *
     * There is another special case with the `Users` and `Employees` module:
     * the filter will be augmented to retrieve only the records with the
     * `status` set to `Active`.
     *
     * @param {string} moduleName The filtered module.
     * @param {string} searchTerm The search term.
     * @return {Array} This search term filter.
     * @static
     */
    buildSearchTermFilter: function(moduleName, searchTerm) {
        if (moduleName === 'all_modules' || !searchTerm) {
            return [];
        }

        searchTerm = searchTerm.trim();

        var splitTermFilter;
        var filterList = [];
        var searchMeta = app.data.getBeanClass('Filters').prototype.getModuleQuickSearchMeta(moduleName);
        var fieldNames = searchMeta.fieldNames;

        // Iterate through each field and check if the field is a simple
        // or complex field, and build the filter object accordingly
        _.each(fieldNames, function(name) {
            if (!_.isArray(name)) {
                var filter = this._buildFilterDef(name, '$starts', searchTerm);
                if (filter) {
                    // Simple filters are pushed to `filterList`
                    filterList.push(filter);
                }
                return;
            }

            if (splitTermFilter) {
                app.logger.error('Cannot have more than 1 split term filter');
                return;
            }
            splitTermFilter = this._buildSplitTermFilterDef(name, '$starts', searchTerm);
        }, this);

        // Push the split term filter
        if (splitTermFilter) {
            filterList.push(splitTermFilter);
        }

        // If more than 1 filter was created, wrap them in `$or`
        if (filterList.length > 1) {
            var filter = this._joinFilterDefs('$or', filterList);
            if (filter) {
                filterList = [filter];
            }
        }

        // FIXME [SC-3560]: This should be moved to the metadata
        if (moduleName === 'Users' || moduleName === 'Employees') {
            filterList = this._simplifyFilterDef(filterList);
            filterList = [{
                '$and': [
                    {'status': {'$not_equals': 'Inactive'}},
                    filterList
                ]
            }];
        }

        return filterList;
    },

    /**
     * Combines two filters into a single filter definition.
     *
     * @param {Array|Object} [baseFilter] The selected filter definition.
     * @param {Array} [searchTermFilter] The filter for the quick search terms.
     * @return {Array} The filter definition.
     * @static
     */
    combineFilterDefinitions: function(baseFilter, searchTermFilter) {
        var isBaseFilter = _.size(baseFilter) > 0,
            isSearchTermFilter = _.size(searchTermFilter) > 0;

        baseFilter = _.isArray(baseFilter) ? baseFilter : [baseFilter];

        if (isBaseFilter && isSearchTermFilter) {
            baseFilter.push(searchTermFilter[0]);
            return [
                {'$and': baseFilter }
            ];
        } else if (isBaseFilter) {
            return baseFilter;
        } else if (isSearchTermFilter) {
            return searchTermFilter;
        }

        return [];
    },

    /**
     * Gets filterable fields from the module metadata.
     *
     * The list of fields comes from the metadata but is also filtered by
     * user acls (`detail`/`read` action).
     *
     * @param {string} moduleName The name of the module.
     * @return {Object} The filterable fields.
     * @static
     */
    getFilterableFields: function(moduleName) {
        var moduleMeta = app.metadata.getModule(moduleName),
            operatorMap = app.metadata.getFilterOperators(moduleName),
            fieldMeta = moduleMeta.fields,
            fields = {};

        if (moduleMeta.filters) {
            _.each(moduleMeta.filters, function(templateMeta) {
                if (templateMeta.meta && templateMeta.meta.fields) {
                    fields = _.extend(fields, templateMeta.meta.fields);
                }
            });
        }

        _.each(fields, function(fieldFilterDef, fieldName) {
            var fieldMetaData = app.utils.deepCopy(fieldMeta[fieldName]);
            if (_.isEmpty(fieldFilterDef)) {
                fields[fieldName] = fieldMetaData || {};
            } else {
                fields[fieldName] = _.extend({name: fieldName}, fieldMetaData, fieldFilterDef);
            }
            delete fields[fieldName]['readonly'];
        });

        var validFields = {};
        _.each(fields, function(value, key) {
            // Check if we support this field type.
            var type = this.fieldTypeMap[value.type] || value.type;
            var hasAccess = app.acl.hasAccess('detail', moduleName, null, key);
            // Predefined filters don't have operators defined.
            if (hasAccess && (operatorMap[type] || value.predefined_filter === true)) {
                validFields[key] = value;
            }
        }, this);

        return validFields;
    },

    /**
     * Retrieves and caches the quick search metadata.
     *
     * @param {string} [moduleName] The filtered module. Only required when the
     *   function is called statically.
     * @return {Object} Quick search metadata (with highest priority).
     * @return {string[]} return.fieldNames The fields to be used in quick search.
     * @return {boolean} return.splitTerms Whether to split the search terms
     *   when there are multiple search fields.
     * @static
     */
    getModuleQuickSearchMeta: function(moduleName) {
        moduleName = moduleName || this.get('module_name');

        var prototype = app.data.getBeanClass('Filters').prototype;
        prototype._moduleQuickSearchMeta = prototype._moduleQuickSearchMeta || {};

        prototype._moduleQuickSearchMeta[moduleName] = prototype._moduleQuickSearchMeta[moduleName] ||
            this._getQuickSearchMetaByPriority(moduleName);
        return prototype._moduleQuickSearchMeta[moduleName];
    },

    /**
     * Populates empty values of a filter definition.
     *
     * @param {Object} filterDef The filter definition.
     * @param {Object} populateObj Populate object containing the
     *   `filter_populate` metadata definition.
     * @return {Object} The filter definition.
     * @static
     */
    populateFilterDefinition: function(filterDef, populateObj) {
        if (!populateObj) {
            return filterDef;
        }
        filterDef = app.utils.deepCopy(filterDef);
        _.each(filterDef, function(row) {
            _.each(row, function(filter, field) {
                var hasNoOperator = (_.isString(filter) || _.isNumber(filter));
                if (hasNoOperator) {
                    filter = {'$equals': filter};
                }
                var operator = _.keys(filter)[0],
                    value = filter[operator],
                    isValueEmpty = !_.isNumber(value) && _.isEmpty(value);

                if (isValueEmpty && populateObj && !_.isUndefined(populateObj[field])) {
                    value = populateObj[field];
                }

                if (hasNoOperator) {
                    row[field] = value;
                } else {
                    row[field][operator] = value;
                }
            });
        });
        return filterDef;
    },

    /**
     * Retrieves the quick search metadata.
     *
     * The metadata returned is the one that has the highest
     * `quicksearch_priority` property.
     *
     * @param {string} searchModule The filtered module.
     * @return {Object}
     * @return {string[]} return.fieldNames The list of field names.
     * @return {boolean} return.splitTerms Whether to split search terms or not.
     * @private
     * @static
     */
    _getQuickSearchMetaByPriority: function(searchModule) {
        var meta = app.metadata.getModule(searchModule),
            filters = meta ? meta.filters : [],
            fieldNames = [],
            priority = 0,
            splitTerms = false;

        _.each(filters, function(value) {
            if (value && value.meta && value.meta.quicksearch_field &&
                priority < value.meta.quicksearch_priority) {
                fieldNames = value.meta.quicksearch_field;
                priority = value.meta.quicksearch_priority;
                if (_.isBoolean(value.meta.quicksearch_split_terms)) {
                    splitTerms = value.meta.quicksearch_split_terms;
                }
            }
        });

        return {
            fieldNames: fieldNames,
            splitTerms: splitTerms
        };
    },

    /**
     * Returns the first filter from `filterList`, if the length of
     * `filterList` is 1.
     *
     * The *simplified* filter is in the form of the one returned by
     * {@link #_buildFilterDef} or {@link #_joinFilterDefs}.
     *
     * @param {Array} filterList An array of filter definitions.
     *
     * @return {Array|Object} First element of `filterList`, if the
     *   length of the array is 1, otherwise, the original `filterList`.
     * @private
     */
    _simplifyFilterDef: function(filterList) {
        return filterList.length > 1 ? filterList : filterList[0];
    },

    /**
     * Builds a filter definition object.
     *
     * A filter definition object is in the form of:
     *
     *     { fieldName: { operator: searchTerm } }
     *
     * @param {string} fieldName Name of the field to search by.
     * @param {string} operator Operator to search by. As found in `FilterApi#addFilters`.
     * @param {string} searchTerm Search input entered.
     *
     * @return {Object} The search filter definition for quick search.
     * @private
     */
    _buildFilterDef: function(fieldName, operator, searchTerm) {
        var def = {};
        var filter = {};
        filter[operator] = searchTerm;
        def[fieldName] = filter;
        return def;
    },

    /**
     * Joins a list of filter definitions under a logical operator.
     *
     * Supports logical operators such as `$or` and `$and`. Ultimately producing
     * a filter definition structured as:
     *
     *     { operator: filterDefs }
     *
     * @param {string} operator Logical operator to join the filter definitions by.
     * @param {Array|Object} filterDefs Array of filter definitions or individual
     *   filter definition objects.
     *
     * @return {Object|Array} Filter definitions joined under a logical operator,
     *   or a simple filter definition if `filterDefs` is of length 1,
     *   otherwise an empty `Array`.
     * @private
     */
    _joinFilterDefs: function(operator) {
        var filterDefs = Array.prototype.slice.call(arguments, 1);

        if (_.isEmpty(filterDefs)) {
            return [];
        }

        if (_.isArray(filterDefs[0])) {
            filterDefs = filterDefs[0];
        }

        // if the length of the `filterList` is less than 2, then just return the simple filter
        if (filterDefs.length < 2) {
            return filterDefs[0];
        }

        var filter = {};
        filter[operator] = filterDefs;
        return filter;
    },

    /**
     * Builds a filter object by using unique combination of the
     * searchTerm delimited by spaces.
     *
     * @param {Array} fieldNames Field within `quicksearch_field`
     *   in the metadata to perform split term filtering.
     * @param {string} operator Operator to search by. As found in `FilterApi#addFilters`.
     * @param {string} searchTerm Search input entered.
     *
     * @return {Object|undefined} The search filter definition for
     *   quick search or `undefined` if no filter to apply or supported.
     * @private
     */
    _buildSplitTermFilterDef: function(fieldNames, operator, searchTerm) {
        if (fieldNames.length > 2) {
            app.logger.error('Cannot have more than 2 fields in a complex filter');
            return;
        }

        // If the field is a split-term field, but only composed of single item
        // return the simple filter
        if (fieldNames.length === 1) {
            return this._buildFilterDef(fieldNames[0], operator, searchTerm);
        }

        var filterList = [];
        var tokens = searchTerm.split(' ');

        // When the searchTerm is composed of at least 2 terms delimited by a space character,
        // Divide the searchTerm in 2 unique sets
        // e.g. For the name "Jean Paul Durand",
        // first = "Jean", rest = "Paul Durand" (1st iteration)
        // first = "Jean Paul", rest = "Durand" (2nd iteration)
        for (var i = 1; i < tokens.length; ++i) {
            var first = _.first(tokens, i).join(' ');
            var rest = _.rest(tokens, i).join(' ');

            // FIXME the order of the filters need to be reviewed (TY-547)
            var tokenFilter = [
                this._buildFilterDef(fieldNames[0], operator, first),
                this._buildFilterDef(fieldNames[1], operator, rest)
            ];
            filterList.push(this._joinFilterDefs('$and', tokenFilter));
        }

        // Try with full search term in each field
        // e.g. `first_name: Sangyoun Kim` or `last_name: Sangyoun Kim`
        _.each(fieldNames, function(name) {
            filterList.push(this._buildFilterDef(name, operator, searchTerm));
        }, this);

        return this._joinFilterDefs('$or', filterList);
    }
}) },
"collection": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This `FiltersCollection` is designed to be used like:
 *
 *     filters = app.data.createBeanCollection('Filters');
 *     filters.setModuleName('Accounts');
 *     filters.setFilterOptions(filterOptions); // Optional
 *     filters.load({
	// Collection Data (base) 

 *         success: _.bind(function() {
 *             // You can start using `filters.collection`
 *         }, this)
 *     });
 *
 * Even though {@link #load} and {@link #collection} are the recommended way to
 * manipulate the filters of a module, you can still use this `BeanCollection`
 * in a more traditional way.
 *
 *     filters = app.data.createBeanCollection('Filters');
 *     filters.fetch({
 *         filter: [
 *             {'created_by': app.user.id},
 *             {'module_name': module}
 *         ],
 *         success: _.bind(function() {
 *             // You can start using the collection
 *         }, this)
 *     });
 *
 * **Note** that in this case you're not taking advantage of the internal cache
 * memory.
 *
 * @class Data.Base.FiltersBeanCollection
 * @extends Data.BeanCollection
 */
({
    /**
     * This is the public and recommended API for manipulating the collection
     * of filters of a module.
     *
     * {@link #load} will create this collection provided that you set the
     * module name with {@link #setModuleName}.
     *
     * @property {Backbone.Collection|null}
     */
    collection: null,

    /**
     * The filter options used by {@link #load} when retrieving and building the
     * filter collection.
     *
     * See {@link #setFilterOptions}.
     *
     * @property {Object}
     * @private
     */
    _filterOptions: {},

    /**
     * Clears the filter options for the next call to {@link #load}.
     *
     * @chainable
     */
    clearFilterOptions: function() {
        this._filterOptions = {};
        return this;
    },

    /**
     * Maintains the filters collection in sorted order.
     *
     * User's filters will be positioned first in the collection, the
     * predefined filters will be positioned second.
     *
     * @param {Data.Bean} model1 The first model.
     * @param {Data.Bean} model2 The second model.
     * @return {Number} If `-1`, the first model goes before the second model,
     *   if `1`, the first model goes after the second model.
     */
    comparator: function(model1, model2) {
        if (model1.get('editable') === false && model2.get('editable') !== false) {
            return 1;
        }
        if (model1.get('editable') !== false && model2.get('editable') === false) {
            return -1;
        }
        if (this._getTranslatedFilterName(model1).toLowerCase() < this._getTranslatedFilterName(model2).toLowerCase()) {
            return -1;
        }
        return 1;
    },

    /**
     * Retrieves the list of filters of a module.
     *
     * The list includes predefined filters (defined in the metadata) as well as
     * the current user's filters.
     *
     * The collection is saved in memory the first time filters are retrieved,
     * so next calls to {@link #load} will just return the cached version.
     *
     * **Note:** Template filters are retrieved and saved in memory but are not
     * in the collection unless you pass the `initial_filter` options. See
     * {@link #setFilterOptions}. Only one template filter can be available at
     * a time.
     *
     * @param {Object} [options]
     * @param {Function} [options.success] Callback function to execute code
     *   once the filters are successfully retrieved.
     * @param {Function} [options.error] Callback function to execute code
     *   in case an error occured when retrieving filters.
     */
    load: function(options) {
        options = options || {};

        var module = this.moduleName,
            prototype = this._getPrototype(),
            collection;

        if (!module) {
            app.logger.error('This Filters collection has no module defined.');
            return;
        }

        if (this.collection) {
            this.collection.off();
        }

        // Make sure only one request is sent for each module.
        prototype._request = prototype._request || {};
        if (prototype._request[module]) {
            prototype._request[module].xhr.done(_.bind(function() {
                this._onSuccessCallback(options.success);
            }, this));
            return;
        }

        // Try to retrieve cached filters.
        prototype._cache = prototype._cache || {};
        if (prototype._cache[module]) {
            this._onSuccessCallback(options.success);
            return;
        }

        this._initFiltersModuleCache();

        // No cache found, retrieve filters.
        this._loadPredefinedFilters();

        var requestObj = {
            showAlerts: false,
            filter: [
                {'created_by': app.user.id},
                {'module_name': module}
            ],
            success: _.bind(function(models) {
                this._cacheFilters(models);
                this._onSuccessCallback(options.success);
            }, this),
            complete: function() {
                delete prototype._request[module];
            },
            error: function() {
                if (_.isFunction(options.error)) {
                    options.error();
                } else {
                    app.logger.error('Unable to get filters from the server.');
                }
            }
        };
        prototype._request[module] = prototype.fetch.call(this, requestObj);
    },

    /**
     * Defines the module name of the filter collection. This is mandatory in
     * order to use {@link #load}.
     *
     * @param {String} module The module name.
     * @chainable
     */
    setModuleName: function(module) {
        this.moduleName = module;
        return this;
    },

    /**
     * Defines the filter options used by {@link #load}.
     *
     * **Options supported:**
     *
     * - `{String} [initial_filter]` The id of the template filter.
     *
     * - `{String} [initial_filter_lang_modules]` The list of modules to look up
     *   the filter label string.
     *
     * - `{String} [filter_populate]` The populate hash in case we want to
     *   create a relate template filter on the fly.
     *
     * Filter options can be cleared with {@link #clearFilterOptions}.
     *
     * @param {String|Object} key The name of the option, or an hash of
     *   options.
     * @param {Mixed} [val] The default value for the `key` argument.
     * @chainable
     */
    setFilterOptions: function(key, val) {
        var options;
        if (_.isObject(key)) {
            options = key;
        } else {
            (options = {})[key] = val;
        }
        this._filterOptions = _.extend({}, this._filterOptions, options);
        return this;
    },

    /**
     * Saves the list of filters in memory.
     *
     * This allows us not to parse the metadata everytime in order to get the
     * predefined and template filters, and not to fetch the API everytime in
     * order to get the user's filters.
     *
     * @param {Mixed} models A list of filters (`Backbone.Collection` or
     *   `Object[]`) or one filter (`Data.Base.FiltersBean` or `Object`).
     * @private
     */
    _cacheFilters: function(models) {
        if (!models) {
            return;
        }
        var filters = _.isFunction(models.toJSON) ? models.toJSON() : models;
        filters = _.isArray(filters) ? filters : [filters];

        var prototype = this._getPrototype();
        _.each(filters, function(filter) {
            if (filter.editable === false) {
                prototype._cache[this.moduleName].predefined[filter.id] = filter;
            } else if (filter.is_template) {
                prototype._cache[this.moduleName].template[filter.id] = filter;
            } else {
                prototype._cache[this.moduleName].user[filter.id] = filter;
            }
        }, this);
    },

    /**
     * Create the collection of filters.
     *
     * The collection contains predefined filters and the current user's
     * filters.
     *
     * @return {Backbone.Collection} The collection of filters.
     * @private
     */
    _createCachedCollection: function() {
        var prototype = app.data.getCollectionClasses().Filters.prototype,
            module = this.moduleName,
            collection;

        // Creating the collection class.
        prototype._cachedCollection = prototype._cachedCollection || Backbone.Collection.extend({
            model: app.data.getBeanClass('Filters'),
            _setInitialFilter: this._setInitialFilter,
            comparator: this.comparator,
            _getPrototype: this._getPrototype,
            _getTranslatedFilterName: this._getTranslatedFilterName,
            _cacheFilters: this._cacheFilters,
            _updateFilterCache: this._updateFilterCache,
            _removeFilterCache: this._removeFilterCache,
            initialize: function(models, options) {
                this.on('add', this._cacheFilters, this);
                this.on('cache:update', this._updateFilterCache, this);
                this.on('remove', this._removeFilterCache, this);
            }
        });

        collection = new prototype._cachedCollection();
        collection.moduleName = module;
        collection._filterOptions = this._filterOptions;
        collection.defaultFilterFromMeta = prototype._cache[module].defaultFilterFromMeta;
        // Important to pass silent `true` to avoid saving in memory again.
        collection.add(_.toArray(prototype._cache[module].predefined), {silent: true});
        collection.add(_.toArray(prototype._cache[module].user), {silent: true});

        return collection;
    },

    /**
     * Gets the translated name of a filter.
     *
     * If the model is not editable or is a template, the filter name must be
     * defined as a label that is internationalized.
     * We allow injecting the translated module name into filter names.
     *
     * @param {Data.Bean} model The filter model.
     * @return {String} The translated filter name.
     * @private
     */
    _getTranslatedFilterName: function(model) {
        var name = model.get('name') || '';

        if (model.get('editable') !== false && !model.get('is_template')) {
            return name;
        }
        var module = model.get('module_name') || this.moduleName;

        var fallbackLangModules = model.langModules || [module, 'Filters'];
        var moduleName = app.lang.getModuleName(module, {plural: true});
        var text = app.lang.get(name, fallbackLangModules) || '';
        return app.utils.formatString(text, [moduleName]);
    },

    /**
     * Loads predefined filters from metadata and stores them in memory.
     *
     * Also determines the default filter. The default filter will be the last
     * `default_filter` property found in the filters metadata.
     *
     * @private
     */
    _loadPredefinedFilters: function() {
        var cache = this._getPrototype()._cache[this.moduleName],
            moduleMeta = app.metadata.getModule(this.moduleName);

        if (!moduleMeta) {
            app.logger.error('The module "' + this.moduleName + '" has no metadata.');
            return;
        }

        var moduleFilterMeta = moduleMeta.filters;
        if (!moduleFilterMeta) {
            app.logger.error('The module "' + this.moduleName + '" has no filter metadata.');
            return;
        }

        _.each(moduleFilterMeta, function(template) {
            if (!template || !template.meta) {
                return;
            }
            if (_.isArray(template.meta.filters)) {
                this._cacheFilters(template.meta.filters);
            }
            if (template.meta.default_filter) {
                cache.defaultFilterFromMeta = template.meta.default_filter;
            }
        }, this);
    },

    /**
     * Success callback applied once filters are retrieved in order to prepare
     * the bean collection.
     *
     * @param {Function} [callback] Custom success callback. The collection is
     *   readily available as the first argument to this callback function.
     * @private
     */
    _onSuccessCallback: function(callback) {
        this.collection = this._createCachedCollection();
        if (this._filterOptions.initial_filter) {
            this.collection._setInitialFilter();
        }

        if (_.isFunction(callback)) {
            callback(this.collection);
        }
    },

    /**
     * Sets an initial/template filter to the collection.
     *
     * Filter options:
     *
     * If the `initial_filter` id is `$relate`, a new filter will be created for
     * you, and will be populated by `filter_populate` definition.
     *
     * If you pass any other `initial_filter` id, the function will look up for
     * this template filter in memory and create it.
     *
     * @private
     */
    _setInitialFilter: function() {
        var filterId = this._filterOptions.initial_filter;

        if (!filterId) {
            return;
        }

        if (filterId === '$relate') {
            var filterDef = {};
            _.each(this._filterOptions.filter_populate, function(value, key) {
                filterDef[key] = '';
            });
            this.add([
                {
                    'id': '$relate',
                    'editable': true,
                    'is_template': true,
                    'filter_definition': [filterDef]
                }
            ], {silent: true});
        } else {
            var prototype = this._getPrototype();
            var filter = prototype._cache[this.moduleName].template[filterId];
            if (!filter) {
                return;
            }
            this.add(filter, {silent: true});
        }
        this.get(filterId).set('name', this._filterOptions.initial_filter_label);
        this.get(filterId).langModules = this._filterOptions.initial_filter_lang_modules;
    },

    /**
     * Saves the list of filters in memory.
     *
     * Only user's filters are refreshed. We want to ignore changes to template
     * filters and predefined filters.
     *
     * @param {Data.Base.FiltersBean|Object} model The filter model to update in
     *   memory.
     * @param {String} model.id The filter id.
     * @private
     */
    _updateFilterCache: function(model) {
        if (!model) {
            return;
        }
        var attributes = _.isFunction(model.toJSON) ? model.toJSON() : model;
        if (attributes.is_template || attributes.editable === false) {
            return;
        }
        this._cacheFilters(model);
    },

    /**
     * Removes a filter stored in memory.
     *
     * @param {Data.Base.FiltersBean|Object} model The filter model to remove
     *   from memory.
     * @param {String} model.id The filter id.
     * @private
     */
    _removeFilterCache: function(model) {
        var prototype = this._getPrototype();
        delete prototype._cache[this.moduleName].predefined[model.id];
        delete prototype._cache[this.moduleName].template[model.id];
        delete prototype._cache[this.moduleName].user[model.id];
    },

    /**
     * Initializes the filter cache for this module.
     *
     * @private
     */
    _initFiltersModuleCache: function() {
        var prototype = this._getPrototype();
        prototype._cache = prototype._cache || {};
        prototype._cache[this.moduleName] = {
            defaultFilterFromMeta: null,
            predefined: {},
            template: {},
            user: {}
        };
    },

    /**
     * Clears all the filters and their associated HTTP requests from the cache.
     */
    resetFiltersCacheAndRequests: function() {
        var prototype = this._getPrototype();
        prototype._cache = {};
        _.each(prototype._request, function(request, module) {
            request.xhr.abort();
        });
        prototype._request = {};
    },

    /**
     * Gets the prototype object of this class.
     *
     * @return {Object} The prototype.
     * @private
     */
    _getPrototype: function() {
        return app.data.getCollectionClasses().Filters.prototype;
    },

    /**
     * Removes all the listeners.
     */
    dispose: function() {
        if (this.collection) {
            this.collection.off();
        }
        this.off();
    }
}) }
}}

},
		"UserSignatures":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {
"base": {
"model": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class Model.Datas.Base.UserSignaturesModel
 * @alias SUGAR.App.model.datas.BaseUserSignaturesModel
 * @extends Data.Bean
 */
({
	// Model Data (base) 

    /**
     * @inheritdoc
     *
     * Wraps the success callback and makes a ping call when the default signature
     * attribute has changed since we are making changes to the user
     * preferences which requires a metadata refresh.
     */
    save: function(attributes, options) {
        var success;
        var syncedAttrs = this.getSynced();
        var changedAttrs = this.changedAttributes(syncedAttrs);

        if (_.has(changedAttrs, 'is_default')) {
            options = options || {};
            success = options.success;
            options.success = function() {
                app.api.call('read', app.api.buildURL('ping'));
                if (_.isFunction(success)) {
                    success.apply(options.context, arguments);
                }
            };
        }

        return app.Bean.prototype.save.call(this, attributes, options);
    }
}) }
}}

},
		"Shippers":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Styleguide":{"fieldTemplates": {
"base": {
"date": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Styleguide.DateField
 * @alias SUGAR.App.view.fields.BaseStyleguideDateField
 * @extends View.Fields.Base.DateField
 */

({
	// Date FieldTemplate (base) 

    extendsFrom: 'DateField',

    /**
     * @inheritdoc
     */
    _dispose: function() {
        // FIXME: new date picker versions have support for plugin removal/destroy
        // we should do the upgrade in order to prevent memory leaks
        // FIXME: the base date field has a bug in disposing a datepicker field
        // that has been instantiated but not rendered.

        if (this._hasDatePicker && !_.isUndefined(this.$(this.fieldTag).data('datepicker'))) {
            $(window).off('resize', this.$(this.fieldTag).data('datepicker').place);
        }
    }
}) }
}}
,
"views": {
"base": {
"sg-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Sg-headerpane View (base) 

    className: 'headerpane',

    initialize: function(options) {
        this._super('initialize', [options]);
        var request = this.context.get('request');
        this.page = request.page_details;
        this.sections = request.page_data.docs.sections;
        this.$find = [];
    },

    _render: function() {
        var self = this,
            $optgroup = {};

        // render view
        this._super('_render');

        // styleguide guide doc search
        this.$find = $('#find_patterns');

        if (this.$find.length) {
            // build search select2 options
            $.each(this.sections, function(k, v) {
                if (!v.index) {
                    return;
                }
                $optgroup = $('<optgroup>').appendTo(self.$find).attr('label', v.title);
                $.each(v.pages, function(i, d) {
                    renderSearchOption(k, i, d, $optgroup);
                });
            });

            // search for patterns
            this.$find.on('change', function(e) {
                window.location.href = $(this).val();
            });

            // init select2 control
            this.$find.select2();
        }

        function renderSearchOption(section, page, d, optgroup) {
            $('<option>')
                .appendTo(optgroup)
                .attr('value', (d.url ? d.url : fmtLink(section, page)))
                .text(d.title);
        }

        function fmtLink(section, page) {
            return '#Styleguide/docs/' + section + (page ? '-' + page : '-index');
        }
    },

    _dispose: function() {
        this.$find.off('change');
        this._super('_dispose');
    }
}) },
"docs-dashboards-dashlets": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-dashboards-dashlets View (base) 

    // dashboard dashlets
    _renderHtml: function() {
        this._super('_renderHtml');

        // define event listeners
        app.events.on('preview:close', _.bind(function() {
            this.toggleSidebar(false);
        }, this));
        app.events.on('app:dashletPreview:close', _.bind(function() {
            this.toggleSidebar(false);
        }, this));
        app.events.on('app:dashletPreview:open', _.bind(function() {
            this.toggleSidebar(true);
        }, this));

        this.$('.dashlet-example').on('click.styleguide', _.bind(function(event) {
            var button = this.$(event.currentTarget);
            var dashlet;
            var module;
            var metadata;
            if (button.hasClass('active')) {
                this.toggleSidebar(false);
                return;
            }
            this.$('.dashlet-example').removeClass('active');
            button.addClass('active');
            app.events.trigger('app:dashletPreview:open');
            dashlet = button.data('dashlet');
            module = button.data('module') || 'Styleguide';
            metadata = app.metadata.getView(module, dashlet).dashlets[0];
            metadata.type = dashlet;
            metadata.component = dashlet;
            this.previewDashlet(metadata);
        }, this));
    },

    _dispose: function() {
        this.$('.dashlet-example').off('click.styleguide');
        this._super('_dispose');
    },

    toggleSidebar: function(state) {
        var defaultLayout = this.layout.getComponent('sidebar');
        if (defaultLayout) {
            defaultLayout.trigger('sidebar:toggle', state);
        }
        if (!state) {
            this.$('.dashlet-example').removeClass('active');
        }
    },

    /**
     * Load dashlet preview by passing preview metadata
     *
     * @param {Object} metadata Preview metadata.
     */
    previewDashlet: function(metadata) {
        var layout = this.layout.getComponent('sidebar');
        var previewLayout;
        var previousComponent;
        var index;
        var contextDef;
        var component;

        while (layout) {
            if (layout.getComponent('preview-pane')) {
                previewLayout = layout.getComponent('preview-pane').getComponent('dashlet-preview');
                break;
            }
            layout = layout.layout;
        }

        if (!previewLayout) {
            return;
        }

        previewLayout.showPreviewPanel();

        // If there is no preview property, use the config property
        if (!metadata.preview) {
            metadata.preview = metadata.config;
        }
        previousComponent = _.last(previewLayout._components);

        if (previousComponent.name !== 'dashlet-preview' && previousComponent.name !== 'preview-header') {
            index = previewLayout._components.length - 1;
            previewLayout._components[index].dispose();
            previewLayout.removeComponent(index);
        }

        component = {
            label: app.lang.get(metadata.label, metadata.preview.module),
            type: metadata.type,
            preview: true
        };

        if (metadata.preview.module || metadata.preview.link) {
            contextDef = {
                skipFetch: false,
                forceNew: true,
                module: metadata.preview.module,
                link: metadata.preview.link
            };
        } else if (metadata.module) {
            contextDef = {
                module: metadata.module
            };
        }

        component.view = _.extend({module: metadata.module}, metadata.preview, component);
        if (contextDef) {
            component.context = contextDef;
        }

        previewLayout.initComponents([{
            layout: {
                type: 'dashlet',
                label: app.lang.get(metadata.preview.label || metadata.label, metadata.preview.module),
                preview: true,
                components: [
                    component
                ]
            }
        }], this.context);

        previewLayout.loadData();
        previewLayout.render();
    }
}) },
"dashlet-tabbed": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dashlet-tabbed View (base) 

    extendsFrom: 'TabbedDashletView',

    /**
     * @inheritdoc
     *
     * @property {Number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '10'.
     * @property {String} _defaultSettings.visibility Records visibility
     *   regarding current user, supported values are 'user' and 'group',
     *   defaults to 'user'.
     */
    _defaultSettings: {
        limit: 10,
        visibility: 'user'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        options.meta = options.meta || {};
        options.meta.template = 'tabbed-dashlet';

        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     *
     * FIXME: This should be removed when metadata supports date operators to
     * allow one to define relative dates for date filters.
     */
    _initTabs: function() {
        this._super("_initTabs");

        // FIXME: since there's no way to do this metadata driven (at the
        // moment) and for the sake of simplicity only filters with 'date_due'
        // value 'today' are replaced by today's date
        var today = new Date();
        today.setHours(23, 59, 59);
        today.toISOString();

        _.each(_.pluck(_.pluck(this.tabs, 'filters'), 'date_due'), function(filter) {
            _.each(filter, function(value, operator) {
                if (value === 'today') {
                    filter[operator] = today;
                }
            });
        });
    },

   _renderHtml: function() {
        if (this.meta.config) {
            this._super('_renderHtml');
            return;
        }

        var tab = this.tabs[this.settings.get('activeTab')];

        if (tab.overdue_badge) {
            this.overdueBadge = tab.overdue_badge;
        }

        var model1 = app.data.createBean('Tasks');
        model1.set("assigned_user_id", "seed_sally_id");
        model1.set("assigned_user_name", "Sally Bronsen");
        model1.set("name", "Programmatically added task");
        model1.set("date_due", "2014-02-07T07:15:00-05:00");
        model1.set("date_due_flag", false);
        model1.set("date_start", null);
        model1.set("date_start_flag", false);
        model1.set("status", "Not Started");

        this.collection.add(model1);

        _.each(this.collection.models, function(model) {
            var pictureUrl = app.api.buildFileURL({
                module: 'Users',
                id: model.get('assigned_user_id'),
                field: 'picture'
            });
            model.set('picture_url', pictureUrl);
        }, this);

        this._super('_renderHtml');
    }
}) },
"docs-index": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-index View (base) 

    initialize: function(options) {
        this._super('initialize', [options]);
        var request = this.context.get('request');
        this.keys = request.keys;
        this.page_data = request.page_data[this.keys[0]];
    },

    /* RENDER index page
    *******************/
    _renderHtml: function() {
        var self = this,
            i = 0,
            html = '',
            chapter_key = this.keys[0],
            section_key = this.keys[1],
            section;

        if (section_key === 'index') {

            // home index call
            $.each(this.page_data.sections, function(kS, vS) {
                if (!vS.index) {
                    return;
                }

                html += (i % 3 === 0 ? '<div class="row-fluid">' : '');
                html += '<div class="span4"><h3>' +
                    '<a class="section-link" href="' +
                    (vS.url ? vS.url : self.fmtLink(kS)) + '">' +
                    vS.title + '</a></h3><p>' + vS.description + '</p><ul>';
                if (vS.pages) {
                    $.each(vS.pages, function(kP, vP) {
                        html += '<li ><a class="section-link" href="' +
                            (vP.url ? vP.url : self.fmtLink(kS, kP)) + '">' +
                            vP.title + '</a></li>';
                    });
                }
                html += '</ul></div>';
                html += (i % 3 === 2 ? '</div>' : '');

                i += 1;
            });

        } else {

            section = this.page_data.sections[section_key];

            // section index call
            $.each(section.pages, function(kP, vP) {
                html += (i % 4 === 0 ? '<div class="row-fluid">' : '');
                html += '<div class="span3"><h3>' +
                    (!vP.items ?
                        ('<a class="section-link" href="' +
                            (vP.url ? vP.url : self.fmtLink(section_key, kP)) + '">' +
                            vP.title + '</a>') :
                        vP.title
                    ) +
                    '</h3><p>' + vP.description;
                html += '</p></div>';
                html += (i % 4 === 3 ? '</div>' : '');

                i += 1;
            });
        }

        this._super('_renderHtml');

        this.$('#index-content').append('<section id="section-menu"></section>').html(html);
    },

    fmtLink: function(s, p) {
        return '#Styleguide/' + this.keys[0] + '/' + s + (p ? '-' + p : '-index');
    }

}) },
"docs-forms-editable": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-forms-editable View (base) 

  // forms editable
  _renderHtml: function () {
      this._super('_renderHtml');

      this.$('.url-editable-trigger').on('click.styleguide',function(){
        var uefield = $(this).next();
        uefield
          .html(uefield.text())
          .editable(
            function(value, settings) {
                var nvprep = '<a href="'+value+'">',
                    nvapp = '</a>',
                    value = nvprep.concat(value);
               return(value);
            },
            {onblur:'submit'}
          )
          .trigger('click.styleguide');
      });

      this.$('.text-editable-trigger').on('click.styleguide',function(){
        var uefield = $(this).next();
        uefield
          .html(uefield.text())
          .editable()
          .trigger('click.styleguide');
      });

      this.$('.urleditable-field > a').each(function(){
        if(isEllipsis($(this))===true) {
          $(this).attr({'data-original-title':$(this).text(),'rel':'tooltip','class':'longUrl'});
        }
      });

      function isEllipsis(e) { // check if ellipsis is present on el, add tooltip if so
        return (e[0].offsetWidth < e[0].scrollWidth);
      }

      this.$('.longUrl[rel=tooltip]').tooltip({placement:'top'});
  }
}) },
"docs-components-popovers": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-components-popovers View (base) 

    // components popovers
    _renderHtml: function () {
        this._super('_renderHtml');

        this.$('[rel=popover]').popover();
        this.$('[rel=popoverHover]').popover({trigger: 'hover'});
        this.$('[rel=popoverTop]').popover({placement: 'top'});
        this.$('[rel=popoverBottom]').popover({placement: 'bottom'});
    }
}) },
"views-dashlet-toolbar": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Views-dashlet-toolbar View (base) 

    plugins: ['Prettify'],

    initialize: function(options) {
        this._super('initialize', [options]);
        this.request = this.context.get('request');
    },

    _render: function() {
        this._super('_render');

        this.example = app.view.createView({
                context: this.context,
                type: 'dashlet-toolbar',
                module: 'Base',
                layout: this.layout,
                model: this.layout.model,
                readonly: true,
                meta: {
                    label: 'Example dashlet title'
                }
            });

        // override view function that relies on the dashlet layout
        this.example.toggleMinify = function(evt) {
            var $el = this.$('.dashlet-toggle > i'),
                collapsed = $el.is('.fa-chevron-up');
            this.$(".dashlet-toggle > i").toggleClass("fa-chevron-down", collapsed);
            this.$(".dashlet-toggle > i").toggleClass("fa-chevron-up", !collapsed);
        };

        this.$('#example_view').append(this.example.el);
        this.example.render();
    }
}) },
"views-list-basic": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Views-list-basic View (base) 

    plugins: ['Prettify'],

    initialize: function(options) {
        this._super('initialize', [options]);
        this.request = this.context.get('request');
    },

    _render: function() {
        this._super('_render');

        this.layout.model.set({
            full_name: 'Cpt. James Kirk',
            title: 'SC937-0176 CEC',
            do_not_call: 1,
            email: 'kirkjt@starfleet.gov',
            assigned_user_name: 'Administrator',
            list_price: 123.45,
            birthdate: '03/22/2233',
            date_end: '06/15/2319 7:50:17PM'
        });
        this.example = app.view.createView({
            context: this.context,
            type: 'list',
            module: 'Styleguide',
            layout: this.layout,
            model: this.layout.model,
            readonly: true
        });

        this.example.collection.add(this.layout.model);

        this.example._render();

        this.$('#example_view').append(this.example.el);
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Styleguide.CreateView
 * @alias SUGAR.App.view.views.StyleguideCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',
    showHelpText: false,
    showErrorDecoration: false,
    showFormHorizontal: false,
    events: {
        'click a[name=show_help_text]:not(.disabled)': 'toggleHelpText',
        'click a[name=display_error_state]:not(.disabled)': 'toggleErrorDecoration',
        'click a[name=display_form_horizontal]:not(.disabled)': 'toggleFormHorizontal'
    },

    _render: function() {
        var error_string = 'You did a bad, bad thing.';
        _.each(this.meta.panels, function(panel) {
            if (!panel.header) {
                panel.labelsOnTop = !this.showFormHorizontal;
            }
        }, this);
        if (this.showErrorDecoration) {
            _.each(this.fields, function(field) {
                if (!_.contains(['button', 'rowaction', 'actiondropdown'], field.type)) {
                    field.setMode('edit');
                    field._errors = error_string;
                    if (field.type === 'email') {
                        var errors = {email: ['primary@example.info']};
                        field.handleValidationError([errors]);
                    } else {
                        if (_.contains(['image', 'picture', 'avatar'], field.type)) {
                            field.handleValidationError(error_string);
                        } else {
                            field.decorateError(error_string);
                        }
                    }
                }
            }, this);
        }
        this._super('_render');
    },

    _renderField: function(field) {
        app.view.View.prototype._renderField.call(this, field);
        var error_string = 'You did a bad, bad thing.';
        if (!this.showHelpText) {
            field.def.help = null;
            field.options.def.help = null;
        }
    },

    toggleHelpText: function(e) {
        this.showHelpText = !this.showHelpText;
        this.render();
        e.preventDefault();
        e.stopPropagation();
    },

    toggleErrorDecoration: function(e) {
        this.showErrorDecoration = !this.showErrorDecoration;
        this.render();
        e.preventDefault();
        e.stopPropagation();
    },

    toggleFormHorizontal: function(e) {
        this.showFormHorizontal = !this.showFormHorizontal;
        this.render();
        e.preventDefault();
        e.stopPropagation();
    }
}) },
"docs-charts-colors": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-charts-colors View (base) 

    _renderHtml: function() {
        this._super('_renderHtml');

        // Chart data
        var dataDefault = {
            'properties': {
                'title': 'Sales by Section'
            },
            'data': [
                {key: 'Section 1', value: 3},
                {key: 'Section 2', value: 5},
                {key: 'Section 3', value: 7},
                {key: 'Section 4', value: 9}
            ]
        };

        var dataColors = {
            'properties': {
                'title': 'Sales by Section'
            },
            'data': [
                {key: 'Section 1', value: 3, color: '#d62728'},
                {key: 'Section 2', value: 5, color: '#ff7f0e'},
                {key: 'Section 3', value: 7, color: '#bcbd22'},
                {key: 'Section 4', value: 9, color: '#2ca02c'}
            ]
        };

        var dataClasses = {
            'properties': {
                'title': 'Sales by Section'
            },
            'data': [
                {key: 'Section 1', value: 3, classes: 'sc-fill09'},
                {key: 'Section 2', value: 5, classes: 'sc-fill03'},
                {key: 'Section 3', value: 7, classes: 'sc-fill12'},
                {key: 'Section 4', value: 9, classes: 'sc-fill05'}
            ]
        };

        // Color options
        var defaultOptions = {};
        var gradientOptions = {gradient: true};
        var graduatedOptions = {c1: '#e8e2ca', c2: '#3e6c0a', l: dataDefault.data.length};
        var graduatedGradientOptions = {c1: '#e8e2ca', c2: '#3e6c0a', l: dataDefault.data.length, gradient: true};

        // Chart models
        var chartDefault = sucrose.charts.pieChart().colorData('default', defaultOptions);
        var chartDefaultGradient = sucrose.charts.pieChart().colorData('default', gradientOptions);
        var chartData = sucrose.charts.pieChart().colorData('data', defaultOptions);
        var chartDataGradient = sucrose.charts.pieChart().colorData('data', gradientOptions);
        var chartGraduated = sucrose.charts.pieChart().colorData('graduated', graduatedOptions);
        var chartGraduatedGradient = sucrose.charts.pieChart().colorData('graduated', graduatedGradientOptions);
        var chartClasses = sucrose.charts.pieChart().colorData('class', defaultOptions);

        // Render
        d3.select('#pie1 svg')
            .datum(dataDefault)
            .call(chartDefault);

        d3.select('#pie2 svg')
            .datum(dataDefault)
            .call(chartDefaultGradient);

        d3.select('#pie3 svg')
            .datum(dataColors)
            .call(chartData);

        d3.select('#pie4 svg')
            .datum(dataColors)
            .call(chartDataGradient);

        d3.select('#pie5 svg')
            .datum(dataDefault)
            .call(chartGraduated);

        d3.select('#pie6 svg')
            .datum(dataDefault)
            .call(chartGraduatedGradient);

        d3.select('#pie7 svg')
            .datum(dataDefault)
            .call(chartClasses);

        d3.select('#pie8 svg')
            .datum(dataClasses)
            .call(chartData);
    }
}) },
"docs-forms-datetime": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-forms-datetime View (base) 

    // forms datetime
    _renderHtml: function () {
        var self = this;

        this._super('_renderHtml');

        // sugar7 date field
        //TODO: figure out how to set the date value when calling createField
        this.model.start_date = '2000-01-01T22:47:00+00:00';
        var fieldSettingsDate = {
            view: this,
            def: {
                name: 'start_date',
                type: 'date',
                view: 'edit',
                enabled: true
            },
            viewName: 'edit',
            context: this.context,
            module: this.module,
            model: this.model,
        },
        dateField = app.view.createField(fieldSettingsDate);
        this.$('#sugar7_date').append(dateField.el);
        dateField.render();

        // sugar7 datetimecombo field
        this.model.start_datetime = '2000-01-01T22:47:00+00:00';
        var fieldSettingsCombo = {
            view: this,
            def: {
                name: 'start_datetime',
                type: 'datetimecombo',
                view: 'edit',
                enabled: true
            },
            viewName: 'edit',
            context: this.context,
            module: this.module,
            model: this.model,
        },
        datetimecomboField = app.view.createField(fieldSettingsCombo);
        this.$('#sugar7_datetimecombo').append(datetimecomboField.el);
        datetimecomboField.render();

        // static examples
        this.$('#dp1').datepicker();
        this.$('#tp1').timepicker();

        this.$('#dp2').datepicker({format:'mm-dd-yyyy'});
        this.$('#tp2').timepicker({timeformat:'H.i.s'});

        this.$('#dp3').datepicker();

        var startDate = new Date(2012,1,20);
        var endDate = new Date(2012,1,25);

        this.$('#dp4').datepicker()
          .on('changeDate', function(ev){
            if (ev.date.valueOf() > endDate.valueOf()){
              self.$('#alert').show().find('strong').text('The start date can not be greater then the end date');
            } else {
              self.$('#alert').hide();
              startDate = new Date(ev.date);
              self.$('#startDate').text(self.$('#dp4').data('date'));
            }
            self.$('#dp4').datepicker('hide');
          });

        this.$('#dp5').datepicker()
          .on('changeDate', function(ev){
            if (ev.date.valueOf() < startDate.valueOf()){
              self.$('#alert').show().find('strong').text('The end date can not be less then the start date');
            } else {
              self.$('#alert').hide();
              endDate = new Date(ev.date);
              self.$('#endDate').text(self.$('#dp5').data('date'));
            }
            self.$('#dp5').datepicker('hide');
          });


        this.$('#tp3').timepicker({'scrollDefaultNow': true});

        this.$('#tp4').timepicker();
        this.$('#tp4_button').on('click', function (){
          self.$('#tp4').timepicker('setTime', new Date());
        });

        this.$('#tp5').timepicker({
          'minTime': '2:00pm',
          'maxTime': '6:00pm',
          'showDuration': true
        });

        this.$('#tp6').timepicker();
        this.$('#tp6').on('changeTime', function() {
          self.$('#tp6_legend').text('You selected: ' + $(this).val());
        });

        this.$('#tp7').timepicker({ 'step': 5 });
    },

    _dispose: function() {
        this.$('#dp4').off('changeDate');
        this.$('#dp5').off('changeDate');
        this.$('#tp4_button').off('click');
        this.$('#tp6').off('changeTime');

        this._super('_dispose');
    }
}) },
"docs-layouts-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-layouts-drawer View (base) 

    // layouts drawer
    _renderHtml: function () {
        this._super('_renderHtml');

        this.$('#sg_open_drawer').on('click.styleguide', function(){
            app.drawer.open({
                layout: 'create',
                context: {
                    create: true,
                    model: app.data.createBean('Styleguide')
                }
            });
        });
    },

    _dispose: function() {
        this.$('#sg_open_drawer').off('click.styleguide');

        this._super('_dispose');
    }
}) },
"dashlet-chart": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dashlet-chart View (base) 

    extendsFrom: 'OpportunityMetricsView',

    loadData: function (options) {
        if (this.meta.config) {
            return;
        }
        this.metricsCollection = {
          "won": {
            "amount_usdollar": 40000,
            "count": 4,
            "formattedAmount": "$30,000",
            "icon": "caret-up",
            "cssClass": "won",
            "dealLabel": "won",
            "stageLabel": "Won"
          },
          "lost": {
            "amount_usdollar": 10000,
            "count": 1,
            "formattedAmount": "$10,000",
            "icon": "caret-down",
            "cssClass": "lost",
            "dealLabel": "lost",
            "stageLabel": "Lost"
          },
          "active": {
            "amount_usdollar": 30000,
            "count": 3,
            "formattedAmount": "$30,000",
            "icon": "minus",
            "cssClass": "active",
            "dealLabel": "active",
            "stageLabel": "Active"
          }
        };
        this.chartCollection = {
          "data": [
            {
              "key": "Won",
              "value": 4,
              "classes": "won"
            },
            {
              "key": "Lost",
              "value": 1,
              "classes": "lost"
            },
            {
              "key": "Active",
              "value": 3,
              "classes": "active"
            }
          ],
          "properties": {
            "title": "Opportunity Metrics",
            "value": 8,
            "label": 8
          }
        };
        this.total = 8;
    }
}) },
"views-index": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Views-index View (base) 

    plugins: ['Prettify'],
    extendsFrom: 'StyleguideDocsIndexView'
}) },
"docs-forms-jstree": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-forms-jstree View (base) 

    // forms jstree
    _renderHtml: function () {
        var self = this;

        this._super('_renderHtml');

        this.$('#people').jstree({
            "json_data" : {
                "data" : [
                    {
                        "data" : "Sabra Khan",
                        "state" : "open",
                        "metadata" : { id : 1 },
                        "children" : [
                            {"data" : "Mark Gibson","metadata" : { id : 2 }},
                            {"data" : "James Joplin","metadata" : { id : 3 }},
                            {"data" : "Terrence Li","metadata" : { id : 4 }},
                            {"data" : "Amy McCray",
                                "metadata" : { id : 5 },
                                "children" : [
                                    {"data" : "Troy McClure","metadata" : {id : 6}},
                                    {"data" : "James Kirk","metadata" : {id : 7}}
                                ]
                            }
                        ]
                    }
                ]
            },
            "plugins" : [ "json_data", "ui", "types" ]
        })
        .bind('loaded.jstree', function () {
            // do stuff when tree is loaded
            self.$('#people').addClass('jstree-sugar');
            self.$('#people > ul').addClass('list');
            self.$('#people > ul > li > a').addClass('jstree-clicked');
        })
        .bind('select_node.jstree', function (e, data) {
            data.inst.toggle_node(data.rslt.obj);
        });
    }
}) },
"docs-layouts-tabs": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-layouts-tabs View (base) 

    // layouts tabs
    _renderHtml: function () {
        this._super('_renderHtml');

        this.$('#nav-tabs-pills')
            .find('ul.nav-tabs > li > a, ul.nav-list > li > a, ul.nav-pills > li > a')
            .on('click.styleguide', function(e){
                e.preventDefault();
                e.stopPropagation();
                $(this).tab('show');
            });
    },

    _dispose: function() {
        this.$('#nav-tabs-pills')
            .find('ul.nav-tabs > li > a, ul.nav-list > li > a, ul.nav-pills > li > a')
            .off('click.styleguide');

        this._super('_dispose');
    }
}) },
"styleguide": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Styleguide View (base) 

    initialize: function(options) {
        this._super('initialize', [options]);
        var request = this.context.get('request');
        this.page = request.page_details;
    }
}) },
"docs-components-alerts": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-components-alerts View (base) 

    // components dropdowns
    _renderHtml: function () {
        this._super('_renderHtml');

        this.$('[data-alert]').on('click', function() {

            var $button = $(this),
                level = $button.data('alert'),
                state = $button.text(),
                auto_close = ['info','success'].indexOf(level) > -1;

            app.alert.dismiss('core_meltdown_' + level);

            if (state !== 'Example') {
                $button.text('Example');
            } else {
                app.alert.show('core_meltdown_' + level, {
                    level: level,
                    messages: 'The core is in meltdown!!',
                    autoClose: auto_close,
                    onClose: function () {
                        $button.text('Example');
                    }
                });
                $button.text('Dismiss');
            }
        });
    },

    _dispose: function() {
        this.$('[data-alert]').off('click');
        app.alert.dismissAll();

        this._super('_dispose');
    }
}) },
"docs-forms-select2": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-forms-select2 View (base) 

    // forms range
    _renderHtml: function () {
        this._super('_renderHtml');

        var $this,
            ctor;

        function select2ChartSelection(chart) {
            if (!chart.id) return chart.text; // optgroup
            return svgChartIcon(chart.id);
        }

        function select2ChartResult(chart) {
            if (!chart.id) return chart.text; // optgroup
            return svgChartIcon(chart.id) + chart.text;
        }

        //
        $('select[name="priority"]').select2({minimumResultsForSearch: 7});

        //
        $('#priority').select2({minimumResultsForSearch: 7, width: '200px'});

        //
        $("#e6").select2({
            placeholder: "Search for a movie",
            minimumInputLength: 1,
            ajax: { // instead of writing the function to execute the request we use Select2's convenient helper
                url: "styleguide/content/js/select2.json",
                dataType: 'json',
                data: function (term, page) {
                    return {q:term};
                },
                results: function (data, page) { // parse the results into the format expected by Select2.
                    // since we are using custom formatting functions we do not need to alter remote JSON data
                    return {results: data.movies};
                }
            },
            formatResult: function(m) { return m.title; },
            formatSelection: function(m) { return m.title; }
        });

        //
        $this = $('#priority2');
        ctor = this.getSelect2Constructor($this);
        $this.select2(ctor);

        //
        $this = $('#state');
        ctor = this.getSelect2Constructor($this);
        ctor.formatSelection = function(state) { return state.id;};
        $this.select2(ctor);
        $('#states3').select2({width: '200px', minimumResultsForSearch: 7, allowClear: true});

        //
        $this = $('#s2_hidden');
        ctor = this.getSelect2Constructor($this);
        ctor.data = [
            {id: 0, text: 'enhancement'},
            {id: 1, text: 'bug'},
            {id: 2, text: 'duplicate'},
            {id: 3, text: 'invalid'},
            {id: 4, text: 'wontfix'}
        ];
        ctor.placeholder = "Select a issue type...";
        $this.select2(ctor);
        $('#states4').select2({width: '200px', minimumResultsForSearch: 1000, dropdownCssClass: 'select2-drop-bootstrap'});

        //
        $this = $('select[name="chart_type"]');
        ctor = this.getSelect2Constructor($this);
        ctor.dropdownCssClass = 'chart-results select2-narrow';
        ctor.width = 'off';
        ctor.minimumResultsForSearch = 9;
        ctor.formatResult = select2ChartResult;
        ctor.formatSelection = select2ChartSelection;
        ctor.escapeMarkup = function(m) { return m; };
        $this.select2(ctor);

        //
        $this = $('select[name="label_module"]');
        ctor = this.getSelect2Constructor($this);
        ctor.width = 'off';
        ctor.minimumResultsForSearch = 9;
        ctor.formatSelection = function(item) {
            return '<span class="label label-module label-module-mini label-' + item.text + '">' + item.id + '</span>';
        };
        ctor.escapeMarkup = function(m) { return m; };
        ctor.width = '55px';
        $this.select2(ctor);

        //
        $('#priority3').select2({width: '200px', minimumResultsForSearch: 7, dropdownCssClass: 'select2-drop-error'});

        //
        $('#multi1').select2({width: '100%'});
        $('#multi2').select2({width: '300px'});

        //
        $('#states5').select2({
            width: '100%',
            minimumResultsForSearch: 7,
            containerCssClass: 'select2-choices-pills-close'
        });

        //
        $('#states4').select2({
            width: '100%',
            minimumResultsForSearch: 7,
            containerCssClass: 'select2-choices-pills-close',
            formatSelection: function(item) {
                return '<span class="select2-choice-type">Link:</span><a href="javascript:void(0)" rel="' + item.id + '">' + item.text + '</a>';
            },
            escapeMarkup: function(m) { return m; }
        });

        $('.error .select .error-tooltip').tooltip({
            trigger: 'click',
            container: 'body'
        });
    },

    getSelect2Constructor: function($select) {
        var _ctor = {};
        _ctor.minimumResultsForSearch = 7;
        _ctor.dropdownCss = {};
        _ctor.dropdownCssClass = '';
        _ctor.containerCss = {};
        _ctor.containerCssClass = '';

        if ( $select.hasClass('narrow') ) {
            _ctor.dropdownCss.width = 'auto';
            _ctor.dropdownCssClass = 'select2-narrow ';
            _ctor.containerCss.width = '75px';
            _ctor.containerCssClass = 'select2-narrow';
            _ctor.width = 'off';
        }

        if ( $select.hasClass('inherit-width') ) {
            _ctor.dropdownCssClass = 'select2-inherit-width ';
            _ctor.containerCss.width = '100%';
            _ctor.containerCssClass = 'select2-inherit-width';
            _ctor.width = 'off';
        }

        return _ctor;
    }
}) },
"docs-dashboards-home": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-dashboards-home View (base) 

    // dashboards home
    _renderHtml: function () {
        var self = this;
        this._super('_renderHtml');

        this.$('.dashlet-example').on('click.styleguide', function(){
            var dashlet = $(this).data('dashlet'),
                metadata = app.metadata.getView('Home', dashlet).dashlets[0];
            metadata.type = dashlet;
            metadata.component = dashlet;
            self.layout.previewDashlet(metadata);
        });

        this.$('[data-modal]').on('click.styleguide', function(){
            var modal = $(this).data('modal');
            $(modal).appendTo('body').modal('show');
        });
    },

    _dispose: function() {
        this.$('.dashlet-example').off('click.styleguide');
        this.$('[data-modal]').off('click.styleguide');
        this._super('_dispose');
    }
}) },
"docs-components-tooltips": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-components-tooltips View (base) 

    //components tooltips
    _renderHtml: function () {
        this._super('_renderHtml');

        this.$('#tooltips').tooltip({
            selector: '[rel=tooltip]'
        });
    }
}) },
"docs-forms-buttons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-forms-buttons View (base) 

    _render: function() {
        this._super('_render');
        // button state demo
        this.$('#fat-btn').click(function () {
            var btn = $(this);
            btn.button('loading');
            setTimeout(function () {
              btn.button('reset');
            }, 3000);
        })
    }
}) },
"docs-components-dropdowns": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-components-dropdowns View (base) 

    // components dropdowns
    _renderHtml: function () {
        this._super('_renderHtml');

        this.$('#mm001demo *').on('click.styleguide', function(){ /* make this menu frozen in its state */
            return false;
        });

        this.$('*').on('click.styleguide', function(){
            /* not sure how to override default menu behaviour, catching any click, becuase any click removes class `open` from li.open div.btn-group */
            setTimeout(function(){
                this.$('#mm001demo').find('li.open .btn-group').addClass('open');
            },0.1);
        });
    },

    _dispose: function() {
        this.$('#mm001demo *').off('click.styleguide');

        this._super('_dispose');
    }
}) },
"docs-forms-layouts": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-forms-layouts View (base) 

    // forms switch
    _renderHtml: function () {
        this._super('_renderHtml');

        var self = this;

        this.$('select.select2').each(function(){
            var $this = $(this),
                ctor = self.getSelect2Constructor($this);
            $this.select2(ctor);
        });

        this.$('table td [rel=tooltip]').tooltip({
            container:'body',
            placement:'top',
            html:'true'
        });

        this.$('.error input, .error textarea').on('focus', function(){
            $(this).next().tooltip('show');
        });

        this.$('.error input, .error textarea').on('blur', function(){
            $(this).next().tooltip('hide');
        });

        this.$('.add-on')
            .tooltip('destroy')  // I cannot find where _this_ tooltip gets initialised with 'hover', so i detroy it first, -f1vlad
            .tooltip({
                trigger: 'click',
                container: 'body'
        });
    },

    _dispose: function() {
        this.$('.error input, .error textarea').off('focus');
        this.$('.error input, .error textarea').off('blur');
    },

    getSelect2Constructor: function($select) {
        var _ctor = {};
        _ctor.minimumResultsForSearch = 7;
        _ctor.dropdownCss = {};
        _ctor.dropdownCssClass = '';
        _ctor.containerCss = {};
        _ctor.containerCssClass = '';

        if ( $select.hasClass('narrow') ) {
            _ctor.dropdownCss.width = 'auto';
            _ctor.dropdownCssClass = 'select2-narrow ';
            _ctor.containerCss.width = '75px';
            _ctor.containerCssClass = 'select2-narrow';
            _ctor.width = 'off';
        }

        if ( $select.hasClass('inherit-width') ) {
            _ctor.dropdownCssClass = 'select2-inherit-width ';
            _ctor.containerCss.width = '100%';
            _ctor.containerCssClass = 'select2-inherit-width';
            _ctor.width = 'off';
        }

        return _ctor;
    }
}) },
"docs-forms-switch": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-forms-switch View (base) 

    // forms switch
    _renderHtml: function () {
        this._super('_renderHtml');

        this.$('#mySwitch').on('switch-change', function (e, data) {
            var $el = $(data.el),
                value = data.value;
        });
    },

    _dispose: function() {
        this.$('#mySwitch').off('switch-change');

        this._super('_dispose');
    }
}) },
"docs-base-labels": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-base-labels View (base) 

    module_list: [],

    _renderHtml: function () {
        this.module_list = _.without(app.metadata.getModuleNames({filter: 'display_tab', access: 'read'}), 'Home');
        this.module_list.sort();
        this._super('_renderHtml');
    }
}) },
"fields-index": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Fields-index View (base) 

    className: 'container-fluid',
    section: {},
    useTable: true,
    parent_link: '',
    tempfields: [],

    initialize: function(options) {
        this._super('initialize', [options]);
        var request = this.context.get('request');
        this.keys = request.keys;
        this.page = request.page_details;
    },

    _render: function() {
        var self = this,
            fieldTypeReq = this.context.get('content_name'),
            fieldTypes = fieldTypeReq === 'index' ? ['text', 'bool', 'date', 'datetimecombo', 'currency', 'email'] : [fieldTypeReq],
            fieldStates = ['detail', 'edit', 'error', 'disabled'],
            fieldLayouts = ['base', 'record', 'list'],
            fieldMeta = {};

        this.useTable = fieldTypeReq === 'index' ? true : false;
        this.parent_link = fieldTypeReq === 'index' ? 'docs/forms-index' : 'fields/index';
        this.tempfields = [];

        _.each(fieldTypes, function(fieldType) {

            //build meta data for field examples from model fields
            fieldMeta = _.find(self.model.fields, function(field) {
                if (field.type === 'datetime' && fieldType.indexOf('date') === 0) {
                    field.type = fieldType;
                }
                return field.type === fieldType;
            }, self);

            //insert metadata into array for hbs template
            if (fieldMeta) {
                var metaData = self.meta['template_values'][fieldType];

                if (_.isObject(metaData) && !_.isArray(metaData)) {
                    _.each(metaData, function(value, name) {
                        self.model.set(name, value);
                    }, self);
                } else {
                    self.model.set(fieldMeta.name, metaData);
                }

                self.tempfields.push(fieldMeta);
            }
        });

        if (fieldTypeReq !== 'index') {
            self.title = fieldTypeReq + ' field';
            var descTpl = app.template.getView('fields-index.' + fieldTypeReq, self.module);
            if (descTpl) {
                this.documentation = descTpl();
            } else {
                this.page.description = 'Sugar7 ' + fieldTypeReq + ' field';
            }
        }

        this._super('_render');

        //render example fields into accordion grids
        //e.g., ['text','bool','date','datetimecombo','currency','email']
        _.each(fieldTypes, function(fieldType) {

            var fieldMeta = _.find(self.tempfields, function(field) {
                    return field.type === fieldType;
                }, self);

            //e.g., ['detail','edit','error','disabled']
            _.each(fieldStates, function(fieldState) {

                //e.g., ['base','record','list']
                _.each(fieldLayouts, function(fieldLayout) {
                    var fieldTemplate = fieldState;

                    //set field view template name
                    if (fieldLayout === 'list') {
                        if (fieldState === 'edit') {
                            fieldTemplate = 'list-edit';
                        } else {
                            fieldTemplate = 'list';
                        }
                    } else if (fieldState === 'error') {
                        fieldTemplate = 'edit';
                    }

                    var fieldSettings = {
                            view: self,
                            def: {
                                name: fieldMeta.name,
                                type: fieldType,
                                view: fieldTemplate,
                                default: true,
                                enabled: fieldState === 'disabled' ? false : true
                            },
                            viewName: fieldTemplate,
                            context: self.context,
                            module: self.module,
                            model: self.model,
                            meta: fieldMeta
                        };

                    var fieldObject = app.view.createField(fieldSettings),
                        fieldDivId = '#' + fieldType + '_' + fieldState + '_' + fieldLayout;

                    //pre render field setup
                    if (fieldState !== 'detail') {
                        if (!fieldObject.plugins || !_.contains(fieldObject.plugins, 'ListEditable') || fieldLayout !== 'list') {
                            fieldObject.setMode('edit');
                        } else {
                            fieldObject.setMode('list-edit');
                        }
                    }
                    if (fieldState === 'disabled') {
                        fieldObject.setDisabled(true);
                    }

                    //render field
                    self.$(fieldDivId).append(fieldObject.el);
                    fieldObject.render();

                    //post render field setup
                    if (fieldType === 'currency' && fieldState === 'edit') {
                        fieldObject.setMode('edit');
                    }
                    if (fieldState === 'error') {
                        if (fieldType === 'email') {
                            var errors = {email: ['primary@example.info']};
                            fieldObject.decorateError(errors);
                        } else {
                            fieldObject.setMode('edit');
                            fieldObject.decorateError('You did a bad, bad thing.');
                        }
                    }
                });

            });

        });
    }
}) },
"docs-forms-file": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-forms-file View (base) 

  // components dropdowns
  _renderHtml: function () {
    this._super('_renderHtml');

    /* Custom file upload overrides and avatar widget */
    var uobj = [],
        onUploadChange = function (e) {
          var status = $(this),
              opts = 'show';
          if (this.value) {
            var this_container = $(this).parent('.file-upload').parent('.upload-field-custom'),
              value_explode = this.value.split('\\'),
              value = value_explode[value_explode.length-1];

            if ($(this).closest('.upload-field-custom').hasClass('avatar')===true) { /* hide status for avatars */
              opts = "hide";
            }

            if (this_container.next('.file-upload-status').length > 0) {
              this_container.next('.file-upload-status').remove();
            }
            this.$('<span class="file-upload-status ' + opts + ' ">' + value + '</span>').insertAfter(this_container);
          }
        },
        onUploadFocus = function () {
          $(this).parent().addClass('focus');
        },
        onUploadBlur = function () {
          $(this).parent().addClass('focus');
        };

    this.$('.upload-field-custom input[type=file]').each(function() {
      // Bind events
      $(this)
        .bind('focus', onUploadFocus)
        .bind('blur', onUploadBlur)
        .bind('change', onUploadChange);

      // Get label width so we can make button fluid, 12px default left/right padding
      var lbl_width = $(this).parent().find('span strong').width() + 24;
      $(this)
        .parent().find('span').css('width',lbl_width)
        .closest('.upload-field-custom').css('width',lbl_width);

      // Set current state
      onUploadChange.call(this);

      // Minimizes the text input part in IE
      $(this).css('width', '0');
    });

    this.$('#photoimg').on('change', function() {
      $("#preview1").html('');
      $("#preview1").html('<span class="loading">Loading...</span>');
      $("#imageform").ajaxForm({
        target: '#preview1'
      }).submit();
    });

    this.$('.preview.avatar').on('click.styleguide', function(e){
        $(this).closest('.span10').find('label.file-upload span strong').trigger('click');
    });
  },

  _dispose: function(view) {
      this.$('#photoimg').off('change');
      this.$('.preview.avatar').off('click.styleguide');
  }
}) },
"docs-layouts-modals": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-layouts-modals View (base) 

    // layouts modals
    _renderHtml: function () {
        this._super('_renderHtml');

        this.$('[rel=popover]').popover();

        this.$('.modal').tooltip({
          selector: '[rel=tooltip]'
        });
        this.$('#dp1').datepicker({
          format: 'mm-dd-yyyy'
        });
        this.$('#dp3').datepicker();
        this.$('#tp1').timepicker();
    }
}) },
"docs-forms-range": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-forms-range View (base) 

    // forms range
    _renderHtml: function () {
        this._super('_renderHtml');

        var fieldSettings = {
            view: this,
            def: {
                name: 'include',
                type: 'range',
                view: 'edit',
                sliderType: 'connected',
                minRange: 0,
                maxRange: 100,
                'default': true,
                enabled: true
            },
            viewName: 'edit',
            context: this.context,
            module: this.module,
            model: this.model,
        },
        rangeField = app.view.createField(fieldSettings);

        this.$('#test_slider').append(rangeField.el);

        rangeField.render();

        rangeField.sliderDoneDelegate = function(minField, maxField) {
            return function(value) {
                minField.val(value.min);
                maxField.val(value.max);
            };
        }(this.$('#test_slider_min'), this.$('#test_slider_max'));
    }
}) },
"docs-charts-types": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-charts-types View (base) 

    _renderHtml: function() {
        this._super('_renderHtml');

        var data = {
            'properties': {
                'title': 'Forecasting for Q1 2017',
                'groups': [
                    {'label': 'Mark Gibson'},
                    {'label': 'Terence Li'},
                    {'label': 'James Joplin'},
                    {'label': 'Amy McCray'},
                    {'label': 'My Opps'}
                ],
                'xDataType': 'ordinal',
                'yDataType': 'currency'
            },
            'data': [
                {
                    'key': 'Qualified',
                    'values': [
                        {'x': 1, 'y': 50},
                        {'x': 2, 'y': 80},
                        {'x': 3, 'y': 0},
                        {'x': 4, 'y': 100},
                        {'x': 5, 'y': 100}
                    ]
                },
                {
                    'key': 'Proposal',
                    'values': [
                        {'x': 1, 'y': 50},
                        {'x': 2, 'y': 80},
                        {'x': 3, 'y': 0},
                        {'x': 4, 'y': 100},
                        {'x': 5, 'y': 90}
                    ]
                },
                {
                    'key': 'Negotiation',
                    'values': [
                        {'x': 1, 'y': 10},
                        {'x': 2, 'y': 50},
                        {'x': 3, 'y': 0},
                        {'x': 4, 'y': 40},
                        {'x': 5, 'y': 40}
                    ]
                }
            ]
        };

        var chart = sucrose.charts.multibarChart().colorData('default');

        d3.select('#chart svg')
            .datum(data)
            .call(chart);
    }
}) },
"docs-base-icons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-base-icons View (base) 

    // base icons
    _renderHtml: function () {
        this._super('_renderHtml');

        this.$('.chart-icon').each(function(){
            var svg = svgChartIcon($(this).data('chart-type'));
            $(this).html(svg);
        });

        this.$('.filetype-thumbnail').each(function(){
            $(this).html( '<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" version="1.1" width="28" height="33"><g><path class="ft-ribbon" d="M 0,15 0,29 3,29 3,13 z" /><path d="M 3,1 20.5,1 27,8 27,32 3,32 z" style="fill:#ececec;stroke:#b3b3b3;stroke-width:1;stroke-linecap:butt;" /><path d="m 20,1 0,7 7,0 z" style="fill:#b3b3b3;stroke-width:0" /></g></svg>' );
        });

        this.$('.sugar-cube').each(function(){
            var svg = svgChartIcon('sugar-cube');
            $(this).html(svg);
        });
    }
}) },
"docs-dashboards-intel": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs-dashboards-intel View (base) 

    // dashboard intel
    _renderHtml: function () {
        var self = this;
        this._super('_renderHtml');

        this.$('.dashlet-example').on('click.styleguide', function(){
            var dashlet = $(this).data('dashlet'),
                metadata = app.metadata.getView('Home', dashlet).dashlets[0];
            metadata.type = dashlet;
            metadata.component = dashlet;
            self.layout.previewDashlet(metadata);
        });
    },

    _dispose: function() {
        this.$('.dashlet-example').off('click.styleguide');
        this._super('_dispose');
    }
}) }
}}
,
"layouts": {
"base": {
"styleguide": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Styleguide Layout (base) 

    initialize: function(options) {
        var request = {
                page_data: {},
                keys: [],
                chapter_details: {},
                section_details: {},
                page_details: {},
                parent_link: '',
                view: 'index'
            };
        var chapterName;
        var contentName;
        var chapter;
        var section;
        var page;

        chapterName = options.context.get('chapter_name');
        contentName = options.context.get('content_name');

        // load up the styleguide css if not already loaded
        //TODO: cleanup styleguide.css and add to main file
        if ($('head #styleguide_css').length === 0) {
            $('<link>')
                .attr({
                    rel: 'stylesheet',
                    href: 'styleguide/assets/css/styleguide.css',
                    id: 'styleguide_css'
                })
                .appendTo('head');
        }

        document.title = $('<span/>').html('Styleguide &#187; SugarCRM').text();

        // request.page_data = this.meta.metadata.page_data;
        request.page_data = app.metadata.getLayout(options.module, 'styleguide').metadata.chapters;

        request.keys = [chapterName];
        if (!_.isUndefined(contentName) && !_.isEmpty(contentName)) {
            Array.prototype.push.apply(request.keys, contentName.split('-'));
        }

        chapter = request.page_data[request.keys[0]];
        request.chapter_details = {
            title: chapter.title,
            description: chapter.description
        };
        if (chapter.index && request.keys.length > 1 && request.keys[1] !== 'index') {
            section = chapter.sections[request.keys[1]];
            request.section_details = {
                title: section.title,
                description: section.description
            };
            if (section.index && request.keys.length > 2 && request.keys[2] !== 'index') {
                page = section.pages[request.keys[2]];
                request.page_details = {
                    title: page.title,
                    description: page.description,
                    url: page.url
                };
                request.view = contentName;
                request.parent_link = '-' + request.keys[0][request.keys[1]];
                window.prettyPrint && prettyPrint();
            } else {
                request.page_details = request.section_details;
            }
        } else {
            request.page_details = request.chapter_details;
        }

        request.page_details.css_class = 'container-fluid';

        options.context.set('request', request);

        this._super('initialize', [options]);
    }
}) },
"fields": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Fields Layout (base) 

    plugins: ['Prettify'],
    extendsFrom: 'StyleguideStyleguideLayout'
}) },
"views": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Views Layout (base) 

    plugins: ['Prettify'],
    extendsFrom: 'StyleguideDocsLayout'
}) },
"docs": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Docs Layout (base) 

    plugins: ['Prettify'],
    extendsFrom: 'StyleguideStyleguideLayout',

    /**
     * @inheritdoc
     */
    initComponents: function(components, context, module) {
        var def;
        var main;
        var content;
        var request = this.context.get('request');

        this._super('initComponents', [components, context, module]);

        def = {
            view: {
                type: request.keys[0] + '-' + request.view,
                name: request.keys[0] + '-' + request.view,
                meta: request.page_details
            }
        };

        main = this.getComponent('sidebar').getComponent('main-pane');
        content = this.createComponentFromDef(def, this.context, this.module);
        main.addComponent(content);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var defaultLayout = this.getComponent('sidebar');
        if (defaultLayout) {
            defaultLayout.trigger('sidebar:toggle', false);
        }

        this._super('_render');
    }
}) }
}}
,
"datas": {}

},
		"Feedbacks":{"fieldTemplates": {
"base": {
"rating": {"controller": /*
 * deprecated
 */
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * Rating field will generate clickable stars that will translate those into
 * a value for the model.
 *
 * Supported properties:
 *
 * - {Number} rate How many stars to display
 * - {Number} default What is the default value of the starts
 *
 * Example:
 *     // ...
 *     array(
 *         'rate' => 3,
 *         'default' => 3,
 *     ),
 *     //...
 *
 * @class View.Fields.Base.Feedbacks.RatingField
 * @alias SUGAR.App.view.fields.BaseFeedbacksRatingField
 * @extends View.Fields.Base.BaseField
 */
({
	// Rating FieldTemplate (base) 


    /**
     * @inheritdoc
     *
     * Initializes default rate and generates stars based on that rate for
     * template.
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.def.rate = this.def.rate || 3;
        this.model.setDefault(this.name, this.def.default);
    },

    /**
     * @inheritdoc
     *
     * Fills all stars up to `this.value`. `true` means fill, `false` means not
     * filled.
     */
    format: function(value) {
        this.stars = _.map(_.range(1, this.def.rate + 1), function(n) {
            return n <= value;
        });
        return value;
    },

    /**
     * @inheritdoc
     */
    unformat: function(value) {
        return value + 1;
    },

    /**
     * @override
     * This will bind to a different event (`click` instead of `change`).
     */
    bindDomChange: function() {

        if (!this.model) {
            return;
        }

        var $el = this.$('[data-value]');
        $el.on('click', _.bind(function(evt) {
            var value = $(evt.currentTarget).data('value');
            this.model.set(this.name, this.unformat(value));
        }, this));
    },

    /**
     * @override
     * This will always render on model change.
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, this.render, this);
        }
    }

}) }
}}
,
"views": {
"base": {
"feedback": {"controller": /*
 * deprecated
 */
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * This View allows the user to provide Feedback about SugarCRM platform to a
 * GoogleDoc spreadsheet.
 *
 * The view can stay visible while the user is navigating and will use the
 * current URL when the user clicks submit. Other fields are mapped into the
 * spreadsheet and might become metadata driven in the future.
 *
 * @class View.Views.Base.Feedbacks.FeedbackView
 * @alias SUGAR.App.view.views.BaseFeedbacksFeedbackView
 * @extends View.View
 */
({
	// Feedback View (base) 

    plugins: ['ErrorDecoration'],

    events: {
        'click [data-action=submit]': 'submit',
        'click [data-action=close]': 'close'
    },

    /**
     * @inheritdoc
     *
     * During initialize we listen to model validation and if it is valid we
     * {@link #send} the Feedback.
     */
    initialize: function(options) {
        options.model = app.data.createBean('Feedbacks');
        var fieldsMeta = _.flatten(_.pluck(options.meta.panels, 'fields'));
        options.model.fields = {};
        _.each(fieldsMeta, function(field) {
            options.model.fields[field.name] = field;
        });
        this._super('initialize', [options]);
        this.context.set('skipFetch', true);

        this.model.on('validation:start', function() {
            app.alert.dismiss('send_feedback');
        });

        this.model.on('error:validation', function() {
            app.alert.show('send_feedback', {
                level: 'error',
                messages: app.lang.get('LBL_FEEDBACK_SEND_ERROR', this.module)
            });
            this.$('[data-action=submit]').removeAttr('disabled');
        }, this);

        this.model.on('validation:success', this.send, this);

        // TODO Once the view renders the button, this is no longer needed
        this.button = $(options.button);

        /**
         * The internal state of this view.
         * By default this view is closed ({@link #toggle} will call render).
         *
         * FIXME TY-1798/TY-1800 This is needed due to the bad popover plugin.
         *
         * @type {boolean}
         * @private
         */
        this._isOpen = false;

        var learnMoreUrl = 'http://www.sugarcrm.com/crm/product_doc.php?' + $.param({
            edition: app.metadata.getServerInfo().flavor,
            version: app.metadata.getServerInfo().version,
            lang: app.lang.getLanguage(),
            module: this.module,
            route: 'list'
        });
        /**
         * Aside text with all the translated links and strings to easily show
         * it in the view.
         * @type {String}
         */
        this.aside = new Handlebars.SafeString(app.lang.get('TPL_FEEDBACK_ASIDE', this.module, {
            learnMoreLink: new Handlebars.SafeString('<a href="' + learnMoreUrl + '" target="_blank">' + Handlebars.Utils.escapeExpression(
                app.lang.get('LBL_FEEDBACK_ASIDE_CLICK_MORE', this.module)
            ) + '</a>'),
            contactSupportLink: new Handlebars.SafeString('<a href="http://support.sugarcrm.com" target="_blank">' + Handlebars.Utils.escapeExpression(
                app.lang.get('LBL_FEEDBACK_ASIDE_CONTACT_SUPPORT', this.module)
            ) + '</a>')
        }));
    },

    /**
     * Initializes the popover plugin for the button given.
     *
     * @param {jQuery} button the jQuery button;
     * @private
     */
    _initPopover: function(button) {
        button.popover({
            title: app.lang.get('LBL_FEEDBACK', this.module),
            content: _.bind(function() { return this.$el; }, this),
            html: true,
            placement: 'top',
            trigger: 'manual',
            template: '<div class="popover feedback"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
        });

        // Reposition the modal so all of its contents are within the window.
        button.on('shown.bs.popover', _.bind(this._positionPopover, this));
    },

    /**
     * Sets the horizontal position of the modal.
     *
     * @private
     */
    _positionPopover: function() {
        var $popoverContainer = this.button.data()['bs.popover'].tip();
        var left;
        if (app.lang.direction === 'rtl') {
            // Leave 16px of space between lhs edge of popover and the screen.
            left = 16;
        } else {
            // Leave 16px of space between rhs edge of popover and the screen.
            left = $(window).width() - $popoverContainer.width() - 16;
        }
        $popoverContainer.css('left', left);
    },

    /**
     * Close button on the feedback view is pressed.
     *
     * @param {Event} evt The `click` event.
     */
    close: function() {
        this.toggle(false);
    },

    /**
     * Toggle this view (by re-rendering) and allow force option.
     *
     * @param {boolean} [show] `true` to show, `false` to hide, `undefined`
     *   toggles the current state.
     */
    toggle: function(show) {

        if (_.isUndefined(show)) {
            this._isOpen = !this._isOpen;
        } else {
            this._isOpen = show;
        }

        this.button.popover('destroy');


        if (this._isOpen) {
            this.render();
            this._initPopover(this.button);
            this.button.popover('show');
        }

        this.trigger(this._isOpen ? 'show' : 'hide', this, this._isOpen);
    },

    /**
     * @inheritdoc
     * During dispose destroy the popover.
     */
    _dispose: function() {
        if (this.button) {
            this.button.popover('destroy');
        }
        this._super('_dispose');
    },

    /**
     * Submit the form
     */
    submit: function(e) {

        var $btn = this.$(e.currentTarget);
        if ($btn.attr('disabled')) {
            return;
        }
        $btn.attr('disabled', 'disabled');

        this.model.doValidate();
    },

    /**
     * Sends the Feedback to google doc page.
     *
     * Populate the rest of the data into the model from different sources of
     * the app.
     */
    send: function() {

        this.model.set({
            timezone: app.user.getPreference('timezone'),
            account_type: app.user.get('type'),
            role: app.user.get('roles').join(', ') || 'n/a',
            feedback_app_path: window.location.href,
            feedback_user_browser: navigator.userAgent + ' (' + navigator.language + ')',
            feedback_user_os: navigator.platform,
            feedback_sugar_version: _.toArray(_.pick(app.metadata.getServerInfo(), 'product_name', 'version')).join(' '),
            company: app.config.systemName
        });

        var post_url = 'https://docs.google.com/forms/d/1iIdfeWma_OUUkaP-wSojZW2GelaxMOBgDq05A8PGHY8/formResponse';

        $.ajax({
            url: post_url,
            type: 'POST',
            data: {
                'entry.98009013': this.model.get('account_type'),
                'entry.1589366838': this.model.get('timezone'),
                'entry.762467312': this.model.get('role'),
                'entry.968140953': this.model.get('feedback_text'),
                'entry.944905780': this.model.get('feedback_app_path'),
                'entry.1750203592': this.model.get('feedback_user_browser'),
                'entry.1115361778': this.model.get('feedback_user_os'),
                'entry.1700062722': this.model.get('feedback_csat'),
                'entry.1926759955': this.model.get('feedback_sugar_version'),
                'entry.398692075': this.model.get('company')
            },
            dataType: 'xml',
            crossDomain: true,
            cache: false,
            context: this,
            timeout: 10000,
            success: this._handleSuccess,
            error: function(xhr) {
                if (xhr.status === 0) {
                    // the status might be 0 which is still a success from a
                    // cross domain request using xml as dataType
                    this._handleSuccess();
                    return;
                }

                app.alert.show('send_feedback', {
                    level: 'error',
                    messages: app.lang.get('LBL_FEEDBACK_NOT_SENT', this.module)
                });
            }
        });
    },

    /**
     * Handles the success of Feedback submission.
     *
     * Show the success message on top (alert), clears the model and hides the
     * view. This will allow the user to be ready for yet another feedback.
     *
     * @private
     */
    _handleSuccess: function() {
        app.alert.show('send_feedback', {
            level: 'success',
            messages: app.lang.get('LBL_FEEDBACK_SENT', this.module),
            autoClose: true
        });
        this.model.clear();
        this.toggle(false);
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Tags":{"fieldTemplates": {
"base": {
"editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.EditablelistbuttonField
 * @alias SUGAR.App.view.fields.BaseEditablelistbuttonField
 * @extends View.Fields.Base.ButtonField
 */
({
	// Editablelistbutton FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // Initialize collection
        this.collection = app.data.createBeanCollection('Tags');
    },

    /**
     * @inheritdoc
     */
    saveClicked: function() {
        var options = {
            showAlerts: true,
            success: _.bind(this.handleTagSuccess, this),
            error: _.bind(this.handleTagError, this),
        };
        this.checkForTagDuplicate(options);
    },

    /**
     * Handle fetch error
     */
    handleTagError: function() {
        app.alert.show('collections_error', {
            level: 'error',
            messages: 'LBL_TAG_FETCH_ERROR'
        });
    },

    /**
     * Handle fetch success
     * @param {array} collection
     */
    handleTagSuccess: function(collection) {
        if (collection.length > 0) {
            // duplicate found, warn user and quit
            app.alert.show('tag_duplicate', {
                level: 'warning',
                messages: app.lang.get('LBL_EDIT_DUPLICATE_FOUND', 'Tags')
            });
        } else {
            // no duplicate found, continue with save
            this.saveModel();
        }
    },

    /**
     * Check to see if new name is a duplicate
     * @param tagName
     * @param options
     */
    checkForTagDuplicate: function(options) {
        this.collection.filterDef = [{
            'name_lower': {'$equals': this.model.get('name').toLowerCase()}
        }, {
            'id': {'$not_equals': this.model.get('id')}
        }];

        this.collection.fetch(options);
    }
}) }
}}
,
"views": {
"base": {
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Tags.CreateView
 * @alias SUGAR.App.view.views.TagsCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    saveAndCreateAnotherButtonName: 'save_create_button',

    /**
     * Add event listener for the save and create another button
     * @override
     * @param options
     */
    initialize: function(options) {
        this._super("initialize", [options]);

        this.alerts = _.extend({}, this.alerts, {
            showMessageFromServerError: function(error) {
                if (!this instanceof app.view.View) {
                    app.logger.error('This method should be invoked by Function.prototype.call(),' +
                        'passing in as argument an instance of this view.');
                    return;
                }
                var name = 'server-error';
                this._viewAlerts.push(name);
                app.alert.show(name, {
                    level: 'warning',
                    messages: error.message ? error.message : 'ERR_GENERIC_SERVER_ERROR',
                    autoClose: true,
                    autoCloseDelay: 9000
                });
            }
        });
    },

    /**
     * Create new record
     * @param callback
     */
    createRecordWaterfall: function(callback) {
        var success = _.bind(function() {
            var acls = this.model.get('_acl');
            if (!_.isEmpty(acls) && acls.access === 'no' && acls.view === 'no') {
                //This happens when the user creates a record he won't have access to.
                //In this case the POST request returns a 200 code with empty response and acls set to no.
                this.alerts.showSuccessButDeniedAccess.call(this);
                callback(false);
            } else {
                this._dismissAllAlerts();
                app.alert.show('create-success', {
                    level: 'success',
                    messages: this.buildSuccessMessage(this.model),
                    autoClose: true,
                    autoCloseDelay: 10000,
                    onLinkClick: function() {
                        app.alert.dismiss('create-success');
                    }
                });
                callback(false);
            }
        }, this);
        var error = _.bind(function(model, error) {
            if (error.status == 412 && !error.request.metadataRetry) {
                this.handleMetadataSyncError(error);
            } else {
                if (error.code === 'duplicate_tag') {
                    this.alerts.showMessageFromServerError.call(this, error);
                } else if (error.status == 403) {
                    this.alerts.showNoAccessError.call(this);
                } else {
                    this.alerts.showServerError.call(this);
                }
                callback(true);
            }
        }, this);

        this.saveModel(success, error);
    },

    /**
     * Save and reload drawer to allow another save
     */
    saveAndCreateAnother: function() {
        this.initiateSave(_.bind(function() {
            //reload the drawer
            if (app.drawer) {
                app.drawer.load({
                    layout: 'create',
                    context: {
                        create: true
                    }
                });

                //Change the context on the cancel button
                app.drawer.getActiveDrawerLayout().context.on('button:' + this.cancelButtonName + ':click', this.multiSaveCancel, this);
            }
        }, this));
    },

    /**
     * When cancelling, re-render the Tags listview to show updates from previous save
     */
    multiSaveCancel: function() {
        if (app.drawer) {
            var route = app.router.buildRoute('Tags');
            app.router.navigate(route, {trigger: true});
            app.drawer.close(app.drawer.context);
        }
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Tags.PreviewView
 * @alias SUGAR.App.view.views.BaseTagsPreviewView
 * @extends View.Views.Tags.PreviewView
 */
({
	// Preview View (base) 

    extendsFrom: 'PreviewView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // Initialize collection
        this.collection_preview = app.data.createBeanCollection('Tags');
    },

    /**
     * @inheritdoc
     */
    saveClicked: function() {
        var options = {
            showAlerts: true,
            success: _.bind(this.handleTagSuccess, this),
            error: _.bind(this.handleTagError, this)
        };
        this.checkForTagDuplicate(options);
    },

    /**
     * Handle fetch error
     */
    handleTagError: function() {
        app.alert.show('collections_error', {
            level: 'error',
            messages: 'LBL_TAG_FETCH_ERROR'
        });
    },

    /**
     * Handle fetch success
     * @param {array} collection_preview
     */
    handleTagSuccess: function(collection_preview) {
        if (collection_preview.length > 0) {
            // duplicate found, warn user and quit
            app.alert.show('tag_duplicate', {
                level: 'warning',
                messages: app.lang.get('LBL_EDIT_DUPLICATE_FOUND', 'Tags')
            });
        } else {
            // no duplicate found, continue with save
            this._super('saveClicked');
        }
    },

    /**
     * Check to see if new name is a duplicate
     * @param options
     */
    checkForTagDuplicate: function(options) {
        this.collection_preview.filterDef = [{
            'name_lower': {'$equals': this.model.get('name').toLowerCase()}
        }, {
            'id': {'$not_equals': this.model.get('id')}
        }];

        this.collection_preview.fetch(options);
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Tags.RecordView
 * @alias SUGAR.App.view.views.BaseTagsRecordView
 * @extends View.Views.Base.RecordView
 */
({
	// Record View (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // Initialize collection
        this.collection = app.data.createBeanCollection('Tags');
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    saveClicked: function() {
        var options = {
            showAlerts: true,
            success: _.bind(this.handleTagSuccess, this),
            error: _.bind(this.handleTagError, this)
        };
        this.checkForTagDuplicate(options);
    },

    /**
     * Handle fetch error
     */
    handleTagError: function() {
        app.alert.show('collections_error', {
            level: 'error',
            messages: 'LBL_TAG_FETCH_ERROR'
        });
    },

    /**
     * Handle fetch success
     * @param {array} collection
     */
    handleTagSuccess: function(collection) {
        if (collection.length > 0) {
            // duplicate found, warn user and quit
            app.alert.show('tag_duplicate', {
                level: 'warning',
                messages: app.lang.get('LBL_EDIT_DUPLICATE_FOUND', 'Tags')
            });
        } else {
            // no duplicate found, continue with save
            this._super('saveClicked');
        }
    },

    /**
     * Check to see if new name is a duplicate
     * @param tagName
     * @param options
     */
    checkForTagDuplicate: function(options) {
        this.collection.filterDef = [{
            'name_lower': {'$equals': this.model.get('name').toLowerCase()}
        }, {
            'id': {'$not_equals': this.model.get('id')}
        }];

        this.collection.fetch(options);
    }
}) },
"merge-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * View for merge duplicates.
 *
 * @class View.Views.Base.Tags.MergeDuplicatesView
 * @alias SUGAR.App.view.views.BaseTagsMergeDuplicatesView
 * @extends View.Views.Base.MergeDuplicatesView
 */
({
	// Merge-duplicates View (base) 

    extendsFrom: 'MergeDuplicatesView',

    /**
     * Saves primary record and triggers `mergeduplicates:primary:saved` event on success.
     * Before saving triggers also `duplicate:unformat:field` event.
     *
     * @override Checks if the tags in the primary record are unique before saving and only saves
     * if no duplicates are found
     * @private
     */
    _savePrimary: function() {
        var self = this;
        var primaryRecordName = this.primaryRecord.get('name');
        var tagCollection = app.data.createBeanCollection('Tags');

        tagCollection.filterDef = {
            'filter': [{'name_lower': {'$equals': primaryRecordName.toLowerCase()}}]
        };

        //fetch records that have the same name as the primaryRecord name
        tagCollection.fetch({
            success: function(tags) {
                //throw a warning if the primaryRecord name is in the tagCollection
                // and it is not one of the merged records
                if (tags.length > 0 && _.isEmpty(_.intersection(_.keys(self.rowFields), _.pluck(tags.models, 'id')))) {
                    app.alert.show('tag_duplicate', {
                        level: 'warning',
                        messages: app.lang.get('LBL_EDIT_DUPLICATE_FOUND', 'Tags')
                    });
                } else {
                    var fields = self.getFieldNames().filter(function(field) {
                        return app.acl.hasAccessToModel('edit', self.primaryRecord, field);
                    }, self);

                    self.primaryRecord.trigger('duplicate:unformat:field');

                    self.primaryRecord.save({}, {
                        fieldsToValidate: fields,
                        success: function() {
                            // Trigger format fields again, because they can come different
                            // from the server (e.g: only teams checked will be in the
                            // response, and we still want to display unchecked teams on the
                            // view)
                            self.primaryRecord.trigger('duplicate:format:field');
                            self.primaryRecord.trigger('mergeduplicates:primary:saved');
                        },
                        error: function(model, error) {
                            if (error.status === 409) {
                                app.utils.resolve409Conflict(error, self.primaryRecord, function(model, isDatabaseData) {
                                    if (model) {
                                        if (isDatabaseData) {
                                            self.resetRadioSelection(model.id);
                                        } else {
                                            self._savePrimary();
                                        }
                                    }
                                });
                            }
                        },
                        lastModified: self.primaryRecord.get('date_modified'),
                        showAlerts: true,
                        viewed: true,
                        params: {verifiedUnique: true}
                    });
                }
            }
        });
    }
}) }
}}
,
"layouts": {
"base": {
"subpanels": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.Tags.SubpanelsLayout
 * @alias SUGAR.App.view.layouts.TagsSubpanelsLayout
 * @extends View.Layout.Base.SubpanelsLayout
 */
({
	// Subpanels Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // Create dynamic subpanel metadata
        var dSubpanels = app.utils.getDynamicSubpanelMetadata(options.module);

        if (dSubpanels.components) {
            _.each(dSubpanels.components, function(sub) {
                if (sub.layout) {
                    sub['override_paneltop_view'] = 'panel-top-readonly';
                }
            }, this);
        }

        // Merge dynamic subpanels with existing metadata
        options.meta = _.extend(
            options.meta || {},
            dSubpanels
        );

        // Call the parent
        this._super('initialize', [options]);
    }
}) }
}}
,
"datas": {}

},
		"Categories":{"fieldTemplates": {}
,
"views": {
"base": {
"nested-set-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.NestedSetHeaderpaneView
 * @alias SUGAR.App.view.views.BaseNestedSetHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Nested-set-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    /**
     * @inheritdoc
     */
    _renderHtml: function() {
        var titleTemplate = Handlebars.compile(this.context.get('title') || app.lang.getAppString('LBL_SEARCH_AND_SELECT')),
            moduleName = app.lang.get('LBL_MODULE_NAME', this.module);
        this.title = titleTemplate({module: moduleName});
        this._super('_renderHtml');

        this.layout.on('selection:closedrawer:fire', _.once(_.bind(function() {
            this.$el.off();
            app.drawer.close();
        }, this)));
    }
}) },
"tree": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Tree View (base) 

    plugins: ['JSTree', 'NestedSetCollection'],

    events: {
        'keyup [data-name=search]': '_keyHandler',
        'click [data-role=icon-remove]': function() {
            this.trigger('search:clear');
        }
    },

    /**
     * Default settings.
     *
     * @property {Object} _defaultSettings
     * @property {boolean} _defaultSettings.showMenu Display menu or not.
     * @property {number} _defaultSettings.liHeight Height (pixels) of row.
     */
    _defaultSettings: {
        showMenu: true,
        liHeight: 37
    },

    /**
     * Aggregated settings.
     * @property {Object} _settings
     */
    _settings: null,

    /**
     * List of overridden callbacks.
     * @property {Object} _callbacks
     */
    _callbacks: null,

    /**
     * @inheritdoc
     *
     * Add listener for 'search:clear' and 'click:add_node_button' events.
     * Init settings.
     * Init callbacks.
     */
    initialize: function(options) {
        this.on('search:clear', function() {
            var el = this.$el.find('input[data-name=search]');
            el.val('');
            this._toggleIconRemove(!_.isEmpty(el.val()));
            this.searchNodeHandler(el.val());
        }, this);
        this._super('initialize', [options]);
        this._initSettings();
        this._initCallbacks();
        this.layout.on('click:add_node_button', this.addNodeHandler, this);
    },

    /**
     * @inheritdoc
     *
     * @example Call _renderTree function with the following parameters.
     * <pre><code>
     * this._renderTree($('.tree-block'), this._settings, {
     *      onToggle: this.jstreeToggle,
     *      onSelect: this.jstreeSelect
     * });
     * </code></pre>
     */
    _renderHtml: function(ctx, options) {
        this._super('_renderHtml', [ctx, options]);
        this._renderTree($('.tree-block'), this._settings, this._callbacks);
    },

    /**
     * Initialize _settings object.
     * @return {Object}
     * @private
     */
    _initSettings: function() {
        this._settings = {
            settings: _.extend({},
                this._defaultSettings,
                this.context.get('treeoptions') || {},
                this.def && this.def.settings || {}
            )
        };
        return this;
    },

    /**
     * Initialize _callbacks object.
     * @return {Object}
     * @private
     */
    _initCallbacks: function() {
        this._callbacks = _.extend({},
            this.context.get('treecallbacks') || {},
            this.def && this.def.callbacks || {}
        );
        return this;
    },

    /**
     * Handle submit in search field.
     * @param {Event} event
     * @return {boolean}
     * @private
     */
    _keyHandler: function(event) {
        this._toggleIconRemove(!_.isEmpty($(event.currentTarget).val()));
        if (event.keyCode != 13) return false;
        this.searchNodeHandler(event);
    },

    /**
     * Append or remove an icon to the search input so the user can clear the search easily.
     * @param {boolean} addIt TRUE if you want to add it, FALSE to remove
     */
    _toggleIconRemove: function(addIt) {
        if (addIt && !this.$('i[data-role=icon-remove]')[0]) {
            this.$el.find('div[data-container=filter-view-search]').append('<i class="fa fa-times add-on" data-role="icon-remove"></i>');
        } else if (!addIt) {
            this.$('i[data-role=icon-remove]').remove();
        }
    },

    /**
     * Custom add handler.
     */
    addNodeHandler: function() {
        this.addNode(app.lang.get('LBL_DEFAULT_TITLE', this.module), 'last', false, true, false);
    },

    /**
     * Custom search handler.
     * @param {Event} event DOM event.
     */
    searchNodeHandler: function(event) {
        this.searchNode($(event.currentTarget).val());
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.off('search:clear');
        this._super('_dispose');
    }
}) }
}}
,
"layouts": {
"base": {
"nested-set-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.NestedSetListLayout
 * @alias SUGAR.App.view.layouts.BaseNestedSetListLayout
 * @extends View.Layout
 */
({
	// Nested-set-list Layout (base) 

    plugins: ['ShortcutSession'],

    shortcuts: [
        'Sidebar:Toggle'
    ],

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var fields = _.union(this.getFieldNames(), (this.context.get('fields') || []));
        this.context.set('fields', fields);
        this._super('loadData', [options]);
    }
}) }
}}
,
"datas": {}

},
		"Dashboards":{"fieldTemplates": {
"base": {
"name": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Fields.Base.DashboardsNameField
 * @alias App.view.fields.BaseDashboardsNameField
 * @extends View.Fields.Base.NameField
 */
({
	// Name FieldTemplate (base) 

    /**
     * Formats the value to be used in handlebars template and displayed on
     * screen. We are overriding this method to translate labels in the name
     * field within the Dashboard module.
     * @override
     */
    format: function(value) {
        return app.lang.get(value, this.model.get('dashboard_module'));
    }
}) }
}}
,
"views": {
"base": {
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DashboardsRecordlistView
 * @alias SUGAR.App.view.views.BaseDashboardsRecordlistView
 * @extends View.Views.Base.RecordlistView
 */
({
	// Recordlist View (base) 

    extendsFrom: 'RecordlistView',

    /**
     * @inheritdoc
     */
    getDeleteMessages: function(model) {
        var messages = {};
        var modelName = app.lang.get(model.get('name'), model.get('dashboard_module'));

        messages.confirmation = app.lang.get('LBL_DELETE_DASHBOARD_CONFIRM', this.module, {name: modelName});
        messages.success = app.lang.get('LBL_DELETE_DASHBOARD_SUCCESS', this.module, {
            name: modelName
        });
        return messages;
    }
}) },
"dashboard-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Dashboards.DashboardHeaderpaneView
 * @alias SUGAR.App.view.views.DashboardsDashboardHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Dashboard-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    buttons: null,

    editableFields: null,

    className: 'preview-headerbar',

    events: {
        'click [name=edit_button]': 'editClicked',
        'click [name=cancel_button]': 'cancelClicked',
        'click [name=create_cancel_button]': 'createCancelClicked',
        'click [name=duplicate_button]': 'duplicateClicked',
        'click [name=delete_button]': 'deleteClicked',
        'click [name=add_button]': 'addClicked',
        'click [name=collapse_button]': 'collapseClicked',
        'click [name=expand_button]': 'expandClicked'
    },

    initialize: function(options) {
        if (options.context.parent) {
            options.meta = app.metadata.getView(options.context.parent.get('module'), options.type, options.loadModule);
            options.template = app.template.getView(options.type);
        }
        this._super('initialize', [options]);
        this.context.set('dataView', '');
        this.model.on('change change:layout change:metadata', function() {
            if (this.inlineEditMode) {
                this.changed = true;
            }
        }, this);
        this.model.on('error:validation', this.handleValidationError, this);

        if (this.context.get('create')) {
            this.changed = true;
            this.action = 'edit';
            this.inlineEditMode = true;
        } else {
            this.action = 'detail';
        }
        this.buttons = {};

        this._bindEvents();
    },

    /**
     * Binds the events that are necessary for this view.
     *
     * @protected
     */
    _bindEvents: function() {
        this.context.on('record:set:state', this.setRecordState, this);
    },

    /**
     * Handles the logic done when the state changes in the record.
     * This is the callback for the `record:set:state` event.
     *
     * @param {string} state The state that the record is set to.
     */
    setRecordState: function(state) {
        this.model.trigger('setMode', state);
        this.setButtonStates(state);
        this.inlineEditMode = state === 'edit';
        this.toggleEdit(this.inlineEditMode);
    },

    editClicked: function(evt) {
        this.previousModelState = app.utils.deepCopy(this.model.attributes);
        this.inlineEditMode = true;
        this.setButtonStates('edit');
        this.toggleEdit(true);
        this.model.trigger('setMode', 'edit');
    },

    cancelClicked: function(evt) {
        this.changed = false;
        this.model.unset('updated');
        this.clearValidationErrors();
        this.setButtonStates('view');
        this.handleCancel();
        this.model.trigger('setMode', 'view');
    },

    /**
     * Create a duplicate of current dashboard and assign it to the user,
     * so that the user can make own modification on top of existing dashboards
     *
     * Some attributes are changed during the duplication:
     *  id, name, assigned_user_id, assigned_user_name, team, default_dashboard, my_favorite
     *
     * @param {Event} evt Triggered mouse event
     */
    duplicateClicked: function(evt) {
        var newModel = app.data.createBean('Dashboards');
        newModel.copy(this.model);

        var oldName = app.lang.get(newModel.get('name'), newModel.get('dashboard_module'));
        // FIXME TY-1463: Will fix the hard coding of 'Dashboards'
        var newName = app.lang.get('LBL_COPY_OF', 'Dashboards', {name: oldName});

        var newAttributes = {
            name: newName,
            my_favorite: true
        };

        // Using void 0 to follow the convention in backbone.js
        var clearAttributes = {
            id: void 0,
            assigned_user_id: void 0,
            assigned_user_name: void 0,
            team_name: void 0,
            default_dashboard: void 0
        };

        newModel.unset(clearAttributes, {silent: true});

        var options = {};
        options.success = _.bind(this._successWhileSave, this, 'add', newModel);
        options.error = this._errorWhileSave;

        newModel.save(newAttributes, options);
    },

    /**
     * Compare with last fetched data and return true if model contains changes
     *
     * See {@link app.plugins.view.editable}. Ignore the favorite icon for
     * checking for unsaved changes.
     *
     * @return {boolean} true if current model contains unsaved changes
     */
    hasUnsavedChanges: function() {
        if (this.model.get('updated')) {
            return true;
        }

        if (this.model.isNew()) {
            return this.model.hasChanged();
        }

        var changes = this.model.changedAttributes(this.model.getSynced());

        // If there are no changes, don't warn.
        if (_.isEmpty(changes)) {
            return false;
        }

        // If the only change is to my_favorite, don't warn.
        var nonFavoriteChange = _.find(changes, function(obj, key) {
            return key !== 'my_favorite';
        });

        return !_.isUndefined(nonFavoriteChange);
    },

    /**
     * @override
     *
     * The save function is handled by {@link View.Layouts.Dashboards.DashboardLayout#handleSave}.
     */
    saveClicked: $.noop,

    createCancelClicked: function(evt) {
        if (this.context.parent) {
            this.layout.navigateLayout('list');
        } else {
            app.navigate(this.context);
        }
    },

    deleteClicked: function(evt) {
        this.handleDelete();
    },

    addClicked: function(evt) {
        if (this.context.parent) {
            this.layout.navigateLayout('create');
        } else {
            var route = app.router.buildRoute(this.module, null, 'create');
            app.router.navigate(route, {trigger: true});
        }
    },

    collapseClicked: function(evt) {
        this.context.trigger('dashboard:collapse:fire', true);
    },

    expandClicked: function(evt) {
        this.context.trigger('dashboard:collapse:fire', false);
    },

    /**
     * Defer rendering until after the data loads. See #_renderHeader for more info.
     *
     * We defer rendering until after data load because by default, the fields
     * will render once on initialization and then will re-render once the data
     * is loaded. This means that while the model is being fetched, it is still
     * possible to interact with the fields, even if the field is in the wrong
     * state (such as favorite/unfavorite). Additionally, this causes a
     * distracting and annoying flickering effect.
     *
     * To avoid both the flickering effect and prevent users from accidentally
     * setting field values during data fetch, we defer rendering until after
     * the data is loaded.
     *
     * @override
     * @private
     */
    _render: function() {
        // When creating a dashboard, there is no model to load, so there is
        // no need to defer rendering.
        if (this.context.get('create')) {
            this._renderHeader();
        } else {
            this.model.once('sync', this._renderHeader, this);
        }
        return this;
    },

    /**
     * Render the view manually.
     *
     * This function handles the responsibility typically handled in _render,
     * but unlike `_render`, it is not called automatically.
     *
     * See #_render for more information.
     */
    _renderHeader: function() {
        app.view.View.prototype._render.call(this);

        this._setButtons();
        this.setButtonStates(this.context.get('create') ? 'create' : 'view');
        this.setEditableFields();
    },

    handleCancel: function() {
        this.inlineEditMode = false;
        if (!_.isEmpty(this.previousModelState)) {
            this.model.set(this.previousModelState);
        }
        this.toggleEdit(false);
    },

    /**
     * This method handles the deletion of a dashboard. It alerts the user
     * before deleting the dashboard, and if the user chooses to delete the
     * dashboard, it handles the deletion logic as well.
     *
     * @override
     */
    handleDelete: function() {
        var modelName = app.lang.get(this.model.get('name'), this.model.get('dashboard_module'));
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            // FIXME TY-1463: Will fix the hard coding of 'Dashboards'.
            messages: app.lang.get('LBL_DELETE_DASHBOARD_CONFIRM', 'Dashboards', {name: modelName}),
            onConfirm: _.bind(function() {
                var message = app.lang.get('LBL_DELETE_DASHBOARD_SUCCESS', this.module, {
                    name: modelName
                });
                this.model.destroy({
                    success: _.bind(this._successWhileSave, this, 'delete', this.model),
                    error: this._errorWhileSave,
                    //Show alerts for this request
                    showAlerts: {
                        'process': true,
                        'success': {
                            messages: message
                        }
                    }
                });
            }, this)
        });
    },

    /**
     * Handler for saving success, it navigates to the layout or
     * the page based on the context
     *
     * @param {string} change The change that's made to the model
     *  This is either 'delete' or 'add'
     * @param {Data.Bean} model The model that's changed
     * @private
     */
    _successWhileSave: function(change, model) {
        if (this.disposed) {
            return;
        }
        // If we don't have a this.context.parent, that means we are
        // navigating to a Home Dashboard, otherwise it's a RHS Dashboard
        if (!this.context || !this.context.parent) {
            var id = change === 'add' ? model.get('id') : null;
            var route = app.router.buildRoute(this.module, id);
            app.router.navigate(route, {trigger: true});
            return;
        }
        var contextBro = this.context.parent.getChildContext({module: 'Home'});
        switch (change) {
            case 'delete':
                contextBro.get('collection').remove(model);
                this.layout.navigateLayout('list');
                break;
            case 'add':
                contextBro.get('collection').add(model);
                this.layout.navigateLayout(model.get('id'));
                break;
        }
    },

    /**
     * Error handler for Dashboard saving
     *
     * @private
     */
    _errorWhileSave: function() {
        app.alert.show('error_while_save', {
            level: 'error',
            title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
            messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
        });
    },

    bindDataChange: function() {
        //empty out because dashboard header does not need to switch the button sets while model is changed
    },

    toggleEdit: function(isEdit) {
        this.toggleFields(this.editableFields, isEdit);
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.Dashboards.RecordView
 * @alias SUGAR.App.view.views.BaseDashboardsRecordView
 * @extends View.Views.Base.RecordView
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    getDeleteMessages: function() {
        var messages = {};
        var modelName = app.lang.get(this.model.get('name'), this.model.get('dashboard_module'));

        messages.confirmation = app.lang.get('LBL_DELETE_DASHBOARD_CONFIRM', this.module, {name: modelName});
        messages.success = app.lang.get('LBL_DELETE_DASHBOARD_SUCCESS', this.module, {
            name: modelName
        });

        return messages;
    }
}) }
}}
,
"layouts": {
"base": {
"dashboard": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * The outer layout of the dashboard.
 *
 * This layout contains the header view and wraps the daslet-main layout.
 * The layouts for each dashboard are stored in the server.
 *
 * @class View.Layouts.Dashboards.DashboardLayout
 * @alias SUGAR.App.view.layouts.DashboardsDashboardLayout
 * @extends View.BaseLayout
 */
({
	// Dashboard Layout (base) 

    extendsFrom: 'BaseLayout',

    className: 'row-fluid',

    //FIXME We need to remove this. TY-1132 will address it.
    dashboardLayouts: {
        'record': 'record-dashboard',
        'records': 'list-dashboard',
        'search': 'search-dashboard'
    },

    events: {
        'click [data-action=create]': 'createClicked'
    },

    error: {
        //Dashboard is a special case where a 404 here shouldn't break the page,
        //it should just send us back to the default homepage
        handleNotFoundError: function(error) {
            var currentRoute = Backbone.history.getFragment();
            if (currentRoute.substr(0, 5) === 'Home/') {
                app.router.redirect('#Home');
                //Prevent the default error handler
                return false;
            }
        },
        handleValidationError: function(error) {
            return false;
        }
    },

    /**
     * What is the current Visible State of the dashboard
     */
    dashboardVisibleState: 'open',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var context = options.context;
        var module = context.parent && context.parent.get('module') || context.get('module');

        if (options.meta && options.meta.method && options.meta.method === 'record' && !context.get('modelId')) {
            context.set('create', true);
        }

        var hasDashboardModels;

        // The dashboard can be used to display facets on the search page.
        // This is a special use case for dashboards.
        // This checks to see if we're in the search context (i.e. the search page).
        if (context.parent && context.parent.get('search')) {
            // Note that dashboard.js is initialized twice because `navigateLayout` will call initComponents directly,
            // which creates a new context for each dashboard.
            // See `navigateLayout` for more details.
            // Also note that the module for the facets dashboard is set to `Home` in the search layout metadata.
            // Therefore, we have two brother contexts, both of which are in the `Home` module.
            // One is the initial dashboard that is created when the search layout is created.
            // The other is instantiated by the dashboard's `navigateLayout` method.
            var contextBro = context.parent.getChildContext({module: 'Home'});
            hasDashboardModels = contextBro.get('collection') && contextBro.get('collection').length;
            if (hasDashboardModels) {
                context.set({
                    // For the search page, we hardcode the facet dashboard index to 0.
                    // This is possible because in search, we only allow the
                    // facets dashboard.
                    // See `loadData` for more details.
                    model: contextBro.get('collection').at(0),
                    collection: this._getNewDashboardObject('collection', context),
                    skipFetch: true
                });
            }
        }

        if (!hasDashboardModels) {
            var model = this._getNewDashboardObject('model', context);
            if (context.get('modelId')) {
                model.set('id', context.get('modelId'), {silent: true});
            }
            context.set({
                model: model,
                collection: this._getNewDashboardObject('collection', context)
            });
        }

        this._super('initialize', [options]);

        this._bindButtonEvents();

        this.model.on('setMode', function(mode) {
            if (mode === 'edit' || mode === 'create') {
                this.$('.dashboard').addClass('edit');
            } else {
                this.$('.dashboard').removeClass('edit');
            }
        }, this);

        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.listenTo(defaultLayout, 'sidebar:state:changed', function(state) {
                this.dashboardVisibleState = state;
            }, this);

            try {
                this.dashboardVisibleState = defaultLayout.isSidePaneVisible() ? 'open' : 'close';
            } catch (error) {
                // this happens when the dashboard component is initially created because the defaultLayout doesn't
                // have _hideLastStateKey key set yet.  Just ignore this for now as with the way dashboards work
                // it this code will get run again once the logic below selects which dashboard to show.
            }
        }

        if (module === 'Home' && context.has('modelId')) {
            // save it as last visit
            var lastVisitedStateKey = this.getLastStateKey();
            app.user.lastState.set(lastVisitedStateKey, context.get('modelId'));
        }
    },

    /**
     * Get the dashboard model attributes.
     *
     * @return {Object} Dashboard model fields to save.
     * @private
     */
    _getDashboardModelAttributes: function() {
        var ctx = this.context && this.context.parent || this.context;
        var dashboardModule = ctx.get('module');

        return {
            'assigned_user_id': app.user.id,
            'dashboard_module': dashboardModule,
            'view_name': dashboardModule === 'Home' ? '' : ctx.get('layout')
        };
    },

    /**
     * Binds the button events that are specific to the record pane.
     *
     * @protected
     */
    _bindButtonEvents: function() {
        this.context.on('button:save_button:click', this.handleSave, this);
    },

    /**
     * Overrides {@link View.Layout#initComponents} to trigger `change:metadata`
     * event if we are in the search results page.
     *
     * For other dashboards than the facet dashboard, `change:metadata` is
     * triggered by {@link View.Fields.Base.Home.LayoutbuttonField} but we don't
     * use this field in the facets dashboard so we need to trigger it here.
     *
     * @override
     */
    initComponents: function(components, context, module) {
        this._super('initComponents', [components, context, module]);
        if (this.isSearchContext()) {
            // For non-search dashboards, `change:metadata` is triggered by the
            // `layoutbutton.js`. We don't use this field in the facets
            // dashboard, so we need to trigger it here.
            this.model.trigger('change:metadata');
        }
    },

    /**
     * Indicates if we are in the search page or not.
     *
     * @return {boolean} `true` means we are in the search page.
     */
    isSearchContext: function() {
        return this.context.parent && this.context.parent.get('search');
    },

    /**
     * Gets the brother context.
     *
     * @param {string} module The module to get the brother context from.
     * @return {Core.Context} The brother context.
     */
    getContextBro: function(module) {
        return this.context.parent.getChildContext({module: module});
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        // Dashboards store their own metadata as part of their model.
        // For search facet dashboard, we do not want to load the dashboard
        // metadata from the database. Instead, we build the metadata below.
        if (this.isSearchContext()) {
            // The model does not have metadata the first time this function
            // is called. In subsequent calls, the model should have metadata
            // so we do not need to fetch it.
            if (this.model.has('metadata')) {
                return;
            }

            this._loadSearchDashboard();

            this.context.set('skipFetch', true);
            this.navigateLayout('search');
            return;
        }

        if (this.context.parent && !this.context.parent.isDataFetched()) {
            var parent = this.context.parent.get('modelId') ?
                this.context.parent.get('model') : this.context.parent.get('collection');

            if (parent) {
                parent.once('sync', function() {
                    this._super('loadData', [options]);
                }, this);
            }
        } else {
            this._super('loadData', [options]);
        }
    },

    /**
     * Loads the facet dashboard for the search page, and add it.
     *
     * @private
     */
    _loadSearchDashboard: function() {
        var dashboardMeta = this._getInitialDashboardMetadata();
        var model = this._getNewDashboardObject('model', this.context);
        // In `dashMeta`, we have a `metadata` property which contains all
        // the metadata needed for the dashboard.
        model.set(dashboardMeta);
        this.collection.add(model);
    },

    /**
     * Navigate to the create layout when create button is clicked.
     *
     * @param {Event} evt Mouse event.
     */
    createClicked: function(evt) {
        if (this.model.dashboardModule === 'Home') {
            var route = app.router.buildRoute(this.module, null, 'create');
            app.router.navigate(route, {trigger: true});
        } else {
            this.navigateLayout('create');
        }
    },

    /**
     * Places only components that include the Dashlet plugin and places them in the 'main-pane' div of
     * the dashlet layout.
     * @param {app.view.Component} component
     * @private
     */
    _placeComponent: function(component) {
        var dashboardEl = this.$('[data-dashboard]');
        var css = this.context.get('create') ? ' edit' : '';

        if (dashboardEl.length === 0) {
            dashboardEl = $('<div></div>').attr({
                'class': 'cols row-fluid'
            });
            this.$el.append(
                $('<div></div>')
                    .addClass('dashboard' + css)
                    .attr({'data-dashboard': 'true'})
                    .append(dashboardEl)
            );
        } else {
            dashboardEl = dashboardEl.children('.row-fluid');
        }
        dashboardEl.append(component.el);
    },

    /**
     * If current context doesn't contain dashboard model id,
     * it will trigger set default dashboard to create default metadata
     */
    bindDataChange: function() {
        if (this.isSearchContext()) {
            return;
        }
        var modelId = this.context.get('modelId');
        if (!(modelId && this.context.get('create')) && this.collection) {
            // On the search page, we don't want to save the facets dashboard
            // in the database, so we don't need to listen to changes on the
            // collection nor do we need to call `setDefaultDashboard`.
            this.collection.on('reset', this.setDefaultDashboard, this);
        }
    },

    /**
     * Set or render the appropriate dashboard for display.
     *
     * The appropriate dashboard is selected using this order of preference:
     * 1. The last viewed dashboard
     * 2. The last modified default dashboard
     * 3. The last modified favorite dashboard
     * 4. Render dashboard-empty template
     */
    setDefaultDashboard: function() {
        if (this.disposed) {
            return;
        }
        var lastVisitedStateKey = this.getLastStateKey();
        var lastViewed = app.user.lastState.get(lastVisitedStateKey);
        var model;

        // FIXME: SC-4915 will change this to rely on the `hidden` context flag
        // instead.
        var hasParentContext = this.context && this.context.parent;
        var parentModule = hasParentContext && this.context.parent.get('module') || 'Home';

        // this.collection contains all the default and favorited dashboards
        // ordered by date modified (descending).
        if (this.collection.length > 0) {
            var currentModule = this.context.get('module');

            // Use the last viewed dashboard.
            if (lastViewed) {
                var lastVisitedModel = this.collection.get(lastViewed);
                // It should navigate to the last viewed dashboard if available,
                // and it should clean out the cached record in lastState
                if (!_.isEmpty(lastVisitedModel)) {
                    app.user.lastState.set(lastVisitedStateKey, '');
                    model = lastVisitedModel;
                }
            }

            // If there is no dashboard found yet,
            // use the last modified default dashboard.
            if (!model) {
                model = _.find(this.collection.models, function(model) {
                    return model.get('default_dashboard');
                });
            }

            // If there is no dashboard found yet,
            // use the last modified favorite dashboard.
            if (!model) {
                // If we get in here, there are no default dashboards in the
                // collection, so the collection only has favorite dashboards.
                model = _.first(this.collection.models);
            }

            if (currentModule == 'Home' && _.isString(lastViewed) && lastViewed.indexOf('bwc_dashboard') !== -1) {
                app.router.navigate(lastViewed, {trigger: true});
            } else {
                // use the _navigate helper
                this._navigate(model);
            }
            // There are no favorite or default dashboards, so the collection
            // is empty.
        } else {
            this._renderEmptyTemplate();
        }
    },

    /**
     * Gets initial dashboard metadata
     *
     * @return {Object} dashboard metadata
     * @private
     */
    _getInitialDashboardMetadata: function() {
        var layoutName = this.dashboardLayouts[this.context.parent && this.context.parent.get('layout') || 'record'];
        var initDash = app.metadata.getLayout(this.model.dashboardModule, layoutName) || {};
        return initDash;
    },

    /**
     * Build the cache key for last visited dashboard
     * Combine parent module and view name to build the unique id
     *
     * @return {string} hash key.
     */
    getLastStateKey: function() {
        if (this._lastStateKey) {
            return this._lastStateKey;
        }

        var model = this.context.get('model');
        var view = model.get('view_name');
        var module = model.dashboardModule;
        var key = module + '.' + view;

        this._lastStateKey = app.user.lastState.key(key, this);
        return this._lastStateKey;
    },

    /**
     * Utility method to use when trying to figure out how we need to navigate when switching dashboards
     *
     * @param {Backbone.Model} (dashboard) The dashboard we are trying to navigate to
     * @private
     */
    _navigate: function(dashboard) {
        if (this.disposed) {
            return;
        }

        var hasParentContext = (this.context && this.context.parent);
        var hasModelId = (dashboard && dashboard.has('id'));
        var actualModule = (hasParentContext) ? this.context.parent.get('module') : this.module;
        var isHomeModule = (actualModule === 'Home');

        if (hasParentContext && hasModelId) {
            // we are on a module and we have an dashboard id
            this._navigateLayout(dashboard.get('id'));
        } else if (hasParentContext && !hasModelId) {
            // we are on a module but we don't have a dashboard id
            this._navigateLayout('list');
        } else if (!hasParentContext && hasModelId && isHomeModule) {
            // we on the Home module and we have a dashboard id
            app.navigate(this.context, dashboard);
        } else if (isHomeModule) {
            // we on the Home module and we don't have a dashboard
            var route = app.router.buildRoute(this.module);
            app.router.navigate(route, {trigger: true});
        }
    },

    /**
     * Intercept the navigateLayout calls to make sure that the dashboard we are currently on didn't change.
     * If it did, we need to prompt and make sure they want to continue or cancel.
     *
     * @param {string} dashboard What dashboard do we want to display
     * @return {boolean}
     * @private
     */
    _navigateLayout: function(dashboard) {
        var onConfirm = _.bind(function() {
            this.navigateLayout(dashboard);
        }, this);
        var headerpane = this.getComponent('dashboard-headerpane');

        // if we have a headerpane and it was changed then run the warnUnsavedChanges method
        if (headerpane && headerpane.changed) {
            return headerpane.warnUnsavedChanges(
                onConfirm,
                undefined,
                _.bind(function() {
                    // when the cancel button is presses, we need to clear out the collection
                    // because it messes with the add dashlet screen.
                    this.collection.reset([], {silent: true});
                }, this)
            );
        }

        // if we didn't have a headerpane or we did have one, but nothing changed, just run the normal method
        onConfirm();
    },

    /**
     * For the RHS dashboard, this method loads entire dashboard component
     *
     * @param {string} id dashboard id. This id can be the dashboard id, or
     * the following strings: create, list, search.
     * @param {string} type (Deprecated) the dashboard type.
     */
    navigateLayout: function(id, type) {
        if (!_.isUndefined(type)) {
            // TODO: Remove the `type` parameter. This is to be done in TY-654
            app.logger.warn('The `type` parameter to `View.Layouts.Dashboards.DashboardLayout.navigateLayout`' +
                'has been deprecated since 7.9.0.0. Please update your code to stop using it.');
        }
        var layout = this.layout;
        var lastVisitedStateKey = this.getLastStateKey();
        this.dispose();

        //if dashboard layout navigates to the different dashboard,
        //it should store last visited dashboard id.
        if (!_.contains(['create', 'list'], id)) {
            app.user.lastState.set(lastVisitedStateKey, id);
        }

        var ctxVars = {};
        if (id === 'create') {
            ctxVars.create = true;
        } else if (id !== 'list') {
            ctxVars.modelId = id;
        }

        // For search dashboards, use the search-dashboard-headerpane
        var headerPane;
        if (id === 'search') {
            headerPane = {
                view: 'search-dashboard-headerpane'
            };
        } else {
            headerPane = {
                view: 'dashboard-headerpane',
                loadModule: 'Dashboards'
            };
        }

        var component = {
            // Note that we reinitialize the dashboard layout itself, creating a new context (forceNew: true)
            layout: {
                type: 'dashboard',
                components: (id === 'list') ? [] : [
                    headerPane,
                    {
                        layout: 'dashlet-main'
                    }
                ],
                last_state: {
                    id: 'last-visit'
                }
            },
            context: _.extend({
                module: 'Home',
                forceNew: true
            }, ctxVars),
            loadModule: 'Dashboards'
        };
        layout.initComponents([component]);

        layout.removeComponent(0);
        layout.loadData({});
        layout.render();
    },

    /**
     * @inheritdoc
     */
    unbindData: function() {
        if (this.collection) {
            this.collection.off('reset', this.setDefaultDashboard, this);
        }

        if (this.context.parent) {
            var model = this.context.parent.get('model');
            var collection = this.context.parent.get('collection');

            if (model) {
                model.off('sync', null, this);
            }
            if (collection) {
                collection.off('sync', null, this);
            }
        }

        this._super('unbindData');
    },

    /**
     * Returns a Dashboard Model or Dashboard Collection based on modelOrCollection
     *
     * @param {string} modelOrCollection The return type, 'model' or 'collection'
     * @param {Object} context
     * @return {Bean|BeanCollection}
     * @private
     */
    _getNewDashboardObject: function(modelOrCollection, context) {
        var obj;
        var ctx = context && context.parent || context;
        var module = ctx.get('module') || context.get('module');
        var layoutName = ctx.get('layout') || '';

        /**
         * Overrides the datamanager sync with dashboard specific functionality.
         *
         * sync overrides {@link Data.DataManager#sync}.
         */
        var sync = function(method, model, options) {
            var callbacks = app.data.getSyncCallbacks(method, model, options);

            var getEditableFields = function() {
                var fieldNames = _.keys(model.attributes);

                var editableFields = _.filter(fieldNames, function(fieldName) {
                    return app.acl.hasAccess('edit', 'Dashboards', {field: fieldName});
                });

                if (editableFields.indexOf('id') < 0) {
                    editableFields.push('id');
                }

                return model.toJSON({
                    fields: editableFields
                });
            };

            // When favoriting, use the favorite endpoint to be consistent
            // with the rest of sidecar.
            if (options.favorite) {
                return app.api.favorite(
                    'Dashboards',
                    model.id,
                    model.isFavorite(),
                    callbacks,
                    options.apiOptions
                );
            }

            options = app.data.parseOptionsForSync(method, model, options);
            // There is no max limit for number of dashboards per module view.
            if (options && options.params) {
                options.params.max_num = -1;
            }
            if (_.isEmpty(options.params)) {
                options.params = {};
            }
            options.params.filter = [{
                'dashboard_module': module,
                '$or': [
                    {'$favorite': ''},
                    {'default_dashboard': 1}
                ]
            }];

            options.order_by = {'date_modified': 'DESC'};
            if (module !== 'Home') {
                options.params.filter.push({view_name: layoutName});
            }

            app.data.trigger('data:sync:start', method, model, options);
            model.trigger('data:sync:start', method, options);

            // Only update the fields that the current user is allowed to modify
            app.api.records(method, model.apiModule, getEditableFields(), options.params, callbacks);
        };

        if (module === 'Home') {
            layoutName = '';
        }
        switch (modelOrCollection) {
            case 'model':
                obj = this._getNewDashboardModel(module, layoutName, sync);
                break;

            case 'collection':
                obj = this._getNewDashboardCollection(module, layoutName, sync);
                break;
        }

        return obj;
    },

    /**
     * Returns a new Dashboard Bean with proper view_name and sync function set.
     *
     * @param {string} module The name of the module we're in
     * @param {string} layoutName The name of the layout
     * @param {Function} syncFn The sync function to use
     * @param {boolean} [getNew=true] If you want a new instance or just the
     *   Dashboard definition.
     * @return {Dashboard} a new Dashboard Bean
     * @private
     */
    _getNewDashboardModel: function(module, layoutName, syncFn, getNew) {
        getNew = (_.isUndefined(getNew)) ? true : getNew;
        var Dashboard = app.Bean.extend({
            sync: syncFn,
            apiModule: 'Dashboards',
            module: 'Home',
            dashboardModule: module,
            maxColumns: (module === 'Home') ? 3 : 1,
            minColumnSpanSize: (module === 'Home') ? 4 : 12,
            defaults: {
                view_name: layoutName
            },
            fields: {}
        });
        return (getNew) ? new Dashboard() : Dashboard;
    },

    /**
     * Returns a new DashboardCollection with proper view_name and sync function set
     *
     * @param {string} module The name of the module we're in
     * @param {string} layoutName The name of the layout
     * @param {Function} syncFn The sync function to use
     * @param {boolean} [getNew=true] If you want a new instance or just the
     *   DashboardCollection definition.
     * @return {DashboardCollection} A new Dashboard BeanCollection
     * @private
     */
    _getNewDashboardCollection: function(module, layoutName, syncFn, getNew) {
        getNew = (_.isUndefined(getNew)) ? true : getNew;

        var Dashboard = this._getNewDashboardModel(module, layoutName, syncFn, false);
        var DashboardCollection = app.BeanCollection.extend({
            sync: syncFn,
            apiModule: 'Dashboards',
            module: 'Home',
            dashboardModule: module,
            model: Dashboard
        });

        return (getNew) ? new DashboardCollection() : DashboardCollection;
    },

    /**
     * Collects params for Dashboard model save
     *
     * @return {Object} The dashboard model params to pass to its save function
     * @private
     */
    _getDashboardModelSaveParams: function() {
        var params = {
            silent: true,
            //Don't show alerts for this request
            showAlerts: false
        };

        params.error = _.bind(this._renderEmptyTemplate, this);

        params.success = _.bind(function(model) {
            if (!this.disposed) {
                this._navigate(model);
            }
        }, this);

        return params;
    },

    /**
     * Gets the empty dashboard layout template
     * and renders it to <pre><code>this.$el</code></pre>
     *
     * @private
     */
    _renderEmptyTemplate: function() {
        var tplName = this.type || this.name;
        var template = app.template.getLayout(tplName + '.dashboard-empty');

        this.$el.html(template(this));
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var defaultLayout = this.closestComponent('sidebar');
        if (defaultLayout) {
            this.stopListening(defaultLayout);
        }

        this.dashboardLayouts = null;
        this._super('_dispose');
    },

    /**
     * Saves the dashboard to the server.
     */
    handleSave: function() {
        var attributes = this._getDashboardModelAttributes();

        // Favorite new dashboards by default
        if (!this.model.get('id')) {
            attributes.my_favorite = true;
        }

        this.model.save(attributes, {
            showAlerts: true,
            fieldsToValidate: {
                'name': {
                    required: true
                },
                'metadata': {
                    required: true
                }
            },
            success: _.bind(function() {
                this.model.unset('updated');
                if (this.context.get('create')) {
                    // We have a parent context only for dashboards in the RHS.
                    if (this.context.parent) {
                        this.getContextBro('Home').get('collection').add(this.model);
                        this.navigateLayout(this.model.id);
                    } else {
                        app.navigate(this.context, this.model);
                    }
                } else {
                    this.context.trigger('record:set:state', 'view');
                }
            }, this),
            error: function() {
                app.alert.show('error_while_save', {
                    level: 'error',
                    title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                    messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                });
            }
        });
    }
}) }
}}
,
"datas": {}

},
		"OutboundEmail":{"fieldTemplates": {
"base": {
"name": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.OutboundEmail.NameField
 * @alias SUGAR.App.view.fields.BaseOutboundEmailNameField
 * @extends View.Fields.Base.NameField
 */
({
	// Name FieldTemplate (base) 

    extendsFrom: 'BaseNameField',

    /**
     * Adds help text (LBL_SYSTEM_ACCOUNT) for the system account. Be aware
     * that this will replace any help text that is defined in metadata.
     *
     * @inheritdoc
     */
    _render: function() {
        if (this.model.get('type') === 'system') {
            this.def.help = 'LBL_SYSTEM_ACCOUNT';
        }

        return this._super('_render');
    }
}) },
"email-provider": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.OutboundEmail.EmailProviderField
 * @alias SUGAR.App.view.fields.BaseOutboundEmailEmailProviderField
 * @extends View.Fields.Base.RadioenumField
 */
({
	// Email-provider FieldTemplate (base) 

    extendsFrom: 'RadioenumField',

    /**
     * Falls back to the detail template when attempting to load the disabled
     * template.
     *
     * @inheritdoc
     */
    _getFallbackTemplate: function(viewName) {
        // Don't just return "detail". In the event that "nodata" or another
        // template should be the fallback for "detail", then we want to allow
        // the parent method to determine that as it always has.
        if (viewName === 'disabled') {
            viewName = 'detail';
        }

        return this._super('_getFallbackTemplate', [viewName]);
    }
}) },
"email-address": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.OutboundEmail.EmailAddressField
 * @alias SUGAR.App.view.fields.BaseOutboundEmailEmailAddressField
 * @extends View.Fields.Base.RelateField
 */
({
	// Email-address FieldTemplate (base) 

    extendsFrom: 'RelateField',

    /**
     * @inheritdoc
     *
     * This field should only ever be a single-select.
     */
    initialize: function(options) {
        options = options || {};
        options.def.isMultiSelect = false;

        this._super('initialize', [options]);

        // Use the RelateField templates.
        this.type = 'relate';

        // Semi-colon can only appear inside quotation marks in an email
        // address. Such a case is unlikely, so it is safer than a pipe,
        // which can appear in an email address without quotes.
        this._separator = ':';
    },

    /**
     * @inheritdoc
     *
     * Adds a `createSearchChoice` option.
     *
     * @see EmailAddressField#_createSearchChoice
     */
    _getSelect2Options: function() {
        var options = this._super('_getSelect2Options');

        options.createSearchChoice = _.bind(this._createSearchChoice, this);

        return options;
    },

    /**
     * Adds a new choice to the dropdown when the search term is a valid email
     * address that doesn't match any search results. This allows the user to
     * enter a new email address that doesn't yet exist in the database.
     *
     * @param {string} term The partial or full email address the user has
     * entered.
     * @return {Object|null} Returns `null` when the email address isn't valid
     * and should not be added to the dropdown.
     * @private
     */
    _createSearchChoice: function(term) {
        var $select2 = this._getSelect2();
        var hasContext = !!($select2 && $select2.context);
        var hasChoice = !!(hasContext && $select2.context.findWhere({email_address: term}));

        // Note: When `hasContext` is false, something went wrong with
        // associating the search collection with Select2. This leaves open the
        // possibility that the entered email address already exists. We allow
        // the user to select the choice anyway, and an attempt will be made to
        // create the email address. `EmailAddressesApi` will recognize the
        // duplicate email address and return the ID of the existing email
        // address. This will yield the same behavior as if searching had
        // worked as expected.

        if (!hasChoice && app.utils.isValidEmailAddress(term)) {
            // Add this choice to the search context so that the Select2 change
            // event handler can find the option among the results.
            if (hasContext) {
                $select2.context.add({
                    id: term,
                    email_address: term
                });
            }

            return {
                id: term,
                text: term
            };
        }

        return null;
    },

    /**
     * @inheritdoc
     *
     * When the selection is a new email address, that email address is created
     * on the server and the result is asynchronously applied to the model such
     * that the Select2 instance obtains the new ID for the email address.
     */
    _onFormatSelection: function(obj) {
        var email;
        var success;
        var error;
        var complete;

        if (obj.id === obj.text) {
            /**
             * Update the ID field with the ID of the newly created model.
             *
             * @param {Data.Bean} model The created EmailAddresses model.
             */
            success = _.bind(function(model) {
                this.setValue({
                    id: model.get('id'),
                    value: model.get('email_address')
                });
            }, this);

            /**
             * Clear the selection on an error when creating the model.
             */
            error = _.bind(function() {
                this.setValue({
                    id: '',
                    value: ''
                });
            }, this);

            /**
             * Remove the choice from the search context so that the Select2
             * change event doesn't ever find the option among its results. The
             * temporary option is replaced by the option that was created on
             * the server.
             *
             * Enables the action buttons once the request is done.
             */
            complete = _.bind(function() {
                var $select2 = this._getSelect2();

                if ($select2 && $select2.context) {
                    $select2.context.remove(obj.id);
                }

                if (_.isFunction(this.view.toggleButtons)) {
                    this.view.toggleButtons(true);
                }
            }, this);

            // Disable the action buttons while creating the new email address.
            if (_.isFunction(this.view.toggleButtons)) {
                this.view.toggleButtons(false);
            }

            email = app.data.createBean(this.getSearchModule(), {email_address: obj.text});
            email.save(null, {
                success: success,
                error: error,
                complete: complete
            });
        }

        return this._super('_onFormatSelection', [obj]);
    },

    /**
     * Convenience method for getting this field's Select2 instance.
     *
     * @return {Select2|undefined}
     * @private
     */
    _getSelect2: function() {
        var $el = this.$(this.fieldTag);

        return $el.data('select2');
    }
}) }
}}
,
"views": {}
,
"layouts": {}
,
"datas": {
"base": {
"model": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class Model.Datas.Base.OutboundEmailModel
 * @alias SUGAR.App.model.datas.BaseOutboundEmailModel
 * @extends Data.Bean
 */
({
	// Model Data (base) 

    /**
     * @inheritdoc
     *
     * Defaults `name` to the current user's full name and `email_address` and
     * `email_address_id` to the requisite values representing the current
     * user's primary email address.
     */
    initialize: function(attributes) {
        var defaults = {};
        var email = app.user.get('email');
        var privateTeamId = app.user.get('private_team_id');
        var privateTeam = _.findWhere(app.user.get('my_teams'), {id: privateTeamId});
        var privateTeamName = privateTeam ? privateTeam.name : '';

        defaults.name = app.user.get('full_name');
        defaults.email_address = app.utils.getPrimaryEmailAddress(app.user);
        defaults.email_address_id = _.chain(email)
            .findWhere({email_address: defaults.email_address})
            .pick('email_address_id')
            .values()
            .first()
            .value();
        defaults.team_name = [{id: privateTeamId, name: privateTeamName, primary: true}];
        this._defaults = _.extend({}, this._defaults, defaults);
        app.Bean.prototype.initialize.call(this, attributes);
    }
}) }
}}

},
		"EmailParticipants":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {
"base": {
"model": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class Model.Datas.Base.EmailParticipantsModel
 * @alias SUGAR.App.model.datas.BaseEmailParticipantsModel
 * @extends Data.Bean
 */
({
	// Model Data (base) 

    /**
     * @inheritdoc
     *
     * Patches the model with the parent's name if the name is empty, but it
     * can be computed from other attributes.
     */
    set: function(key, val, options) {
        var result = app.Bean.prototype.set.call(this, key, val, options);
        var parent = this.getParent();
        var name;

        // If the name field is empty but other fields are present, then it may
        // be possible to construct the name. We try to do that before assuming
        // the name can't be found.
        if (parent && !parent.get('name') && !app.utils.isNameErased(parent)) {
            name = app.utils.getRecordName(parent);

            // Replicate the name to all of the fields on the model that
            // contain the name, so we don't have to construct it again.
            if (name) {
                this.get('parent').name = name;
                this.set('parent_name', name);
            }
        }

        return result;
    },

    /**
     * Returns a string representing the email participant in the format that
     * would be used for an address in an email address header. Note that the
     * name is not surrounded by quotes unless the `surroundNameWithQuotes`
     * parameter is `true`.
     *
     * @example
     * // With name and email address.
     * Will Westin <will@example.com>
     * @example
     * // Without name.
     * will@example.com
     * @example
     * // Surround name with quotes.
     * "Will Westin" <will@example.com>
     * @example
     * // Name has been erased via a data privacy request.
     * Value erased <will@example.com>
     * @example
     * // Email address has been erased via a data privacy request.
     * Will Westin <Value erased>
     * @param {Object} [options]
     * @param {boolean} [options.quote_name=false]
     * @return {string}
     */
    toHeaderString: function(options) {
        var name = this.get('parent_name') || '';
        var email = this.get('email_address') || '';

        options = options || {};

        // The name was erased, so let's use the label.
        if (_.isEmpty(name) && this.isNameErased()) {
            name = app.lang.get('LBL_VALUE_ERASED', this.module);
        }

        // The email was erased, so let's use the label.
        if (_.isEmpty(email) && this.isEmailErased()) {
            email = app.lang.get('LBL_VALUE_ERASED', this.module);
        }

        if (_.isEmpty(name)) {
            return email;
        }

        if (_.isEmpty(email)) {
            return name;
        }

        if (options.quote_name) {
            name = '"' + name + '"';
        }

        return name + ' <' + email + '>';
    },

    /**
     * Determines if there is really a parent record.
     *
     * The type and id fields are not unset after a parent record is deleted.
     * So we test for name because the parent record is truly only there if
     * type and id are non-empty and the parent record can be resolved and has
     * not been deleted.
     *
     * @return {boolean}
     */
    hasParent: function() {
        var parent = this.getParent();

        return !!(parent && (parent.get('name') || app.utils.isNameErased(parent)));
    },

    /**
     * Returns a bean from the parent data or undefined if no parent exists.
     *
     * @return {undefined|Data.Bean}
     */
    getParent: function() {
        if (this.get('parent') && this.get('parent').type && this.get('parent').id) {
            // We omit type because it is actually the module name and should
            // not be treated as an attribute.
            return app.data.createBean(this.get('parent').type, _.omit(this.get('parent'), 'type'));
        }
    },

    /**
     * Returns true of the parent record's name has been erased.
     *
     * @return {boolean}
     */
    isNameErased: function() {
        var parent;

        if (this.hasParent()) {
            parent = this.getParent();

            if (parent) {
                return app.utils.isNameErased(parent);
            }
        }

        return false;
    },

    /**
     * Returns true if the email address has been erased.
     *
     * @return {boolean}
     */
    isEmailErased: function() {
        var link = this.get('email_addresses');
        var erasedFields = link && link._erased_fields ? link._erased_fields : [];

        return _.isEmpty(erasedFields) ? false : _.contains(erasedFields, 'email_address');
    }
}) }
}}

},
		"DataPrivacy":{"fieldTemplates": {}
,
"views": {
"base": {
"marked-for-erasure-dashlet": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DataPrivacy.MarkedForErasureDashlet
 * @alias SUGAR.App.view.views.BaseDataPrivacyMarkedForErasureDashlet
 * @extends View.Views.Base.Dashlet
 *
 */
(function() {
    /**
     *
     * Given a starting layout will recusively find a child layout with a matching name.
     * The use of this function is an anti-pattern and SHOULD NOT BE COPIED OR REPLICATED!
     *
     * Normally events should be used across the common shared objects (model, collection, context).
     * Finding a specific layout somewhere on the page to set a value or call a function on creates tight coupling
     * between the components. Rather than this view doing anything with the subpanel views/layouts,
     * the subpanel layouts and views should be listening to the proper update/sync events on the collections/contexts
     * that they are attached to and re-render or update themselves appropriately.
     *
     * @param {Layout} layout
     * @param {string} name
     * @return {Component|undefined}
     */
    var findLayout = function(layout, name) {
        if (!layout.getComponent) {
            return;
        }
        var comp = layout.getComponent(name);

        if (!comp) {
            _.find(layout._components, function(subComp) {
                var found = findLayout(subComp, name);
                if (found) {
                    comp = found;
                }
            });
        }

        return comp;
    };
    return {
        plugins: ['Dashlet'],

        events: {
            'click .more': 'loadMore'
        },

        initialize: function(options) {
            this._super('initialize', arguments);
            this.relContexts = {};
            this.render = _.bind(_.debounce(this.render, 100), this);
        },

        initDashlet: function() {
            this.listenTo(this.model, 'change:fields_to_erase', this.formatData);
            this.listenTo(this.model, 'sync', this.formatData);
        },

        /**
         * Should be called when a related data set changes. Will run through the related collections and
         * fields_to_erase from the parent record and format the data in preparation for rendering.
         * Will also trigger a render.
         *
         * This can be optomized later to only update/render the components that changed.
         * This is a simplistic initial implementation.
         */
        formatData: function() {
            this.notApplicable = this.model.get('type') !== 'Request to Erase Information';
            if (this.notApplicable) {
                this.values = false;
            } else {
                var values = this.model.get('fields_to_erase') || {};
                this.values = _.map(values, function(ids, link) {
                    var module = app.data.getRelatedModule(this.model.module, link);
                    var recordCount = _.size(ids);
                    var erased = {
                        link: link,
                        module: module,
                        count: recordCount,
                        models: {},
                        label: app.lang.getModuleName(module, {plural: true})
                    };

                    var ctx = this.listenToRelatedContext(link);
                    if (recordCount > 0 && ctx.get('collapsed')) {
                        // This one is pretty optional. It forces subpanels
                        // open so we can get the names of the models marked for erasure.
                        ctx.set('collapsed', false);
                    }
                    var col = ctx.get('collection');
                    if (col) {
                        col.each(function(model) {
                            if (model.id && ids[model.id]) {
                                erased.models[model.id] = {
                                    model: model,
                                    count: _.size(ids[model.id]),
                                    nameFieldDef: _.extend(model.fields.name, {link: true})
                                };
                            }
                        });
                        if (!_.isEmpty(_.without(ids, _.keys(erased.models))) &&
                            col.next_offset > -1 && col.dataFetched
                        ) {
                            erased.hasMore = true;
                        }
                    }

                    return erased;
                }, this);
            }
            this.render();
        },

        /**
         *  Given a link name, will find and attach the appropriate listeners to that related context
         * @param {string} link
         * @return {Context}
         */
        listenToRelatedContext: function(link) {
            var context = this.context.parent || this.context;
            if (!this.relContexts[link] && context.get('module') == 'DataPrivacy') {
                this.relContexts[link] = context.getChildContext({
	// Marked-for-erasure-dashlet View (base) 
link: link});
                if (this.relContexts[link].get('collection')) {
                    this.listenTo(this.relContexts[link].get('collection'), 'sync', this.formatData);
                }
            }

            return this.relContexts[link];
        },

        /**
         * Paginate the clicked collection
         *
         * None of the below logic should be neccesary other than calling collection paginate.
         * The subpanel view is triggered instead to allow the required subpanel success callbacks to trigger.
         * In the future, these should be refactored to listen for collection update events.
         * @param e
         * @return {*}
         */
        loadMore: function(e) {
            e.preventDefault();
            var link = $(e.target).data('link');
            if (link && this.relContexts[link]) {
                var subpanel = this.getSubpanelForLink(link);
                if (subpanel) {
                    var footer = _.find(subpanel._components, function(view) {
                        return view.showMoreRecords;
                    });
                    if (footer) {
                        return footer.showMoreRecords();
                    }
                    var listView = _.find(subpanel._components, function(view) {
                        return view.getNextPagination;
                    });
                    if (listView) {
                        return listView.getNextPagination();
                    }
                }
            }
            //We couldn't find an appropriate subpanel, paginate ourselves
            this.relContexts[link].get('collection').paginate({add: true});
        },

        /**
         * Because subpanels do not listen for or handle the collection's update event properly
         * we must trigger the pagination from the subpanel.
         * @param link
         * @return {Mixed}
         */
        getSubpanelForLink: function(link) {
            var topLayout = this.closestComponent('sidebar');
            if (topLayout) {
                var main = topLayout.getComponent('main-pane');
                if (main) {
                    var subPanelLayout = findLayout(main, 'subpanels');
                    if (subPanelLayout) {
                        return _.find(subPanelLayout._components, function(comp) {
                            return comp.context.get('link') === link;
                        });
                    }
                }
            }
        },

        loadData: function() {
            this.formatData();
        }
    };
})() },
"mark-for-erasure-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.MarkForErasureHeaderpaneView
 * @alias SUGAR.App.view.views.BaseMarkForErasureHeaderpaneView
 * @extends View.Views.Base.HeaderpaneView
 */
({
	// Mark-for-erasure-headerpane View (base) 

    extendsFrom: 'HeaderpaneView',

    events: {
        'click a[name=close_button]': 'close',
        'click a[name=mark_for_erasure_button]': 'markForErasure'
    },

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        app.shortcuts.register({
            id: 'MarkForErasureHeaderPanel:Close',
            keys: ['esc','mod+alt+l'],
            component: this,
            description: 'LBL_SHORTCUT_CLOSE_DRAWER',
            callOnFocus: true,
            handler: function() {
                var $closeButton = this.$('a[name=close_button]');
                if ($closeButton.is(':visible') && !$closeButton.hasClass('disabled')) {
                    $closeButton.click();
                }
            }
        });
    },

    /**
     * @inheritdoc
     *
     * Also bind mass collection events.
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.context.once('change:mass_collection', this._addMassCollectionListener, this);
        this.context.on('markforerasure:masscollection:init', function(models) {
            this._initialModels = _.clone(models);
        }, this);
    },

    /**
     * Closes the drawer.
     */
    close: function() {
        app.drawer.close();
    },

    /**
     * Mark the currently selected fields for erasure.
     */
    markForErasure: function() {
        this.context.trigger('markforerasure:mark');
    },

    /**
     * Set up `add`, `remove` and `reset` listeners on the `mass_collection` so
     * we can enable/disable the merge button whenever the collection changes.
     *
     * @private
     */
    _addMassCollectionListener: function() {
        var massCollection = this.context.get('mass_collection');
        massCollection.on('add remove reset', this._toggleMarkForErasureButton, this);
    },

    /**
     * Check if we should disable the Mark for Erasure button.
     * We disable if the list of fields selected differs in any way from the
     * currently saved list.
     *
     * @return {boolean} `true` if we should disable the button; `false` if
     *   we should not.
     * @private
     */
    _shouldDisable: function() {
        var massCollection = this.context.get('mass_collection');
        if (!this._initialModels) {
            // No fields to erase were selected; disable by default
            return true;
        } else if (this._initialModels.length !== massCollection.length) {
            return false;
        }

        // Mass collection and initial mass collection have same number of models, no choice but
        // to compare them one-by-one
        return _.every(this._initialModels, function(model) {
            return massCollection.get(model.id);
        });
    },

    /**
     * Enable or disable the mark for erasure button as appropriate.
     */
    _toggleMarkForErasureButton: function() {
        this.$('[name="mark_for_erasure_button"]').toggleClass('disabled', this._shouldDisable());
    },

    /*
     * @override
     *
     * Overriding to show record name on title header if it is available;
     * if not, use the standard title.
     */
    _formatTitle: function(title) {
        var recordName;
        var model = this.context.get('modelForErase');

        // Special case for `Person` type modules
        if (model.fields && model.fields.name && model.fields.name.type == 'fullname') {
            recordName = app.utils.formatNameModel(model.module, model.attributes);
        } else {
            recordName = app.utils.getRecordName(model);
        }

        if (recordName) {
            return app.lang.get('TPL_DATAPRIVACY_PII_TITLE', model.module, {name: recordName});
        } else if (title) {
            return app.lang.get(title, this.module);
        } else {
            return '';
        }
    },
}) },
"mark-for-erasure": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DataPrivacy.MarkForErasureView
 * @alias SUGAR.App.view.views.BaseDataPrivacyMarkForErasureView
 * @extends View.Views.Base.PiiView
 *
 * `MarkForErasureView` handles selecting fields for erasure from a particular record
 * that contains PII.
 *
 * The fields_to_erase field is a JSON field that looks something like this:
 *
 *  ```
 *  {
 *      leads: {
 *          lead_id1: [
 *              'first_name',
 *              'last_name',
 *              'phone'
 *          ],
 *          lead_id2: [
 *              'first_name',
 *              'phone'
 *          ],
 *      ],
 *      contacts: {
 *          contact_id1: [
 *              'first_name',
 *              'last_name',
 *              'phone'
 *          ],
 *          'contact_id2': [
 *              'first_name',
 *              'phone'
 *          ]
 *       }
 *  }
 */
({
	// Mark-for-erasure View (base) 

    extendsFrom: 'PiiView',

    className: 'flex-list-view left-actions',

    /**
     * @inheritdoc
     *
     * Initialize and override the Pii collection.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var modelForErase = this.context.get('modelForErase');
        this.baseModule = modelForErase.module;
        this.baseRecord = modelForErase.id;
        this.context.set('piiModule', this.baseModule);
        this.collection.baseModule = this.baseModule;
        this.collection.baseRecordId = this.baseRecord;

        this.massCollection = app.data.createBeanCollection('MarkForErasureView');
        this.context.set('mass_collection', this.massCollection);
        this._bindMassCollectionEvents();

        this.context.on('markforerasure:mark', this._markForErasure, this);

        this._setColumnActions();
    },

    /**
     * Save just the fields_to_erase for the relevant DataPrivacy record.
     *
     * @param {Object} attributes Attributes from the record to save.
     * @param {Object} attributes.fields_to_erase Fields from related models to
     *   erase.
     */
    saveRecord: function(attributes) {
        // sync just the fields_to_erase (and the ID to make sure we save the right record)
        // to ensure we don't save in-progress changes from the DataPrivacy record view
        var parentModel = this.context.parent.get('model');
        var cloneModel = parentModel.clone();
        cloneModel.set('fields_to_erase', attributes.fields_to_erase);

        cloneModel.sync = function(method, model, options) {
            var callbacks = app.data.getSyncCallbacks(method, model, options);
            options = app.data.parseOptionsForSync(method, model, options);
            app.data.trigger('data:sync:start', method, model, options);
            model.trigger('data:sync:start', method, options);

            // Only actually save the fields_to_erase (and the ID)
            app.api.records(method, model.module, attributes, options.params, callbacks);
        };

        cloneModel.save(attributes, {
            showAlerts: false, // FIXME PX-30: enable custom alert here
            success: function() {
                parentModel.set('fields_to_erase', attributes.fields_to_erase);
                app.drawer.close();
            },
            error: _.bind(function(model, error) {
                if (error.status === 412 && !error.request.metadataRetry) {
                    var self = this;
                    // On a metadata sync error, retry the save after the app is synced
                    self.resavingAfterMetadataSync = true;
                    app.once('app:sync:complete', function() {
                        error.request.metadataRetry = true;
                        model.once('sync', function() {
                            self.resavingAfterMetadataSync = false;
                            app.router.refresh();
                        });
                        //add a new success callback to refresh the page after the save completes
                        error.request.execute(null, app.api.getMetadataHash());
                    });
                } else {
                    // FIXME: Not handling 409's at this time
                    app.alert.show('error_while_save', {
                        level: 'error',
                        title: app.lang.get('ERR_INTERNAL_ERR_MSG'),
                        messages: ['ERR_HTTP_500_TEXT_LINE1', 'ERR_HTTP_500_TEXT_LINE2']
                    });
                }
            }, this)
        });
    },

    /**
     * Initialize the collection.
     *
     * @private
     */
    _initCollection: function() {
        // FIXME TY-2169: move this code into the PII view and stop overriding here.
        var self = this;
        var PiiCollection = app.BeanCollection.extend({
            baseModule: this.baseModule,
            baseRecordId: this.baseRecord,
            sync: function(method, model, options) {
                options.params = _.extend(options.params || {}, {erased_fields: true});
                var url = app.api.buildURL(this.baseModule, 'pii', {id: this.baseRecordId}, options.params);
                var callbacks = app.data.getSyncCallbacks(method, model, options);
                var defaultSuccessCallback = app.data.getSyncSuccessCallback(method, model, options);
                callbacks.success = function(data, request) {
                    data.records = _.map(data.fields, function(field) {
                        // Each field having a unique ID is required for using the MassCollection
                        field.id = _.uniqueId();
                        return field;
                    });
                    data.records = self.mergePiiFields(data.records);
                    self.applyDataToRecords(data);
                    return defaultSuccessCallback(data, request);
                };
                app.api.call(method, url, options.attributes, callbacks);
            }
        });
        this.collection = new PiiCollection();
        this.collection.on('sync', this._initMassCollection, this);
        this.context.set('collection', this.collection);
    },

    /**
     * Get the list of names of fields to erase corresponding to the module and
     * id of a linked record.
     *
     * @return {string[]} List of field names to erase.
     * @private
     */
    _getFieldsToErase: function() {
        if (this.context && this.context.parent) {
            var parentModel = this.context.parent.get('model');
            var modelForErase = this.context.get('modelForErase');
            if (!parentModel || !modelForErase) {
                return [];
            }

            var fieldsToErase = parentModel.get('fields_to_erase');
            var link = modelForErase.link;
            if (!fieldsToErase || !link || !fieldsToErase[link.name]) {
                return [];
            }

            var modelId = modelForErase.get('id');
            var eraseFieldList = fieldsToErase[link.name];
            return eraseFieldList[modelId] || [];
        }
        return [];
    },

    /**
     * Retrieve models from the collection given a list of field names.
     *
     * @param {string[]} fieldNames List of fields to pick from the collection.
     * @return {Data.Bean[]} List of field beans.
     * @private
     */
    _getModelsByName: function(fieldNames) {
        if (this.collection && this.collection.models) {
            var models = [];
            _.each(fieldNames, function(field) {
                _.each(this.collection.models, function(model) {
                    var fieldName = model.get('field_name');
                    if (field === fieldName || (!_.isUndefined(field.id) && field.id === model.get('value').id)) {
                        models.push(model);
                    }
                });
            }, this);
            return models;
        }
        return [];
    },

    /**
     * @inheritdoc
     *
     * Patch pii models fields with fielddefs from related module
     * in order to render properly.
     */
    _renderData: function() {
        var fields = app.metadata.getModule(this.baseModule).fields;

        _.each(this.collection.models, function(model) {
            model.fields = app.utils.deepCopy(this.metaFields);

            var value = _.findWhere(model.fields, {name: 'value'});
            _.extend(value, fields[model.get('field_name')], {name: 'value'});

            if (_.contains(['multienum', 'enum'], value.type) && value.function) {
                value.type = 'base';
            }

            model.fields = app.metadata._patchFields(
                this.module,
                app.metadata.getModule(this.baseModule),
                model.fields
            );
        }, this);

        this._super('_renderData');
    },

    /**
     * Add previously marked fields for erasure to the mass collection.
     *
     * @private
     */
    _initMassCollection: function() {
        var fieldsToErase = this._getFieldsToErase();
        var preselectedModels = this._getModelsByName(fieldsToErase);
        this._addModel(preselectedModels);
        this.context.trigger('markforerasure:masscollection:init', preselectedModels);
    },

    /**
     * Mark the selected fields from the drawer to erase.
     *
     * @private
     */
    _markForErasure: function() {
        var selectedModels = this.massCollection.models;
        var selectedFields;
        try {
            selectedFields = _.map(selectedModels, function(model) {
                var fieldName = model.get('field_name');
                // Email addresses and other related fields will have an object containing
                // the name and id of the record
                var value = model.get('value');
                if (_.isObject(value) && !_.isArray(value)) {
                    if (!fieldName || !value.id) {
                        throw new Error('Unable to mark field ' + fieldName + ' to erase.');
                    }
                    return {
                        field_name: fieldName,
                        id: value.id
                    };
                }
                return fieldName;
            });
        } catch (e) {
            app.alert.show('invalid_pii_field', {
                level: 'error',
                messages: [e.message],
            });
            return;
        }

        var modelForErase = this.context.get('modelForErase');
        var link = modelForErase.link;
        if (!link) {
            throw new Error('Cannot erase fields on an unlinked record');
        }
        var linkName = link.name;
        var modelId = modelForErase.get('id');

        var parentModel = this.context.parent.get('model');
        var fieldsToErase = app.utils.deepCopy(parentModel.get('fields_to_erase'));
        if (_.isEmpty(fieldsToErase)) {
            fieldsToErase = {};
        }
        fieldsToErase[linkName] = fieldsToErase[linkName] || {};

        if (_.isEmpty(selectedFields)) {
            fieldsToErase = this._cleanupFieldsToErase(fieldsToErase, linkName, modelId);
        } else {
            fieldsToErase[linkName][modelId] = selectedFields;
        }

        var attributesToSave = {
            id: parentModel.id,
            fields_to_erase: fieldsToErase
        };
        this.saveRecord(attributesToSave);
    },

    /**
     * Clean up the fields_to_erase so we don't leave empty keys floating in it
     *
     * @param {Object} fieldsToErase The fields_to_erase data structure.
     * @param {string} linkName Name of the linked subpanel to which this view corresponds.
     * @param {string} modelId ID of the model from which we were erasing fields.
     * @return {Object} The cleaned fields_to_erase.
     * @private
     */
    _cleanupFieldsToErase: function(fieldsToErase, linkName, modelId) {
        // if the list of fields is now empty, wipe out this linked record
        delete fieldsToErase[linkName][modelId];

        // if there are now no fields_to_erase from *any* record from this link type,
        // wipe out this link
        if (_.isEmpty(fieldsToErase[linkName])) {
            delete fieldsToErase[linkName];

            // NOTE: do NOT null out this one more level
            // doing so means sending fields_to_erase as NULL, which is ignored
        }

        return fieldsToErase;
    },

    /**
     * Binds mass collection event listeners.
     *
     * @private
     */
    _bindMassCollectionEvents: function() {
        this.context.on('mass_collection:add', this._addModel, this);
        this.context.on('mass_collection:add:all', this._addAllModels, this);
        this.context.on('mass_collection:remove', this._removeModel, this);
        this.context.on('mass_collection:remove:all mass_collection:clear', this._clearMassCollection, this);
    },

    /**
     * Adds a model or a list of models to the mass collection.
     *
     * @param {Data.Bean|Data.Bean[]} models The model or the list of models
     *   to add.
     * @private
     */
    _addModel: function(models) {
        models = _.isArray(models) ? models : [models];
        this.massCollection.add(models);
        if (this._isAllChecked()) {
            this.massCollection.trigger('all:checked');
        }
    },

    /**
     * Adds all models of the view collection to the mass collection.
     *
     * @private
     */
    _addAllModels: function() {
        this.massCollection.reset(this.collection.models);
        this.massCollection.trigger('all:checked');
    },

    /**
     * Removes a model or a list of models from the mass collection.
     *
     * @param {Data.Bean|Data.Bean[]} models The model or the list of models
     *   to remove.
     * @private
     */
    _removeModel: function(models) {
        models = _.isArray(models) ? models : [models];
        this.massCollection.remove(models);
        this.massCollection.trigger('not:all:checked');
    },

    /**
     * Clears the mass collection.
     *
     * @private
     */
    _clearMassCollection: function() {
        this.massCollection.entire = false;
        this.massCollection.reset();
        this.massCollection.trigger('not:all:checked');
    },

    /**
     * Checks if all models of the view collection are in the mass
     * collection.
     *
     * @return {boolean} allChecked `true` if all models of the view
     *   collection are in the mass collection.
     * @private
     */
    _isAllChecked: function() {
        if (this.massCollection.length < this.collection.length) {
            return false;
        }
        return _.every(this.collection.models, function(model) {
            return this.massCollection.get(model.id);
        }, this);
    },

    /**
     * Set the checkbox column metadata.
     *
     * @private
     */
    _setColumnActions: function() {
        this.leftColumns = [{
            type: 'fieldset',
            fields: [
                {
                    type: 'actionmenu',
                    buttons: [],
                    disable_select_all_alert: true
                }
            ],
            value: false,
            sortable: false
        }];
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.DataPrivacy.RecordView
 * @alias SUGAR.App.view.views.BaseDataPrivacyRecordView
 * @extends View.Views.Base.RecordView
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     *
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.on('button:erase_complete_button:click', this.showConfirmEraseAlert, this);
        this.context.on('button:reject_button:click', this.showRejectEraseAlert, this);
        this.context.on('button:complete_button:click', this.showConfirmCompleteAlert, this);
    },

    /**
     * Save status.
     *
     * @private
     */
    _setStatus: function(status) {
        this.model.set('status', status);
        this.handleSave();
    },

    /**
     * Calculates and returns the number of fields on all related records marked for erasure.
     *
     * @return {number} The number of records marked for erasure.
     * @private
     */
    _getNumberOfFieldsToErased: function() {
        var fieldsNumber = 0;
        var fieldsToErase = this.model.get('fields_to_erase');

        _.each(fieldsToErase, function(module) {
            fieldsNumber += _.reduce(module, function(memo, fields) {
                return memo + fields.length;
            }, 0);
        });

        return fieldsNumber;
    },

    /**
     * Displays a confirmation warning for erasing all field values for the fields marked for erasure.
     */
    showConfirmEraseAlert: function() {
        var self = this;
        var alertText = app.lang.get('LBL_WARNING_ERASE_CONFIRM', 'DataPrivacy');
        app.alert.show('confirm_complete:' + this.model.get('id'), {
            level: 'confirmation',
            messages: app.utils.formatString(alertText, [this._getNumberOfFieldsToErased()]),
            onConfirm: function() {
                self._setStatus('Closed');
            }
        });
    },

    /**
     * Displays a confirmation warning for closing the request.
     */
    showConfirmCompleteAlert: function() {
        var self = this;
        app.alert.show('confirm_erase_and_complete:' + this.model.get('id'), {
            level: 'confirmation',
            messages: app.lang.get('LBL_WARNING_COMPLETE_CONFIRM', 'DataPrivacy'),
            onConfirm: function() {
                self._setStatus('Closed');
            }
        });
    },

    /**
     * Displays a confirmation warning for rejecting the erasure of field values for all fields marked for erasure.
     */
    showRejectEraseAlert: function() {
        var self = this;
        var alertText;
        if (this.model.get('type') == 'Request to Erase Information') {
            alertText = app.utils.formatString(
                app.lang.get('LBL_WARNING_REJECT_ERASURE_CONFIRM', 'DataPrivacy'),
                [this._getNumberOfFieldsToErased()]
            );
        } else {
            alertText = app.lang.get('LBL_WARNING_REJECT_REQUEST_CONFIRM', 'DataPrivacy');
        }
        app.alert.show('confirm_reject_erase:' + this.model.get('id'), {
            level: 'confirmation',
            messages: alertText,
            onConfirm: function() {
                self._setStatus('Rejected');
            }
        });
    },

    /**
     * @inheritdoc
     *
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.model.on('change', function() {
            if (!this.inlineEditMode &&
                this.action !== 'edit') {
                this.setButtonStates(this.STATE.VIEW);
            }
        }, this);
    },

    /**
     * @inheritdoc
     *
     */
    setButtonStates: function(state) {
        this._super('setButtonStates', [state]);
        this.setButtons(state);
    },

    /**
     * @inheritdoc
     *
     *  Depending on the type index, we either show or hide
     *  complete_button, erase_complete_button & reject_button
     */
    setButtons: function(state) {
        var open = (this.model.get('status') === 'Open');
        var erase = (this.model.get('type') === 'Request to Erase Information');
        if (state === this.STATE.VIEW && app.acl.hasAccess('admin', this.module)) {
            this.currentState = state;
            _.each(this.buttons, function(field) {
                if (this.shouldHide(open, erase, field)) {
                    field.hide();
                }
            }, this);
            this.toggleButtons(true);
        }
    },

    /**
     * @inheritdoc
     *
     * Check whether the button should be hidden
     */
    shouldHide: function(open, erase, field) {
        var DPActions = [
            'complete_button',
            'erase_complete_button',
            'reject_button'
        ];
        if ((!open && DPActions.indexOf(field.name) !== -1) ||
            (erase && field.name === 'complete_button') ||
            (!erase && field.name === 'erase_complete_button')) {
            return true;
        }
        return false;
    },
}) }
}}
,
"layouts": {
"base": {
"mark-for-erasure": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
 /**
 * @class View.Layouts.Base.MarkForErasureLayout
 * @alias SUGAR.App.view.layouts.MarkForErasureLayout
 * @extends View.Layouts.Base.DefaultLayout
 */
({
	// Mark-for-erasure Layout (base) 

    extendsFrom: 'DefaultLayout',

    plugins: ['ShortcutSession'],

    shortcuts: ['MarkForErasureHeaderPanel:Close']
}) },
"subpanels": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.DataPrivacy.SubpanelsLayout
 * @alias SUGAR.App.view.layouts.DataPrivacySubpanelsLayout
 * @extends View.Layout.Base.SubpanelsLayout
 */
({
	// Subpanels Layout (base) 

    /**
     * @inheritdoc
     * inject the Mark for Erase action link to all subpanels
     */
    initComponents: function(component, def) {
        this._super('initComponents', arguments);

        // Add the erase action to all subpanel rowactions
        _.each(this._components, function(comp) {
            if (!comp.getComponent) {
                return;
            }
            var viewName = 'subpanel-list';
            if (comp.meta && comp.meta.components) {
                _.find(comp.meta.components, function(def) {
                    var name = '';
                    var prefix = 'subpanel-for';
                    if (def.view) {
                        name = _.isObject(def.view) ? def.view.name || def.view.type : def.view;
                    }

                    if (name === 'subpanel-list' || _.isString(name) && name.substr(0, prefix.length) === prefix) {
                        viewName = name;
                        return true;
                    }

                    return false;
                });
            }
            var subView = comp.getComponent(viewName);
            if (subView && subView.meta && subView.meta.rowactions && subView.meta.rowactions.actions) {
                subView.meta.rowactions.actions.push({
                    'type': 'dataprivacyerase',
                    'icon': 'fa-eye',
                    'name': 'dataprivacy-erase',
                    'label': 'LBL_DATAPRIVACY_MARKFORERASE'
                });
            }
        });
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
 /**
 * @class View.Layouts.Base.DataPrivacy.RecordLayout
 * @alias SUGAR.App.view.layouts.BaseDataPrivacyRecordLayout
 * @extends View.Layouts.Base.RecordLayout
 */
({
	// Record Layout (base) 

    extendsFrom: 'RecordLayout',

    /**
     * @inheritdoc
     *
     * Adds handler for invoking Mark for Erasure view
     */
    initialize: function(options) {
        this._super('initialize', arguments);
        this.listenTo(this.context, 'mark-erasure:click', this.showMarkForEraseDrawer);
    },

    /**
     * Open a drawer to mark fields on the given model for erasure.
     *
     * @param {Data.Bean} modelForErase Model to mark fields on.
     */
    showMarkForEraseDrawer: function(modelForErase) {
        var context = this.context.getChildContext({
            name: 'Pii',
            model: app.data.createBean('Pii'),
            modelForErase: modelForErase,
            fetch: false
        });

        app.drawer.open({
            layout: 'mark-for-erasure',
            context: context
        });
    }
}) }
}}
,
"datas": {}

},
		"ReportSchedules":{"fieldTemplates": {}
,
"views": {
"base": {
"list-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ReportSchedules.ListHeaderpaneView
 * @alias SUGAR.App.view.views.BaseReportSchedulesListHeaderpaneView
 * @extends View.Views.Base.ListHeaderpaneView
 */
({
	// List-headerpane View (base) 

    extendsFrom: 'ListHeaderpaneView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.context.on('button:create_button:click', this.create, this);
    },

    /**
     * Pass current report to 'create' view if report filter is applied
     */
    create: function() {
        var newModel = app.data.createBean('ReportSchedules');
        var currentFilter = this.context.get('currentFilterId');
        var filterOptions = this.context.get('filterOptions');
        // report filter is initially appied and has not been removed
        if (filterOptions && filterOptions.initial_filter === 'by_report' && currentFilter === 'by_report') {
            newModel.set({
                report_id: filterOptions.filter_populate.report_id[0],
                report_name: filterOptions.initial_filter_label
            });
        }
        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: 'ReportSchedules',
                model: newModel
            }
        }, function(context, model) {
            if (model && model.module === app.controller.context.get('module')) {
                app.controller.context.reloadData();
            }
        });
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.ScheduleReports.CreateView
 * @alias SUGAR.App.view.views.BaseScheduleReportsCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    /**
     * Check for possible duplicates before creating a new record
     * @param callback
     */
    initiateSave: function(callback) {
        this.disableButtons();
        async.waterfall([
            _.bind(this.validateSubpanelModelsWaterfall, this),
            _.bind(this.validateModelWaterfall, this),
            _.bind(this.dupeCheckWaterfall, this),
            _.bind(this.createRecordWaterfall, this),
            _.bind(this.linkUserWaterfall, this)
        ], _.bind(function(error) {
            this.enableButtons();
            if (error && error.status == 412 && !error.request.metadataRetry) {
                this.handleMetadataSyncError(error);
            } else if (!error && !this.disposed) {
                this.context.lastSaveAction = null;
                callback();
            }
        }, this));
    },

    /**
     * Waterfall function
     * @param callback
     */
    linkUserWaterfall: function(callback) {
        if (this.context.get('copiedFromModelId')) {
            this.copyExistingUsers();
        } else {
            this.linkCurrentUser();
        }
        callback(false);
    },

    /**
     * Link to current user
     */
    linkCurrentUser: function() {
        var user = app.data.createRelatedBean(this.model, app.user.get('id'), 'users');
        user.save(null, {relate: true});
    },

    /**
     * Copy existing users
     */
    copyExistingUsers: function() {
        var bulkRequest;
        var bulkUrl;
        var bulkCalls = [];
        var bean = this.context.parent.get('model');
        var collection = bean.getRelatedCollection('users');
        _.each(collection.models, function(model) {
            bulkUrl = app.api.buildURL('ReportSchedules/' + this.model.get('id') + '/link/users/' + model.get('id'));
            bulkRequest = {
                url: bulkUrl.substr(4),
                method: 'POST',
                data: {}
            };
            bulkCalls.push(bulkRequest);
        }, this);
        if (bulkCalls.length) {
            app.api.call('create', app.api.buildURL(null, 'bulk'), {requests: bulkCalls}, {});
        }
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"CommentLog":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Library":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"EmailAddresses":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {
"base": {
"model": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class Model.Datas.Base.EmailAddressesModel
 * @alias SUGAR.App.model.datas.BaseEmailAddressesModel
 * @extends Data.Bean
 */
({
	// Model Data (base) 

    /**
     * @inheritdoc
     *
     * Defaults `opt_out` to the `new_email_addresses_opted_out` config.
     */
    initialize: function(attributes) {
        this._defaults = _.extend({}, this._defaults, {opt_out: app.config.newEmailAddressesOptedOut});
        app.Bean.prototype.initialize.call(this, attributes);
    }
}) }
}}

},
		"Words":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"Sugar_Favorites":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"KBDocuments":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"KBContents":{"fieldTemplates": {
"base": {
"languages": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Languages FieldTemplate (base) 

    extendsFrom: 'FieldsetField',

    events: {
        'click .btn[data-action=add-field]': 'addItem',
        'click .btn[data-action=remove-field]': 'removeItem',
        'click .btn[data-action=set-primary-field]': 'setPrimaryItem'
    },

    intKey: null,

    deletedLanguages: [],

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._currentIndex = 0;
        this.model.unset('deleted_languages', {silent: true});
    },

    /**
     * @inheritdoc
     */
    format: function(value) {
        var result = [],
            numItems = 0;
        value = app.utils.deepCopy(value);

        if (_.isString(value)) {
            value = [{'': value, primary: false}];
        }

        // Place the add button as needed
        if (_.isArray(value) && value.length > 0) {
            _.each(value, function(item, ind) {
                delete item.remove_button;
                delete item.add_button;
                result[ind] = {
                    name: this.name,
                    primary: item.primary || false
                };
                delete item.primary;
                result[ind].items = item;
            }, this);
            if (!result[this._currentIndex]) {
                result[this._currentIndex] = {};
            }
            result[value.length - 1].add_button = true;
            // number of valid teams
            numItems = _.filter(result, function(item) {
                return _.isUndefined(item.items['']);
            }).length;
            // Show remove button for all unset combos and only set combos if there are more than one
            _.each(result, function(item) {
                if (!_.isUndefined(item.items['']) || numItems > 1) {
                    item.remove_button = true;
                }
            });
        }
        return result;
    },

    /**
     * @inheritdoc
     */
    unformat: function(value) {
        var result = [];
        _.each(value, function(item) {
            result.push(_.extend({}, item.items, {primary: item.primary}));
        }, this);
        return result;
    },

    /**
     * Set primary item.
     * @param {number} index
     * @return {boolean}
     */
    setPrimary: function(index) {
        var value = this.unformat(this.value);
        _.each(value, function(item) {
            item.primary = false;
        }, this);
        value[index].primary = true;
        this.model.set(this.name, value);
        return (this.value[index]) ? this.value[index].primary : false;
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function() {
        var self = this,
            el = null;
        if (this.model) {
            el = this.$el.find('div[data-name=languages_' + this.name + '] input[type=text]');
            el.on('change', function() {
                var value = self.unformatValue();
                self.model.set(self.name, value, {silent: true});
                self.value = self.format(value);
            });
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change', function() {
                if (this.disposed) {
                    return;
                }
                this.render();
            }, this);
        }
    },

    /**
     * Get value from view data.
     * @return [{}]
     */
    unformatValue: function() {
        var container = $(this.$('div[data-name=languages_' + this.name + ']')),
            input = container.find('input[type=text]'),
            value = [],
            val,
            k,
            v,
            pr,
            i;
        for (i = 0; i < input.length / 2; i = i + 1) {
            val = {};
            k = container.find('input[data-index=' + i + '][name=key_' + this.name + ']').val();
            v = container.find('input[data-index=' + i + '][name=value_' + this.name + ']').val();
            pr = container.find('button[data-index=' + i + '][name=primary]').hasClass('active');

            val[k] = v;
            val.primary = pr;
            value.push(val);
        }
        return value;
    },

    /**
     * Add item to list.
     * @param {Event} evt DOM event.
     */
    addItem: function(evt) {
        var index = $(evt.currentTarget).data('index'),
            value = this.unformat(this.value);
        if (!index || _.isUndefined(this.value[this.value.length - 1].items[''])) {
            value.push({'': ''});
            this._currentIndex += 1;
            this.model.set(this.name, value);
        }
    },

    /**
     * Remove item from list.
     * @param {Event} evt DOM event.
     */
    removeItem: function(evt) {
        this._currentTarget = evt.currentTarget;
        this.warnDelete();
    },

    /**
     * Popup dialog message to confirm delete action.
     */
    warnDelete: function() {
        app.alert.show('delete_confirmation', {
            level: 'confirmation',
            messages: app.lang.get('LBL_DELETE_CONFIRMATION_LANGUAGE', this.module),
            onConfirm: _.bind(this.confirmDelete, this),
            onCancel: _.bind(this.cancelDelete, this)
        });
    },

    /**
     * Predefined function for confirm delete.
     */
    confirmDelete: function() {
        var index = $(this._currentTarget).data('index'),
            value = null,
            removed = null;

        if (_.isNumber(index)) {
            if (index === 0 && this.value.length === 1) {
                return;
            }
            if (this._currentIndex === this.value.length - 1) {
                this._currentIndex -= 1;
            }

            value = this.unformat(this.value);
            removed = value.splice(index, 1);
            if (removed && removed.length > 0 && removed[0].primary) {
                value[0].primary = this.setPrimary(0);
            }
            for (var key in removed[0]) {
                if (key !== 'primary' && 2 == key.length) {
                    if (-1 === this.deletedLanguages.indexOf(key)) {
                        this.deletedLanguages.push(key);
                    }
                }
            }
            if (value) {
                this.model.set(this.name, value);
            }

            if (_.size(this.deletedLanguages) > 0) {
                this.model.set({'deleted_languages': this.deletedLanguages}, {silent: true});
            }
        }
    },

    /**
     * Predefined function for cancel delete.
     * @param {Event} evt DOM event.
     */
    cancelDelete: function(evt) {
    },

    /**
     * Set primary item.
     * @param {Event} evt DOM event.
     */
    setPrimaryItem: function(evt) {
        var index = $(evt.currentTarget).data('index');

        if (!this.value[index] ||
            !_.isUndefined(this.value[index].items['']) ||
            $(evt.currentTarget).hasClass('active')) {
            return;
        }
        this.$('.btn[name=primary]').removeClass('active');
        if (this.setPrimary(index)) {
            this.$('.btn[name=primary][data-index=' + index + ']').addClass('active');
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        this.$el.off();
        this.model.off('change');
        this._super('_dispose');
    },

    /**
     * Need own decoration for field error.
     * @override
     */
    handleValidationError: function (errors) {
        this.clearErrorDecoration();
        var err = errors.errors || errors;
        _.each(err, function(value) {
            var inpName = value.type + '_' + this.name,
                $inp = this.$('input[data-index=' + value.ind + '][name=' + inpName + ']');
            $inp.wrap('<div class="input-append input error ' + this.name + '">');
            errorMessages = [value.message];
            $tooltip = $(this.exclamationMarkTemplate(errorMessages));
            $inp.after($tooltip);
        }, this);
    },

    /**
     * Need own method to clear error decoration.
     * @override
     */
    clearErrorDecoration: function () {
        this.$('.add-on.error-tooltip').remove();
        _.each(this.$('input[type=text]'), function(inp) {
            var $inp = this.$(inp);
            if ($inp.parent().hasClass('input-append') && $inp.parent().hasClass('error')) {
                $inp.unwrap();
            }
        });
        if (this.view && this.view.trigger) {
            this.view.trigger('field:error', this, false);
        }
    }
}) },
"nestedset": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Fields.Base.KBContents.NestedsetField
 * @alias SUGAR.App.view.fields.BaseNestedsetField
 * @extends View.Fields.Base.BaseField
 */
({
	// Nestedset FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    fieldTag: 'div',

    /**
     * Root ID of a shown Nestedset.
     * @property {String}
     */
    categoryRoot: null,

    /**
     * Module which implements Nestedset.
     * @property {String}
     */
    moduleRoot: null,

    /**
     * @inheritdoc
     */
    extendsFrom: 'BaseField',

    /**
     * @inheritdoc
     */
    plugins: ['JSTree', 'NestedSetCollection'],

    /**
     * Selector for tree's placeholder.
     * @property {String}
     */
    ddEl: '[data-menu=dropdown]',

    /**
     * Flag indicates if input for new node shown.
     * @property {Boolean}
     */
    inCreation: false,

    /**
     * Callback to handle global dropdown click event.
     * @property {Callback}
     */
    dropdownCallback: null,

    /**
     * @inheritdoc
     */
    events: {
        'click [data-role=treeinput]': 'openDropDown',
        'click': 'handleClick',
        'keydown [data-role=secondinput]': 'handleKeyDown',
        'click [data-action=full-screen]': 'fullScreen',
        'click [data-action=create-new]': 'switchCreate',
        'keydown [data-role=add-item]': 'handleKeyDown',
        'click [data-action=show-list]': 'showList',
        'click [data-action=clear-field]': 'clearField'
    },

    /**
     * @inheritdoc
     */
    initialize: function(opts) {
        this._super('initialize', [opts]);
        var module = this.def.config_provider || this.context.get('module'),
            config = app.metadata.getModule(module, 'config');
        this.categoryRoot = this.def.category_root || config.category_root || '';
        this.moduleRoot = this.def.category_provider || this.def.data_provider || module;
        this.dropdownCallback = _.bind(this.handleGlobalClick, this);
        this.emptyLabel = app.lang.get(
            'LBL_SEARCH_SELECT_MODULE',
            this.module,
            {module: app.lang.get(this.def.label, this.module)}
        );
        this.before('render', function() {
            if (this.$(this.ddEl).length !== 0 && this._dropdownExists()) {
                this.closeDropDown();
            }
            return true;
        });
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        var treeOptions = {},
            $ddEl,
            self = this;
        this._super('_render');
        $ddEl = this.$(this.ddEl);
        if ($ddEl.length !== 0 && this._dropdownExists()) {
            $ddEl.dropdown();
            $ddEl.data('dropdown').opened = false;
            $ddEl.off('click.bs.dropdown');
            treeOptions = {
                settings: {
                    category_root: this.categoryRoot,
                    module_root: this.moduleRoot
                },
                options: {}
            };
            this._renderTree(
                this.$('[data-place=tree]'),
                treeOptions,
                {
                    'onSelect': _.bind(this.selectedNode, this),
                    'onLoad': function () {
                        if (!self.disposed) {
                            self.toggleSearchIcon(false);
                        }
                    }
                }
            );
            this.toggleSearchIcon(true);
            this.toggleClearIcon();
        }
    },

    /**
     * Gets HTML placeholder for a field.
     * @return {String} HTML placeholder for the field as Handlebars safe string.
     */
    getPlaceholder: function() {
        // if this in the filter row, the placeholder must have some css rules
        if (this.view && this.view.action === 'filter-rows') {
            return new Handlebars.SafeString('<span sfuuid="' + this.sfId + '" class="nestedset-filter-container"></span>');
        }
        return this._super('getPlaceholder');
    },

    /**
     * Show dropdown.
     * @param {Event} evt Triggered mouse event.
     */
    openDropDown: function(evt) {
        if (!this._dropdownExists()) {
            return;
        }
        var dropdown = this.$(this.ddEl).data('dropdown');
        if (dropdown.opened === true) {
            return;
        }
        this.view.trigger('list:scrollLock', true);
        $('body').on('click.bs.dropdown.data-api', this.dropdownCallback);
        evt.stopPropagation();
        evt.preventDefault();
        _.defer(function(dropdown, self) {
            var treePosition, $input;
            if (self.disposed) {
                return;
            }
            treePosition = self.$el.find('[data-role=treeinput]').position();
            $input = self.$('[data-role=secondinput]');
            self.$(self.ddEl).css({'left': treePosition.left - 1 + 'px', 'top': treePosition.top + 27 + 'px'});
            self.$(self.ddEl).dropdown('toggle');
            $input.val('');
            dropdown.opened = true;
            $input.focus();
        }, dropdown, this);
    },

    /**
     * Close dropdown.
     * @return {Boolean} Return `true` if dropdown has been closed, `false` otherwise.
     */
    closeDropDown: function() {
        var dropdown = this.$(this.ddEl).data('dropdown');
        if (!dropdown) {
            return false;
        }
        if (!dropdown.opened === true) {
            return false;
        }
        this.view.trigger('list:scrollLock', false);
        this.$(this.ddEl).dropdown('toggle');
        if (this.inCreation) {
            this.switchCreate();
        }
        dropdown.opened = false;
        $('body').off('click.bs.dropdown.data-api', this.dropdownCallback);
        this.clearSelection();
        return true;
    },

    /**
     * Toggle icon in search field while loading tree.
     * @param {Boolean} hide Flag indicates would we show the icon.
     */
    toggleSearchIcon: function(hide) {
        this.$('[data-role=secondinputaddon]')
            .toggleClass('fa-search', !hide)
            .toggleClass('fa-spinner', hide)
            .toggleClass('fa-spin', hide);
    },

    /**
     * Toggle clear icon in field.
     */
    toggleClearIcon: function() {
        if (_.isEmpty(this.model.get(this.def.name))) {
            this.$el.find('[data-action=clear-field]').hide();
        } else {
            this.$el.find('[data-action=clear-field]').show();
        }
    },

    /**
     * Handle global dropdown clicks.
     * @param evt {Event} Triggered mouse event.
     */
    handleGlobalClick: function(evt) {
        if (this._dropdownExists()) {
            this.closeDropDown();
            evt.preventDefault();
            evt.stopPropagation();
        }
    },

    /**
     * Handle all clicks for the field.
     * Need to catch for preventing external events.
     * @param evt {Event} Triggered mouse event.
     */
    handleClick: function(evt) {
        evt.preventDefault();
        evt.stopPropagation();
    },

    /**
     *  Search in the tree.
     */
    searchTreeValue: function() {
        var val = this.$('[data-role=secondinput]').val();
        this.searchNode(val);
    },

    /**
     * @override `Editable` plugin event to prevent default behavior.
     */
    bindKeyDown: function() {},

    /**
     * @override `Editable` plugin event to prevent default behavior.
     */
    bindDocumentMouseDown: function() {},

    /**
     * @override `Editable` plugin event to prevent default behavior.
     */
    focus: function() {
        if (this._dropdownExists()) {
            this.$('[data-role=treeinput]').click();
        }
    },

    /**
     * Handle key events in input fields.
     * @param evt {Event} Triggered key event.
     */
    handleKeyDown: function(evt) {
        var role = $(evt.currentTarget).data('role');
        if (evt.keyCode !== 13 && evt.keyCode !== 27) {
            return;
        }
        evt.preventDefault();
        evt.stopPropagation();
        switch (evt.keyCode) {
            case 13:
                switch (role) {
                    case 'secondinput':
                        this.searchTreeValue(evt);
                        break;
                    case 'add-item':
                        this.addNew(evt);
                        break;
                }
                break;
            case 27:
                switch (role) {
                    case 'secondinput':
                        this.closeDropDown();
                        break;
                    case 'add-item':
                        this.switchCreate();
                        break;
                }
                break;
        }
    },

    /**
     * Set value of a model.
     * @param {String} id Related ID value.
     * @param {String} val Related value.
     */
    setValue: function(id, val) {
        this.model.set(this.def.id_name, id);
        this.model.set(this.def.name, val);
    },

    /**
     * @inheritdoc
     *
     * No data changes to bind.
     */
    bindDomChange: function () {
    },

    /**
     * @inheritdoc
     *
     * Set right value in DOM for the field.
     */
    bindDataChange: function() {
        this.model.on("change:" + this.name, this.dataChangeUpdate, this);
    },

    /**
     * Update field data.
     */
    dataChangeUpdate: function() {
        if (this._dropdownExists()) {
            var id = this.model.get(this.def.id_name),
                name = this.model.get(this.def.name),
                child = this.collection.getChild(id);
            if (!name && child) {
                name = child.get(this.def.rname);
            }
            if (!name) {
                bean = app.data.createBean(this.moduleRoot, {id: id});
                bean.fetch({
                    success: _.bind(function(data) {
                        if (this.model) {
                            this.model.set(this.def.name, data.get(this.def.rname));
                        }
                    }, this)
                });
            }
            this.$('[data-role="treevalue"]','[name=' + this.def.name + ']').text(name);
            this.$('[name=' + this.def.id_name + ']').val(id);
        }
        if (!this.disposed) {
            this.render();
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (this._dropdownExists()) {
            $('body').off('click.bs.dropdown.data-api', this.dropdownCallback);
        }
        this._super('_dispose');
    },

    /**
     * Open drawer with tree list.
     */
    fullScreen: function() {
        var treeOptions = {
            category_root: this.categoryRoot,
            module_root: this.moduleRoot,
            plugins: ['dnd', 'contextmenu'],
            isDrawer: true
            },
            treeCallbacks = {
                'onRemove': function(node) {
                    if (this.context.parent) {
                        this.context.parent.trigger('kbcontents:category:deleted', node);
                    }
                },
                'onSelect': function(node) {
                    if (!_.isEmpty(node) && !_.isEmpty(node.id) && !_.isEmpty(node.name)) {
                        return true;
                    }
                }
            },
        // @TODO: Find out why params from context for drawer don't pass to our view tree::_initSettings
            context = _.extend({}, this.context, {treeoptions: treeOptions, treecallbacks: treeCallbacks});
        app.drawer.open({
            layout: 'nested-set-list',
            context: {
                module: 'Categories',
                parent: context,
                treeoptions: treeOptions,
                treecallbacks: treeCallbacks
            }
        }, _.bind(this.selectedNode, this));
    },

    /**
     * Open drawer with module records.
     */
    showList: function() {
        var popDef = {},
            filterOptions;
        popDef[this.def.id_name] = this.model.get(this.def.id_name);
        filterOptions = new app.utils.FilterOptions()
            .config(this.def)
            .setFilterPopulate(popDef)
            .format();

        app.drawer.open({
            layout: 'prefiltered',
            module: this.module,
            context: {
                module: this.module,
                filterOptions: filterOptions,
            }
        });
    },

    /**
     * Add new element to the tree.
     * @param {Event} evt Triggered key event.
     */
    addNew: function(evt) {
        var name = $(evt.target).val().trim();
        if (!name) {
            app.alert.show('wrong_node_name', {
                level: 'error',
                messages: app.error.getErrorString('empty_node_name', this),
                autoClose: true
            });
        } else {
            this.addNode(name, 'last', true, false, true);
            this.switchCreate();
        }
    },

    /**
     * Create and hide input for new element.
     */
    switchCreate: function() {
        var $options = this.$('[data-place=bottom-options]'),
            $create = this.$('[data-place=bottom-create]'),
            $input = this.$('[data-role=add-item]'),
            placeholder = app.lang.get('LBL_CREATE_CATEGORY_PLACEHOLDER', this.module);
        if (this.inCreation === false) {
            $options.hide();
            $create.show();
            $input
                .tooltip({
                    title: placeholder,
                    container: 'body',
                    trigger: 'manual',
                    delay: {show: 200, hide: 100}
                })
                .tooltip('show');
            $input.focus().select();
        } else {
            $input.tooltip('destroy');
            $input.val('');
            $create.hide();
            $options.show();
        }
        this.inCreation = !this.inCreation;
    },

    /**
     * Clear input element.
     */
    clearField: function(event) {
        event.preventDefault();
        event.stopPropagation();
        this.setValue('', '');
        this.$('[data-role="treevalue"]','[name=' + this.def.name + ']').text(this.emptyLabel);
        this.$('[name=' + this.def.id_name + ']').val();
        this.toggleClearIcon();
    },

    /**
     * Callback to handle selection of the tree.
     * @param data {Object} Data from selected node.
     */
    selectedNode: function(data) {
        if (_.isEmpty(data) || _.isEmpty(data.id) || _.isEmpty(data.name)) {
            return;
        }
        var id = data.id,
            val = data.name;
        this.setValue(id, val);
        this.closeDropDown();
        this.toggleClearIcon();
    },

    /**
     * Checks whether we need to work with dropdown on the view.
     * @private
     */
    _dropdownExists: function() {
        return this.action === 'edit' || (this.meta && this.meta.view === 'edit');
    },

    /**
     * We don't need tooltip, because it breaks dropdown.
     * @inheritdoc
     */
    decorateError: function(errors) {
        var $tooltip = $(this.exclamationMarkTemplate()),
            $ftag = this.$('span.select-arrow');
        this.$el.closest('.record-cell').addClass('error');
        this.$el.addClass('error');
        $ftag.after($tooltip);
        this.$('[data-role=parent]').addClass('error');
    },

    /**
     * Need to remove own error decoration.
     * @inheritdoc
     */
    clearErrorDecoration: function() {
        this.$el.closest('.record-cell').removeClass('error');
        this.$el.removeClass('error');
        this.$('[data-role=parent]').removeClass('error');
        this.$('.add-on.error-tooltip').remove();
        if (this.view && this.view.trigger) {
            this.view.trigger('field:error', this, false);
        }
    },

    /**
     * @inheritdoc
     */
    exclamationMarkTemplate: function() {
        var extraClass = this.view.tplName === 'record' ? 'top0' : 'top4';
        return '<span class="error-tooltip ' + extraClass + ' add-on" data-contexclamationMarkTemplateainer="body">' +
        '<i class="fa fa-exclamation-circle">&nbsp;</i>' +
        '</span>';
    }
}) },
"rowaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Rowaction is a button that when selected will trigger a Backbone Event.
 *
 * @class View.Fields.KBContents.RowactionField
 * @alias SUGAR.App.view.fields.KBContentsRowactionField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Rowaction FieldTemplate (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        if ((this.options.def.name === 'create_localization_button' ||
            this.options.def.name === 'create_revision_button') && !app.acl.hasAccessToModel('view', this.model)) {
            this.hide();
        }
    }
}) },
"enum-config": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Enum-config FieldTemplate (base) 

    extendsFrom: 'EnumField',

    /**
     * @inheritdoc
     */
    initialize: function(opts) {
        this._super('initialize', [opts]);
        if (this.model.isNew() && this.view.action === 'detail') {
            this.def.readonly = false;
        } else {
            this.def.readonly = true;
        }
    },

    /**
     * @inheritdoc
     */
    loadEnumOptions: function(fetch, callback) {
        var module = this.def.module || this.module,
            optKey = this.def.key || this.name,
            config = app.metadata.getModule(module, 'config') || {};
        this._setItems(config[optKey]);
        fetch = fetch || false;

        if (fetch || !this.items) {
            var url = app.api.buildURL(module, 'config', null, {});
            app.api.call('read', url, null, {
                success: _.bind(function(data) {
                    this._setItems(data[optKey]);
                    callback.call(this);
                }, this)
            });
        }
    },

    /**
     * @inheritdoc
     */
    _loadTemplate: function() {
        this.type = 'enum';
        this._super('_loadTemplate');
        this.type = this.def.type;
    },

    /**
     * Sets current items.
     * @param {Array} values Values to set into items.
     */
    _setItems: function(values) {
        var result = {},
            def = null;
        _.each(values, function(val) {
            var tmp = _.omit(val, 'primary');
            _.extend(result, tmp);
            if (val.primary) {
                def = _.first(_.keys(tmp));
            }
        });
        this.items = result;
        if (def && _.isUndefined(this.model.get(this.name))) {
            this.defaultOnUndefined = false;
            // call with {silent: true} on, so it won't re-render the field, since we haven't rendered the field yet
            this.model.set(this.name, def, {silent: true});
            //Forecasting uses backbone model (not bean) for custom enums so we have to check here
            if (_.isFunction(this.model.setDefault)) {
                this.model.setDefault(this.name, def);
            }
        }
    },

    /**
     * @inheritdoc
     *
     * Filters language items for different modes.
     * Disable edit mode for editing revision and for creating new revision.
     * Displays only available langs for creating localization.
     */
    setMode: function(mode) {
        if (mode == 'edit') {
            if (this.model.has('id')) {
                this.setDisabled(true);
            } else if (this.model.has('related_languages')) {
                if (this.model.has('kbarticle_id')) {
                    this.setDisabled(true);
                } else {
                    _.each(this.model.get('related_languages'), function(lang) {
                        delete this.items[lang];
                    }, this);
                    this.model.set(this.name, _.first(_.keys(this.items)), {silent: true});
                }
            }
        }
        this._super('setMode', [mode]);
    }
}) },
"sticky-rowaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.KBContents.StickyRowactionField
 * @alias SUGAR.App.view.fields.BaseKBContentsStickyRowactionField
 * @extends View.Fields.Base.StickyRowactionField
 */
({
	// Sticky-rowaction FieldTemplate (base) 

    extendsFrom: 'StickyRowactionField',

    /**
     * Disable field if it has no access to edit.
     * @inheritdoc
     */
    isDisabled: function() {
        var parentLayout = this.context.parent.get('layout');
        var parentModel = this.context.parent.get('model');

        if (
            this.def.name === 'create_button' &&
            parentLayout === 'record' &&
            !app.acl.hasAccessToModel('edit', parentModel)
        ) {
            return true;
        }
        return this._super('isDisabled');
    }

}) },
"usefulness": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Usefulness FieldTemplate (base) 

    events: {
        'click [data-action=useful]': 'usefulClicked',
        'click [data-action=notuseful]': 'notusefulClicked'
    },

    /**
     * @inheritdoc
     *
     * This field doesn't support `showNoData`.
     */
    showNoData: false,

    plugins: [],

    KEY_USEFUL: '1',
    KEY_NOT_USEFUL: '-1',

    voted: false,
    votedUseful: false,
    votedNotUseful: false,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        if (!this.model.has('useful')) {
            this.model.set('useful', 0);
        }
        if (!this.model.has('notuseful')) {
            this.model.set('notuseful', 0);
        }
        this.checkVotes();
    },

    /**
     * Check votes state,
     * Set values for votedUseful, if user voted `useful` and
     * votedNotUseful if user voted `not useful`.
     */
    checkVotes: function() {
        var vote = this.model.get('usefulness_user_vote');
        this.votedUseful = (vote == this.KEY_USEFUL);
        this.votedNotUseful = (vote == this.KEY_NOT_USEFUL);
    },

    /**
     * The vote for useful or not useful.
     *
     * @param {boolean} isUseful Flag of useful or not useful.
     */
    vote: function(isUseful) {
        if (
            (isUseful && this.model.get('usefulness_user_vote') == this.KEY_USEFUL)
            || (!isUseful && this.model.get('usefulness_user_vote') == this.KEY_NOT_USEFUL)
        ) {
            return;
        }
        var action = isUseful ? 'useful' : 'notuseful';
        var url = app.api.buildURL(this.model.module, action, {
            id: this.model.id
        });
        var callbacks = {
            success: _.bind(function(data) {
                this.model.set({
                    'usefulness_user_vote': data.usefulness_user_vote,
                    'useful': data.useful,
                    'notuseful': data.notuseful,
                    'date_modified': data.date_modified
                });
                if (!this.disposed) {
                    this.render();
                }
            }, this),
            error: function() {}
        };

        app.api.call('update', url, null, callbacks);
    },

    /**
     * Handler to vote useful when icon clicked.
     */
    usefulClicked: function() {
        this.vote(true);
    },

    /**
     * Handler to vote not useful when icon clicked.
     */
    notusefulClicked: function() {
        this.vote(false);
    },

    /**
     * @inheritdoc
     */
    _render: function() {
        this.checkVotes();
        this._super('_render');
        return this;
    }
}) },
"status": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Status FieldTemplate (base) 

    /**
     * status Widget.
     *
     * Extends from EnumField widget adding style property according to specific
     * status.
     */
    extendsFrom: 'BadgeSelectField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        /**
         * An object where its keys map to specific status and color to matching
         * CSS classes.
         */
        this.statusClasses = {
            'draft': 'label-pending',
            'in-review': 'label-warning',
            'approved': 'label-info',
            'published': 'label-success',
            'expired': 'label'
        };

        this.type = 'badge-select';
    },

    /**
     * @inheritdoc
     */
    format: function(value) {
        if (this.action === 'edit') {
            var def = this.def.default ? this.def.default : value;
            value = (this.items[value] ? value : false) ||
            (this.items[def] ? def : false) ||
            value;
        }
        return this._super('format', [value]);
    }
}) },
"attachments": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Attachments FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    events: {
        'click [data-action=download-all]': 'startDownloadArchive'
    },

    plugins: ['DragdropAttachments'],

    /**
     * @property {Object} `Select2` object.
     */
    $node: null,

    /**
     * @property {string} Selector for `Select2` dropdown.
     */
    fieldSelector: '',

    /**
     * @property {string} Unique ID for file input.
     */
    cid: null,

    /**
     * @property {string} Selector for file input.
     */
    fileInputSelector: '',

    /**
     * @property {Object} Handlebar object.
     */
    _select2formatSelectionTemplate: null,

    /**
     * Label for `Download all`.
     */
    download_label: '',

    /**
     * @inheritdoc
     */
    initialize: function (opts) {
        var evt = {},
            relate,
            self = this;
        evt['change ' + this.fileInputSelector + '[data-type=fileinput]'] = 'uploadFile';
        this.events = _.extend({}, this.events, opts.def.events, evt);

        this.fileInputSelector = opts.def.fileinput || '';
        this.fieldSelector = opts.def.field || '';
        this.cid = _.uniqueId('attachment');

        this._super('initialize', [opts]);
        this._select2formatSelectionTemplate = app.template.get('f.attachments.KBContents.selection-partial');

        /**
         * Override handling on drop attachment.
         */
        this.before('attachments:drop', this._onAttachmentDrop, this);
    },

    /**
     * Bind data changes to the field
     * @override Base attachments field made this a noop
     */
    bindDataChange: function() {
        if (this.model) {
            this.model.on('change:' + this.name, function() {
                if (!_.isEmpty(this.$node.data('select2'))) {
                    this.$node.select2('data', this.getFormattedValue());
                } else {
                    this.render();
                }
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    format: function (value) {
        return _.map(value, function (item) {
            var forceDownload = !item.isImage,
                mimeType = item.isImage ? 'image' : 'application/octet-stream',
                fileName = item.name.substring(0, item.name.lastIndexOf(".")),
                fileExt = item.name.substring(item.name.lastIndexOf(".") + 1).toLowerCase(),
                urlOpts = {
                    module: this.def.module,
                    id: item.id,
                    field: this.def.modulefield
                };

            fileExt = !_.isEmpty(fileExt) ? '.' + fileExt : fileExt;

            return _.extend(
                {},
                {
                    mimeType: mimeType,
                    fileName: fileName,
                    fileExt: fileExt,
                    url: app.api.buildFileURL(
                        urlOpts,
                        {
                            htmlJsonFormat: false,
                            passOAuthToken: false,
                            cleanCache: true,
                            forceDownload: forceDownload
                        }
                    )
                },
                item
            );
        }, this);
    },

    /**
     * @inheritdoc
     */
    _render: function () {
        if (this.action == 'noaccess') {
            return;
        }
        this.download_label = (this.value && this.value.length > 1) ? 'LBL_DOWNLOAD_ALL' : 'LBL_DOWNLOAD_ONE';
        // Please, do not put this._super call before acl check,
        // due to _loadTemplate function logic from sidecar/src/view.js file
        this._super('_render',[]);

        this.$node = this.$(this.fieldSelector + '[data-type=attachments]');
        this.setSelect2Node();
        if (this.$node.length > 0) {
            this.$node.select2({
                allowClear: true,
                multiple: true,
                containerCssClass: 'select2-choices-pills-close span12 with-padding kb-attachmentlist-details-view',
                tags: [],
                formatSelection: _.bind(this.formatSelection, this),
                width: 'off',
                escapeMarkup: function(m) {
                    return m;
                }
            });
            $(this.$node.data('select2').container).attr('data-attachable', true);
            this.refreshFromModel();
        }
        this._IEDownloadAttributeWorkaroud();
    },

    /**
     * 'Download' attribute workaround for IE browser (which does not support it)
     */
    _IEDownloadAttributeWorkaroud: function () {
        var isIE = /*@cc_on!@*/false || !!document.documentMode;
        var field = "";
        var href = "";
        if (isIE) {
            var downloadFile = function (event) {
                field = this.getAttribute("download");
                href = this.getAttribute("href");
                event.preventDefault();
                var request = new XMLHttpRequest();
                request.addEventListener("load",requestListener, false);
                request.open("get", this, true);
                request.responseType = 'blob';
                request.send();
            }
            var requestListener = function () {
                if (field == "") {
                    field = href;
                }
                var blobObject = this.response;
                window.navigator.msSaveBlob(blobObject, field);
            }
            var items = document.querySelectorAll('a[download], area[download]');
            for (var i = 0; i < items.length; i++) {
                items[i].addEventListener('click', downloadFile, false);
            }
        }
    },

    /**
     *  Update `Select2` data from model.
     */
    refreshFromModel: function () {
        var attachments = [];
        if (this.model.has(this.name)) {
            attachments = this.model.get(this.name);
        }
        this.$node.select2('data', this.format(attachments));
    },

    /**
     * Set `$node` as `Select2` object.
     * Unlink and delete attached notes on remove from select2.
     */
    setSelect2Node: function () {
        var self = this;
        if (!this.$node || this.$node.length == 0) {
            return;
        }
        this.$node.off('select2-removed');
        this.$node.off('select2-opening');

        this.$node.on('select2-removed', function(evt) {
            var note = app.data.createBean('Notes', {id: evt.val});
            note.fetch({
                success: function(model) {
                    // Do nothing with a note of original record.
                    if (!self.model.id && model.get('parent_id')) {
                        return;
                    }
                    model.destroy();
                }
            });
            self.model.set(self.name, _.filter(self.model.get(self.name),
                function(file) {
                    return (file.id !== evt.val);
                }
            ));
            self.render();
        });
        /**
         * Disables dropdown for `Select2`
         */
        this.$node.on('select2-opening', function (evt) {
            evt.preventDefault();
        });

    },

    /**
     * Return file input.
     * @return {Object}
     */
    getFileNode: function () {
        return this.$(this.fileInputSelector + '[data-type=fileinput]');
    },

    /**
     * @inheritdoc
     */
    bindDomChange: function () {
        this.setSelect2Node();
    },

    /**
     * Upload file to server.
     * Create a real note for an attachment to use drag and drop and the file in body.
     * Do not create a related note because the attachment field is enabled on create view.
     */
    uploadFile: function() {
        var self = this,
            $input = this.getFileNode(),
            note = app.data.createBean('Notes'),
            fieldName = 'filename';

        note.save({name: $input[0].files[0].name, portal_flag: true}, {
            success: function(model) {
                // FileApi uses one name for file key and defs.
                var $cloneInput = _.clone($input);
                $cloneInput.attr('name', fieldName);
                model.uploadFile(
                    fieldName,
                    $input,
                    {
                        success: function(rsp) {
                            var att = {};
                            att.id = rsp.record.id;
                            att.isImage = (rsp[fieldName]['content-type'].indexOf('image') !== -1);
                            att.name = rsp[fieldName].name;
                            self.model.set(self.name, _.union([], self.model.get(self.name) || [], [att]));
                            $input.val('');
                            self.render();
                        },
                        error: function(error) {
                            app.alert.show('delete_confirmation', {
                                level: 'error',
                                title: 'LBL_EMAIL_ATTACHMENT_UPLOAD_FAILED',
                                messages: [error.error_message]
                            });
                        }
                    }
                );
            }
        });
    },

    /**
     * Handler for 'attachments:drop' event.
     * This event is triggered when user drops file on the file field.
     *
     * @param {Event} event Drop event.
     * @return {boolean} Returns 'false' to prevent running default behavior.
     */
    _onAttachmentDrop: function(event) {
        event.preventDefault();
        var self = this,
            data = new FormData(),
            fieldName = 'filename';

        _.each(event.dataTransfer.files, function(file) {
            data.append(this.name, file);

            var note = app.data.createBean('Notes');
            note.save({name: file.name}, {
                success: function(model) {
                    var url = app.api.buildFileURL({
                        module: model.module,
                        id: model.id,
                        field: 'filename'
                    }, {htmlJsonFormat: false});
                    data.append('filename', file);
                    data.append('OAuth-Token', app.api.getOAuthToken());

                    $.ajax({
                        url: url,
                        type: 'POST',
                        data: data,
                        processData: false,
                        contentType: false,
                        success: function(rsp) {
                            var att = {};
                            att.id = rsp.record.id;
                            att.isImage = (rsp[fieldName]['content-type'].indexOf('image') !== -1);
                            att.name = rsp[fieldName].name;
                            self.model.set(self.name, _.union([], self.model.get(self.name) || [], [att]));
                            self.render();
                        }
                    });
                }
            });
        }, this);

        return false;
    },

    /**
     * Format selection for `Select2` to display.
     * @param {Object} attachment
     * @return {string}
     */
    formatSelection: function (attachment) {
        return this._select2formatSelectionTemplate(attachment);
    },

    /**
     * Download archived files from server.
     */
    startDownloadArchive: function () {
        var params = {
            format:'sugar-html-json',
            link_name: this.def.link,
            platform: app.config.platform
        };
        params[(new Date()).getTime()] = 1;

        // todo: change buildURL to buildFileURL when will be allowed "link" attribute
        var uri = app.api.buildURL(this.model.module, 'file', {
            module: this.model.module,
            id: this.model.id,
            field: this.def.modulefield
        }, params);

        app.api.fileDownload(
            uri,
            {
                error: function (data) {
                    // refresh token if it has expired
                    app.error.handleHttpError(data, {});
                }
            },
            {iframe: this.$el}
        );
    },

    /**
     * @inheritdoc
     *
     * Disposes event listeners on `Select2` object.
     */
    dispose: function () {
        this.$node.off('select2-removed');
        this.$node.off('select2-opening');
        this._super('dispose');
    },

    /**
     * We do not support this field for preview edit
     * @inheritdoc
     */
    _loadTemplate: function() {
        this._super('_loadTemplate');

        if (this.view.name === 'preview') {
            this.template = app.template.getField('attachments', 'detail', this.model.module);
        }
    }
}) },
"htmleditable_tinymce": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Htmleditable_tinymce FieldTemplate (base) 

    extendsFrom: 'Htmleditable_tinymceField',

    /**
     * Flag indicates, should we disable field.
     * @property {boolean}
     */
    shouldDisable: null,

    /**
     * KB specific parameters.
     * @private
     */
    _tinyMCEConfig: {
        'height': '300',
        'plugins': 'code,textcolor,link,image',
        'toolbar': 'code | bold italic underline strikethrough | bullist numlist | ' +
        'alignleft aligncenter alignright alignjustify | forecolor backcolor | ' +
        'removeformat | image link | fontsizeselect formatselect'
    },

    /**
     * @inheritdoc
     * Additional override fieldSelector property from field's meta.
     */
    initialize: function(opts) {
        if (opts.view.action === 'filter-rows') {
            opts.viewName = 'filter-rows-edit';
        }
        this._super('initialize', [opts]);
        this.shouldDisable = false;
        if (!_.isUndefined(this.def.fieldSelector)) {
            this.fieldSelector = '[data-htmleditable=' + this.def.fieldSelector + ']';
        }
        this.before('render', function() {
            if (this.shouldDisable != this.isDisabled()) {
                this.setDisabled(this.shouldDisable);
                return false;
            }
        }, this);
    },

    /**
     * @inheritdoc
     *
     * Apply document css style to editor.
     */
    getTinyMCEConfig: function() {
        var config = this._super('getTinyMCEConfig'),
            content_css = [];

        config = _.extend(config, this._tinyMCEConfig);

        _.each(document.styleSheets, function(style) {
            if (style.href) {
                content_css.push(style.href);
            }
        });
        config.content_css = content_css;
        config.body_class = 'kbdocument-body';

        config.file_browser_callback = _.bind(this.tinyMCEFileBrowseCallback, this);

        return config;
    },

    /**
     * @inheritdoc
     * Need to strip tags for list and activity stream.
     */
    format: function(value) {
        var result;
        switch (this.view.tplName) {
            case 'audit':
            case 'list':
            case 'activitystream':
                result = this.stripTags(value);
                break;
            default:
                result = this._super('format', [value]);
                break;
        }
        return result;
    },

    /**
     * Strip HTML tags from text.
     * @param {string} value Value to strip tags from.
     * @return {string} Plain text.
     */
    stripTags: function(value) {
        var $el = $('<div/>').html(value),
            texts = $el.contents()
            .map(function() {
                if (this.nodeType === 1 && this.nodeName != 'STYLE' && this.nodeName != 'SCRIPT') {
                    return this.textContent.replace(/ +?\r?\n/g, ' ').trim();
                }
                if (this.nodeType === 3) {
                    return this.textContent.replace(/ +?\r?\n/g, ' ').trim();
                }
            });
        return _.filter(texts, function(value) {
            return (value.length > 0);
        }).join(' ');
    },

    /**
     * @inheritdoc
     * Should check, if field should be disabled while mode change.
     */
    setMode: function(mode) {
        this.shouldDisable = (mode === 'edit' &&
            (this.view.tplName === 'list' ||
            (this.view.tplName == 'flex-list' && (this.tplName == 'subpanel-list' || this.tplName == 'list'))
            )
        );
        this._super('setMode', [mode]);
    },

    /**
     * We are trying to get HTML content instead of raw one because
     * when editor initialized it already contains some HTML (blank <p> or <br> tags).
     * In this case it will be considered as non-empty value for this field even if we don't enter anything.
     * It comes from ticket RS-1072.
     *
     * @override
     * @inheritdoc
     */
    getEditorContent: function() {
        // We can't use getContent({format: 'html'}) due to this issue https://github.com/tinymce/tinymce/issues/794
        // That's why we save HTML Editor content to HTML Field and get content directly from HTML field.
        this._htmleditor.save();
        var text = this._getHtmlEditableField().html();
        //We don't need to get empty html, to prevent model changes.
        if (text !== '') {
            text = this._super('getEditorContent');
        }
        return text;
    },

    /**
     * @inheritdoc
     */
    setViewName: function ()
    {
        this.destroyTinyMCEEditor();
        this._super('setViewName', arguments);
    }
}) },
"editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.KBContents.EditablelistbuttonField
 * @alias SUGAR.App.view.fields.KBContentsEditablelistbuttonField
 * @extends View.Fields.Base.EditablelistbuttonField
 */
({
	// Editablelistbutton FieldTemplate (base) 

    extendsFrom: 'EditablelistbuttonField',

    /**
     * @inheritdoc
     *
     * Add KBNotify plugin for field.
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], [
            'KBNotify'
        ]);
        this._super('initialize', [options]);
    },

    /**
     * Overriding custom save options to trigger kb:collection:updated event when KB model saved.
     *
     * @override
     * @param {Object} options
     */
    getCustomSaveOptions: function(options) {
        var success = _.compose(options.success, _.bind(function(model) {
            this.notifyAll('kb:collection:updated', model);
            return model;
        }, this));
        return {'success': success};
    }
}) }
}}
,
"views": {
"base": {
"kbs-dashlet-localizations": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Kbs-dashlet-localizations View (base) 

    plugins: ['Dashlet'],

    events: {
        'click [data-action=show-more]': 'loadMoreData'
    },

    /**
     * @inheritdoc
     *
     * @property {number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '5'.
     */
    _defaultSettings: {
        limit: 5
    },

    /**
     * KBContents bean collection.
     *
     * @property {Data.BeanCollection}
     */
    collection: null,

    /**
     * @inheritdoc
     *
     * Init collection.
     */
    initDashlet: function () {
        this._initSettings();
        this._initCollection();
    },

    /**
     * Sets up settings, starting with defaults.
     *
     * @return {View.Views.BaseRelatedDocumentsView} Instance of this view.
     * @protected
     */
    _initSettings: function () {
        this.settings.set(
            _.extend(
                {},
                this._defaultSettings,
                this.settings.attributes
            )
        );
        return this;
    },

    /**
     * Initialize feature collection.
     */
    _initCollection: function () {
        this.collection = app.data.createBeanCollection(this.module);
        this.context.set('collection', this.collection);
        return this;
    },

    /**
     * @inheritdoc
     *
     * Once collection has been changed, the view should be refreshed.
     */
    bindDataChange: function () {
        if (this.collection) {
            this.collection.on('add remove reset', function () {
                if (this.disposed) {
                    return;
                }
                this.render();
            }, this);
        }
    },

    /**
     * Load more data (paginate).
     */
    loadMoreData: function () {
        if (this.collection.next_offset > 0) {
            this.collection.paginate({add: true});
        }
    },

    /**
     * @inheritdoc
     */
    loadData: function (options) {
        if (this.collection.dataFetched) {
            return;
        }
        var currentContext = this.context.parent || this.context,
            model = currentContext.get('model');

        if (!model.get('kbdocument_id')) {
            model.once('sync', function() {this.loadData();}, this);
            return;
        }
        options = options || {};
        this.collection.setOption({
            limit: this.settings.get('limit'),
            fields: [
                'id',
                'name',
                'date_entered',
                'created_by',
                'created_by_name',
                'language'
            ],
            filter: {
                'kbdocument_id': {
                    '$equals': model.get('kbdocument_id')
                },
                'id' : {
                    '$not_equals': model.get('id')
                },
                'status': {
                    '$equals': 'published'
                },
                'active_rev': {
                    '$equals': 1
                }
            }
        });
        if (!options.error) {
            options.error = _.bind(function(collection, error) {
                if (error.code === 'not_authorized') {
                    this.$el.find('.block-footer').html(app.lang.get('LBL_NO_DATA_AVAILABLE', this.module));
                }
            }, this);
        }
        this.collection.fetch(options);
    }
}) },
"subpanel-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Custom Subpanel Layout for Revenue Line Items.
 *
 * @class View.Views.Base.KBContents.SubpanelListView
 * @alias SUGAR.App.view.views.BaseKBContentsSubpanelListView
 * @extends View.Views.Base.SubpanelListView
 */
({
	// Subpanel-list View (base) 

    extendsFrom: 'SubpanelListView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['KBContent']);
        this._super('initialize', [options]);
    }
}) },
"filter-rows": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Filter-rows View (base) 

    extendsFrom: 'FilterRowsView',

    /**
     * @inheritdoc
     *
     * Add 'kbdocument_body' filter field only on KBContents listView. This field is not present in filter's
     * metadata to avoid its appearance on KBContents subpanels - this is done due to technical inability to make
     * REST calls to specific module's RelateApi and thus to perform KB specific filtering logic.
     */
    loadFilterFields: function(module) {
        this._super('loadFilterFields', [module]);
        if (this.context.get('layout') === 'records') {
            var bodyField = this.model.fields['kbdocument_body'];
            this.fieldList[bodyField.name] = bodyField;
            this.filterFields[bodyField.name] = app.lang.get(bodyField.vname, this.module);
        }
    }
}) },
"prefilteredlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PrefilterelistView
 * @alias SUGAR.App.view.views.BasePrefilteredlistView
 * @extends View.Views.Base.RecordlistView
 */
({
	// Prefilteredlist View (base) 

    extendsFrom: 'RecordlistView',

    /**
     * Load recordlist templates.
     * @inheritdoc
     */
    _loadTemplate: function(options) {
        this.tplName = 'recordlist';
        this.template = app.template.getView(this.tplName);
    }
}) },
"panel-top-for-revisions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Panel-top-for-revisions View (base) 

    extendsFrom: 'PanelTopView',

    plugins: ['KBContent'],

    /**
     * @inheritdoc
     */
    createRelatedClicked: function(event) {
        var parentModel = this.context.parent.get('model');
        if (parentModel) {
            this.createRelatedContent(parentModel, this.CONTENT_REVISION);
        }
    }
}) },
"module-menu": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Module menu provides a reusable and easy render of a module Menu.
 *
 * This also helps doing customization of the menu per module and provides more
 * metadata driven features.
 *
 * @class View.Views.Base.KBContents.ModuleMenuView
 * @alias SUGAR.App.view.views.BaseKBContentsModuleMenuView
 * @extends View.Views.Base.ModuleMenuView
 */
({
	// Module-menu View (base) 

    extendsFrom: 'ModuleMenuView',

    /**
     * Root ID of a shown NestedSet.
     * @property {string}
     */
    categoryRoot: null,

    /**
     * Module which implements NestedSet.
     */
    moduleRoot: null,

    /**
     * Panel label.
     */
    label: null,

    /**
     * @inheritdoc
     *
     * Init additional properties and events.
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        var module = this.meta.config.config_provider || this.context.get('module'),
            config = app.metadata.getModule(module, 'config');
        this.categoryRoot = this.meta.config.category_root || config.category_root || '';
        this.moduleRoot = this.meta.config.data_provider || module;

        this.label = this.meta.label || '';

        this.events = _.extend({}, this.events, {
            'click [data-event="tree:list:fire"]': 'handleCategoriesList'
        });
    },

    /**
     * Handle click on KB category menu item.
     */
    handleCategoriesList: function() {
        var treeOptions = {
            category_root: this.categoryRoot,
            module_root: this.moduleRoot,
            plugins: ['dnd', 'contextmenu'],
            isDrawer: true
        };

        var treeCallbacks = {
                'onSelect': function() {
                    return;
                },
                'onRemove': function(node) {
                    if (this.context.parent) {
                        this.context.parent.trigger('kbcontents:category:deleted', node);
                    }
                }
            },
        // @TODO: Find out why params from context for drawer don't pass to our view tree::_initSettings
            context = _.extend({}, this.context, {treeoptions: treeOptions, treecallbacks: treeCallbacks});
        if (app.drawer.getActiveDrawerLayout().module === this.moduleRoot) {
            app.drawer.closeImmediately();
        }
        app.drawer.open({
            layout: 'nested-set-list',
            context: {
                module: this.moduleRoot,
                parent: context,
                title: app.lang.getModString(this.label, this.module),
                treeoptions: treeOptions,
                treecallbacks: treeCallbacks
            }
        });
    },

    /**
     * @inheritdoc
     */
    populate: function(tplName, filter, limit) {
        if (limit <= 0) {
            return;
        }
        filter =  _.union([], filter, this.meta.filterDef || []);
        this.getCollection(tplName).fetch({
            'showAlerts': false,
            'fields': ['id', 'name'],
            'filter': filter,
            'limit': limit,
            'success': _.bind(function() {
                this._renderPartial(tplName);
            }, this)
        });
    }
}) },
"config-languages": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.KBContentsConfigLanguagesView
 * @alias SUGAR.App.view.layouts.BaseKBContentsConfigLanguages
 * @extends View.Views.Base.ConfigPanelView
 */
({
	// Config-languages View (base) 

    extendsFrom: 'ConfigPanelView',

    /**
     * @inheritdoc
     */
    initialize: function (options) {
        this._super('initialize', [options]);
        var model = this.context.get('model');
        model.fields = this.getFieldNames();
        model.addValidationTask('validate_config_languages', _.bind(this._validateLanguages, this));
        model.on('validation:success', _.bind(this._validationSuccess, this));

        app.error.errorName2Keys['lang_empty_key'] = 'ERR_CONFIG_LANGUAGES_EMPTY_KEY';
        app.error.errorName2Keys['lang_empty_value'] = 'ERR_CONFIG_LANGUAGES_EMPTY_VALUE';
        app.error.errorName2Keys['lang_duplicate'] = 'ERR_CONFIG_LANGUAGES_DUPLICATE';
    },

    /**
     * Validate languages duplicates.
     * @param {Object} fields
     * @param {Object} errors
     * @param {Function} callback
     */
    _validateLanguages: function (fields, errors, callback) {
        var model = this.context.get('model'),
            languages = this.model.get('languages'),
            languagesToSave = [],
            index = 0,
            languageErrors = [];

        _.each(languages, function(lang) {
            var lng = _.omit(lang, 'primary'),
                key = _.first(_.keys(lng)),
                val = lang[key].trim();
            if (val.length === 0) {
                languageErrors.push({
                    'message': app.error.getErrorString('lang_empty_value', this),
                    'key': key,
                    'ind': index,
                    'type': 'value'
                });
            }
            index = index + 1;
            languagesToSave.push(key.trim().toLowerCase());
        }, this);

        if ((index = _.indexOf(languagesToSave, '')) !== -1) {
            languageErrors.push({
                'message': app.error.getErrorString('lang_empty_key', this),
                'key': '',
                'ind': index,
                'type': 'key'
            });
        }

        if (languagesToSave.length !== _.uniq(languagesToSave).length) {
            var tmp = languagesToSave.slice(0);
            tmp.sort();
            for (var i = 0; i < tmp.length - 1; i++) {
                if (tmp[i + 1] == tmp[i]) {
                    languageErrors.push({
                        'message': app.error.getErrorString('lang_duplicate', this),
                        'key': tmp[i],
                        'ind': _.indexOf(languagesToSave, tmp[i]),
                        'type': 'key'
                    });
                }
            }
        }

        if (languageErrors.length > 0) {
            errors.languages = errors.languages || {};
            errors.languages.errors = languageErrors;
            app.alert.show('languages', {
                level: 'error',
                autoClose: true,
                messages: app.lang.get('ERR_RESOLVE_ERRORS')
            });
        }
        callback(null, fields, errors);
    },

    /**
     * On success validation, trim language keys and labels
     */
    _validationSuccess: function () {
        var model = this.context.get('model'),
            languages = this.model.get('languages');

        // trim keys
        var buf = _.map(languages, function(lang) {
            var prim = lang['primary'],
                lng = _.omit(lang, 'primary'),
                key = _.first(_.keys(lng)),
                val = lang[key].trim();

            key = key.trim();
            var res = {primary: prim};
            res[key] = val;

            return res;
        }, this);

        model.set('languages', buf);
    }
}) },
"prefiltered-headerpane": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.PrefilteredHeaderpaneView
 * @alias SUGAR.App.view.views.BasePrefilteredHeaderpaneView
 * @extends View.Views.Base.SelectionHeaderpaneView
 */

({
	// Prefiltered-headerpane View (base) 

    extendsFrom: 'SelectionHeaderpaneView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.meta.fields = _.map(this.meta.fields, function(field) {
            if (field.name === 'title') {
                field['formatted_value'] = this.context.get('headerPaneTitle')
                    || this._formatTitle(field['default_value'])
                    || app.lang.get(field['value'], this.module);
                this.title = field['formatted_value'];
            }
            return field;
        }, this);
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Create View (base) 

    extendsFrom: 'CreateView',

    /**
     * @inheritdoc
     *
     * Add KBContent plugin for view.
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], [
            'KBContent',
            'KBNotify'
        ]);
        this._super('initialize', [options]);
    },

    /**
     * Using the model returned from the API call, build the success message.
     * @param {Data.Bean} model KBContents bean for record that was just created.
     * @return {string} The success message.
     */
    buildSuccessMessage: function(model) {
        var message = this._super('buildSuccessMessage', [model]);

        // If user has no access to view record - don't show record link for him
        if (!app.acl.hasAccessToModel('view', this.model)) {
            message = message.replace(/<\/?a[^>]+>/g, '');
        }

        return message;
    },

    /**
     * Overriding custom save options to trigger kb:collection:updated event when KB model saved.
     *
     * @override
     * @param {Object} options
     */
    getCustomSaveOptions: function(options) {
        var success = _.compose(options.success, _.bind(function(model) {
            this.notifyAll('kb:collection:updated', model);
            return model;
        }, this));
        return {'success': success};
    }
}) },
"preview": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.KBContentsPreviewView
 * @alias SUGAR.App.view.views.BaseKBContentsPreviewView
 * @extends View.Views.Base.PreviewView
 */
({
	// Preview View (base) 


    extendsFrom: 'PreviewView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['KBContent']);
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     * @TODO: Need to be removed after BR-2704 fixed.
     */
    _previewifyMetadata: function(meta) {
        _.each(meta.panels, function(panel) {
            panel.fields = _.filter(panel.fields, function(def) {
                if (def.type == 'fieldset' && !_.isEmpty(def.fields)) {
                    return _.find(def.fields, function(def) {
                        return def.type !== 'htmleditable_tinymce';
                    }) === undefined;
                }
                return def.type !== 'htmleditable_tinymce';
            });
        }, this);
        return this._super('_previewifyMetadata', [meta]);
    },

    /**
     * We don't need to initialize KB listeners.
     * @override.
     * @private
     */
    _initKBListeners: function() {}
}) },
"config-header-buttons": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.SchedulersJobsConfigHeaderButtonsView
 * @alias SUGAR.App.view.layouts.BaseSchedulersJobsConfigHeaderButtonsView
 * @extends View.Views.Base.ConfigHeaderButtonsView
 */
({
	// Config-header-buttons View (base) 

    extendsFrom: 'ConfigHeaderButtonsView',

    /**
     * Saves the config model
     *
     * Also calling doValidate to check that there is no Language duplication
     *
     * @private
     */
    _saveConfig: function() {
        var self = this,
            model = this.context.get('model');

        // Standard ConfigHeaderButtonsView doesn't use doValidate
        model.doValidate(null, function(isValid) {
            if (isValid) {
                self._super('_saveConfig');
            } else {
                self.getField('save_button').setDisabled(false);
            }
        });
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     *
     * Add KBContent plugin for view.
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], [
            'KBContent'
        ]);

        this._super('initialize', [options]);
        this.context.on('kbcontents:category:deleted', this._categoryDeleted, this);
    },

    /**
     * Process record on category delete.
     * @param {Object} node
     * @private
     */
    _categoryDeleted: function(node) {
        if (this.model.get('category_id') === node.data('id')) {
            this.model.unset('category_id');
            this.model.unset('category_name');
        }
        if (this.disposed) {
            return;
        }
        this.render();
    },

    /**
     * @inheritdoc
     *
     * Need to switch field to `edit` if it has errors.
     */
    handleFieldError: function(field, hasError) {
        this._super('handleFieldError', [field, hasError]);
        if (hasError && field.tplName === 'detail') {
            field.setMode('edit');
        }
    }

}) },
"list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// List View (base) 

    extendsFrom: 'ListView',

    /**
     * @inheritdoc
     *
     * Add KBContent plugin for view.
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], [
            'KBContent'
        ]);

        this._super('initialize', [options]);
    }

}) },
"subpanel-for-localizations": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Subpanel-for-localizations View (base) 

    extendsFrom: 'SubpanelListView',

    /**
     * @inheritdoc
     */
    dataView: 'subpanel-for-localizations',

    /**
     * @inheritdoc
     *
     * Check access to model.
     * Setup dataView to load correct viewdefs from subpanel-for-localizations
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        if (!app.acl.hasAccessToModel('edit', this.model)) {
            this.context.set('requiredFilter', 'records-noedit');
        }
    },

    /**
     * @inheritdoc
     *
     * Removes 'status' field from options if there is no access to model.
     */
    parseFieldMetadata: function(options) {
        options = this._super('parseFieldMetadata', [options]);

        if (app.acl.hasAccess('edit', options.module)) {
            return options;
        }

        _.each(options.meta.panels, function(panel, panelIdx) {
            panel.fields = _.filter(panel.fields, function(field) {
                return field.name !== 'status';
            }, this);
        }, this);

        return options;
    }
}) },
"massupdate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Massupdate View (base) 

    extendsFrom: 'MassupdateView',
    
    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['CommittedDeleteWarning', 'KBContent', 'KBNotify']);
        this._super('initialize', [options]);
    },

    /**
     * @inheritdoc
     */
    saveClicked: function(evt) {
        var massUpdateModels = this.getMassUpdateModel(this.module).models,
            fieldsToValidate = this._getFieldsToValidate(),
            emptyValues = [];

        this._restoreInitialState(massUpdateModels);

        this._doValidateMassUpdate(massUpdateModels, fieldsToValidate, _.bind(function(fields, errors) {
            if (_.isEmpty(errors)) {
                this.trigger('massupdate:validation:complete', {
                    errors: errors,
                    emptyValues: emptyValues
                });
                if(this.$('.btn[name=update_button]').hasClass('disabled') === false) {
                    this.listenTo(this.collection, 'data:sync:complete', _.bind(function() {
                        this.notifyAll('kb:collection:updated');
                        this.stopListening(this.collection);
                    }, this));
                    this.save();
                }
            } else {
                this.handleValidationError(errors);
            }
        }, this));
    },

    /**
     * Restore models state.
     *
     * @param {Array} models
     * @private
     */
    _restoreInitialState: function(models) {
        _.each(models, function(model) {
            model.revertAttributes();
        });
    },

    /**
     * Custom MassUpdate validation.
     *
     * @param {Object} models
     * @param {Object} fields
     * @param {Function} callback
     * @private
     */
    _doValidateMassUpdate: function(models, fields, callback) {
        var checkField = 'status',
            errorFields = [],
            messages = [],
            errors = {},
            updatedValues = {};
        _.each(fields, function(field) {
            updatedValues[field.name] = this.model.get(field.name);
            if (undefined !== field.id_name && this.model.has(field.id_name)) {
                updatedValues[field.id_name] = this.model.get(field.id_name);
            }
        }, this);
        _.each(models, function(model) {
            var values = _.extend({}, model.toJSON(), updatedValues),
                newModel = app.data.createBean(model.module, values);
            if (undefined !== updatedValues[checkField] && updatedValues[checkField] === 'approved') {
                this._doValidateActiveDateField(newModel, fields, errors, function(model, fields, errors) {
                    var fieldName = 'active_date';
                    if (!_.isEmpty(errors[fieldName])) {
                        errors[checkField] = errors[fieldName];
                        errorFields.push(fieldName);
                        messages.push(app.lang.get('LBL_SPECIFY_PUBLISH_DATE', 'KBContents'));
                    }
                });
            }
            this._doValidateExpDateField(newModel, fields, errors, function(model, fields, errors) {
                var fieldName = 'exp_date';
                if (!_.isEmpty(errors[fieldName])) {
                    errors[checkField] = errors[fieldName];
                    errorFields.push(fieldName);
                    messages.push(app.lang.get('LBL_MODIFY_EXP_DATE_LOW', 'KBContents'));
                }
            });
        }, this);

        if (!_.isEmpty(errorFields)) {
            if (!_.isUndefined(errors.active_date) && errors.active_date.activeDateLow ||
                !_.isUndefined(errors.exp_date) && errors.exp_date.expDateLow) {
                callback(fields, errors);
                return;
            }
            errorFields.push(checkField);
            app.alert.show('save_without_publish_date_confirmation', {
                level: 'confirmation',
                messages: _.uniq(messages),
                confirm: {
                    label: app.lang.get('LBL_YES')
                },
                cancel: {
                    label: app.lang.get('LBL_NO')
                },
                onConfirm: function() {
                    errors = _.filter(errors, function(error, key) {
                        _.indexOf(errorFields, key) === -1;
                    });
                    callback(fields, errors);
                }
            });
        } else {
            callback(fields, errors);
        }
    },

    /**
     * We don't need to initialize KB listeners.
     * @override.
     * @private
     */
    _initKBListeners: function() {},
    
    /**
     * @inheritdoc
     */
    cancelClicked: function(evt) {
        this._restoreInitialState(this.getMassUpdateModel(this.module).models);
        this._super('cancelClicked', [evt]);
    }
}) },
"subpanel-for-revisions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Subpanel-for-revisions View (base) 

    extendsFrom: 'SubpanelListView',

    /**
     * @inheritdoc
     */
    dataView: 'subpanel-for-revisions',

}) },
"kbs-dashlet-usefulness": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Kbs-dashlet-usefulness View (base) 

    plugins: ['Dashlet'],

    /**
     * Holds report data from the server's endpoint once we fetch it
     */
    chartData: undefined,

    /**
     * We'll use this property to bind loadData function for event
     */
    refresh: null,

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.chartData = new Backbone.Model();
        this._super('initialize', [options]);
        this.refresh = _.bind(this.loadData, this);
        this.listenTo(app.controller.context.get('model'), 'change:useful', this.refresh);
        this.listenTo(app.controller.context.get('model'), 'change:notuseful', this.refresh);
    },

    /**
     * @inheritdoc
     */
    loadData: function(options) {
        var currModel = app.controller.context.get('model'),
            model = currModel.clone(),
            opts = options || {},
            self = this;

        model.fetch({
            success: function(model) {
                var dt = self.layout.getComponent('dashlet-toolbar'),
                    useful = model.get('useful') || '0',
                    notuseful = model.get('notuseful') || '0';
                if (dt) {
                    // manually set the icon class to spiny
                    self.$('[data-action=loading]')
                        .removeClass(dt.cssIconDefault)
                        .addClass(dt.cssIconRefresh);
                }

                useful = parseInt(useful, 10);
                notuseful = parseInt(notuseful, 10);

                // correcting values for pie chart,
                // because pie chart not support all zero values.
                if (0 === useful && 0 === notuseful) {
                    self.chartData.set({rawChartData: {values: []}});
                    return;
                }
                var chartData = {
                        properties: [
                            {
                                labels: 'value',
                                type: 'pie chart'
                            }
                        ],
                        values: [
                            {
                                label: [app.lang.get('LBL_USEFUL', 'KBContents')],
                                values: [useful],
                                classes: 'nv-fill-green'
                            },
                            {
                                label: [app.lang.get('LBL_NOT_USEFUL', 'KBContents')],
                                values: [notuseful],
                                classes: 'nv-fill-red'
                            }
                        ]
                    },
                    chartParams = {
                        donut: true,
                        donutRatio: 0.45,
                        hole: parseInt(useful * 100 / (notuseful + useful)) + '%',
                        donutLabelsOutside: true,
                        colorData: 'data',
                        chart_type: 'pie chart',
                        show_legend: false,
                        show_title: false
                    };
                _.defer(_.bind(function() {
                    self.chartData.set({rawChartData: chartData, rawChartParams: chartParams});
                }, this));
            },
            complete: function() {
                if (opts && _.isFunction(opts.complete)) {
                    opts.complete();
                }
            }
        });
    },

    /**
     * @inheritdoc
     *
     * Dispose listeners for 'change:useful' and 'change:notuseful' events.
     */
    dispose: function() {
        this.stopListening(app.controller.context.get('model'), 'change:useful', this.refresh);
        this.stopListening(app.controller.context.get('model'), 'change:notuseful', this.refresh);
        this._super('dispose');
    }
}) },
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Recordlist View (base) 

    extendsFrom: 'RecordlistView',

    /**
     * @inheritdoc
     *
     * Add KBContent plugin for view.
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], [
            'KBContent',
            'KBNotify'
        ]);

        this._super('initialize', [options]);

        this.layout.on('list:record:deleted', function() {
            this.refreshCollection();
            this.notifyAll('kb:collection:updated');
        }, this);

        this.context.on('kbcontents:category:deleted', function(node) {
            this.refreshCollection();
            this.notifyAll('kb:collection:updated');
        }, this);

        if (!app.acl.hasAccessToModel('edit', this.model)) {
            this.context.set('requiredFilter', 'records-noedit');
        }
    }
}) },
"help-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Help-create View (base) 

    // TODO: Remove this View completely, when it is possible to place a standard help-dashlet to the Create layout

    /**
     * @inheritdoc
     */
    _renderHtml: function () {
        var helpUrl = {
                more_info_url: this.createMoreHelpLink(),
                more_info_url_close: '</a>'
            },
            helpObject = app.help.get(this.context.get('module'), 'create', helpUrl);

        this._super('_renderHtml', [helpObject, this.options]);
    },

    /**
     * Collects server version, language, module, and route and returns an HTML link to be used
     * in the template
     *
     * @returns {string} The HTML a-tag for the More Help link
     */
    createMoreHelpLink: function () {
        var serverInfo = app.metadata.getServerInfo(),
            lang = app.lang.getLanguage(),
            module = app.controller.context.get('module'),
            route = 'create';

        var url = 'http://www.sugarcrm.com/crm/product_doc.php?edition=' + serverInfo.flavor
            + '&version=' + serverInfo.version + '&lang=' + lang + '&module=' + module + '&route=' + route;

        return '<a href="' + url + '" target="_blank">';
    }
}) },
"panel-top-for-localizations": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Panel-top-for-localizations View (base) 

    extendsFrom: 'PanelTopView',

    plugins: ['KBContent'],

    /**
     * @inheritdoc
     */
    createRelatedClicked: function(event) {
        var parentModel = this.context.parent.get('model');
        if (parentModel) {
            this.createRelatedContent(parentModel, this.CONTENT_LOCALIZATION);
        }
    }
}) },
"filter-module-dropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Filter-module-dropdown View (base) 

    extendsFrom: 'FilterModuleDropdownView',

    /**
     * @inheritdoc
     */
    getModuleListForSubpanels: function() {
        var filters = [];
        filters.push({id: 'all_modules', text: app.lang.get('LBL_MODULE_ALL')});

        var subpanels = this.pullSubpanelRelationships(),
            subpanelsAcls = this._getSubpanelsAclsActions();

        subpanels = this._pruneHiddenModules(subpanels);
        _.each(subpanels, function(value, key) {
            var module = app.data.getRelatedModule(this.module, value),
                aclToCheck = !_.isUndefined(subpanelsAcls[value]) ? subpanelsAcls[value] : 'list';

            if (app.acl.hasAccess(aclToCheck, module)) {
                filters.push({id: value, text: app.lang.get(key, this.module)});
            }
        }, this);
        return filters;
    },

    /**
     * Returns acl actions for subpanels based on metadata.
     * @return {Object} Alcs for subpanels.
     * @private
     */
    _getSubpanelsAclsActions: function() {
        var subpanelsMeta = app.metadata.getModule(this.module).layouts.subpanels,
            subpanelsAclActions = {};

        if (subpanelsMeta && subpanelsMeta.meta && subpanelsMeta.meta.components) {
            _.each(subpanelsMeta.meta.components, function(comp) {
                if (comp.context && comp.context.link) {
                    subpanelsAclActions[comp.context.link] = comp.acl_action ?
                        comp.acl_action : 'list';
                }
            });
        }

        return subpanelsAclActions;
    }
}) },
"kbs-dashlet-most-useful": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Kbs-dashlet-most-useful View (base) 

    plugins: ['Dashlet'],

    events: {
        "click [data-action=show-more]": "loadMoreData"
    },

    /**
     * KBContents bean collection.
     *
     * @property {Data.BeanCollection}
     */
    collection: null,

    /**
     * We'll use this property to bind loadData function for event
     */
    refresh: null,

    /**
     * @inheritdoc
     */
    initialize: function (options) {
        var self = this;
        
        options.module = 'KBContents';
        this._super('initialize', [options]);
        this.refresh = _.bind(this.loadData, this);

        if (_.isUndefined(this.meta.config) || this.meta.config === false){
            this.listenTo(this.context.parent.get('collection'), 'sync', function () {
                if (self.collection) {
                    self.collection.dataFetched = false;
                    self.layout.reloadDashlet(options);
                }
            });
        }

        this._initCollection();
        this.listenTo(app.controller.context.get('model'), 'change:useful', this.refresh);
        this.listenTo(app.controller.context.get('model'), 'change:notuseful', this.refresh);
    },

    /**
     * Initialize feature collection.
     */
    _initCollection: function () {
        this.collection = app.data.createBeanCollection(this.module);
        this.collection.setOption({
            params: {
                order_by: 'useful:desc,notuseful:asc,viewcount:desc,date_entered:desc',
                mostUseful: true
            },
            limit: 3,
            fields: [
                'id',
                'name',
                'date_entered',
                'created_by',
                'created_by_name'
            ],
            filter: {
                'active_rev': {
                    '$equals': 1
                },
                'useful': {
                    '$gt': {
                        '$field': 'notuseful'
                    }
                },
                'status': {
                    '$equals': 'published'
                }
            }
        });
        return this;
    },

    /**
     * @inheritdoc
     *
     * Once collection has been changed, the view should be refreshed.
     */
    bindDataChange: function () {
        if (this.collection) {
            this.collection.on('add remove reset', function () {
                if (this.disposed) {
                    return;
                }
                this.render();
            }, this);
        }
    },

    /**
     * Load more data (paginate)
     */
    loadMoreData: function () {
        if (this.collection.next_offset > 0) {
            this.collection.paginate({add: true});
        }
    },

    /**
     * @inheritdoc
     */
    loadData: function (options) {
        this.collection.resetPagination();
        this.collection.fetch({
            success: function () {
                if (options && options.complete) {
                    options.complete();
                }
            },
            error: _.bind(function(collection, error) {
                if (error.code === 'not_authorized') {
                    this.$el.find('.block-footer').html(app.lang.get('LBL_NO_DATA_AVAILABLE', this.module));
                }
            }, this)
        });
    },

    /**
     * @inheritdoc
     *
     * Dispose listeners for 'change:useful' and 'change:notuseful' events.
     */
    dispose: function() {
        this.stopListening(app.controller.context.get('model'), 'change:useful', this.refresh);
        this.stopListening(app.controller.context.get('model'), 'change:notuseful', this.refresh);
        this._super('dispose');
    }
}) },
"panel-top-for-cases": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Views.Base.KBContentsPanelTopForCases
 * @alias SUGAR.App.view.views.BaseKBContentsPanelTopForCases
 * @extends View.Views.Base.PanelTopView
 */

({
	// Panel-top-for-cases View (base) 

    extendsFrom: 'PanelTopView',
    plugins: ['KBContent'],
    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
    },
    /**
     * Event handler for the create button.
     *
     * @param {Event} event The click event.
     */
    createRelatedClicked: function(event) {
        this.createArticleSubpanel();
    },
}) },
"related-documents": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Related-documents View (base) 

    plugins: ['Dashlet'],

    events: {
        'click [data-action=show-more]': 'loadMoreData'
    },

    /**
     * @inheritdoc
     *
     * @property {Object} _defaultSettings Default settings.
     * @property {number} _defaultSettings.limit Maximum number of records to
     *   load per request, defaults to '5'.
     */
    _defaultSettings: {
        limit: 5
    },

    /**
     * KBContents bean collection.
     *
     * @property {Data.BeanCollection}
     */
    collection: null,

    /**
     * @inheritdoc
     *
     * Initialize settings and collection.
     */
    initDashlet: function() {
        this._initSettings();
        this._initCollection();
    },

    /**
     * Sets up settings, starting with defaults.
     *
     * @return {View.Views.BaseRelatedDocumentsView} Instance of this view.
     * @protected
     */
    _initSettings: function() {
        this.settings.set(
            _.extend(
                {},
                this._defaultSettings,
                this.settings.attributes
            )
        );

        return this;
    },

    /**
     * Initialize feature collection.
     */
    _initCollection: function() {
        this.collection = app.data.createBeanCollection(this.module);
        this.collection.options = {
            limit: this.settings.get('limit'),
            fields: [
                'id',
                'name',
                'date_entered',
                'created_by',
                'created_by_name'
            ]
        };
        this.collection.sync = _.wrap(
            this.collection.sync,
            _.bind(function(sync, method, model, options) {
                options = options || {};
                var viewModelId = this.model.get('id')
                    || this.context.get('model').get('id')
                    || this.context.parent.get('model').get('id');
                options.endpoint = function(method, model, options, callbacks) {
                    var url = app.api.buildURL(
                        model.module,
                        'related_documents',
                        {
                            id: viewModelId
                        },
                        options.params
                    );
                    return app.api.call('read', url, {}, callbacks);
                };
                sync(method, model, options);
            }, this)
        );

        this.context.set('collection', this.collection);
        return this;
    },

    /**
     * @inheritdoc
     *
     * Once collection has been changed, the view should be refreshed.
     */
    bindDataChange: function() {
        if (this.collection) {
            this.collection.on('add remove reset', this.render, this);
        }
    },

    /**
     * Load more data (paginate)
     */
    loadMoreData: function() {
        if (this.collection.next_offset > 0) {
            this.collection.paginate({add: true});
        }
    },

    /**
     * @inheritdoc
     *
     * Fetch collection if it was not fetched before.
     */
    loadData: function(options) {
        options = options || {};
        if (this.collection.dataFetched) {
            return;
        }
        this.collection.fetch(options);
    }
}) },
"dashlet-nestedset-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Dashlet-nestedset-list View (base) 


    plugins: ['Dashlet', 'NestedSetCollection', 'JSTree', 'KBNotify'],

    /**
     * Module name that provides an netedset data.
     *
     * @property {String}
     */
    moduleRoot: null,

    /**
     * Root ID of a shown NestedSet.
     * @property {String}
     */
    categoryRoot: null,

    /**
     * Module to load additional data into nested set.
     * @property {Object}
     * @property {String} extraModule.module Module to load additional data from.
     * @property {String} extraModule.field Linked field of provided module.
     */
    extraModule: null,

    /**
     * Cache to store loaded leafs to prevent extra loading.
     * @property {Object}
     */
    loadedLeafs: null,

    /**
     * Lifetime for data cache in ms.
     * @property {Number}
     */
    cacheLifetime: 300000,

    /**
     * Flag which indicate, if we need to use saved states.
     * @property {Boolean}
     */
    useStates: true,

    /**
     * Value of extraModule.field.
     * @property {String}
     */
    currentFieldValue: null,

    /**
     * Flag indicates should we hide tree.
     */
    hidden: null,

    /**
     * Initialize dashlet properties.
     */
    initDashlet: function() {
        var config = app.metadata.getModule(
            this.meta.config_provider,
            'config'
            ),
            currentContext = this.context.parent || this.context,
            currentModule = currentContext.get('module'),
            currentAction = currentContext.get('action');
        this.moduleRoot = this.settings.get('data_provider');
        this.categoryRoot = !_.isUndefined(config.category_root) ?
            config.category_root :
            null;
        this.extraModule = this.meta.extra_provider || {};
        if (currentModule === this.extraModule.module &&
            (currentAction === 'detail' || currentAction === 'edit')
        ) {
            this.useStates = false;
            this.changedCallback = _.bind(this.modelFieldChanged, this);
            this.savedCallback = _.bind(this.modelSaved, this);

            this.context.get('model').on('change:' + this.extraModule.field, this.modelFieldChanged, this);
            this.context.get('model').on('data:sync:complete', this.modelSaved, this);

            this.currentFieldValue = this.context.get('model').get(this.extraModule.field);
            this.on('openCurrentParent', this.hideTree, this);
        } else {
            this.on('stateLoaded', this.hideTree, this);
        }
        currentContext.on('subpanel:reload', function(args) {
            if (!_.isUndefined(args) &&
                _.isArray(args.links) &&
                (_.contains(args.links, 'revisions') || _.contains(args.links, 'localizations'))
            ) {
                this.layout.reloadDashlet({complete: function() {}, saveLeafs: false});
            }
        }, this);

        this.on('kb:collection:updated', _.bind(function() {
            _.defer(function(self) {
                if (self.layout.disposed === true) {
                    return;
                }
                if (!_.isUndefined(self.layout.reloadDashlet)) {
                    self.layout.reloadDashlet({complete: function() {}, saveLeafs: false});
                }
            }, this);
        }, this));

    },

    /**
     * The view doesn't need standard handlers for data change because it use own events and handlers.
     *
     * @override.
     */
    bindDataChange: function() {},

    /**
     * @inheritdoc
     */
    _render: function() {
        this._super('_render');
        if (this.meta.config) {
            return;
        }
        this.hideTree(this.hidden);
        var treeOptions = {
            settings: {
                category_root: this.categoryRoot,
                module_root: this.moduleRoot,
                plugins: [],
                liHeight: 14
            },
            options: {
            }},
            callbacks = {
                onLeaf: _.bind(this.leafClicked, this),
                onToggle: _.bind(this.folderToggled, this),
                onLoad: _.bind(this.treeLoaded, this),
                onSelect: _.bind(this.openRecord, this),
                onLoadState:  _.bind(this.stateLoaded, this)
            };
        if (this.useStates === true) {
            treeOptions.settings.plugins.push('state');
            treeOptions.options.state = {
                save_selected: false,
                auto_save: false,
                save_opened: 'jstree_open',
                options: {},
                storage: this._getStorage()
            };
        }
        this._renderTree(this.$('[data-place=dashlet-tree]'), treeOptions, callbacks);
    },

    /**
     * Return storage for tree state.
     * @return {Function}
     * @private
     */
    _getStorage: function () {
        var self = this;
        return function(key, value, options) {
            var intKey = app.user.lastState.buildKey(self.categoryRoot, self.moduleRoot, self.module);
            if (!_.isUndefined(value)) {
                app.user.lastState.set(intKey, value);
            }
            return app.user.lastState.get(intKey);
        };
    },

    /**
     * Handle tree selection.
     * @param data {Object} Selected item.
     */
    openRecord: function(data) {
        switch (data.type) {
            case 'document':
                if (_.isEmpty(this.extraModule.module)) {
                    break;
                }
                if (!this.$el.find('[data-id=' + data.id +']').data('disabled')) {
                    var route = app.router.buildRoute(this.extraModule.module, data.id);
                    app.router.navigate(route, {trigger: true});
                }
                break;
            case 'folder':
                if (this.$el.find('[data-id=' + data.id +']').hasClass('jstree-closed')) {
                    this.openNode(data.id);
                    data.open = true;
                } else {
                    this.closeNode(data.id);
                    data.open = false;
                }
                this.folderToggled(data);
                break;
        }
    },

    /**
     * Handle tree loaded. Load additional leafs for the tree.
     * @return {boolean} If tree has been loaded.
     */
    treeLoaded: function() {
        var self = this;
        if (this.collection === undefined) {
            return false;
        }
        this.bulkLoadLeafs(this.collection.models, function() {
            if (self.useStates) {
                self.loadJSTreeState();
            } else {
                self.openCurrentParent();
            }
        });
        return true;
    },

    /**
     * Loads leafs for all models (nodes) using single request.
     *
     * @param {Array} models Array of models (categories) which additional leafs will be loaded for.
     * @param {Function} callback Callback function that will be run after leafs loaded.
     */
    bulkLoadLeafs: function(models, callback) {
        var ids = _.map(models, function(model) {
            return model.id;
        });

        if (ids.length === 0) {
            if (_.isFunction(callback)) {
                callback.call();
            }
            return;
        }

        this.loadAdditionalLeafs(ids, callback, true);
    },

    /**
     * Open category, which is parent to current record.
     */
    openCurrentParent: function() {
        if (_.isEmpty(this.extraModule)
            || _.isEmpty(this.extraModule.module)
            || _.isEmpty(this.extraModule.field)
            ) {
            return;
        }
        var currentContext = this.context.parent || this.context,
            currentModel = currentContext.get('model'),
            id = currentModel.get(this.extraModule.field),
            self = this;

        this.loadAdditionalLeafs([id], function() {
            if (self.disposed) {
                return;
            }
            var nestedBean = self.collection.getChild(id);
            if (!_.isUndefined(nestedBean)) {
                nestedBean.getPath({
                    success: function(data) {
                        var path = [];
                        _.each(data, function(cat) {
                            if (cat.id == this.categoryRoot) {
                                return;
                            }
                            path.push({
                                id: cat.id,
                                name: cat.name
                            });
                        }, self);
                        path.push({
                            id: nestedBean.id,
                            name: nestedBean.get('name')
                        });
                        async.forEach(
                            path,
                            function(item, c) {
                                self.folderToggled({
                                    id: item.id,
                                    name: item.name,
                                    type: 'folder',
                                    open: true
                                }, c);
                            },
                            function() {
                                self.selectNode(currentModel.id);
                                self.trigger('openCurrentParent', false);
                            }
                        );
                    }
                });
            } else {
                self.trigger('openCurrentParent', false);
            }
        });
    },

    /**
     * Handle load state of tree.
     * Always returns true to process the code, which called the method.
     * @param {Object} data Data of loaded tree.
     * @return {Boolean} Always returns `true`.
     */
    stateLoaded: function(data) {
        var self = this;

        var models = _.reduce(data.open, function(memo, value) {
            var model = self.collection.getChild(value.id);
            return _.extend(memo, model.children.models);
        }, []);

        this.bulkLoadLeafs(models, function() {
            _.each(data.open, function(value) {
                self.openNode(value.id);
            });
            self.trigger('stateLoaded', false);
        });

        return true;
    },

    /**
     * Handle toggle of tree folder.
     * Always returns true to process the code, which called the method.
     * @param {Object} data Toggled folder.
     * @param {Function} callback Async callback to use with async.js
     * @return {Boolean} Return `true` to continue execution, `false` otherwise..
     */
    folderToggled: function (data, callback) {
        var triggeredCallback = false,
            self = this;
        if (data.open) {
            var model = this.collection.getChild(data.id),
                items = [];

            if (model.id) {
                items = model.children.models;
                if (items.length !== 0) {
                    triggeredCallback = true;
                    this.bulkLoadLeafs(items, function() {
                        if (_.isFunction(callback)) {
                            callback.call();
                            return false;
                        } else if (self.useStates) {
                            self.saveJSTreeState();
                        }
                    });
                }
            }
        }
        if (triggeredCallback === false && _.isFunction(callback)) {
            callback.call();
            return false;
        }
        if (this.useStates && triggeredCallback === false) {
            this.saveJSTreeState();
        }
        return true;
    },

    /**
     * Handle leaf click for tree.
     * @param {Object} data Clicked leaf.
     */
    leafClicked: function (data) {
        if (data.type !== 'folder') {
            if (_.isEmpty(this.extraModule.module)) {
                return;
            }
            if (!this.$el.find('[data-id=' + data.id +']').data('disabled')) {
                var route = app.router.buildRoute(this.extraModule.module, data.id);
                app.router.navigate(route, {trigger: true});
            }
            return;
        }
        this.loadAdditionalLeafs([data.id]);
    },

    /**
     * Load extra data for tree.
     *
     * @param {Array} ids Ids of tree nodes to load data in.
     * @param {Function} callback Callback funct
     * @param {boolean} bulkLoad Identify if we need to perform bulk load
     */
    loadAdditionalLeafs: function(ids, callback, bulkLoad) {
        var self = this;
        var processedIds = _.filter(ids, function(id) {
            return self.addLeafFromCache(id);
        });
        if (processedIds.length === ids.length) {
            if (_.isFunction(callback)) {
                callback.call();
            }
            return;
        }

        var collection = this.createCollection();
        collection.filterDef = [{}];
        collection.filterDef[0][this.extraModule.field] = {$in: ids};
        collection.filterDef[0]['status'] = {$equals: 'published'};
        collection.filterDef[0]['active_rev'] = {$equals: 1};

        collection.fetch({
            success: function(data) {
                var groupedModels = _.groupBy(data.models, function(model) {
                    return model.get('category_id');
                });

                _.each(ids, function(id) {
                    self.addLeafs(groupedModels[id] || [], id);
                });

                if (_.isFunction(callback)) {
                    callback.call();
                }
            },
            apiOptions: bulkLoad ? {bulk: true} : {}
        });
        app.api.triggerBulkCall();
    },

    /**
     * Tries to find loaded leaf in cache and adds it to the tree.
     *
     * @param {String} id Leaf id.
     * @return {boolean} Returns true if leaf was added from cache, otherwise - false.
     */
    addLeafFromCache: function(id) {
        if (!_.isUndefined(this.loadedLeafs[id]) && this.loadedLeafs[id].timestamp < Date.now() - this.cacheLifetime) {
            delete this.loadedLeafs[id];
        }

        if (_.isEmpty(this.extraModule)
            || id === undefined
            || _.isEmpty(id)
            || _.isEmpty(this.extraModule.module)
            || _.isEmpty(this.extraModule.field)
            || !_.isUndefined(this.loadedLeafs[id])
        ) {
            if (!_.isUndefined(this.loadedLeafs[id])) {
                this.addLeafs(this.loadedLeafs[id].models, id);
            }
            return true;
        }

        return false;
    },

    /**
     * Creates bean collection with predefined options.
     *
     * @return {Object} Bean Collection.
     */
    createCollection: function() {
        var collection = app.data.createBeanCollection(this.extraModule.module);

        collection.options = {
            params: {
                order_by: 'date_entered:desc'
            },
            fields: [
                'id',
                'name'
            ]
        };

        return collection;
    },

    /**
     * @inheritdoc
     *
     * Need additional check for tree leafs.
     *
     * @override
     */
    loadData: function(options) {
        this.hideTree(true);
        if (!options || _.isUndefined(options.saveLeafs) || options.saveLeafs === false) {
            this.loadedLeafs = {};
        }

        if (options && options.complete) {
            this._render();
            options.complete();
        }
    },

    /**
     * Override behavior of JSTree plugin.
     * @param {Data,BeanCollection} collection synced collection.
     */
    onNestedSetSyncComplete: function(collection) {
        if (this.disposed || this.collection.root !== collection.root) {
            return;
        }
        this.layout.reloadDashlet({complete: function() {}, saveLeafs: true});
    },

    /**
     * Handle change of this.extraModule.field.
     * @param {Data.Bean} model Changed model.
     * @param {String} value Current field value of the field.
     */
    modelFieldChanged: function(model, value) {
        delete this.loadedLeafs[this.currentFieldValue];
        this.currentFieldValue = value;
    },

    /**
     * Handle save of context model.
     */
    modelSaved: function() {
        delete this.loadedLeafs[this.currentFieldValue];
        this.onNestedSetSyncComplete(this.collection);
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        var model;
        if (this.useStates === false && (model = this.context.get('model'))) {
            model.off('change:' + this.extraModule.field, this.changedCallback);
            model.off('data:sync:complete', this.savedCallback);
        }
        this._super('_dispose');
    },

    /**
     * Add documents as leafs for categories.
     * @param {Array} models Documents which should be added into the tree.
     * @param {String} id ID of category leaf to insert documents in.
     */
    addLeafs: function(models, id) {
        this.removeChildrens(id, 'document');
        _.each(models, function(value) {
            var insData = {
                id: value.id,
                name: value.get('name'),
                isViewable: app.acl.hasAccessToModel('view', value)
            };
            this.insertNode(insData, id, 'document');
        }, this);
        this.loadedLeafs[id] = {
            timestamp: Date.now(),
            models: models
        };
    },

    /**
     * Hide or show tree,
     * @param {boolean} hide Whether we need to hide tree.
     */
    hideTree: function(hide) {
        hide = hide || false;
        if (!hide) {
            this.hidden = false;
            this.$('[data-place=dashlet-tree]').removeClass('hide').show();
            this.$('[data-place=loading]').addClass('hide').hide();
        } else {
            this.hidden = true;
            this.$('[data-place=dashlet-tree]').addClass('hide').hide();
            this.$('[data-place=loading]').removeClass('hide').show();
        }
    }
}) }
}}
,
"layouts": {
"base": {
"config-drawer": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.KBContentsConfigDrawerLayout
 * @alias SUGAR.App.view.layouts.BaseKBContentsConfigDrawerLayout
 * @extends View.Layouts.Base.ConfigDrawerLayout
 */
({
	// Config-drawer Layout (base) 


    extendsFrom: 'ConfigDrawerLayout',

    /**
     * @inheritdoc
     */
    _checkModuleAccess: function() {
        var acls = app.user.getAcls().KBContents,
            isSysAdmin = (app.user.get('type') == 'admin'),
            isAdmin = (!_.has(acls, 'admin'));
        isDev = (!_.has(acls, 'developer'));
        return (isSysAdmin || isAdmin || isDev);
    }
}) },
"records-search-tags": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Records-search-tags Layout (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this._initializeCollectionFilterDef(options);
    },

    /**
     * Initialize collection in the sub-sub-component recordlist
     * with specific filterDef using tags for build recordlist
     * filtered by tags.
     *
     * @param {Object} options
     * @private
     */
    _initializeCollectionFilterDef: function(options) {
        if (_.isUndefined(options.def.context.tag)) {
            return;
        }

        var filterDef = {
            filter: [{
                tag: {
                    $in: [{
                        id: false,
                        name: options.def.context.tag
                    }]
                },
                active_rev: {
                    $equals: 1
                }
            }]
        };

        var chain = ['sidebar', 'main-pane', 'list', 'recordlist'];
        var recordList = _.reduce(chain, function(component, name) {
            if (!_.isUndefined(component)) {
                return component.getComponent(name);
            }
        }, this);

        if (!_.isUndefined(recordList)) {
            recordList.collection.filterDef = filterDef;
        }
    }
}) },
"subpanels": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Subpanels Layout (base) 

    extendsFrom: 'SubpanelsLayout',

    /**
     * @inheritdoc
     */
    _pruneNoAccessComponents: function(components) {
        var prunedComponents = [];
        var layoutFromContext = this.context ? this.context.get('layout') || this.context.get('layoutName') : null;
        this.layoutType = layoutFromContext ? layoutFromContext : app.controller.context.get('layout');
        this.aclToCheck = this.aclToCheck || (this.layoutType === 'record') ? 'view' : 'list';
        _.each(components, function(component) {
            var relatedModule,
                link = component.context ? component.context.link : null;
            if (link) {
                relatedModule = app.data.getRelatedModule(this.module, link);
                var aclToCheck = component.acl_action || this.aclToCheck;
                if (!relatedModule || relatedModule && app.acl.hasAccess(aclToCheck, relatedModule)) {
                    prunedComponents.push(component);
                }
            }
        }, this);
        return prunedComponents;
    }
}) },
"config-drawer-content": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Layouts.Base.KBContentsConfigDrawerContentLayout
 * @alias SUGAR.App.view.layouts.BaseKBContentsConfigDrawerContentLayout
 * @extends View.Layouts.Base.ConfigDrawerContentLayout
 */
({
	// Config-drawer-content Layout (base) 

    extendsFrom: 'ConfigDrawerContentLayout',

    /**
     * @inheritdoc
     * @override
     */
    _switchHowToData: function(helpId) {
        switch (helpId) {
            case 'config-languages':
                this.currentHowToData.title = app.lang.get(
                    'LBL_CONFIG_LANGUAGES_TITLE',
                    this.module
                );
                this.currentHowToData.text = app.lang.get(
                    'LBL_CONFIG_LANGUAGES_TEXT',
                    this.module
                );
                break;
        }
    }
}) }
}}
,
"datas": {}

},
		"KBArticles":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"KBContentTemplates":{"fieldTemplates": {
"base": {
"htmleditable_tinymce": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Htmleditable_tinymce FieldTemplate (base) 

    extendsFrom: 'BaseKBContentsHtmleditable_tinymceField',

    /**
     * Override to load handlebar templates from `KBContents module
     * @inheritdoc
     */
    _loadTemplate: function() {
        var module = this.module;
        this.module = 'KBContents';
        this._super('_loadTemplate');
        this.module = module;
    }
}) }
}}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"EmbeddedFiles":{"fieldTemplates": {}
,
"views": {}
,
"layouts": {}
,
"datas": {}

},
		"RevenueLineItems":{"fieldTemplates": {
"base": {
"actiondropdown": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Create a dropdown button that contains multiple
 * {@link View.Fields.Base.RowactionField} fields.
 *
 * @class View.Fields.Base.RevenueLineItems.ActiondropdownField
 * @alias SUGAR.App.view.fields.BaseRevenueLineItemsActiondropdownField
 * @extends View.Fields.Base.ActiondropdownField
 */
({
	// Actiondropdown FieldTemplate (base) 

    extendsFrom: 'ActiondropdownField',

    /**
     * Enable or disable caret depending on if there are any enabled actions in the dropdown list
     *
     * @inheritdoc
     * @private
     */
    _updateCaret: function() {
        // Left empty on purpose, the menu should always show
    }
}) },
"currency": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RevenueLineItems.CurrencyField
 * @alias SUGAR.App.view.fields.BaseRevenueLineItemsCurrencyField
 * @extends View.Fields.Base.CurrencyField
 */
({
	// Currency FieldTemplate (base) 

    extendsFrom: 'BaseCurrencyField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        // Enabling currency dropdown on RLIl ist views
        this.hideCurrencyDropdown = false;
    }
}) },
"convert-to-quote": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Fields.Base.RevenueLineItems.ConvertToQuoteField
 * @alias SUGAR.App.view.fields.BaseRevenueLineItemsConvertToQuoteField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Convert-to-quote FieldTemplate (base) 

    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     *
     * @param {Object} options
     */
    initialize: function(options) {
        this._super('initialize', [options]);
        this.type = 'rowaction';

        this.context.on('button:convert_to_quote:click', this.convertToQuote, this);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('sync', this._toggleDisable, this);
        this.model.on('change:quote_id', this._toggleDisable, this);
    },

    /**
     * convert RLI to quote
     * @param {Object} e
     */
    convertToQuote: function(e) {
        var massCollection = this.context.get('mass_collection');
        if (!massCollection) {
            massCollection = this.context.get('collection').clone();
            this.context.set('mass_collection', massCollection);
        }

        this.view.layout.trigger('list:massquote:fire');
    },

    /**
     * Reusable method for the event actions
     *
     * @private
     */
    _toggleDisable: function() {
        var quote_id = this.model.get('quote_id');
        this.setDisabled(!(_.isUndefined(quote_id) || _.isEmpty(quote_id)));
    }
}) },
"rowactions": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/*
 * @class View.Fields.Base.RevenueLineItems.RowactionsField
 * @alias SUGAR.App.view.fields.BaseRevenueLineItemsRowactionsField
 * @extends View.Fields.Base.RowactionsField
 */
({
	// Rowactions FieldTemplate (base) 

    extendsFrom: 'RowactionsField',

    /**
     * Enable or disable caret depending on if there are any enabled actions in the dropdown list
     *
     * @inheritdoc
     * @private
     */
    _updateCaret: function() {
        // Left empty on purpose, the menu should always show
    }
}) },
"relate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

/**
 * @class View.Fields.Base.RevenueLineItems.RelateField
 * @alias SUGAR.App.view.fields.BaseRevenueLineItemsRelateField
 * @extends View.Fields.Base.RelateField
 */
({
	// Relate FieldTemplate (base) 

    extendsFrom: 'BaseRelateField',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        // deleting for RLI create when there is no account_id.
        if (options && options.def.filter_relate && !options.model.has('account_id')) {
            delete options.def.filter_relate;
        }

        this._super('initialize', [options]);
    },

    setValue: function(models) {
        if (!models) {
            return;
        }
        var userCurrency = app.user.getCurrency();
        var createInPreferred = userCurrency.currency_create_in_preferred;
        var currencyFields;
        var currencyFromRate;

        if (this.name === 'product_template_name' && createInPreferred) {
            // get any currency fields on the model
            currencyFields = _.filter(this.model.fields, function(field) {
                return field.type === 'currency';
            });
            currencyFromRate = models.base_rate;
            models.currency_id = userCurrency.currency_id;
            models.base_rate = userCurrency.currency_rate;

            _.each(currencyFields, function(field) {
                // if the field exists on the model, convert the value to the new rate
                if (models[field.name] && field.name.indexOf('_usdollar') === -1) {
                    models[field.name] = app.currency.convertWithRate(
                        models[field.name],
                        currencyFromRate,
                        userCurrency.currency_rate
                    );
                }
            }, this);
        }
        this._super('setValue', [models]);
    }
}) },
"badge": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.RevenueLineItems.BadgeField
 * @alias SUGAR.App.view.fields.BaseRevenueLineItemsBadgeField
 * @extends View.Fields.Base.RowactionField
 */
({
	// Badge FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    extendsFrom: 'RowactionField',

    /**
     * @inheritdoc
     */
    showNoData: false,

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this.model.on('change:' + this.name, this.render, this);
    }
}) },
"rowaction": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Rowaction FieldTemplate (base) 

    extendsFrom: "RowactionField",
    
    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.clone(this.plugins) || [];

        if (!options.context.get('isCreateSubpanel')) {
            // if this is not a create subpanel, add the DisableDelete plugin
            // on a create subpanel, don't add the plugin so users can delete rows
            this.plugins.push('DisableDelete');
        }

        this._super("initialize", [options]);
    }
}) },
"editablelistbutton": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Editablelistbutton FieldTemplate (base) 

    extendsFrom: 'EditablelistbuttonField',
    /**
     * extend save options
     * @param {Object} options save options.
     * @return {Object} modified success param.
     */
    getCustomSaveOptions: function(options) {
        // make copy of original function we are extending
        var origSuccess = options.success;
        // return extended success function with added alert
        return {
            success: _.bind(function() {
                if (_.isFunction(origSuccess)) {
                    origSuccess.apply(this, arguments);
                }

                if (this.model && !_.isEmpty(this.model.get('quote_id'))) {
                    app.alert.show('save_rli_quote_notice', {
                        level: 'info',
                        messages: app.lang.get(
                            'SAVE_RLI_QUOTE_NOTICE',
                            'RevenueLineItems'
                        ),
                        autoClose: true
                    });
                }

                // trigger a save event across the parent context so listening components
                // know the changes made in this row has been saved
                if(this.context.parent) {
                    this.context.parent.trigger('editablelist:save', this.model);
                }
            }, this)
        };
    }
}) }
}}
,
"views": {
"base": {
"recordlist": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Recordlist View (base) 

    extendsFrom : 'RecordlistView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['CommittedDeleteWarning']);
        this._super("initialize", [options]);
        this.before('mergeduplicates', this._checkMergeModels, this);
    },

    /**
     * Event handler to make sure that before the merge drawer shows, make sure that all the models contain the first
     * records opportunity_id
     *
     * @param {Array} mergeModels
     * @returns {boolean}
     * @private
     */
    _checkMergeModels: function(mergeModels) {
        var primaryRecordOppId = _.first(mergeModels).get('opportunity_id');
        var invalid_models = _.find(mergeModels, function(model) {
            return !_.isEqual(model.get('opportunity_id'), primaryRecordOppId);
        });

        if (!_.isUndefined(invalid_models)) {
            app.alert.show("merge_duplicates_different_opps_warning", {
                level: "warning",
                messages: app.lang.get('WARNING_MERGE_RLIS_WITH_DIFFERENT_OPPORTUNITIES', this.module)
            });
            return false;
        }

        return true;
    },

    /**
     * @inheritdoc
     *
     * Augment to remove the fields that should not be displayed.
     */
    _createCatalog: function(fields) {
        var forecastConfig = app.metadata.getModule('Forecasts', 'config'),
            isSetup = (forecastConfig && forecastConfig.is_setup);

        if (isSetup) {
            fields = _.filter(fields, function(fieldMeta) {
                if (fieldMeta.name.indexOf('_case') !== -1) {
                    var field = 'show_worksheet_' + fieldMeta.name.replace('_case', '');
                    return (forecastConfig[field] == 1);
                }
                return true;
            });
        } else {
            // Forecast is not setup
            fields = _.reject(fields, function(fieldMeta) {
                return (fieldMeta.name === 'commit_stage');
            });
        }

        var catalog = this._super('_createCatalog', [fields]);
        return catalog;
    }
}) },
"record": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Record View (base) 

    extendsFrom: 'RecordView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['HistoricalSummary', 'CommittedDeleteWarning', 'MassQuote']);
        this._super('initialize', [options]);
        app.utils.hideForecastCommitStageField(this.meta.panels);
    },

    /**
     * @inheritdoc
     */
    cancelClicked: function() {
        /**
         * todo: this is a sad way to work around some problems with sugarlogic and revertAttributes
         * but it makes things work now. Probability listens for Sales Stage to change and then by
         * SugarLogic, it updates probability when sales_stage changes. When the user clicks cancel,
         * it goes to revertAttributes() which sets the model back how it was, but when you try to
         * navigate away, it picks up those new changes as unsaved changes to your model, and tries to
         * falsely warn the user. This sets the model back to those changed attributes (causing them to
         * show up in this.model.changed) then calls the parent cancelClicked function which does the
         * exact same thing, but that time, since the model was already set, it doesn't see anything in
         * this.model.changed, so it doesn't warn the user.
         */
        var changedAttributes = this.model.changedAttributes(this.model.getSynced());
        this.model.set(changedAttributes, { revert: true });
        this._super('cancelClicked');
    },

    /**
     * extend save options
     * @param {Object} options save options.
     * @return {Object} modified success param.
     */
    getCustomSaveOptions: function(options) {
        // make copy of original function we are extending
        var origSuccess = options.success;
        // return extended success function with added alert
        return {
            success: _.bind(function() {
                if (_.isFunction(origSuccess)) {
                    origSuccess();
                }
                if (!_.isEmpty(this.model.get('quote_id'))) {
                    app.alert.show('save_rli_quote_notice', {
                        level: 'info',
                        messages: app.lang.get(
                            'SAVE_RLI_QUOTE_NOTICE',
                            'RevenueLineItems'
                        ),
                        autoClose: true
                    });
                }
            }, this)
        };
    },

    /**
     * Bind to model to make it so that it will re-render once it has loaded.
     */
    bindDataChange: function() {
        this.model.on('duplicate:before', this._handleDuplicateBefore, this);
        this._super('bindDataChange');
    },

    /**
     * Handle what should happen before a duplicate is created
     *
     * @param {Backbone.Model} new_model
     * @private
     */
    _handleDuplicateBefore: function(new_model) {
        new_model.unset('quote_id');
        new_model.unset('quote_name');
    }
}) },
"subpanel-for-opportunities-create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Custom Subpanel Layout for Revenue Line Items.
 *
 * @class View.Views.Base.RevenueLineItems.SubpanelForOpportunitiesCreate
 * @alias SUGAR.App.view.views.BaseRevenueLineItemsSubpanelForOpportunitiesCreate
 * @extends View.Views.Base.SubpanelListCreateView
 */
({
	// Subpanel-for-opportunities-create View (base) 

    extendsFrom: 'SubpanelListCreateView',

    /**
     * Overriding to add the commit_stage field to the bean
     *
     * @inheritdoc
     */
    _addCustomFieldsToBean: function(bean, skipCurrency) {
        var dom;
        var attrs;
        var userCurrencyId;
        var userCurrency = app.user.getCurrency();
        var createInPreferred = userCurrency.currency_create_in_preferred;
        var currencyFields;
        var currencyFromRate;

        if (bean.has('sales_stage')) {
            dom = app.lang.getAppListStrings('sales_probability_dom');
            attrs = {
                probability: dom[bean.get('sales_stage')]
            };
        }

        if (skipCurrency && createInPreferred) {
            // force the line item to the user's preferred currency and rate
            attrs.currency_id = userCurrency.currency_id;
            attrs.base_rate = userCurrency.currency_rate;

            // get any currency fields on the model
            currencyFields = _.filter(this.model.fields, function(field) {
                return field.type === 'currency';
            });
            currencyFromRate = bean.get('base_rate');

            _.each(currencyFields, function(field) {
                // if the field exists on the bean, convert the value to the new rate
                // do not convert any base currency "_usdollar" fields
                if (bean.has(field.name) && field.name.indexOf('_usdollar') === -1) {
                    attrs[field.name] = app.currency.convertWithRate(
                        bean.get(field.name),
                        currencyFromRate,
                        userCurrency.currency_rate
                    );
                }
            }, this);
        } else if (!skipCurrency) {
            userCurrencyId = userCurrency.currency_id || app.currency.getBaseCurrencyId();
            attrs.currency_id = userCurrencyId;
            attrs.base_rate = app.metadata.getCurrency(userCurrencyId).conversion_rate;
        }

        if (!_.isEmpty(attrs)) {
            // we need to set the defaults
            bean.setDefault(attrs);
            // just to make sure that any attributes that were already set, are set again.
            bean.set(attrs);
        }

        return bean;
    },

    /**
     * We have to overwrite this method completely, since there is currently no way to completely disable
     * a field from being displayed
     *
     * @returns {{default: Array, available: Array, visible: Array, options: Array}}
     */
    parseFields : function() {
        var catalog = this._super('parseFields'),
            config = app.metadata.getModule('Forecasts', 'config'),
            isForecastSetup = config.is_setup;

        // if forecast is not setup, we need to make sure that we hide the commit_stage field
        _.each(catalog, function (group, i) {
            if (isForecastSetup) {
                catalog[i] = _.filter(group, function(fieldMeta) {
                    if (fieldMeta.name.indexOf('_case') != -1) {
                        var field = 'show_worksheet_' + fieldMeta.name.replace('_case', '');
                        return (config[field] == 1);
                    }

                    return true;
                });
            } else {
                catalog[i] = _.filter(group, function (fieldMeta) {
                    return (fieldMeta.name != 'commit_stage');
                });
            }
        });

        return catalog;
    }
}) },
"create": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Views.Base.RevenueLineItems.CreateView
 * @alias SUGAR.App.view.views.RevenueLineItemsCreateView
 * @extends View.Views.Base.CreateView
 */
({
	// Create View (base) 

    extendsFrom: 'CreateView',

    initialize: function(options) {
        this._super('initialize', [options]);
        app.utils.hideForecastCommitStageField(this.meta.panels);
    }
}) },
"subpanel-list": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * Custom Subpanel Layout for Revenue Line Items.
 *
 * @class View.Views.Base.RevenueLineItems.SubpanelListView
 * @alias SUGAR.App.view.views.BaseRevenueLineItemsSubpanelListView
 * @extends View.Views.Base.SubpanelListView
 */
({
	// Subpanel-list View (base) 

    extendsFrom: 'SubpanelListView',

    /**
     * We have to overwrite this method completely, since there is currently no way to completely disable
     * a field from being displayed
     *
     * @returns {{default: Array, available: Array, visible: Array, options: Array}}
     */
    parseFields : function() {
        var catalog = this._super('parseFields'),
            config = app.metadata.getModule('Forecasts', 'config'),
            isForecastSetup = (config && config.is_setup);

        // if forecast is not setup, we need to make sure that we hide the commit_stage field
        _.each(catalog, function (group, i) {
            if (isForecastSetup) {
                catalog[i] = _.filter(group, function(fieldMeta) {
                    if (fieldMeta.name.indexOf('_case') != -1) {
                        var field = 'show_worksheet_' + fieldMeta.name.replace('_case', '');
                        return (config[field] == 1);
                    }

                    return true;
                });
            } else {
                catalog[i] = _.filter(group, function (fieldMeta) {
                    return (fieldMeta.name != 'commit_stage');
                });
            }
        });

        return catalog;
    }
}) },
"filter-rows": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Filter-rows View (base) 

    extendsFrom: 'FilterRowsView',

    /**
     * @inheritdoc
     */
    loadFilterFields: function(moduleName) {
        this._super('loadFilterFields', [moduleName]);

        var cfg = app.metadata.getModule("Forecasts", "config");
        if (cfg && cfg.is_setup === 1) {
            _.each(this.filterFields, function(field, key, list) {
                if (key.indexOf('_case') != -1) {
                    var fieldName = 'show_worksheet_' + key.replace('_case', '');
                    if (cfg[fieldName] !== 1) {
                        delete list[key];
                        delete this.fieldList[key];
                    }
                }
            }, this);
        } else {
            delete this.fieldList['commit_stage'];
            delete this.filterFields['commit_stage'];
        }
    }
}) },
"massupdate": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Massupdate View (base) 

    extendsFrom: 'MassupdateView',
    
    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this.plugins = _.union(this.plugins || [], ['DisableMassDelete', 'MassQuote', 'CommittedDeleteWarning']);
        this._super("initialize", [options]);
    },

    /**
     *
     * @inheritdoc
     */
    setMetadata: function(options) {
        var config = app.metadata.getModule('Forecasts', 'config');

        this._super("setMetadata", [options]);

        if (!config || (config && !config.is_setup)) {
            _.each(options.meta.panels, function(panel) {
                _.every(panel.fields, function (item, index) {
                    if (_.isEqual(item.name, "commit_stage")) {
                        panel.fields.splice(index, 1);
                        return false;
                    }
                    return true;
                }, this);
            }, this);
        }
    },

    /**
     * @inheritdoc
     */
    save: function(forCalcFields) {
        var forecastCfg = app.metadata.getModule("Forecasts", "config");
        if (forecastCfg && forecastCfg.is_setup) {
            // Forecasts is enabled and setup
            var hasCommitStage = _.some(this.fieldValues, function(field) {
                    return field.name === 'commit_stage';
                }),
                hasClosedModels = false;

            if(!hasCommitStage && this.defaultOption.name === 'commit_stage') {
                hasCommitStage = true;
            }

            if(hasCommitStage) {
                hasClosedModels = this.checkMassUpdateClosedModels();
            }

            if(!hasClosedModels) {
                // if this has closed models, first time through will uncheck but not save
                // if this doesn't it will save like normal
                this._super('save', [forCalcFields]);
            }
        } else {
            // Forecasts is not enabled and the commit_stage field isn't in the mass update list
            this._super('save', [forCalcFields]);
        }
    }
}) },
"panel-top": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Panel-top View (base) 

    extendsFrom: 'PanelTopView',

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        var userACLs;

        this._super('initialize', [options]);

        if (this.parentModule === 'Accounts') {
            this.context.parent.on('editablelist:save', this._reloadOpportunities, this);
            this.meta.buttons = _.filter(this.meta.buttons, function(item) {
                return item.type !== 'actiondropdown';
            });
        }

        userACLs = app.user.getAcls();

        if (!(_.has(userACLs.Opportunities, 'edit') ||
            _.has(userACLs.RevenueLineItems, 'access') ||
            _.has(userACLs.RevenueLineItems, 'edit'))) {
            // need to trigger on app.controller.context because of contexts changing between
            // the PCDashlet, and Opps create being in a Drawer, or as its own standalone page
            // app.controller.context is the only consistent context to use
            var viewDetails = this.closestComponent('record') ?
                this.closestComponent('record') :
                this.closestComponent('create');

            if (!_.isUndefined(viewDetails)) {
                app.controller.context.on(viewDetails.cid + ':productCatalogDashlet:add', this.openRLICreate, this);
            }
        }
    },

    /**
     * Refreshes the RevenueLineItems subpanel when a new Opportunity is added
     * @private
     */
    _reloadOpportunities: function() {
        var $oppsSubpanel = $('div[data-subpanel-link="opportunities"]');
        // only reload Opportunities if it is closed & no data exists
        if ($('li.subpanel', $oppsSubpanel).hasClass('closed')) {
            if ($('table.dataTable', $oppsSubpanel).length) {
                this.context.parent.trigger('subpanel:reload', {links: ['opportunities']});
            } else {
                this.context.parent.trigger('subpanel:reload');
            }
        } else {
            this.context.parent.trigger('subpanel:reload', {links: ['opportunities']});
        }
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');
        this.context.parent.on('subpanel:reload', function(args) {
            if (!_.isUndefined(args) && _.isArray(args.links) && _.contains(args.links, this.context.get('link'))) {
                // have to set skipFetch to false so panel.js will toggle this panel open
                this.context.set('skipFetch', false);
                this.context.reloadData({recursive: false});
            }
        }, this);
    },

    /**
     * @inheritdoc
     */
    createRelatedClicked: function(event) {
        // close RLI warning alert
        app.alert.dismiss('opp-rli-create');

        this._super('createRelatedClicked', [event]);
    },

    /**
     * Open a new Drawer with the RLI Create Form
     */
    openRLICreate: function(data) {
        var routerFrags = app.router.getFragment().split('/');
        var parentModel;
        var model;
        var userCurrency;
        var createInPreferred;
        var currencyFields;
        var currencyFromRate;

        if (routerFrags[1] === 'create' || app.drawer.count()) {
            // if panel-top has been initialized on a record, but we're currently in create, ignore the event
            // or if there is already an Opps drawer opened
            return;
        }

        userCurrency = app.user.getCurrency();
        createInPreferred = userCurrency.currency_create_in_preferred;

        if (data.product_template_id) {
            var metadataFields = app.metadata.getModule('Products', 'fields');

            // getting the fields from metadata of the module and mapping them to data
            if (metadataFields && metadataFields.product_template_name &&
                metadataFields.product_template_name.populate_list) {
                _.each(metadataFields.product_template_name.populate_list, function(val, key) {
                    data[val] = data[key];
                }, this);
            }
        }

        parentModel = this.context.parent.get('model');
        model = this.createLinkModel(parentModel, 'revenuelineitems');

        data.likely_case = data.discount_price;
        data.best_case = data.discount_price;
        data.worst_case = data.discount_price;
        data.assigned_user_id = app.user.get('id');
        data.assigned_user_name = app.user.get('name');

        if (createInPreferred) {
            currencyFields = _.filter(model.fields, function(field) {
                return field.type === 'currency';
            });
            currencyFromRate = data.base_rate;
            data.currency_id = userCurrency.currency_id;
            data.base_rate = userCurrency.currency_rate;

            _.each(currencyFields, function(field) {
                // if the field exists on the model, convert the value to the new rate
                if (data[field.name] && field.name.indexOf('_usdollar') === -1) {
                    data[field.name] = app.currency.convertWithRate(
                        data[field.name],
                        currencyFromRate,
                        userCurrency.currency_rate
                    );
                }
            }, this);
        }

        model.set(data);
        model.ignoreUserPrefCurrency = true;

        app.drawer.open({
            layout: 'create',
            context: {
                create: true,
                module: 'RevenueLineItems',
                model: model
            }
        }, _.bind(this.rliCreateClose, this));
    },

    /**
     * Callback for when the create drawer closes
     *
     * @param {Data.Bean} model
     */
    rliCreateClose: function(model) {
        var rliCtx;
        var ctx;

        if (!model) {
            return;
        }

        ctx = this.context;
        ctx.resetLoadFlag();
        ctx.set('skipFetch', false);
        ctx.loadData();

        // find the child collection for the RLI subpanel
        // if we find one and it has the loadData method, call that method to
        // force the subpanel to load the data.
        rliCtx = _.find(ctx.children, function(child) {
            return child.get('module') === 'RevenueLineItems';
        }, this);
        if (!_.isUndefined(rliCtx) && _.isFunction(rliCtx.loadData)) {
            rliCtx.loadData();
        }
    },

    /**
     * @inheritdoc
     */
    _dispose: function() {
        if (app.controller && app.controller.context) {
            var viewDetails = this.closestComponent('record') ?
                this.closestComponent('record') :
                this.closestComponent('create');

            if (!_.isUndefined(viewDetails)) {
                app.controller.context.off(viewDetails.cid + ':productCatalogDashlet:add', null, this);
            }
        }

        this._super('_dispose');
    }
}) },
"merge-duplicates": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
({
	// Merge-duplicates View (base) 

    extendsFrom: 'MergeDuplicatesView',

    /**
     * @inheritdoc
     */
    _initializeMergeFields: function(module) {
        var config = app.metadata.getModule('Forecasts', 'config');
        if (!config || !config.is_setup) {
            if(!_.contains(this.fieldNameBlacklist, 'commit_stage')) {
                this.fieldNameBlacklist.push('commit_stage');
            }
        } else if (_.contains(this.fieldNameBlacklist, 'commit_stage')) {
            this.fieldNameBlacklist.splice(_.indexOf(this.fieldNameBlacklist, 'commit_stage'), 1);
        }

        this._super('_initializeMergeFields', [module]);
    },

    /**
     * @inheritdoc
     */
    bindDataChange: function() {
        this._super('bindDataChange');

        var config = app.metadata.getModule('Forecasts', 'config');

        if(config && config.is_setup && config.forecast_by === 'RevenueLineItems') {
            // make sure forecasts exists and is setup
            this.collection.on('change:sales_stage change:commit_stage reset', function(model) {
                var myModel = model;

                //check to see if this is a collection (for the reset event), use this.primaryRecord instead if true;
                if (!_.isUndefined(model.models)) {
                    myModel = this.primaryRecord;
                }
                var salesStage = myModel.get('sales_stage'),
                    commit_stage = this.getField('commit_stage');

                if(salesStage) {
                    if(_.contains(config.sales_stage_won, salesStage)) {
                        // check if the sales_stage has changed to a Closed Won stage
                        if(config.commit_stages_included.length) {
                            // set the commit_stage to the first included stage
                            myModel.set('commit_stage', _.first(config.commit_stages_included));
                        } else {
                            // otherwise set the commit stage to just "include"
                            myModel.set('commit_stage', 'include');
                        }
                        commit_stage.setDisabled(true);
                        this.$('input[data-record-id="' + myModel.get('id') + '"][name="copy_commit_stage"]').prop("checked", true);
                    } else if(_.contains(config.sales_stage_lost, salesStage)) {
                        // check if the sales_stage has changed to a Closed Lost stage
                        // set the commit_stage to exclude
                        myModel.set('commit_stage', 'exclude');
                        commit_stage.setDisabled(true);
                        this.$('input[data-record-id="' + myModel.get('id') + '"][name="copy_commit_stage"]').prop("checked", true);
                    } else {
                        commit_stage.setDisabled(false);
                    }
                }
            }, this);
        }
    }
}) }
}}
,
"layouts": {}
,
"datas": {}

},
		"Audit":{"fieldTemplates": {
"base": {
"htmleditable_tinymce": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

({
	// Htmleditable_tinymce FieldTemplate (base) 

    extendsFrom: 'Htmleditable_tinymceField',
    /**
     * Sets the content displayed in the non-editor view
     *
     * @param {String} value Sanitized HTML to be placed in view
     */
    setViewContent: function(value) {
        var editable = this._getHtmlEditableField();
        if (this.action == 'list') {
            // Strip HTML tags for ListView.
            value = $('<div/>').html(value).text();
        }
        if (!editable) {
            return;
        }
        if (!_.isUndefined(editable.get(0)) && !_.isEmpty(editable.get(0).contentDocument)) {
            if (editable.contents().find('body').length > 0) {
                editable.contents().find('body').html(value);
            }
        } else {
            editable.html(value);
        }
    }
}) },
"currency": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Audit.CurrencyField
 * @alias SUGAR.App.view.fields.BaseAuditCurrencyField
 * @extends View.Fields.Base.CurrencyField
 */
({
	// Currency FieldTemplate (base) 

    /**
     * @inheritdoc
     */
    initialize: function(options) {
        this._super('initialize', [options]);

        //audit log is always in base currency. Make sure the currency def reflects that.
        this.def.is_base_currency = true;
    }
}) },
"fieldtype": {"controller": /*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
/**
 * @class View.Fields.Base.Audit.FieldtypeField
 * @alias SUGAR.App.view.fields.BaseAuditFieldtypeField
 * @extends View.Fields.Base.BaseField
 */
({
	// Fieldtype FieldTemplate (base) 

    /**
     * @inheritdoc
     * Convert the raw field type name
     * into the label of the field of the parent model.
     */
    format: function(value) {
        if (this.context && this.context.parent) {
            var parentModel = this.context.parent.get('model'),
                field = parentModel.fields[value];
            if (field) {
                value = app.lang.get(field.label || field.vname, parentModel.module);
            }
        }
        return value;
    }
}) }
}}
,
"views": {}
,
"layouts": {}
,
"datas": {}

}
	}}})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on('router:init', function(router) {
        /*
         * Allow modules to extend routing rules.
         *
         * Manually create a route for the router.
         * The route argument may be a routing string or regular expression.
         */
        var homeOptions = {
            dashboard: 'dashboard',
            activities: 'activities'
        };

        var getLastHomeKey = function() {
            return app.user.lastState.buildKey('last-home', 'app-header');
        };

        var routes = [
            {
                name: 'activities',
                route: 'activities',
                callback: function() {
                    // when visiting activity stream, save last state of activities
                    // so future Home routes go back to activities
                    var lastHomeKey = getLastHomeKey();
                    app.user.lastState.set(lastHomeKey, homeOptions.activities);

                    app.controller.loadView({
                        layout: 'activities',
                        module: 'Activities'
                    });
                }
            },
            {
                name: 'home',
                route: 'Home',
                callback: function() {
                    var lastHomeKey = getLastHomeKey(),
                        lastHome = app.user.lastState.get(lastHomeKey);
                    if (lastHome === homeOptions.dashboard) {
                        app.controller.loadView({
                            module: 'Home',
                            layout: 'record'
                        });
                    } else if (lastHome === homeOptions.activities) {
                        app.router.redirect('#activities');
                    }
                }
            },
            {
                name: 'homeCreate',
                route: 'Home/create',
                callback: function() {
                    app.controller.loadView({
                        module: 'Home',
                        layout: 'record',
                        create: true
                    });
                }
            },
            {
                name: 'homeRecord',
                route: 'Home/:id',
                callback: function(id) {
                    // when visiting a dashboard, save last state of dashboard
                    // so future Home routes go back to dashboard
                    var lastHomeKey = getLastHomeKey();
                    app.user.lastState.set(lastHomeKey, homeOptions.dashboard);

                    app.controller.loadView({
                        module: 'Home',
                        layout: 'record',
                        action: 'detail',
                        modelId: id
                    });
                }
            }
        ];

        /*
         * Triggering the event on init will go over all those listeners
         * and add the routes to the router.
         */
        app.router.addRoutes(routes);
    });
})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    var module = 'Emails';

    /**
     * Open the email compose view in either a drawer or full-page.
     *
     * The view will be opened in a drawer if the user is routing from a page
     * in the application. The view will be opened in full-page if the user is
     * routing from login or a location outside the application.
     *
     * @param {Data.Bean} model The model that is given to the layout.
     */
    function openEmailCompose(model) {
        var prevLayout = app.controller.context.get('layout');

        if (prevLayout && prevLayout !== 'login') {
            app.utils.openEmailCreateDrawer(
                'compose-email',
                {
                    model: model,
                    fromRouter: true
                }, function(context, model) {
                    if (model && model.module === app.controller.context.get('module')) {
                        app.controller.context.reloadData();
                    }
                }
            );
        } else {
            options = {
                module: module,
                layout: 'compose-email',
                action: model.isNew() ? 'create' : 'edit',
                model: model,
                create: true
            };
            app.controller.loadView(options);
        }
    }

    app.events.on('router:init', function() {
        var routes = [{
            name: 'email_compose',
            route: module + '(/:id)/compose',
            callback: function(id) {
                var model = app.data.createBean(module);

                if (_.isEmpty(id)) {
                    openEmailCompose(model);
                } else {
                    model.set('id', id);
                    model.fetch({
                        view: 'compose-email',
                        params: {
                            erased_fields: true
                        },
                        success: function(model) {
                            var route;

                            if (model.get('state') === 'Draft' && app.acl.hasAccessToModel('edit', model)) {
                                openEmailCompose(model);
                            } else {
                                // Handle routing for an email that used to be
                                // a draft or a draft the current user cannot
                                // edit.
                                route = '#' + app.router.buildRoute(model.module, model.get('id'));
                                app.router.redirect(route);
                            }
                        }
                    });
                }
            }
        }];

        app.router.addRoutes(routes);
    });
})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on('router:init', function(router) {
        var routes = [{
            name: 'quotesCompatibility',
            route: 'Quotes/create',
            callback: function() {
                app.router.record('Quotes', 'create');
            }
        }];

        /*
         * Triggering the event on init will go over all those listeners
         * and add the routes to the router.
         */
        app.router.addRoutes(routes);
    });
})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on('router:init', function(router) {
        var routes = [
            {
                name: 'productBundlesList',
                route: 'ProductBundles',
                callback: function() {
                    app.router.redirect('#Quotes');
                }
            },
            {
                name: 'productBundlesCreate',
                route: 'ProductBundles/create',
                callback: function() {
                    app.router.redirect('#Quotes');
                }
            },
            {
                name: 'productBundlesRecord',
                route: 'ProductBundles/:id',
                callback: function(id) {
                    app.router.redirect('#Quotes');
                }
            }
        ];
        app.router.addRoutes(routes);
    });
})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

(function(app) {
    app.events.on('router:init', function(router) {
        var module = 'Reports';
        var routes = [
            {
                name: 'ReportsList',
                route: 'Reports',
                callback: function(params) {
                    var filterOptions;

                    if (params) {
                        var parsedParams = {filterModule: []};
                        // FIXME SC-5657 will handle url param parsing
                        var paramsArray = params.split('&');
                        _.each(paramsArray, function(paramPair) {
                            var keyValueArray = paramPair.split('=');
                            if (keyValueArray.length > 1) {
                                parsedParams[keyValueArray[0]] = keyValueArray[1].split(',');
                            }
                        });

                        if (!_.isEmpty(parsedParams.filterModule)) {
                            filterOptions = new app.utils.FilterOptions().config({
                                initial_filter_label: app.lang.get('LBL_MODULE_NAME', parsedParams.filterModule),
                                initial_filter: '$relate',
                                filter_populate: {
                                    'module': {$in: parsedParams.filterModule}
                                }
                            });
                        }
                    }

                    app.controller.loadView({
                        module: module,
                        layout: 'records',
                        filterOptions: filterOptions ? filterOptions.format() : null
                    });
                }
            },
            // This will be removed once we move Reports record view into sidecar
            // For now, let's just catch all the edge cases that link to sidecar record view
            // and reroute them
            {
                name: 'ReportsRecord',
                route: 'Reports/:id(/:action)',
                callback: function(id, action) {
                    var route = app.bwc.buildRoute('Reports', id);
                    app.router.redirect(route);
                }
            }
        ];

        app.router.addRoutes(routes);
    });
})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on('router:init', function(router) {
        var module = 'pmse_Inbox';
        var routes = [
            {
                name: 'show-case_layout_record_action',
                route: module + '/:id/layout/:layout/:record(/:action)',
                callback: function(id, layout, record, action) {
                    if (!this._moduleExists(module)) {
                        return;
                    }

                    var opts = {
                        module: module,
                        modelId: id,
                        layout: layout || 'record',
                        action: record,
                        record: action || 'detail'
                    };

                    app.controller.loadView(opts);
                }
            }
        ];

        app.router.addRoutes(routes);
    });
})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on('router:init', function(router) {
        var module = 'pmse_Project';
        var routes = [
            {
                name: 'pd_record_layout',
                route: module + '/:id/layout/:layout',
                callback: function(id, layout) {
                    if (!app.router._moduleExists(module)) {
                        return;
                    }
                    app.router.record(module, id, null, layout);
                }
            }
        ];

        app.router.addRoutes(routes);
    });
})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on('router:init', function(router) {
        var module = 'pmse_Business_Rules';
        var routes = [
            {
                name: 'br_record_layout',
                route: module + '/:id/layout/:layout',
                callback: function(id, layout) {
                    if (!app.router._moduleExists(module)) {
                        return;
                    }
                    app.router.record(module, id, null, layout);
                }
            }
        ];

        app.router.addRoutes(routes);
    });
})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on('router:init', function(router) {
        var module = 'pmse_Emails_Templates';
        var routes = [
            {
                name: 'et_record_layout',
                route: module + '/:id/layout/:layout',
                callback: function(id, layout) {
                    if (!app.router._moduleExists(module)) {
                        return;
                    }
                    app.router.record(module, id, null, layout);
                }
            }
        ];

        app.router.addRoutes(routes);
    });
})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */
(function(app) {
    app.events.on('router:init', function() {
        var routes = [
            {
                name: 'sg_index',
                route: 'Styleguide',
                callback: function() {
                    app.controller.loadView({
                        module: 'Styleguide',
                        layout: 'styleguide',
                        chapter_name: 'home',
                        content_name: null
                    });
                }
            },
            {
                name: 'sg_module',
                route: 'Styleguide/:layout/:resource',
                callback: function(layout, resource) {
                    var chapter_name = '',
                        content_name = '';
                    switch (layout) {
                        case 'docs':
                            //route: "Styleguide/docs/base"
                            //route: "Styleguide/docs/base-grid"
                        case 'fields':
                            //route: "Styleguide/fields/text"
                        case 'views':
                            //route: "Styleguide/views/list"
                            chapter_name = layout;
                            content_name = resource;
                            break;
                        case 'layout':
                            //route: "Styleguide/layout/records"
                            layout = resource;
                            content_name = 'module';
                            break;
                        default:
                            app.logger.warn('Invalid route: ' + layout + '/' + resource);
                            break;
                    }
                    app.controller.loadView({
                        module: 'Styleguide',
                        layout: layout,
                        chapter_name: chapter_name,
                        content_name: content_name,
                        skipFetch: true
                    });
                }
            }
        ];

        app.router.addRoutes(routes);
    });
})(SUGAR.App);
/*
 * Your installation or use of this SugarCRM file is subject to the applicable
 * terms available at
 * http://support.sugarcrm.com/Resources/Master_Subscription_Agreements/.
 * If you do not agree to all of the applicable terms or do not have the
 * authority to bind the entity as an authorized representative, then do not
 * install or use this SugarCRM file.
 *
 * Copyright (C) SugarCRM Inc. All rights reserved.
 */

(function(app) {
    /*
     * Add the Dashboard module routes to Sugar's router
     */
    app.events.on('router:init', function(router) {
        var routes = [
            {
                name: 'dashboardCreate',
                route: 'Dashboards/create',
                callback: function() {
                    app.error.handleHttpError({status: 404});
                }
            },
            {
                name: 'manageDashboards',
                route: 'Dashboards',
                callback: function(urlParams) {
                    if (!this._moduleExists('Dashboards')) {
                        return;
                    }
                    // This may be filled in with values from urlParams
                    // Expected (optional) keys are moduleName and viewName
                    var params = {};

                    if (urlParams) {
                        // FIXME TY-1469: Use the URL splitter in the router
                        // and remove this block of code.
                        var paramsArray = urlParams.split('&');
                        _.each(paramsArray, function(paramPair) {
                            var keyValueArray = paramPair.split('=');
                            if (keyValueArray.length > 1) {
                                params[keyValueArray[0]] = keyValueArray[1];
                            }
                        });
                    }

                    var moduleName = params.moduleName;
                    var viewName = params.viewName;

                    // Initialize the options for `app.controller.loadView`
                    var viewOptions = {
                        module: 'Dashboards',
                        layout: 'records'
                    };

                    // If `previousModule` is defined, we need to pre-apply a
                    // filter to the dashboards list view.
                    if (!_.isUndefined(moduleName)) {
                        var initialFilter;
                        var translatedModule = app.lang.getModuleName(moduleName, {plural: true});
                        var filterLabel;
                        var filterOptions;
                        var filterDef = {
                            dashboard_module: [moduleName]
                        };
                        // FIXME TY-1458: If we're here, then `previousLayout`
                        // should also be defined. The `if` statement and its
                        // contents would no longer be necessary. The `else`
                        // contents would be the only portion remaining.
                        if (_.isUndefined(viewName)) {
                            initialFilter = 'module';
                            filterLabel = app.lang.get('LBL_FILTER_BY_MODULE', 'Dashboards', {
                                module: translatedModule
                            });
                        } else {
                            initialFilter = 'module_and_layout';
                            filterDef.view_name = viewName;
                            filterLabel = app.lang.get('LBL_FILTER_BY_MODULE_AND_VIEW', 'Dashboards', {
                                module: translatedModule,
                                view: app.lang.getAppListStrings('dashboard_view_name_list')[viewName] || viewName
                            });
                        }

                        filterOptions = new app.utils.FilterOptions();
                        filterOptions.setInitialFilter(initialFilter);
                        filterOptions.setInitialFilterLabel(filterLabel);
                        filterOptions.setFilterPopulate(filterDef);

                        viewOptions.filterOptions = filterOptions.format();
                    }
                    app.controller.loadView(viewOptions);
                }
            }
        ];

        /*
         * Triggering the event on init will go over all those listeners
         * and add the routes to the router.
         */
        app.router.addRoutes(routes);
    });
})(SUGAR.App);
